!function(e){function r(e,r,o){return 4===arguments.length?t.apply(this,arguments):void n(e,{declarative:!0,deps:r,declare:o})}function t(e,r,t,o){n(e,{declarative:!1,deps:r,executingRequire:t,execute:o})}function n(e,r){r.name=e,e in v||(v[e]=r),r.normalizedDeps=r.deps}function o(e,r){if(r[e.groupIndex]=r[e.groupIndex]||[],-1==g.call(r[e.groupIndex],e)){r[e.groupIndex].push(e);for(var t=0,n=e.normalizedDeps.length;n>t;t++){var a=e.normalizedDeps[t],u=v[a];if(u&&!u.evaluated){var d=e.groupIndex+(u.declarative!=e.declarative);if(void 0===u.groupIndex||u.groupIndex<d){if(void 0!==u.groupIndex&&(r[u.groupIndex].splice(g.call(r[u.groupIndex],u),1),0==r[u.groupIndex].length))throw new TypeError("Mixed dependency cycle detected");u.groupIndex=d}o(u,r)}}}}function a(e){var r=v[e];r.groupIndex=0;var t=[];o(r,t);for(var n=!!r.declarative==t.length%2,a=t.length-1;a>=0;a--){for(var u=t[a],i=0;i<u.length;i++){var s=u[i];n?d(s):l(s)}n=!n}}function u(e){return y[e]||(y[e]={name:e,dependencies:[],exports:{},importers:[]})}function d(r){if(!r.module){var t=r.module=u(r.name),n=r.module.exports,o=r.declare.call(e,function(e,r){if(t.locked=!0,"object"==typeof e)for(var o in e)n[o]=e[o];else n[e]=r;for(var a=0,u=t.importers.length;u>a;a++){var d=t.importers[a];if(!d.locked)for(var i=0;i<d.dependencies.length;++i)d.dependencies[i]===t&&d.setters[i](n)}return t.locked=!1,r},{id:r.name});t.setters=o.setters,t.execute=o.execute;for(var a=0,i=r.normalizedDeps.length;i>a;a++){var l,s=r.normalizedDeps[a],c=v[s],f=y[s];f?l=f.exports:c&&!c.declarative?l=c.esModule:c?(d(c),f=c.module,l=f.exports):l=p(s),f&&f.importers?(f.importers.push(t),t.dependencies.push(f)):t.dependencies.push(null),t.setters[a]&&t.setters[a](l)}}}function i(e){var r,t=v[e];if(t)t.declarative?f(e,[]):t.evaluated||l(t),r=t.module.exports;else if(r=p(e),!r)throw new Error("Unable to load dependency "+e+".");return(!t||t.declarative)&&r&&r.__useDefault?r["default"]:r}function l(r){if(!r.module){var t={},n=r.module={exports:t,id:r.name};if(!r.executingRequire)for(var o=0,a=r.normalizedDeps.length;a>o;o++){var u=r.normalizedDeps[o],d=v[u];d&&l(d)}r.evaluated=!0;var c=r.execute.call(e,function(e){for(var t=0,n=r.deps.length;n>t;t++)if(r.deps[t]==e)return i(r.normalizedDeps[t]);throw new TypeError("Module "+e+" not declared as a dependency.")},t,n);void 0!==typeof c&&(n.exports=c),t=n.exports,t&&t.__esModule?r.esModule=t:r.esModule=s(t)}}function s(r){var t={};if(("object"==typeof r||"function"==typeof r)&&r!==e)if(m)for(var n in r)"default"!==n&&c(t,r,n);else{var o=r&&r.hasOwnProperty;for(var n in r)"default"===n||o&&!r.hasOwnProperty(n)||(t[n]=r[n])}return t["default"]=r,x(t,"__useDefault",{value:!0}),t}function c(e,r,t){try{var n;(n=Object.getOwnPropertyDescriptor(r,t))&&x(e,t,n)}catch(o){return e[t]=r[t],!1}}function f(r,t){var n=v[r];if(n&&!n.evaluated&&n.declarative){t.push(r);for(var o=0,a=n.normalizedDeps.length;a>o;o++){var u=n.normalizedDeps[o];-1==g.call(t,u)&&(v[u]?f(u,t):p(u))}n.evaluated||(n.evaluated=!0,n.module.execute.call(e))}}function p(e){if(I[e])return I[e];if("@node/"==e.substr(0,6))return I[e]=s(D(e.substr(6)));var r=v[e];if(!r)throw"Module "+e+" not present.";return a(e),f(e,[]),v[e]=void 0,r.declarative&&x(r.module.exports,"__esModule",{value:!0}),I[e]=r.declarative?r.module.exports:r.esModule}var v={},g=Array.prototype.indexOf||function(e){for(var r=0,t=this.length;t>r;r++)if(this[r]===e)return r;return-1},m=!0;try{Object.getOwnPropertyDescriptor({a:0},"a")}catch(h){m=!1}var x;!function(){try{Object.defineProperty({},"a",{})&&(x=Object.defineProperty)}catch(e){x=function(e,r,t){try{e[r]=t.value||t.get.call(e)}catch(n){}}}}();var y={},D="undefined"!=typeof System&&System._nodeRequire||"undefined"!=typeof require&&require.resolve&&"undefined"!=typeof process&&require,I={"@empty":{}};return function(e,n,o,a){return function(u){u(function(u){for(var d={_nodeRequire:D,register:r,registerDynamic:t,get:p,set:function(e,r){I[e]=r},newModule:function(e){return e}},i=0;i<n.length;i++)(function(e,r){r&&r.__esModule?I[e]=r:I[e]=s(r)})(n[i],arguments[i]);a(d);var l=p(e[0]);if(e.length>1)for(var i=1;i<e.length;i++)p(e[i]);return o?l["default"]:l})}}}("undefined"!=typeof self?self:global)

(["1"], [], false, function($__System) {
var require = this.require, exports = this.exports, module = this.module;
$__System.registerDynamic('2', [], true, function ($__require, exports, module) {
  /*!
   * merge-descriptors
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */

  'use strict';

  /**
   * Module exports.
   * @public
   */

  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = merge;

  /**
   * Module variables.
   * @private
   */

  var hasOwnProperty = Object.prototype.hasOwnProperty;

  /**
   * Merge the property descriptors of `src` into `dest`
   *
   * @param {object} dest Object to add descriptors to
   * @param {object} src Object to clone descriptors from
   * @param {boolean} [redefine=true] Redefine `dest` properties with `src` properties
   * @returns {object} Reference to dest
   * @public
   */

  function merge(dest, src, redefine) {
    if (!dest) {
      throw new TypeError('argument dest is required');
    }

    if (!src) {
      throw new TypeError('argument src is required');
    }

    if (redefine === undefined) {
      // Default to true
      redefine = true;
    }

    Object.getOwnPropertyNames(src).forEach(function forEachOwnPropertyName(name) {
      if (!redefine && hasOwnProperty.call(dest, name)) {
        // Skip desriptor
        return;
      }

      // Copy descriptor
      var descriptor = Object.getOwnPropertyDescriptor(src, name);
      Object.defineProperty(dest, name, descriptor);
    });

    return dest;
  }
  return module.exports;
});
$__System.registerDynamic("3", ["2"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("2");
  return module.exports;
});
$__System.registerDynamic('4', [], true, function ($__require, exports, module) {
  /*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */

  'use strict';

  /**
   * Initialization middleware, exposing the
   * request and response to each other, as well
   * as defaulting the X-Powered-By header field.
   *
   * @param {Function} app
   * @return {Function}
   * @api private
   */

  var define,
      global = this || self,
      GLOBAL = global;
  exports.init = function (app) {
    return function expressInit(req, res, next) {
      if (app.enabled('x-powered-by')) res.setHeader('X-Powered-By', 'Express');
      req.res = res;
      res.req = req;
      req.next = next;

      req.__proto__ = app.request;
      res.__proto__ = app.response;

      res.locals = res.locals || Object.create(null);

      next();
    };
  };
  return module.exports;
});
$__System.registerDynamic('5', ['8', '9', '7', '6'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var debug = $__require('8')('express:view');
  var path = $__require('9');
  var fs = $__require('7');
  var utils = $__require('6');
  var dirname = path.dirname;
  var basename = path.basename;
  var extname = path.extname;
  var join = path.join;
  var resolve = path.resolve;
  module.exports = View;
  function View(name, options) {
    var opts = options || {};
    this.defaultEngine = opts.defaultEngine;
    this.ext = extname(name);
    this.name = name;
    this.root = opts.root;
    if (!this.ext && !this.defaultEngine) {
      throw new Error('No default engine was specified and no extension was provided.');
    }
    var fileName = name;
    if (!this.ext) {
      this.ext = this.defaultEngine[0] !== '.' ? '.' + this.defaultEngine : this.defaultEngine;
      fileName += this.ext;
    }
    if (!opts.engines[this.ext]) {
      opts.engines[this.ext] = $__require(this.ext.substr(1)).__express;
    }
    this.engine = opts.engines[this.ext];
    this.path = this.lookup(fileName);
  }
  View.prototype.lookup = function lookup(name) {
    var path;
    var roots = [].concat(this.root);
    debug('lookup "%s"', name);
    for (var i = 0; i < roots.length && !path; i++) {
      var root = roots[i];
      var loc = resolve(root, name);
      var dir = dirname(loc);
      var file = basename(loc);
      path = this.resolve(dir, file);
    }
    return path;
  };
  View.prototype.render = function render(options, callback) {
    debug('render "%s"', this.path);
    this.engine(this.path, options, callback);
  };
  View.prototype.resolve = function resolve(dir, file) {
    var ext = this.ext;
    var path = join(dir, file);
    var stat = tryStat(path);
    if (stat && stat.isFile()) {
      return path;
    }
    path = join(dir, basename(file, ext), 'index' + ext);
    stat = tryStat(path);
    if (stat && stat.isFile()) {
      return path;
    }
  };
  function tryStat(path) {
    debug('stat "%s"', path);
    try {
      return fs.statSync(path);
    } catch (e) {
      return undefined;
    }
  }
  return module.exports;
});
$__System.registerDynamic('a', ['10', 'b', 'd', '4', 'c', '8', '5', '11', '6', '12', 'e', 'f', '9', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var finalhandler = $__require('10');
    var Router = $__require('b');
    var methods = $__require('d');
    var middleware = $__require('4');
    var query = $__require('c');
    var debug = $__require('8')('express:application');
    var View = $__require('5');
    var http = $__require('11');
    var compileETag = $__require('6').compileETag;
    var compileQueryParser = $__require('6').compileQueryParser;
    var compileTrust = $__require('6').compileTrust;
    var deprecate = $__require('12')('express');
    var flatten = $__require('e');
    var merge = $__require('f');
    var resolve = $__require('9').resolve;
    var slice = Array.prototype.slice;
    var app = exports = module.exports = {};
    var trustProxyDefaultSymbol = '@@symbol:trust_proxy_default';
    app.init = function init() {
      this.cache = {};
      this.engines = {};
      this.settings = {};
      this.defaultConfiguration();
    };
    app.defaultConfiguration = function defaultConfiguration() {
      var env = 'production' || 'development';
      this.enable('x-powered-by');
      this.set('etag', 'weak');
      this.set('env', env);
      this.set('query parser', 'extended');
      this.set('subdomain offset', 2);
      this.set('trust proxy', false);
      Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
        configurable: true,
        value: true
      });
      debug('booting in %s mode', env);
      this.on('mount', function onmount(parent) {
        if (this.settings[trustProxyDefaultSymbol] === true && typeof parent.settings['trust proxy fn'] === 'function') {
          delete this.settings['trust proxy'];
          delete this.settings['trust proxy fn'];
        }
        this.request.__proto__ = parent.request;
        this.response.__proto__ = parent.response;
        this.engines.__proto__ = parent.engines;
        this.settings.__proto__ = parent.settings;
      });
      this.locals = Object.create(null);
      this.mountpath = '/';
      this.locals.settings = this.settings;
      this.set('view', View);
      this.set('views', resolve('views'));
      this.set('jsonp callback name', 'callback');
      if (env === 'production') {
        this.enable('view cache');
      }
      Object.defineProperty(this, 'router', { get: function () {
          throw new Error('\'app.router\' is deprecated!\nPlease see the 3.x to 4.x migration guide for details on how to update your app.');
        } });
    };
    app.lazyrouter = function lazyrouter() {
      if (!this._router) {
        this._router = new Router({
          caseSensitive: this.enabled('case sensitive routing'),
          strict: this.enabled('strict routing')
        });
        this._router.use(query(this.get('query parser fn')));
        this._router.use(middleware.init(this));
      }
    };
    app.handle = function handle(req, res, callback) {
      var router = this._router;
      var done = callback || finalhandler(req, res, {
        env: this.get('env'),
        onerror: logerror.bind(this)
      });
      if (!router) {
        debug('no routes defined on app');
        done();
        return;
      }
      router.handle(req, res, done);
    };
    app.use = function use(fn) {
      var offset = 0;
      var path = '/';
      if (typeof fn !== 'function') {
        var arg = fn;
        while (Array.isArray(arg) && arg.length !== 0) {
          arg = arg[0];
        }
        if (typeof arg !== 'function') {
          offset = 1;
          path = fn;
        }
      }
      var fns = flatten(slice.call(arguments, offset));
      if (fns.length === 0) {
        throw new TypeError('app.use() requires middleware functions');
      }
      this.lazyrouter();
      var router = this._router;
      fns.forEach(function (fn) {
        if (!fn || !fn.handle || !fn.set) {
          return router.use(path, fn);
        }
        debug('.use app under %s', path);
        fn.mountpath = path;
        fn.parent = this;
        router.use(path, function mounted_app(req, res, next) {
          var orig = req.app;
          fn.handle(req, res, function (err) {
            req.__proto__ = orig.request;
            res.__proto__ = orig.response;
            next(err);
          });
        });
        fn.emit('mount', this);
      }, this);
      return this;
    };
    app.route = function route(path) {
      this.lazyrouter();
      return this._router.route(path);
    };
    app.engine = function engine(ext, fn) {
      if (typeof fn !== 'function') {
        throw new Error('callback function required');
      }
      var extension = ext[0] !== '.' ? '.' + ext : ext;
      this.engines[extension] = fn;
      return this;
    };
    app.param = function param(name, fn) {
      this.lazyrouter();
      if (Array.isArray(name)) {
        for (var i = 0; i < name.length; i++) {
          this.param(name[i], fn);
        }
        return this;
      }
      this._router.param(name, fn);
      return this;
    };
    app.set = function set(setting, val) {
      if (arguments.length === 1) {
        return this.settings[setting];
      }
      debug('set "%s" to %o', setting, val);
      this.settings[setting] = val;
      switch (setting) {
        case 'etag':
          this.set('etag fn', compileETag(val));
          break;
        case 'query parser':
          this.set('query parser fn', compileQueryParser(val));
          break;
        case 'trust proxy':
          this.set('trust proxy fn', compileTrust(val));
          Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
            configurable: true,
            value: false
          });
          break;
      }
      return this;
    };
    app.path = function path() {
      return this.parent ? this.parent.path() + this.mountpath : '';
    };
    app.enabled = function enabled(setting) {
      return Boolean(this.set(setting));
    };
    app.disabled = function disabled(setting) {
      return !this.set(setting);
    };
    app.enable = function enable(setting) {
      return this.set(setting, true);
    };
    app.disable = function disable(setting) {
      return this.set(setting, false);
    };
    methods.forEach(function (method) {
      app[method] = function (path) {
        if (method === 'get' && arguments.length === 1) {
          return this.set(path);
        }
        this.lazyrouter();
        var route = this._router.route(path);
        route[method].apply(route, slice.call(arguments, 1));
        return this;
      };
    });
    app.all = function all(path) {
      this.lazyrouter();
      var route = this._router.route(path);
      var args = slice.call(arguments, 1);
      for (var i = 0; i < methods.length; i++) {
        route[methods[i]].apply(route, args);
      }
      return this;
    };
    app.del = deprecate.function(app.delete, 'app.del: Use app.delete instead');
    app.render = function render(name, options, callback) {
      var cache = this.cache;
      var done = callback;
      var engines = this.engines;
      var opts = options;
      var renderOptions = {};
      var view;
      if (typeof options === 'function') {
        done = options;
        opts = {};
      }
      merge(renderOptions, this.locals);
      if (opts._locals) {
        merge(renderOptions, opts._locals);
      }
      merge(renderOptions, opts);
      if (renderOptions.cache == null) {
        renderOptions.cache = this.enabled('view cache');
      }
      if (renderOptions.cache) {
        view = cache[name];
      }
      if (!view) {
        var View = this.get('view');
        view = new View(name, {
          defaultEngine: this.get('view engine'),
          root: this.get('views'),
          engines: engines
        });
        if (!view.path) {
          var dirs = Array.isArray(view.root) && view.root.length > 1 ? 'directories "' + view.root.slice(0, -1).join('", "') + '" or "' + view.root[view.root.length - 1] + '"' : 'directory "' + view.root + '"';
          var err = new Error('Failed to lookup view "' + name + '" in views ' + dirs);
          err.view = view;
          return done(err);
        }
        if (renderOptions.cache) {
          cache[name] = view;
        }
      }
      tryRender(view, renderOptions, done);
    };
    app.listen = function listen() {
      var server = http.createServer(this);
      return server.listen.apply(server, arguments);
    };
    function logerror(err) {
      if (this.get('env') !== 'test') console.error(err.stack || err.toString());
    }
    function tryRender(view, options, callback) {
      try {
        view.render(options, callback);
      } catch (err) {
        callback(err);
      }
    }
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('14', ['8', 'e', '15', 'd', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var debug = $__require('8')('express:router:route');
    var flatten = $__require('e');
    var Layer = $__require('15');
    var methods = $__require('d');
    var slice = Array.prototype.slice;
    var toString = Object.prototype.toString;
    module.exports = Route;
    function Route(path) {
      this.path = path;
      this.stack = [];
      debug('new %s', path);
      this.methods = {};
    }
    Route.prototype._handles_method = function _handles_method(method) {
      if (this.methods._all) {
        return true;
      }
      var name = method.toLowerCase();
      if (name === 'head' && !this.methods['head']) {
        name = 'get';
      }
      return Boolean(this.methods[name]);
    };
    Route.prototype._options = function _options() {
      var methods = Object.keys(this.methods);
      if (this.methods.get && !this.methods.head) {
        methods.push('head');
      }
      for (var i = 0; i < methods.length; i++) {
        methods[i] = methods[i].toUpperCase();
      }
      return methods;
    };
    Route.prototype.dispatch = function dispatch(req, res, done) {
      var idx = 0;
      var stack = this.stack;
      if (stack.length === 0) {
        return done();
      }
      var method = req.method.toLowerCase();
      if (method === 'head' && !this.methods['head']) {
        method = 'get';
      }
      req.route = this;
      next();
      function next(err) {
        if (err && err === 'route') {
          return done();
        }
        var layer = stack[idx++];
        if (!layer) {
          return done(err);
        }
        if (layer.method && layer.method !== method) {
          return next(err);
        }
        if (err) {
          layer.handle_error(err, req, res, next);
        } else {
          layer.handle_request(req, res, next);
        }
      }
    };
    Route.prototype.all = function all() {
      var handles = flatten(slice.call(arguments));
      for (var i = 0; i < handles.length; i++) {
        var handle = handles[i];
        if (typeof handle !== 'function') {
          var type = toString.call(handle);
          var msg = 'Route.all() requires callback functions but got a ' + type;
          throw new TypeError(msg);
        }
        var layer = Layer('/', {}, handle);
        layer.method = undefined;
        this.methods._all = true;
        this.stack.push(layer);
      }
      return this;
    };
    methods.forEach(function (method) {
      Route.prototype[method] = function () {
        var handles = flatten(slice.call(arguments));
        for (var i = 0; i < handles.length; i++) {
          var handle = handles[i];
          if (typeof handle !== 'function') {
            var type = toString.call(handle);
            var msg = 'Route.' + method + '() requires callback functions but got a ' + type;
            throw new Error(msg);
          }
          debug('%s %s', method, this.path);
          var layer = Layer('/', {}, handle);
          layer.method = method;
          this.methods[method] = true;
          this.stack.push(layer);
        }
        return this;
      };
    });
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('16', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /**
   * Expose `pathtoRegexp`.
   */

  module.exports = pathtoRegexp;

  /**
   * Match matching groups in a regular expression.
   */
  var MATCHING_GROUP_REGEXP = /\((?!\?)/g;

  /**
   * Normalize the given path string,
   * returning a regular expression.
   *
   * An empty array should be passed,
   * which will contain the placeholder
   * key names. For example "/user/:id" will
   * then contain ["id"].
   *
   * @param  {String|RegExp|Array} path
   * @param  {Array} keys
   * @param  {Object} options
   * @return {RegExp}
   * @api private
   */

  function pathtoRegexp(path, keys, options) {
    options = options || {};
    keys = keys || [];
    var strict = options.strict;
    var end = options.end !== false;
    var flags = options.sensitive ? '' : 'i';
    var extraOffset = 0;
    var keysOffset = keys.length;
    var i = 0;
    var name = 0;
    var m;

    if (path instanceof RegExp) {
      while (m = MATCHING_GROUP_REGEXP.exec(path.source)) {
        keys.push({
          name: name++,
          optional: false,
          offset: m.index
        });
      }

      return path;
    }

    if (Array.isArray(path)) {
      // Map array parts into regexps and return their source. We also pass
      // the same keys and options instance into every generation to get
      // consistent matching groups before we join the sources together.
      path = path.map(function (value) {
        return pathtoRegexp(value, keys, options).source;
      });

      return new RegExp('(?:' + path.join('|') + ')', flags);
    }

    path = ('^' + path + (strict ? '' : path[path.length - 1] === '/' ? '?' : '/?')).replace(/\/\(/g, '/(?:').replace(/([\/\.])/g, '\\$1').replace(/(\\\/)?(\\\.)?:(\w+)(\(.*?\))?(\*)?(\?)?/g, function (match, slash, format, key, capture, star, optional, offset) {
      slash = slash || '';
      format = format || '';
      capture = capture || '([^\\/' + format + ']+?)';
      optional = optional || '';

      keys.push({
        name: key,
        optional: !!optional,
        offset: offset + extraOffset
      });

      var result = '' + (optional ? '' : slash) + '(?:' + format + (optional ? slash : '') + capture + (star ? '((?:[\\/' + format + '].+?)?)' : '') + ')' + optional;

      extraOffset += result.length - match.length;

      return result;
    }).replace(/\*/g, function (star, index) {
      var len = keys.length;

      while (len-- > keysOffset && keys[len].offset > index) {
        keys[len].offset += 3; // Replacement length minus asterisk length.
      }

      return '(.*)';
    });

    // This is a workaround for handling unnamed matching groups.
    while (m = MATCHING_GROUP_REGEXP.exec(path)) {
      var escapeCount = 0;
      var index = m.index;

      while (path.charAt(--index) === '\\') {
        escapeCount++;
      }

      // It's possible to escape the bracket.
      if (escapeCount % 2 === 1) {
        continue;
      }

      if (keysOffset + i === keys.length || keys[keysOffset + i].offset > m.index) {
        keys.splice(keysOffset + i, 0, {
          name: name++, // Unnamed matching groups must be consistently linear.
          optional: false,
          offset: m.index
        });
      }

      i++;
    }

    // If the path is non-ending, match until the end or a slash.
    path += end ? '$' : path[path.length - 1] === '/' ? '' : '(?=\\/|$)';

    return new RegExp(path, flags);
  };
  return module.exports;
});
$__System.registerDynamic("17", ["16"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("16");
  return module.exports;
});
$__System.registerDynamic('15', ['17', '8'], true, function ($__require, exports, module) {
  /*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */

  'use strict';

  /**
   * Module dependencies.
   * @private
   */

  var define,
      global = this || self,
      GLOBAL = global;
  var pathRegexp = $__require('17');
  var debug = $__require('8')('express:router:layer');

  /**
   * Module variables.
   * @private
   */

  var hasOwnProperty = Object.prototype.hasOwnProperty;

  /**
   * Module exports.
   * @public
   */

  module.exports = Layer;

  function Layer(path, options, fn) {
    if (!(this instanceof Layer)) {
      return new Layer(path, options, fn);
    }

    debug('new %s', path);
    var opts = options || {};

    this.handle = fn;
    this.name = fn.name || '<anonymous>';
    this.params = undefined;
    this.path = undefined;
    this.regexp = pathRegexp(path, this.keys = [], opts);

    if (path === '/' && opts.end === false) {
      this.regexp.fast_slash = true;
    }
  }

  /**
   * Handle the error for the layer.
   *
   * @param {Error} error
   * @param {Request} req
   * @param {Response} res
   * @param {function} next
   * @api private
   */

  Layer.prototype.handle_error = function handle_error(error, req, res, next) {
    var fn = this.handle;

    if (fn.length !== 4) {
      // not a standard error handler
      return next(error);
    }

    try {
      fn(error, req, res, next);
    } catch (err) {
      next(err);
    }
  };

  /**
   * Handle the request for the layer.
   *
   * @param {Request} req
   * @param {Response} res
   * @param {function} next
   * @api private
   */

  Layer.prototype.handle_request = function handle(req, res, next) {
    var fn = this.handle;

    if (fn.length > 3) {
      // not a standard request handler
      return next();
    }

    try {
      fn(req, res, next);
    } catch (err) {
      next(err);
    }
  };

  /**
   * Check if this route matches `path`, if so
   * populate `.params`.
   *
   * @param {String} path
   * @return {Boolean}
   * @api private
   */

  Layer.prototype.match = function match(path) {
    if (path == null) {
      // no path, nothing matches
      this.params = undefined;
      this.path = undefined;
      return false;
    }

    if (this.regexp.fast_slash) {
      // fast path non-ending match for / (everything matches)
      this.params = {};
      this.path = '';
      return true;
    }

    var m = this.regexp.exec(path);

    if (!m) {
      this.params = undefined;
      this.path = undefined;
      return false;
    }

    // store values
    this.params = {};
    this.path = m[0];

    var keys = this.keys;
    var params = this.params;

    for (var i = 1; i < m.length; i++) {
      var key = keys[i - 1];
      var prop = key.name;
      var val = decode_param(m[i]);

      if (val !== undefined || !hasOwnProperty.call(params, prop)) {
        params[prop] = val;
      }
    }

    return true;
  };

  /**
   * Decode param value.
   *
   * @param {string} val
   * @return {string}
   * @private
   */

  function decode_param(val) {
    if (typeof val !== 'string' || val.length === 0) {
      return val;
    }

    try {
      return decodeURIComponent(val);
    } catch (err) {
      if (err instanceof URIError) {
        err.message = 'Failed to decode param \'' + val + '\'';
        err.status = err.statusCode = 400;
      }

      throw err;
    }
  }
  return module.exports;
});
$__System.registerDynamic('18', ['@empty'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var http = $__require('@empty');
  module.exports = getCurrentNodeMethods() || getBasicNodeMethods();
  function getCurrentNodeMethods() {
    return http.METHODS && http.METHODS.map(function lowerCaseMethod(method) {
      return method.toLowerCase();
    });
  }
  function getBasicNodeMethods() {
    return ['get', 'post', 'put', 'head', 'delete', 'options', 'trace', 'copy', 'lock', 'mkcol', 'move', 'purge', 'propfind', 'proppatch', 'unlock', 'report', 'mkactivity', 'checkout', 'merge', 'm-search', 'notify', 'subscribe', 'unsubscribe', 'patch', 'search', 'connect'];
  }
  return module.exports;
});
$__System.registerDynamic("d", ["18"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("18");
  return module.exports;
});
$__System.registerDynamic('b', ['14', '15', 'd', 'f', '8', '12', 'e', '19', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var Route = $__require('14');
    var Layer = $__require('15');
    var methods = $__require('d');
    var mixin = $__require('f');
    var debug = $__require('8')('express:router');
    var deprecate = $__require('12')('express');
    var flatten = $__require('e');
    var parseUrl = $__require('19');
    var objectRegExp = /^\[object (\S+)\]$/;
    var slice = Array.prototype.slice;
    var toString = Object.prototype.toString;
    var proto = module.exports = function (options) {
      var opts = options || {};
      function router(req, res, next) {
        router.handle(req, res, next);
      }
      router.__proto__ = proto;
      router.params = {};
      router._params = [];
      router.caseSensitive = opts.caseSensitive;
      router.mergeParams = opts.mergeParams;
      router.strict = opts.strict;
      router.stack = [];
      return router;
    };
    proto.param = function param(name, fn) {
      if (typeof name === 'function') {
        deprecate('router.param(fn): Refactor to use path params');
        this._params.push(name);
        return;
      }
      var params = this._params;
      var len = params.length;
      var ret;
      if (name[0] === ':') {
        deprecate('router.param(' + JSON.stringify(name) + ', fn): Use router.param(' + JSON.stringify(name.substr(1)) + ', fn) instead');
        name = name.substr(1);
      }
      for (var i = 0; i < len; ++i) {
        if (ret = params[i](name, fn)) {
          fn = ret;
        }
      }
      if ('function' != typeof fn) {
        throw new Error('invalid param() call for ' + name + ', got ' + fn);
      }
      (this.params[name] = this.params[name] || []).push(fn);
      return this;
    };
    proto.handle = function handle(req, res, out) {
      var self = this;
      debug('dispatching %s %s', req.method, req.url);
      var search = 1 + req.url.indexOf('?');
      var pathlength = search ? search - 1 : req.url.length;
      var fqdn = req.url[0] !== '/' && 1 + req.url.substr(0, pathlength).indexOf('://');
      var protohost = fqdn ? req.url.substr(0, req.url.indexOf('/', 2 + fqdn)) : '';
      var idx = 0;
      var removed = '';
      var slashAdded = false;
      var paramcalled = {};
      var options = [];
      var stack = self.stack;
      var parentParams = req.params;
      var parentUrl = req.baseUrl || '';
      var done = restore(out, req, 'baseUrl', 'next', 'params');
      req.next = next;
      if (req.method === 'OPTIONS') {
        done = wrap(done, function (old, err) {
          if (err || options.length === 0) return old(err);
          sendOptionsResponse(res, options, old);
        });
      }
      req.baseUrl = parentUrl;
      req.originalUrl = req.originalUrl || req.url;
      next();
      function next(err) {
        var layerError = err === 'route' ? null : err;
        if (slashAdded) {
          req.url = req.url.substr(1);
          slashAdded = false;
        }
        if (removed.length !== 0) {
          req.baseUrl = parentUrl;
          req.url = protohost + removed + req.url.substr(protohost.length);
          removed = '';
        }
        if (idx >= stack.length) {
          setImmediate(done, layerError);
          return;
        }
        var path = getPathname(req);
        if (path == null) {
          return done(layerError);
        }
        var layer;
        var match;
        var route;
        while (match !== true && idx < stack.length) {
          layer = stack[idx++];
          match = matchLayer(layer, path);
          route = layer.route;
          if (typeof match !== 'boolean') {
            layerError = layerError || match;
          }
          if (match !== true) {
            continue;
          }
          if (!route) {
            continue;
          }
          if (layerError) {
            match = false;
            continue;
          }
          var method = req.method;
          var has_method = route._handles_method(method);
          if (!has_method && method === 'OPTIONS') {
            appendMethods(options, route._options());
          }
          if (!has_method && method !== 'HEAD') {
            match = false;
            continue;
          }
        }
        if (match !== true) {
          return done(layerError);
        }
        if (route) {
          req.route = route;
        }
        req.params = self.mergeParams ? mergeParams(layer.params, parentParams) : layer.params;
        var layerPath = layer.path;
        self.process_params(layer, paramcalled, req, res, function (err) {
          if (err) {
            return next(layerError || err);
          }
          if (route) {
            return layer.handle_request(req, res, next);
          }
          trim_prefix(layer, layerError, layerPath, path);
        });
      }
      function trim_prefix(layer, layerError, layerPath, path) {
        var c = path[layerPath.length];
        if (c && '/' !== c && '.' !== c) return next(layerError);
        if (layerPath.length !== 0) {
          debug('trim prefix (%s) from url %s', layerPath, req.url);
          removed = layerPath;
          req.url = protohost + req.url.substr(protohost.length + removed.length);
          if (!fqdn && req.url[0] !== '/') {
            req.url = '/' + req.url;
            slashAdded = true;
          }
          req.baseUrl = parentUrl + (removed[removed.length - 1] === '/' ? removed.substring(0, removed.length - 1) : removed);
        }
        debug('%s %s : %s', layer.name, layerPath, req.originalUrl);
        if (layerError) {
          layer.handle_error(layerError, req, res, next);
        } else {
          layer.handle_request(req, res, next);
        }
      }
    };
    proto.process_params = function process_params(layer, called, req, res, done) {
      var params = this.params;
      var keys = layer.keys;
      if (!keys || keys.length === 0) {
        return done();
      }
      var i = 0;
      var name;
      var paramIndex = 0;
      var key;
      var paramVal;
      var paramCallbacks;
      var paramCalled;
      function param(err) {
        if (err) {
          return done(err);
        }
        if (i >= keys.length) {
          return done();
        }
        paramIndex = 0;
        key = keys[i++];
        if (!key) {
          return done();
        }
        name = key.name;
        paramVal = req.params[name];
        paramCallbacks = params[name];
        paramCalled = called[name];
        if (paramVal === undefined || !paramCallbacks) {
          return param();
        }
        if (paramCalled && (paramCalled.match === paramVal || paramCalled.error && paramCalled.error !== 'route')) {
          req.params[name] = paramCalled.value;
          return param(paramCalled.error);
        }
        called[name] = paramCalled = {
          error: null,
          match: paramVal,
          value: paramVal
        };
        paramCallback();
      }
      function paramCallback(err) {
        var fn = paramCallbacks[paramIndex++];
        paramCalled.value = req.params[key.name];
        if (err) {
          paramCalled.error = err;
          param(err);
          return;
        }
        if (!fn) return param();
        try {
          fn(req, res, paramCallback, paramVal, key.name);
        } catch (e) {
          paramCallback(e);
        }
      }
      param();
    };
    proto.use = function use(fn) {
      var offset = 0;
      var path = '/';
      if (typeof fn !== 'function') {
        var arg = fn;
        while (Array.isArray(arg) && arg.length !== 0) {
          arg = arg[0];
        }
        if (typeof arg !== 'function') {
          offset = 1;
          path = fn;
        }
      }
      var callbacks = flatten(slice.call(arguments, offset));
      if (callbacks.length === 0) {
        throw new TypeError('Router.use() requires middleware functions');
      }
      for (var i = 0; i < callbacks.length; i++) {
        var fn = callbacks[i];
        if (typeof fn !== 'function') {
          throw new TypeError('Router.use() requires middleware function but got a ' + gettype(fn));
        }
        debug('use %s %s', path, fn.name || '<anonymous>');
        var layer = new Layer(path, {
          sensitive: this.caseSensitive,
          strict: false,
          end: false
        }, fn);
        layer.route = undefined;
        this.stack.push(layer);
      }
      return this;
    };
    proto.route = function route(path) {
      var route = new Route(path);
      var layer = new Layer(path, {
        sensitive: this.caseSensitive,
        strict: this.strict,
        end: true
      }, route.dispatch.bind(route));
      layer.route = route;
      this.stack.push(layer);
      return route;
    };
    methods.concat('all').forEach(function (method) {
      proto[method] = function (path) {
        var route = this.route(path);
        route[method].apply(route, slice.call(arguments, 1));
        return this;
      };
    });
    function appendMethods(list, addition) {
      for (var i = 0; i < addition.length; i++) {
        var method = addition[i];
        if (list.indexOf(method) === -1) {
          list.push(method);
        }
      }
    }
    function getPathname(req) {
      try {
        return parseUrl(req).pathname;
      } catch (err) {
        return undefined;
      }
    }
    function gettype(obj) {
      var type = typeof obj;
      if (type !== 'object') {
        return type;
      }
      return toString.call(obj).replace(objectRegExp, '$1');
    }
    function matchLayer(layer, path) {
      try {
        return layer.match(path);
      } catch (err) {
        return err;
      }
    }
    function mergeParams(params, parent) {
      if (typeof parent !== 'object' || !parent) {
        return params;
      }
      var obj = mixin({}, parent);
      if (!(0 in params) || !(0 in parent)) {
        return mixin(obj, params);
      }
      var i = 0;
      var o = 0;
      while (i in params) {
        i++;
      }
      while (o in parent) {
        o++;
      }
      for (i--; i >= 0; i--) {
        params[i + o] = params[i];
        if (i < o) {
          delete params[i];
        }
      }
      return mixin(obj, params);
    }
    function restore(fn, obj) {
      var props = new Array(arguments.length - 2);
      var vals = new Array(arguments.length - 2);
      for (var i = 0; i < props.length; i++) {
        props[i] = arguments[i + 2];
        vals[i] = obj[props[i]];
      }
      return function (err) {
        for (var i = 0; i < props.length; i++) {
          obj[props[i]] = vals[i];
        }
        return fn.apply(this, arguments);
      };
    }
    function sendOptionsResponse(res, options, next) {
      try {
        var body = options.join(',');
        res.set('Allow', body);
        res.send(body);
      } catch (err) {
        next(err);
      }
    }
    function wrap(old, fn) {
      return function proxy() {
        var args = new Array(arguments.length + 1);
        args[0] = old;
        for (var i = 0, len = arguments.length; i < len; i++) {
          args[i + 1] = arguments[i];
        }
        fn.apply(this, args);
      };
    }
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('1a', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  module.exports = preferredCharsets;
  preferredCharsets.preferredCharsets = preferredCharsets;

  function parseAcceptCharset(accept) {
    var accepts = accept.split(',');

    for (var i = 0, j = 0; i < accepts.length; i++) {
      var charset = parseCharset(accepts[i].trim(), i);

      if (charset) {
        accepts[j++] = charset;
      }
    }

    // trim accepts
    accepts.length = j;

    return accepts;
  }

  function parseCharset(s, i) {
    var match = s.match(/^\s*(\S+?)\s*(?:;(.*))?$/);
    if (!match) return null;

    var charset = match[1];
    var q = 1;
    if (match[2]) {
      var params = match[2].split(';');
      for (var i = 0; i < params.length; i++) {
        var p = params[i].trim().split('=');
        if (p[0] === 'q') {
          q = parseFloat(p[1]);
          break;
        }
      }
    }

    return {
      charset: charset,
      q: q,
      i: i
    };
  }

  function getCharsetPriority(charset, accepted, index) {
    var priority = { o: -1, q: 0, s: 0 };

    for (var i = 0; i < accepted.length; i++) {
      var spec = specify(charset, accepted[i], index);

      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }

    return priority;
  }

  function specify(charset, spec, index) {
    var s = 0;
    if (spec.charset.toLowerCase() === charset.toLowerCase()) {
      s |= 1;
    } else if (spec.charset !== '*') {
      return null;
    }

    return {
      i: index,
      o: spec.i,
      q: spec.q,
      s: s
    };
  }

  function preferredCharsets(accept, provided) {
    // RFC 2616 sec 14.2: no header = *
    var accepts = parseAcceptCharset(accept === undefined ? '*' : accept || '');

    if (!provided) {
      // sorted list of all charsets
      return accepts.filter(isQuality).sort(compareSpecs).map(function getCharset(spec) {
        return spec.charset;
      });
    }

    var priorities = provided.map(function getPriority(type, index) {
      return getCharsetPriority(type, accepts, index);
    });

    // sorted list of accepted charsets
    return priorities.filter(isQuality).sort(compareSpecs).map(function getCharset(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }

  function compareSpecs(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
  }

  function isQuality(spec) {
    return spec.q > 0;
  }
  return module.exports;
});
$__System.registerDynamic('1b', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  module.exports = preferredEncodings;
  preferredEncodings.preferredEncodings = preferredEncodings;

  function parseAcceptEncoding(accept) {
    var accepts = accept.split(',');
    var hasIdentity = false;
    var minQuality = 1;

    for (var i = 0, j = 0; i < accepts.length; i++) {
      var encoding = parseEncoding(accepts[i].trim(), i);

      if (encoding) {
        accepts[j++] = encoding;
        hasIdentity = hasIdentity || specify('identity', encoding);
        minQuality = Math.min(minQuality, encoding.q || 1);
      }
    }

    if (!hasIdentity) {
      /*
       * If identity doesn't explicitly appear in the accept-encoding header,
       * it's added to the list of acceptable encoding with the lowest q
       */
      accepts[j++] = {
        encoding: 'identity',
        q: minQuality,
        i: i
      };
    }

    // trim accepts
    accepts.length = j;

    return accepts;
  }

  function parseEncoding(s, i) {
    var match = s.match(/^\s*(\S+?)\s*(?:;(.*))?$/);

    if (!match) return null;

    var encoding = match[1];
    var q = 1;
    if (match[2]) {
      var params = match[2].split(';');
      for (var i = 0; i < params.length; i++) {
        var p = params[i].trim().split('=');
        if (p[0] === 'q') {
          q = parseFloat(p[1]);
          break;
        }
      }
    }

    return {
      encoding: encoding,
      q: q,
      i: i
    };
  }

  function getEncodingPriority(encoding, accepted, index) {
    var priority = { o: -1, q: 0, s: 0 };

    for (var i = 0; i < accepted.length; i++) {
      var spec = specify(encoding, accepted[i], index);

      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }

    return priority;
  }

  function specify(encoding, spec, index) {
    var s = 0;
    if (spec.encoding.toLowerCase() === encoding.toLowerCase()) {
      s |= 1;
    } else if (spec.encoding !== '*') {
      return null;
    }

    return {
      i: index,
      o: spec.i,
      q: spec.q,
      s: s
    };
  };

  function preferredEncodings(accept, provided) {
    var accepts = parseAcceptEncoding(accept || '');

    if (!provided) {
      // sorted list of all encodings
      return accepts.filter(isQuality).sort(compareSpecs).map(function getEncoding(spec) {
        return spec.encoding;
      });
    }

    var priorities = provided.map(function getPriority(type, index) {
      return getEncodingPriority(type, accepts, index);
    });

    // sorted list of accepted encodings
    return priorities.filter(isQuality).sort(compareSpecs).map(function getEncoding(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }

  function compareSpecs(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
  }

  function isQuality(spec) {
    return spec.q > 0;
  }
  return module.exports;
});
$__System.registerDynamic('1c', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  module.exports = preferredLanguages;
  preferredLanguages.preferredLanguages = preferredLanguages;

  function parseAcceptLanguage(accept) {
    var accepts = accept.split(',');

    for (var i = 0, j = 0; i < accepts.length; i++) {
      var langauge = parseLanguage(accepts[i].trim(), i);

      if (langauge) {
        accepts[j++] = langauge;
      }
    }

    // trim accepts
    accepts.length = j;

    return accepts;
  }

  function parseLanguage(s, i) {
    var match = s.match(/^\s*(\S+?)(?:-(\S+?))?\s*(?:;(.*))?$/);
    if (!match) return null;

    var prefix = match[1],
        suffix = match[2],
        full = prefix;

    if (suffix) full += "-" + suffix;

    var q = 1;
    if (match[3]) {
      var params = match[3].split(';');
      for (var i = 0; i < params.length; i++) {
        var p = params[i].split('=');
        if (p[0] === 'q') q = parseFloat(p[1]);
      }
    }

    return {
      prefix: prefix,
      suffix: suffix,
      q: q,
      i: i,
      full: full
    };
  }

  function getLanguagePriority(language, accepted, index) {
    var priority = { o: -1, q: 0, s: 0 };

    for (var i = 0; i < accepted.length; i++) {
      var spec = specify(language, accepted[i], index);

      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }

    return priority;
  }

  function specify(language, spec, index) {
    var p = parseLanguage(language);
    if (!p) return null;
    var s = 0;
    if (spec.full.toLowerCase() === p.full.toLowerCase()) {
      s |= 4;
    } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
      s |= 2;
    } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
      s |= 1;
    } else if (spec.full !== '*') {
      return null;
    }

    return {
      i: index,
      o: spec.i,
      q: spec.q,
      s: s
    };
  };

  function preferredLanguages(accept, provided) {
    // RFC 2616 sec 14.4: no header = *
    var accepts = parseAcceptLanguage(accept === undefined ? '*' : accept || '');

    if (!provided) {
      // sorted list of all languages
      return accepts.filter(isQuality).sort(compareSpecs).map(function getLanguage(spec) {
        return spec.full;
      });
    }

    var priorities = provided.map(function getPriority(type, index) {
      return getLanguagePriority(type, accepts, index);
    });

    // sorted list of accepted languages
    return priorities.filter(isQuality).sort(compareSpecs).map(function getLanguage(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }

  function compareSpecs(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
  }

  function isQuality(spec) {
    return spec.q > 0;
  }
  return module.exports;
});
$__System.registerDynamic("1d", [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /**
   * negotiator
   * Copyright(c) 2012 Isaac Z. Schlueter
   * Copyright(c) 2014 Federico Romero
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */

  module.exports = preferredMediaTypes;
  preferredMediaTypes.preferredMediaTypes = preferredMediaTypes;

  function parseAccept(accept) {
    var accepts = splitMediaTypes(accept);

    for (var i = 0, j = 0; i < accepts.length; i++) {
      var mediaType = parseMediaType(accepts[i].trim(), i);

      if (mediaType) {
        accepts[j++] = mediaType;
      }
    }

    // trim accepts
    accepts.length = j;

    return accepts;
  };

  function parseMediaType(s, i) {
    var match = s.match(/\s*(\S+?)\/([^;\s]+)\s*(?:;(.*))?/);
    if (!match) return null;

    var type = match[1],
        subtype = match[2],
        full = "" + type + "/" + subtype,
        params = {},
        q = 1;

    if (match[3]) {
      params = match[3].split(';').map(function (s) {
        return s.trim().split('=');
      }).reduce(function (set, p) {
        var name = p[0].toLowerCase();
        var value = p[1];

        set[name] = value && value[0] === '"' && value[value.length - 1] === '"' ? value.substr(1, value.length - 2) : value;

        return set;
      }, params);

      if (params.q != null) {
        q = parseFloat(params.q);
        delete params.q;
      }
    }

    return {
      type: type,
      subtype: subtype,
      params: params,
      q: q,
      i: i,
      full: full
    };
  }

  function getMediaTypePriority(type, accepted, index) {
    var priority = { o: -1, q: 0, s: 0 };

    for (var i = 0; i < accepted.length; i++) {
      var spec = specify(type, accepted[i], index);

      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }

    return priority;
  }

  function specify(type, spec, index) {
    var p = parseMediaType(type);
    var s = 0;

    if (!p) {
      return null;
    }

    if (spec.type.toLowerCase() == p.type.toLowerCase()) {
      s |= 4;
    } else if (spec.type != '*') {
      return null;
    }

    if (spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {
      s |= 2;
    } else if (spec.subtype != '*') {
      return null;
    }

    var keys = Object.keys(spec.params);
    if (keys.length > 0) {
      if (keys.every(function (k) {
        return spec.params[k] == '*' || (spec.params[k] || '').toLowerCase() == (p.params[k] || '').toLowerCase();
      })) {
        s |= 1;
      } else {
        return null;
      }
    }

    return {
      i: index,
      o: spec.i,
      q: spec.q,
      s: s
    };
  }

  function preferredMediaTypes(accept, provided) {
    // RFC 2616 sec 14.2: no header = */*
    var accepts = parseAccept(accept === undefined ? '*/*' : accept || '');

    if (!provided) {
      // sorted list of all types
      return accepts.filter(isQuality).sort(compareSpecs).map(function getType(spec) {
        return spec.full;
      });
    }

    var priorities = provided.map(function getPriority(type, index) {
      return getMediaTypePriority(type, accepts, index);
    });

    // sorted list of accepted types
    return priorities.filter(isQuality).sort(compareSpecs).map(function getType(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }

  function compareSpecs(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
  }

  function isQuality(spec) {
    return spec.q > 0;
  }

  function quoteCount(string) {
    var count = 0;
    var index = 0;

    while ((index = string.indexOf('"', index)) !== -1) {
      count++;
      index++;
    }

    return count;
  }

  function splitMediaTypes(accept) {
    var accepts = accept.split(',');

    for (var i = 1, j = 0; i < accepts.length; i++) {
      if (quoteCount(accepts[j]) % 2 == 0) {
        accepts[++j] = accepts[i];
      } else {
        accepts[j] += ',' + accepts[i];
      }
    }

    // trim accepts
    accepts.length = j + 1;

    return accepts;
  }
  return module.exports;
});
$__System.registerDynamic('1e', ['1a', '1b', '1c', '1d'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var preferredCharsets = $__require('1a');
  var preferredEncodings = $__require('1b');
  var preferredLanguages = $__require('1c');
  var preferredMediaTypes = $__require('1d');
  module.exports = Negotiator;
  Negotiator.Negotiator = Negotiator;
  function Negotiator(request) {
    if (!(this instanceof Negotiator)) {
      return new Negotiator(request);
    }
    this.request = request;
  }
  Negotiator.prototype.charset = function charset(available) {
    var set = this.charsets(available);
    return set && set[0];
  };
  Negotiator.prototype.charsets = function charsets(available) {
    return preferredCharsets(this.request.headers['accept-charset'], available);
  };
  Negotiator.prototype.encoding = function encoding(available) {
    var set = this.encodings(available);
    return set && set[0];
  };
  Negotiator.prototype.encodings = function encodings(available) {
    return preferredEncodings(this.request.headers['accept-encoding'], available);
  };
  Negotiator.prototype.language = function language(available) {
    var set = this.languages(available);
    return set && set[0];
  };
  Negotiator.prototype.languages = function languages(available) {
    return preferredLanguages(this.request.headers['accept-language'], available);
  };
  Negotiator.prototype.mediaType = function mediaType(available) {
    var set = this.mediaTypes(available);
    return set && set[0];
  };
  Negotiator.prototype.mediaTypes = function mediaTypes(available) {
    return preferredMediaTypes(this.request.headers.accept, available);
  };
  Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
  Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
  Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
  Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
  Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
  Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
  Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
  Negotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;
  return module.exports;
});
$__System.registerDynamic("1f", ["1e"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("1e");
  return module.exports;
});
$__System.registerDynamic('20', ['1f', '21'], true, function ($__require, exports, module) {
  /*!
   * accepts
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */

  'use strict';

  /**
   * Module dependencies.
   * @private
   */

  var define,
      global = this || self,
      GLOBAL = global;
  var Negotiator = $__require('1f');
  var mime = $__require('21');

  /**
   * Module exports.
   * @public
   */

  module.exports = Accepts;

  /**
   * Create a new Accepts object for the given req.
   *
   * @param {object} req
   * @public
   */

  function Accepts(req) {
    if (!(this instanceof Accepts)) return new Accepts(req);

    this.headers = req.headers;
    this.negotiator = new Negotiator(req);
  }

  /**
   * Check if the given `type(s)` is acceptable, returning
   * the best match when true, otherwise `undefined`, in which
   * case you should respond with 406 "Not Acceptable".
   *
   * The `type` value may be a single mime type string
   * such as "application/json", the extension name
   * such as "json" or an array `["json", "html", "text/plain"]`. When a list
   * or array is given the _best_ match, if any is returned.
   *
   * Examples:
   *
   *     // Accept: text/html
   *     this.types('html');
   *     // => "html"
   *
   *     // Accept: text/*, application/json
   *     this.types('html');
   *     // => "html"
   *     this.types('text/html');
   *     // => "text/html"
   *     this.types('json', 'text');
   *     // => "json"
   *     this.types('application/json');
   *     // => "application/json"
   *
   *     // Accept: text/*, application/json
   *     this.types('image/png');
   *     this.types('png');
   *     // => undefined
   *
   *     // Accept: text/*;q=.5, application/json
   *     this.types(['html', 'json']);
   *     this.types('html', 'json');
   *     // => "json"
   *
   * @param {String|Array} types...
   * @return {String|Array|Boolean}
   * @public
   */

  Accepts.prototype.type = Accepts.prototype.types = function (types_) {
    var types = types_;

    // support flattened arguments
    if (types && !Array.isArray(types)) {
      types = new Array(arguments.length);
      for (var i = 0; i < types.length; i++) {
        types[i] = arguments[i];
      }
    }

    // no types, return all requested types
    if (!types || types.length === 0) {
      return this.negotiator.mediaTypes();
    }

    if (!this.headers.accept) return types[0];
    var mimes = types.map(extToMime);
    var accepts = this.negotiator.mediaTypes(mimes.filter(validMime));
    var first = accepts[0];
    if (!first) return false;
    return types[mimes.indexOf(first)];
  };

  /**
   * Return accepted encodings or best fit based on `encodings`.
   *
   * Given `Accept-Encoding: gzip, deflate`
   * an array sorted by quality is returned:
   *
   *     ['gzip', 'deflate']
   *
   * @param {String|Array} encodings...
   * @return {String|Array}
   * @public
   */

  Accepts.prototype.encoding = Accepts.prototype.encodings = function (encodings_) {
    var encodings = encodings_;

    // support flattened arguments
    if (encodings && !Array.isArray(encodings)) {
      encodings = new Array(arguments.length);
      for (var i = 0; i < encodings.length; i++) {
        encodings[i] = arguments[i];
      }
    }

    // no encodings, return all requested encodings
    if (!encodings || encodings.length === 0) {
      return this.negotiator.encodings();
    }

    return this.negotiator.encodings(encodings)[0] || false;
  };

  /**
   * Return accepted charsets or best fit based on `charsets`.
   *
   * Given `Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5`
   * an array sorted by quality is returned:
   *
   *     ['utf-8', 'utf-7', 'iso-8859-1']
   *
   * @param {String|Array} charsets...
   * @return {String|Array}
   * @public
   */

  Accepts.prototype.charset = Accepts.prototype.charsets = function (charsets_) {
    var charsets = charsets_;

    // support flattened arguments
    if (charsets && !Array.isArray(charsets)) {
      charsets = new Array(arguments.length);
      for (var i = 0; i < charsets.length; i++) {
        charsets[i] = arguments[i];
      }
    }

    // no charsets, return all requested charsets
    if (!charsets || charsets.length === 0) {
      return this.negotiator.charsets();
    }

    return this.negotiator.charsets(charsets)[0] || false;
  };

  /**
   * Return accepted languages or best fit based on `langs`.
   *
   * Given `Accept-Language: en;q=0.8, es, pt`
   * an array sorted by quality is returned:
   *
   *     ['es', 'pt', 'en']
   *
   * @param {String|Array} langs...
   * @return {Array|String}
   * @public
   */

  Accepts.prototype.lang = Accepts.prototype.langs = Accepts.prototype.language = Accepts.prototype.languages = function (languages_) {
    var languages = languages_;

    // support flattened arguments
    if (languages && !Array.isArray(languages)) {
      languages = new Array(arguments.length);
      for (var i = 0; i < languages.length; i++) {
        languages[i] = arguments[i];
      }
    }

    // no languages, return all requested languages
    if (!languages || languages.length === 0) {
      return this.negotiator.languages();
    }

    return this.negotiator.languages(languages)[0] || false;
  };

  /**
   * Convert extnames to mime.
   *
   * @param {String} type
   * @return {String}
   * @private
   */

  function extToMime(type) {
    return type.indexOf('/') === -1 ? mime.lookup(type) : type;
  }

  /**
   * Check if mime is valid.
   *
   * @param {String} type
   * @return {String}
   * @private
   */

  function validMime(type) {
    return typeof type === 'string';
  }
  return module.exports;
});
$__System.registerDynamic("22", ["20"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("20");
  return module.exports;
});
$__System.registerDynamic('23', ['22', '12', '26', '27', '11', '24', '25', '19', '28'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var accepts = $__require('22');
  var deprecate = $__require('12')('express');
  var isIP = $__require('26').isIP;
  var typeis = $__require('27');
  var http = $__require('11');
  var fresh = $__require('24');
  var parseRange = $__require('25');
  var parse = $__require('19');
  var proxyaddr = $__require('28');
  var req = exports = module.exports = { __proto__: http.IncomingMessage.prototype };
  req.get = req.header = function header(name) {
    var lc = name.toLowerCase();
    switch (lc) {
      case 'referer':
      case 'referrer':
        return this.headers.referrer || this.headers.referer;
      default:
        return this.headers[lc];
    }
  };
  req.accepts = function () {
    var accept = accepts(this);
    return accept.types.apply(accept, arguments);
  };
  req.acceptsEncodings = function () {
    var accept = accepts(this);
    return accept.encodings.apply(accept, arguments);
  };
  req.acceptsEncoding = deprecate.function(req.acceptsEncodings, 'req.acceptsEncoding: Use acceptsEncodings instead');
  req.acceptsCharsets = function () {
    var accept = accepts(this);
    return accept.charsets.apply(accept, arguments);
  };
  req.acceptsCharset = deprecate.function(req.acceptsCharsets, 'req.acceptsCharset: Use acceptsCharsets instead');
  req.acceptsLanguages = function () {
    var accept = accepts(this);
    return accept.languages.apply(accept, arguments);
  };
  req.acceptsLanguage = deprecate.function(req.acceptsLanguages, 'req.acceptsLanguage: Use acceptsLanguages instead');
  req.range = function (size) {
    var range = this.get('Range');
    if (!range) return;
    return parseRange(size, range);
  };
  req.param = function param(name, defaultValue) {
    var params = this.params || {};
    var body = this.body || {};
    var query = this.query || {};
    var args = arguments.length === 1 ? 'name' : 'name, default';
    deprecate('req.param(' + args + '): Use req.params, req.body, or req.query instead');
    if (null != params[name] && params.hasOwnProperty(name)) return params[name];
    if (null != body[name]) return body[name];
    if (null != query[name]) return query[name];
    return defaultValue;
  };
  req.is = function is(types) {
    var arr = types;
    if (!Array.isArray(types)) {
      arr = new Array(arguments.length);
      for (var i = 0; i < arr.length; i++) {
        arr[i] = arguments[i];
      }
    }
    return typeis(this, arr);
  };
  defineGetter(req, 'protocol', function protocol() {
    var proto = this.connection.encrypted ? 'https' : 'http';
    var trust = this.app.get('trust proxy fn');
    if (!trust(this.connection.remoteAddress, 0)) {
      return proto;
    }
    proto = this.get('X-Forwarded-Proto') || proto;
    return proto.split(/\s*,\s*/)[0];
  });
  defineGetter(req, 'secure', function secure() {
    return this.protocol === 'https';
  });
  defineGetter(req, 'ip', function ip() {
    var trust = this.app.get('trust proxy fn');
    return proxyaddr(this, trust);
  });
  defineGetter(req, 'ips', function ips() {
    var trust = this.app.get('trust proxy fn');
    var addrs = proxyaddr.all(this, trust);
    return addrs.slice(1).reverse();
  });
  defineGetter(req, 'subdomains', function subdomains() {
    var hostname = this.hostname;
    if (!hostname) return [];
    var offset = this.app.get('subdomain offset');
    var subdomains = !isIP(hostname) ? hostname.split('.').reverse() : [hostname];
    return subdomains.slice(offset);
  });
  defineGetter(req, 'path', function path() {
    return parse(this).pathname;
  });
  defineGetter(req, 'hostname', function hostname() {
    var trust = this.app.get('trust proxy fn');
    var host = this.get('X-Forwarded-Host');
    if (!host || !trust(this.connection.remoteAddress, 0)) {
      host = this.get('Host');
    }
    if (!host) return;
    var offset = host[0] === '[' ? host.indexOf(']') + 1 : 0;
    var index = host.indexOf(':', offset);
    return index !== -1 ? host.substring(0, index) : host;
  });
  defineGetter(req, 'host', deprecate.function(function host() {
    return this.hostname;
  }, 'req.host: Use req.hostname instead'));
  defineGetter(req, 'fresh', function () {
    var method = this.method;
    var s = this.res.statusCode;
    if ('GET' != method && 'HEAD' != method) return false;
    if (s >= 200 && s < 300 || 304 == s) {
      return fresh(this.headers, this.res._headers || {});
    }
    return false;
  });
  defineGetter(req, 'stale', function stale() {
    return !this.fresh;
  });
  defineGetter(req, 'xhr', function xhr() {
    var val = this.get('X-Requested-With') || '';
    return val.toLowerCase() === 'xmlhttprequest';
  });
  function defineGetter(obj, name, getter) {
    Object.defineProperty(obj, name, {
      configurable: true,
      enumerable: true,
      get: getter
    });
  }
  ;
  return module.exports;
});
$__System.registerDynamic('29', ['9', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    'use strict';

    module.exports = contentDisposition;
    module.exports.parse = parse;
    var basename = $__require('9').basename;
    var encodeUriAttrCharRegExp = /[\x00-\x20"'\(\)*,\/:;<=>?@\[\\\]\{\}\x7f]/g;
    var hexEscapeRegExp = /%[0-9A-Fa-f]{2}/;
    var hexEscapeReplaceRegExp = /%([0-9A-Fa-f]{2})/g;
    var nonLatin1RegExp = /[^\x20-\x7e\xa0-\xff]/g;
    var qescRegExp = /\\([\u0000-\u007f])/g;
    var quoteRegExp = /([\\"])/g;
    var paramRegExp = /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g;
    var textRegExp = /^[\x20-\x7e\x80-\xff]+$/;
    var tokenRegExp = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/;
    var extValueRegExp = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+\-\.^_`|~])+)$/;
    var dispositionTypeRegExp = /^([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *(?:$|;)/;
    function contentDisposition(filename, options) {
      var opts = options || {};
      var type = opts.type || 'attachment';
      var params = createparams(filename, opts.fallback);
      return format(new ContentDisposition(type, params));
    }
    function createparams(filename, fallback) {
      if (filename === undefined) {
        return;
      }
      var params = {};
      if (typeof filename !== 'string') {
        throw new TypeError('filename must be a string');
      }
      if (fallback === undefined) {
        fallback = true;
      }
      if (typeof fallback !== 'string' && typeof fallback !== 'boolean') {
        throw new TypeError('fallback must be a string or boolean');
      }
      if (typeof fallback === 'string' && nonLatin1RegExp.test(fallback)) {
        throw new TypeError('fallback must be ISO-8859-1 string');
      }
      var name = basename(filename);
      var isQuotedString = textRegExp.test(name);
      var fallbackName = typeof fallback !== 'string' ? fallback && getlatin1(name) : basename(fallback);
      var hasFallback = typeof fallbackName === 'string' && fallbackName !== name;
      if (hasFallback || !isQuotedString || hexEscapeRegExp.test(name)) {
        params['filename*'] = name;
      }
      if (isQuotedString || hasFallback) {
        params.filename = hasFallback ? fallbackName : name;
      }
      return params;
    }
    function format(obj) {
      var parameters = obj.parameters;
      var type = obj.type;
      if (!type || typeof type !== 'string' || !tokenRegExp.test(type)) {
        throw new TypeError('invalid type');
      }
      var string = String(type).toLowerCase();
      if (parameters && typeof parameters === 'object') {
        var param;
        var params = Object.keys(parameters).sort();
        for (var i = 0; i < params.length; i++) {
          param = params[i];
          var val = param.substr(-1) === '*' ? ustring(parameters[param]) : qstring(parameters[param]);
          string += '; ' + param + '=' + val;
        }
      }
      return string;
    }
    function decodefield(str) {
      var match = extValueRegExp.exec(str);
      if (!match) {
        throw new TypeError('invalid extended field value');
      }
      var charset = match[1].toLowerCase();
      var encoded = match[2];
      var value;
      var binary = encoded.replace(hexEscapeReplaceRegExp, pdecode);
      switch (charset) {
        case 'iso-8859-1':
          value = getlatin1(binary);
          break;
        case 'utf-8':
          value = new Buffer(binary, 'binary').toString('utf8');
          break;
        default:
          throw new TypeError('unsupported charset in extended field');
      }
      return value;
    }
    function getlatin1(val) {
      return String(val).replace(nonLatin1RegExp, '?');
    }
    function parse(string) {
      if (!string || typeof string !== 'string') {
        throw new TypeError('argument string is required');
      }
      var match = dispositionTypeRegExp.exec(string);
      if (!match) {
        throw new TypeError('invalid type format');
      }
      var index = match[0].length;
      var type = match[1].toLowerCase();
      var key;
      var names = [];
      var params = {};
      var value;
      index = paramRegExp.lastIndex = match[0].substr(-1) === ';' ? index - 1 : index;
      while (match = paramRegExp.exec(string)) {
        if (match.index !== index) {
          throw new TypeError('invalid parameter format');
        }
        index += match[0].length;
        key = match[1].toLowerCase();
        value = match[2];
        if (names.indexOf(key) !== -1) {
          throw new TypeError('invalid duplicate parameter');
        }
        names.push(key);
        if (key.indexOf('*') + 1 === key.length) {
          key = key.slice(0, -1);
          value = decodefield(value);
          params[key] = value;
          continue;
        }
        if (typeof params[key] === 'string') {
          continue;
        }
        if (value[0] === '"') {
          value = value.substr(1, value.length - 2).replace(qescRegExp, '$1');
        }
        params[key] = value;
      }
      if (index !== -1 && index !== string.length) {
        throw new TypeError('invalid parameter format');
      }
      return new ContentDisposition(type, params);
    }
    function pdecode(str, hex) {
      return String.fromCharCode(parseInt(hex, 16));
    }
    function pencode(char) {
      var hex = String(char).charCodeAt(0).toString(16).toUpperCase();
      return hex.length === 1 ? '%0' + hex : '%' + hex;
    }
    function qstring(val) {
      var str = String(val);
      return '"' + str.replace(quoteRegExp, '\\$1') + '"';
    }
    function ustring(val) {
      var str = String(val);
      var encoded = encodeURIComponent(str).replace(encodeUriAttrCharRegExp, pencode);
      return 'UTF-8\'\'' + encoded;
    }
    function ContentDisposition(type, parameters) {
      this.type = type;
      this.parameters = parameters;
    }
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic("2b", ["29"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("29");
  return module.exports;
});
$__System.registerDynamic('2c', [], true, function ($__require, exports, module) {
  /* */
  'use strict';

  /**
   * Expose `arrayFlatten`.
   */

  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = arrayFlatten;

  /**
   * Recursive flatten function with depth.
   *
   * @param  {Array}  array
   * @param  {Array}  result
   * @param  {Number} depth
   * @return {Array}
   */
  function flattenWithDepth(array, result, depth) {
    for (var i = 0; i < array.length; i++) {
      var value = array[i];

      if (depth > 0 && Array.isArray(value)) {
        flattenWithDepth(value, result, depth - 1);
      } else {
        result.push(value);
      }
    }

    return result;
  }

  /**
   * Recursive flatten function. Omitting depth is slightly faster.
   *
   * @param  {Array} array
   * @param  {Array} result
   * @return {Array}
   */
  function flattenForever(array, result) {
    for (var i = 0; i < array.length; i++) {
      var value = array[i];

      if (Array.isArray(value)) {
        flattenForever(value, result);
      } else {
        result.push(value);
      }
    }

    return result;
  }

  /**
   * Flatten an array, with the ability to define a depth.
   *
   * @param  {Array}  array
   * @param  {Number} depth
   * @return {Array}
   */
  function arrayFlatten(array, depth) {
    if (depth == null) {
      return flattenForever(array, []);
    }

    return flattenWithDepth(array, [], depth);
  }
  return module.exports;
});
$__System.registerDynamic("e", ["2c"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("2c");
  return module.exports;
});
$__System.registerDynamic('2d', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /*!
   * forwarded
   * Copyright(c) 2014 Douglas Christopher Wilson
   * MIT Licensed
   */

  /**
   * Module exports.
   */

  module.exports = forwarded;

  /**
   * Get all addresses in the request, using the `X-Forwarded-For` header.
   *
   * @param {Object} req
   * @api public
   */

  function forwarded(req) {
    if (!req) {
      throw new TypeError('argument req is required');
    }

    // simple header parsing
    var proxyAddrs = (req.headers['x-forwarded-for'] || '').split(/ *, */).filter(Boolean).reverse();
    var socketAddr = req.connection.remoteAddress;
    var addrs = [socketAddr].concat(proxyAddrs);

    // return all addresses
    return addrs;
  }
  return module.exports;
});
$__System.registerDynamic("2e", ["2d"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("2d");
  return module.exports;
});
$__System.registerDynamic("2f", [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function () {
    var expandIPv6, ipaddr, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root;

    ipaddr = {};

    root = this;

    if (typeof module !== "undefined" && module !== null && module.exports) {
      module.exports = ipaddr;
    } else {
      root['ipaddr'] = ipaddr;
    }

    matchCIDR = function (first, second, partSize, cidrBits) {
      var part, shift;
      if (first.length !== second.length) {
        throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
      }
      part = 0;
      while (cidrBits > 0) {
        shift = partSize - cidrBits;
        if (shift < 0) {
          shift = 0;
        }
        if (first[part] >> shift !== second[part] >> shift) {
          return false;
        }
        cidrBits -= partSize;
        part += 1;
      }
      return true;
    };

    ipaddr.subnetMatch = function (address, rangeList, defaultName) {
      var rangeName, rangeSubnets, subnet, _i, _len;
      if (defaultName == null) {
        defaultName = 'unicast';
      }
      for (rangeName in rangeList) {
        rangeSubnets = rangeList[rangeName];
        if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
          rangeSubnets = [rangeSubnets];
        }
        for (_i = 0, _len = rangeSubnets.length; _i < _len; _i++) {
          subnet = rangeSubnets[_i];
          if (address.match.apply(address, subnet)) {
            return rangeName;
          }
        }
      }
      return defaultName;
    };

    ipaddr.IPv4 = function () {
      function IPv4(octets) {
        var octet, _i, _len;
        if (octets.length !== 4) {
          throw new Error("ipaddr: ipv4 octet count should be 4");
        }
        for (_i = 0, _len = octets.length; _i < _len; _i++) {
          octet = octets[_i];
          if (!(0 <= octet && octet <= 255)) {
            throw new Error("ipaddr: ipv4 octet is a byte");
          }
        }
        this.octets = octets;
      }

      IPv4.prototype.kind = function () {
        return 'ipv4';
      };

      IPv4.prototype.toString = function () {
        return this.octets.join(".");
      };

      IPv4.prototype.toByteArray = function () {
        return this.octets.slice(0);
      };

      IPv4.prototype.match = function (other, cidrRange) {
        var _ref;
        if (cidrRange === void 0) {
          _ref = other, other = _ref[0], cidrRange = _ref[1];
        }
        if (other.kind() !== 'ipv4') {
          throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
        }
        return matchCIDR(this.octets, other.octets, 8, cidrRange);
      };

      IPv4.prototype.SpecialRanges = {
        unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
        broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
        multicast: [[new IPv4([224, 0, 0, 0]), 4]],
        linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
        loopback: [[new IPv4([127, 0, 0, 0]), 8]],
        "private": [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],
        reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]]
      };

      IPv4.prototype.range = function () {
        return ipaddr.subnetMatch(this, this.SpecialRanges);
      };

      IPv4.prototype.toIPv4MappedAddress = function () {
        return ipaddr.IPv6.parse("::ffff:" + this.toString());
      };

      return IPv4;
    }();

    ipv4Part = "(0?\\d+|0x[a-f0-9]+)";

    ipv4Regexes = {
      fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", 'i'),
      longValue: new RegExp("^" + ipv4Part + "$", 'i')
    };

    ipaddr.IPv4.parser = function (string) {
      var match, parseIntAuto, part, shift, value;
      parseIntAuto = function (string) {
        if (string[0] === "0" && string[1] !== "x") {
          return parseInt(string, 8);
        } else {
          return parseInt(string);
        }
      };
      if (match = string.match(ipv4Regexes.fourOctet)) {
        return function () {
          var _i, _len, _ref, _results;
          _ref = match.slice(1, 6);
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            part = _ref[_i];
            _results.push(parseIntAuto(part));
          }
          return _results;
        }();
      } else if (match = string.match(ipv4Regexes.longValue)) {
        value = parseIntAuto(match[1]);
        if (value > 0xffffffff || value < 0) {
          throw new Error("ipaddr: address outside defined range");
        }
        return function () {
          var _i, _results;
          _results = [];
          for (shift = _i = 0; _i <= 24; shift = _i += 8) {
            _results.push(value >> shift & 0xff);
          }
          return _results;
        }().reverse();
      } else {
        return null;
      }
    };

    ipaddr.IPv6 = function () {
      function IPv6(parts) {
        var part, _i, _len;
        if (parts.length !== 8) {
          throw new Error("ipaddr: ipv6 part count should be 8");
        }
        for (_i = 0, _len = parts.length; _i < _len; _i++) {
          part = parts[_i];
          if (!(0 <= part && part <= 0xffff)) {
            throw new Error("ipaddr: ipv6 part should fit to two octets");
          }
        }
        this.parts = parts;
      }

      IPv6.prototype.kind = function () {
        return 'ipv6';
      };

      IPv6.prototype.toString = function () {
        var compactStringParts, part, pushPart, state, stringParts, _i, _len;
        stringParts = function () {
          var _i, _len, _ref, _results;
          _ref = this.parts;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            part = _ref[_i];
            _results.push(part.toString(16));
          }
          return _results;
        }.call(this);
        compactStringParts = [];
        pushPart = function (part) {
          return compactStringParts.push(part);
        };
        state = 0;
        for (_i = 0, _len = stringParts.length; _i < _len; _i++) {
          part = stringParts[_i];
          switch (state) {
            case 0:
              if (part === '0') {
                pushPart('');
              } else {
                pushPart(part);
              }
              state = 1;
              break;
            case 1:
              if (part === '0') {
                state = 2;
              } else {
                pushPart(part);
              }
              break;
            case 2:
              if (part !== '0') {
                pushPart('');
                pushPart(part);
                state = 3;
              }
              break;
            case 3:
              pushPart(part);
          }
        }
        if (state === 2) {
          pushPart('');
          pushPart('');
        }
        return compactStringParts.join(":");
      };

      IPv6.prototype.toByteArray = function () {
        var bytes, part, _i, _len, _ref;
        bytes = [];
        _ref = this.parts;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          part = _ref[_i];
          bytes.push(part >> 8);
          bytes.push(part & 0xff);
        }
        return bytes;
      };

      IPv6.prototype.toNormalizedString = function () {
        var part;
        return function () {
          var _i, _len, _ref, _results;
          _ref = this.parts;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            part = _ref[_i];
            _results.push(part.toString(16));
          }
          return _results;
        }.call(this).join(":");
      };

      IPv6.prototype.match = function (other, cidrRange) {
        var _ref;
        if (cidrRange === void 0) {
          _ref = other, other = _ref[0], cidrRange = _ref[1];
        }
        if (other.kind() !== 'ipv6') {
          throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
        }
        return matchCIDR(this.parts, other.parts, 16, cidrRange);
      };

      IPv6.prototype.SpecialRanges = {
        unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
        linkLocal: [new IPv6([0xfe80, 0, 0, 0, 0, 0, 0, 0]), 10],
        multicast: [new IPv6([0xff00, 0, 0, 0, 0, 0, 0, 0]), 8],
        loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
        uniqueLocal: [new IPv6([0xfc00, 0, 0, 0, 0, 0, 0, 0]), 7],
        ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 0xffff, 0, 0]), 96],
        rfc6145: [new IPv6([0, 0, 0, 0, 0xffff, 0, 0, 0]), 96],
        rfc6052: [new IPv6([0x64, 0xff9b, 0, 0, 0, 0, 0, 0]), 96],
        '6to4': [new IPv6([0x2002, 0, 0, 0, 0, 0, 0, 0]), 16],
        teredo: [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 32],
        reserved: [[new IPv6([0x2001, 0xdb8, 0, 0, 0, 0, 0, 0]), 32]]
      };

      IPv6.prototype.range = function () {
        return ipaddr.subnetMatch(this, this.SpecialRanges);
      };

      IPv6.prototype.isIPv4MappedAddress = function () {
        return this.range() === 'ipv4Mapped';
      };

      IPv6.prototype.toIPv4Address = function () {
        var high, low, _ref;
        if (!this.isIPv4MappedAddress()) {
          throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
        }
        _ref = this.parts.slice(-2), high = _ref[0], low = _ref[1];
        return new ipaddr.IPv4([high >> 8, high & 0xff, low >> 8, low & 0xff]);
      };

      return IPv6;
    }();

    ipv6Part = "(?:[0-9a-f]+::?)+";

    ipv6Regexes = {
      "native": new RegExp("^(::)?(" + ipv6Part + ")?([0-9a-f]+)?(::)?$", 'i'),
      transitional: new RegExp("^((?:" + ipv6Part + ")|(?:::)(?:" + ipv6Part + ")?)" + ("" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$"), 'i')
    };

    expandIPv6 = function (string, parts) {
      var colonCount, lastColon, part, replacement, replacementCount;
      if (string.indexOf('::') !== string.lastIndexOf('::')) {
        return null;
      }
      colonCount = 0;
      lastColon = -1;
      while ((lastColon = string.indexOf(':', lastColon + 1)) >= 0) {
        colonCount++;
      }
      if (string.substr(0, 2) === '::') {
        colonCount--;
      }
      if (string.substr(-2, 2) === '::') {
        colonCount--;
      }
      if (colonCount > parts) {
        return null;
      }
      replacementCount = parts - colonCount;
      replacement = ':';
      while (replacementCount--) {
        replacement += '0:';
      }
      string = string.replace('::', replacement);
      if (string[0] === ':') {
        string = string.slice(1);
      }
      if (string[string.length - 1] === ':') {
        string = string.slice(0, -1);
      }
      return function () {
        var _i, _len, _ref, _results;
        _ref = string.split(":");
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          part = _ref[_i];
          _results.push(parseInt(part, 16));
        }
        return _results;
      }();
    };

    ipaddr.IPv6.parser = function (string) {
      var match, parts;
      if (string.match(ipv6Regexes['native'])) {
        return expandIPv6(string, 8);
      } else if (match = string.match(ipv6Regexes['transitional'])) {
        parts = expandIPv6(match[1].slice(0, -1), 6);
        if (parts) {
          parts.push(parseInt(match[2]) << 8 | parseInt(match[3]));
          parts.push(parseInt(match[4]) << 8 | parseInt(match[5]));
          return parts;
        }
      }
      return null;
    };

    ipaddr.IPv4.isIPv4 = ipaddr.IPv6.isIPv6 = function (string) {
      return this.parser(string) !== null;
    };

    ipaddr.IPv4.isValid = function (string) {
      var e;
      try {
        new this(this.parser(string));
        return true;
      } catch (_error) {
        e = _error;
        return false;
      }
    };

    ipaddr.IPv6.isValid = function (string) {
      var e;
      if (typeof string === "string" && string.indexOf(":") === -1) {
        return false;
      }
      try {
        new this(this.parser(string));
        return true;
      } catch (_error) {
        e = _error;
        return false;
      }
    };

    ipaddr.IPv4.parse = ipaddr.IPv6.parse = function (string) {
      var parts;
      parts = this.parser(string);
      if (parts === null) {
        throw new Error("ipaddr: string is not formatted like ip address");
      }
      return new this(parts);
    };

    ipaddr.IPv4.parseCIDR = function (string) {
      var maskLength, match;
      if (match = string.match(/^(.+)\/(\d+)$/)) {
        maskLength = parseInt(match[2]);
        if (maskLength >= 0 && maskLength <= 32) {
          return [this.parse(match[1]), maskLength];
        }
      }
      throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
    };

    ipaddr.IPv6.parseCIDR = function (string) {
      var maskLength, match;
      if (match = string.match(/^(.+)\/(\d+)$/)) {
        maskLength = parseInt(match[2]);
        if (maskLength >= 0 && maskLength <= 128) {
          return [this.parse(match[1]), maskLength];
        }
      }
      throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
    };

    ipaddr.isValid = function (string) {
      return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
    };

    ipaddr.parse = function (string) {
      if (ipaddr.IPv6.isValid(string)) {
        return ipaddr.IPv6.parse(string);
      } else if (ipaddr.IPv4.isValid(string)) {
        return ipaddr.IPv4.parse(string);
      } else {
        throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
      }
    };

    ipaddr.parseCIDR = function (string) {
      var e;
      try {
        return ipaddr.IPv6.parseCIDR(string);
      } catch (_error) {
        e = _error;
        try {
          return ipaddr.IPv4.parseCIDR(string);
        } catch (_error) {
          e = _error;
          throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
        }
      }
    };

    ipaddr.process = function (string) {
      var addr;
      addr = this.parse(string);
      if (addr.kind() === 'ipv6' && addr.isIPv4MappedAddress()) {
        return addr.toIPv4Address();
      } else {
        return addr;
      }
    };
  }).call(this);
  return module.exports;
});
$__System.registerDynamic("30", ["2f"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("2f");
  return module.exports;
});
$__System.registerDynamic('31', ['2e', '30'], true, function ($__require, exports, module) {
  /*!
   * proxy-addr
   * Copyright(c) 2014 Douglas Christopher Wilson
   * MIT Licensed
   */

  'use strict';

  /**
   * Module exports.
   */

  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = proxyaddr;
  module.exports.all = alladdrs;
  module.exports.compile = compile;

  /**
   * Module dependencies.
   */

  var forwarded = $__require('2e');
  var ipaddr = $__require('30');

  /**
   * Variables.
   */

  var digitre = /^[0-9]+$/;
  var isip = ipaddr.isValid;
  var parseip = ipaddr.parse;

  /**
   * Pre-defined IP ranges.
   */

  var ipranges = {
    linklocal: ['169.254.0.0/16', 'fe80::/10'],
    loopback: ['127.0.0.1/8', '::1/128'],
    uniquelocal: ['10.0.0.0/8', '172.16.0.0/12', '192.168.0.0/16', 'fc00::/7']
  };

  /**
   * Get all addresses in the request, optionally stopping
   * at the first untrusted.
   *
   * @param {Object} request
   * @param {Function|Array|String} [trust]
   * @api public
   */

  function alladdrs(req, trust) {
    // get addresses
    var addrs = forwarded(req);

    if (!trust) {
      // Return all addresses
      return addrs;
    }

    if (typeof trust !== 'function') {
      trust = compile(trust);
    }

    for (var i = 0; i < addrs.length - 1; i++) {
      if (trust(addrs[i], i)) continue;

      addrs.length = i + 1;
    }

    return addrs;
  }

  /**
   * Compile argument into trust function.
   *
   * @param {Array|String} val
   * @api private
   */

  function compile(val) {
    if (!val) {
      throw new TypeError('argument is required');
    }

    var trust = typeof val === 'string' ? [val] : val;

    if (!Array.isArray(trust)) {
      throw new TypeError('unsupported trust argument');
    }

    for (var i = 0; i < trust.length; i++) {
      val = trust[i];

      if (!ipranges.hasOwnProperty(val)) {
        continue;
      }

      // Splice in pre-defined range
      val = ipranges[val];
      trust.splice.apply(trust, [i, 1].concat(val));
      i += val.length - 1;
    }

    return compileTrust(compileRangeSubnets(trust));
  }

  /**
   * Compile `arr` elements into range subnets.
   *
   * @param {Array} arr
   * @api private
   */

  function compileRangeSubnets(arr) {
    var rangeSubnets = new Array(arr.length);

    for (var i = 0; i < arr.length; i++) {
      rangeSubnets[i] = parseipNotation(arr[i]);
    }

    return rangeSubnets;
  }

  /**
   * Compile range subnet array into trust function.
   *
   * @param {Array} rangeSubnets
   * @api private
   */

  function compileTrust(rangeSubnets) {
    // Return optimized function based on length
    var len = rangeSubnets.length;
    return len === 0 ? trustNone : len === 1 ? trustSingle(rangeSubnets[0]) : trustMulti(rangeSubnets);
  }

  /**
   * Parse IP notation string into range subnet.
   *
   * @param {String} note
   * @api private
   */

  function parseipNotation(note) {
    var ip;
    var kind;
    var max;
    var pos = note.lastIndexOf('/');
    var range;

    ip = pos !== -1 ? note.substring(0, pos) : note;

    if (!isip(ip)) {
      throw new TypeError('invalid IP address: ' + ip);
    }

    ip = parseip(ip);

    kind = ip.kind();
    max = kind === 'ipv6' ? 128 : 32;

    range = pos !== -1 ? note.substring(pos + 1, note.length) : max;

    if (typeof range !== 'number') {
      range = digitre.test(range) ? parseInt(range, 10) : isip(range) ? parseNetmask(range) : 0;
    }

    if (ip.kind() === 'ipv6' && ip.isIPv4MappedAddress()) {
      // Store as IPv4
      ip = ip.toIPv4Address();
      range = range <= max ? range - 96 : range;
    }

    if (range <= 0 || range > max) {
      throw new TypeError('invalid range on address: ' + note);
    }

    return [ip, range];
  }

  /**
   * Parse netmask string into CIDR range.
   *
   * @param {String} note
   * @api private
   */

  function parseNetmask(netmask) {
    var ip = parseip(netmask);
    var parts;
    var size;

    switch (ip.kind()) {
      case 'ipv4':
        parts = ip.octets;
        size = 8;
        break;
      case 'ipv6':
        parts = ip.parts;
        size = 16;
        break;
    }

    var max = Math.pow(2, size) - 1;
    var part;
    var range = 0;

    for (var i = 0; i < parts.length; i++) {
      part = parts[i] & max;

      if (part === max) {
        range += size;
        continue;
      }

      while (part) {
        part = part << 1 & max;
        range += 1;
      }

      break;
    }

    return range;
  }

  /**
   * Determine address of proxied request.
   *
   * @param {Object} request
   * @param {Function|Array|String} trust
   * @api public
   */

  function proxyaddr(req, trust) {
    if (!req) {
      throw new TypeError('req argument is required');
    }

    if (!trust) {
      throw new TypeError('trust argument is required');
    }

    var addrs = alladdrs(req, trust);
    var addr = addrs[addrs.length - 1];

    return addr;
  }

  /**
   * Static trust function to trust nothing.
   *
   * @api private
   */

  function trustNone() {
    return false;
  }

  /**
   * Compile trust function for multiple subnets.
   *
   * @param {Array} subnets
   * @api private
   */

  function trustMulti(subnets) {
    return function trust(addr) {
      if (!isip(addr)) return false;

      var ip = parseip(addr);
      var ipv4;
      var kind = ip.kind();
      var subnet;
      var subnetip;
      var subnetkind;
      var subnetrange;
      var trusted;

      for (var i = 0; i < subnets.length; i++) {
        subnet = subnets[i];
        subnetip = subnet[0];
        subnetkind = subnetip.kind();
        subnetrange = subnet[1];
        trusted = ip;

        if (kind !== subnetkind) {
          if (kind !== 'ipv6' || subnetkind !== 'ipv4' || !ip.isIPv4MappedAddress()) {
            continue;
          }

          // Store addr as IPv4
          ipv4 = ipv4 || ip.toIPv4Address();
          trusted = ipv4;
        }

        if (trusted.match(subnetip, subnetrange)) return true;
      }

      return false;
    };
  }

  /**
   * Compile trust function for single subnet.
   *
   * @param {Object} subnet
   * @api private
   */

  function trustSingle(subnet) {
    var subnetip = subnet[0];
    var subnetkind = subnetip.kind();
    var subnetisipv4 = subnetkind === 'ipv4';
    var subnetrange = subnet[1];

    return function trust(addr) {
      if (!isip(addr)) return false;

      var ip = parseip(addr);
      var kind = ip.kind();

      return kind === subnetkind ? ip.match(subnetip, subnetrange) : subnetisipv4 && kind === 'ipv6' && ip.isIPv4MappedAddress() ? ip.toIPv4Address().match(subnetip, subnetrange) : false;
    };
  }
  return module.exports;
});
$__System.registerDynamic("28", ["31"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("31");
  return module.exports;
});
$__System.registerDynamic('6', ['2b', '32', '12', 'e', '34', '9', '35', '28', '33', '36', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    'use strict';

    var contentDisposition = $__require('2b');
    var contentType = $__require('32');
    var deprecate = $__require('12')('express');
    var flatten = $__require('e');
    var mime = $__require('34').mime;
    var basename = $__require('9').basename;
    var etag = $__require('35');
    var proxyaddr = $__require('28');
    var qs = $__require('33');
    var querystring = $__require('36');
    exports.etag = function (body, encoding) {
      var buf = !Buffer.isBuffer(body) ? new Buffer(body, encoding) : body;
      return etag(buf, { weak: false });
    };
    exports.wetag = function wetag(body, encoding) {
      var buf = !Buffer.isBuffer(body) ? new Buffer(body, encoding) : body;
      return etag(buf, { weak: true });
    };
    exports.isAbsolute = function (path) {
      if ('/' == path[0]) return true;
      if (':' == path[1] && '\\' == path[2]) return true;
      if ('\\\\' == path.substring(0, 2)) return true;
    };
    exports.flatten = deprecate.function(flatten, 'utils.flatten: use array-flatten npm module instead');
    exports.normalizeType = function (type) {
      return ~type.indexOf('/') ? acceptParams(type) : {
        value: mime.lookup(type),
        params: {}
      };
    };
    exports.normalizeTypes = function (types) {
      var ret = [];
      for (var i = 0; i < types.length; ++i) {
        ret.push(exports.normalizeType(types[i]));
      }
      return ret;
    };
    exports.contentDisposition = deprecate.function(contentDisposition, 'utils.contentDisposition: use content-disposition npm module instead');
    function acceptParams(str, index) {
      var parts = str.split(/ *; */);
      var ret = {
        value: parts[0],
        quality: 1,
        params: {},
        originalIndex: index
      };
      for (var i = 1; i < parts.length; ++i) {
        var pms = parts[i].split(/ *= */);
        if ('q' == pms[0]) {
          ret.quality = parseFloat(pms[1]);
        } else {
          ret.params[pms[0]] = pms[1];
        }
      }
      return ret;
    }
    exports.compileETag = function (val) {
      var fn;
      if (typeof val === 'function') {
        return val;
      }
      switch (val) {
        case true:
          fn = exports.wetag;
          break;
        case false:
          break;
        case 'strong':
          fn = exports.etag;
          break;
        case 'weak':
          fn = exports.wetag;
          break;
        default:
          throw new TypeError('unknown value for etag function: ' + val);
      }
      return fn;
    };
    exports.compileQueryParser = function compileQueryParser(val) {
      var fn;
      if (typeof val === 'function') {
        return val;
      }
      switch (val) {
        case true:
          fn = querystring.parse;
          break;
        case false:
          fn = newObject;
          break;
        case 'extended':
          fn = parseExtendedQueryString;
          break;
        case 'simple':
          fn = querystring.parse;
          break;
        default:
          throw new TypeError('unknown value for query parser function: ' + val);
      }
      return fn;
    };
    exports.compileTrust = function (val) {
      if (typeof val === 'function') return val;
      if (val === true) {
        return function () {
          return true;
        };
      }
      if (typeof val === 'number') {
        return function (a, i) {
          return i < val;
        };
      }
      if (typeof val === 'string') {
        val = val.split(/ *, */);
      }
      return proxyaddr.compile(val || []);
    };
    exports.setCharset = function setCharset(type, charset) {
      if (!type || !charset) {
        return type;
      }
      var parsed = contentType.parse(type);
      parsed.parameters.charset = charset;
      return contentType.format(parsed);
    };
    function parseExtendedQueryString(str) {
      return qs.parse(str, {
        allowDots: false,
        allowPrototypes: true
      });
    }
    function newObject() {
      return {};
    }
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic('37', ['38'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var crypto = $__require('38');
  exports.sign = function (val, secret) {
    if ('string' != typeof val) throw new TypeError("Cookie value must be provided as a string.");
    if ('string' != typeof secret) throw new TypeError("Secret string must be provided.");
    return val + '.' + crypto.createHmac('sha256', secret).update(val).digest('base64').replace(/\=+$/, '');
  };
  exports.unsign = function (val, secret) {
    if ('string' != typeof val) throw new TypeError("Signed cookie string must be provided.");
    if ('string' != typeof secret) throw new TypeError("Secret string must be provided.");
    var str = val.slice(0, val.lastIndexOf('.')),
        mac = exports.sign(str, secret);
    return sha1(mac) == sha1(val) ? str : false;
  };
  function sha1(str) {
    return crypto.createHash('sha1').update(str).digest('hex');
  }
  return module.exports;
});
$__System.registerDynamic("39", ["37"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("37");
  return module.exports;
});
$__System.registerDynamic('3a', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /*!
   * cookie
   * Copyright(c) 2012-2014 Roman Shtylman
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */

  /**
   * Module exports.
   * @public
   */

  exports.parse = parse;
  exports.serialize = serialize;

  /**
   * Module variables.
   * @private
   */

  var decode = decodeURIComponent;
  var encode = encodeURIComponent;

  /**
   * RegExp to match field-content in RFC 7230 sec 3.2
   *
   * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]
   * field-vchar   = VCHAR / obs-text
   * obs-text      = %x80-FF
   */

  var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;

  /**
   * Parse a cookie header.
   *
   * Parse the given cookie header string into an object
   * The object has the various cookies as keys(names) => values
   *
   * @param {string} str
   * @param {object} [options]
   * @return {object}
   * @public
   */

  function parse(str, options) {
    if (typeof str !== 'string') {
      throw new TypeError('argument str must be a string');
    }

    var obj = {};
    var opt = options || {};
    var pairs = str.split(/; */);
    var dec = opt.decode || decode;

    pairs.forEach(function (pair) {
      var eq_idx = pair.indexOf('=');

      // skip things that don't look like key=value
      if (eq_idx < 0) {
        return;
      }

      var key = pair.substr(0, eq_idx).trim();
      var val = pair.substr(++eq_idx, pair.length).trim();

      // quoted values
      if ('"' == val[0]) {
        val = val.slice(1, -1);
      }

      // only assign once
      if (undefined == obj[key]) {
        obj[key] = tryDecode(val, dec);
      }
    });

    return obj;
  }

  /**
   * Serialize data into a cookie header.
   *
   * Serialize the a name value pair into a cookie string suitable for
   * http headers. An optional options object specified cookie parameters.
   *
   * serialize('foo', 'bar', { httpOnly: true })
   *   => "foo=bar; httpOnly"
   *
   * @param {string} name
   * @param {string} val
   * @param {object} [options]
   * @return {string}
   * @public
   */

  function serialize(name, val, options) {
    var opt = options || {};
    var enc = opt.encode || encode;

    if (!fieldContentRegExp.test(name)) {
      throw new TypeError('argument name is invalid');
    }

    var value = enc(val);

    if (value && !fieldContentRegExp.test(value)) {
      throw new TypeError('argument val is invalid');
    }

    var pairs = [name + '=' + value];

    if (null != opt.maxAge) {
      var maxAge = opt.maxAge - 0;
      if (isNaN(maxAge)) throw new Error('maxAge should be a Number');
      pairs.push('Max-Age=' + maxAge);
    }

    if (opt.domain) {
      if (!fieldContentRegExp.test(opt.domain)) {
        throw new TypeError('option domain is invalid');
      }

      pairs.push('Domain=' + opt.domain);
    }

    if (opt.path) {
      if (!fieldContentRegExp.test(opt.path)) {
        throw new TypeError('option path is invalid');
      }

      pairs.push('Path=' + opt.path);
    }

    if (opt.expires) pairs.push('Expires=' + opt.expires.toUTCString());
    if (opt.httpOnly) pairs.push('HttpOnly');
    if (opt.secure) pairs.push('Secure');

    return pairs.join('; ');
  }

  /**
   * Try decoding a string using a decoding function.
   *
   * @param {string} str
   * @param {function} decode
   * @private
   */

  function tryDecode(str, decode) {
    try {
      return decode(str);
    } catch (e) {
      return str;
    }
  }
  return module.exports;
});
$__System.registerDynamic("3b", ["3a"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("3a");
  return module.exports;
});
$__System.registerDynamic('3c', ['2b', '12', '3d', '11', '6', '3f', '9', 'f', '39', '3b', '34', '3e', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    'use strict';

    var contentDisposition = $__require('2b');
    var deprecate = $__require('12')('express');
    var escapeHtml = $__require('3d');
    var http = $__require('11');
    var isAbsolute = $__require('6').isAbsolute;
    var onFinished = $__require('3f');
    var path = $__require('9');
    var merge = $__require('f');
    var sign = $__require('39').sign;
    var normalizeType = $__require('6').normalizeType;
    var normalizeTypes = $__require('6').normalizeTypes;
    var setCharset = $__require('6').setCharset;
    var statusCodes = http.STATUS_CODES;
    var cookie = $__require('3b');
    var send = $__require('34');
    var extname = path.extname;
    var mime = send.mime;
    var resolve = path.resolve;
    var vary = $__require('3e');
    var res = module.exports = { __proto__: http.ServerResponse.prototype };
    var charsetRegExp = /;\s*charset\s*=/;
    res.status = function status(code) {
      this.statusCode = code;
      return this;
    };
    res.links = function (links) {
      var link = this.get('Link') || '';
      if (link) link += ', ';
      return this.set('Link', link + Object.keys(links).map(function (rel) {
        return '<' + links[rel] + '>; rel="' + rel + '"';
      }).join(', '));
    };
    res.send = function send(body) {
      var chunk = body;
      var encoding;
      var len;
      var req = this.req;
      var type;
      var app = this.app;
      if (arguments.length === 2) {
        if (typeof arguments[0] !== 'number' && typeof arguments[1] === 'number') {
          deprecate('res.send(body, status): Use res.status(status).send(body) instead');
          this.statusCode = arguments[1];
        } else {
          deprecate('res.send(status, body): Use res.status(status).send(body) instead');
          this.statusCode = arguments[0];
          chunk = arguments[1];
        }
      }
      if (typeof chunk === 'number' && arguments.length === 1) {
        if (!this.get('Content-Type')) {
          this.type('txt');
        }
        deprecate('res.send(status): Use res.sendStatus(status) instead');
        this.statusCode = chunk;
        chunk = statusCodes[chunk];
      }
      switch (typeof chunk) {
        case 'string':
          if (!this.get('Content-Type')) {
            this.type('html');
          }
          break;
        case 'boolean':
        case 'number':
        case 'object':
          if (chunk === null) {
            chunk = '';
          } else if (Buffer.isBuffer(chunk)) {
            if (!this.get('Content-Type')) {
              this.type('bin');
            }
          } else {
            return this.json(chunk);
          }
          break;
      }
      if (typeof chunk === 'string') {
        encoding = 'utf8';
        type = this.get('Content-Type');
        if (typeof type === 'string') {
          this.set('Content-Type', setCharset(type, 'utf-8'));
        }
      }
      if (chunk !== undefined) {
        if (!Buffer.isBuffer(chunk)) {
          chunk = new Buffer(chunk, encoding);
          encoding = undefined;
        }
        len = chunk.length;
        this.set('Content-Length', len);
      }
      var etag;
      var generateETag = len !== undefined && app.get('etag fn');
      if (typeof generateETag === 'function' && !this.get('ETag')) {
        if (etag = generateETag(chunk, encoding)) {
          this.set('ETag', etag);
        }
      }
      if (req.fresh) this.statusCode = 304;
      if (204 == this.statusCode || 304 == this.statusCode) {
        this.removeHeader('Content-Type');
        this.removeHeader('Content-Length');
        this.removeHeader('Transfer-Encoding');
        chunk = '';
      }
      if (req.method === 'HEAD') {
        this.end();
      } else {
        this.end(chunk, encoding);
      }
      return this;
    };
    res.json = function json(obj) {
      var val = obj;
      if (arguments.length === 2) {
        if (typeof arguments[1] === 'number') {
          deprecate('res.json(obj, status): Use res.status(status).json(obj) instead');
          this.statusCode = arguments[1];
        } else {
          deprecate('res.json(status, obj): Use res.status(status).json(obj) instead');
          this.statusCode = arguments[0];
          val = arguments[1];
        }
      }
      var app = this.app;
      var replacer = app.get('json replacer');
      var spaces = app.get('json spaces');
      var body = JSON.stringify(val, replacer, spaces);
      if (!this.get('Content-Type')) {
        this.set('Content-Type', 'application/json');
      }
      return this.send(body);
    };
    res.jsonp = function jsonp(obj) {
      var val = obj;
      if (arguments.length === 2) {
        if (typeof arguments[1] === 'number') {
          deprecate('res.jsonp(obj, status): Use res.status(status).json(obj) instead');
          this.statusCode = arguments[1];
        } else {
          deprecate('res.jsonp(status, obj): Use res.status(status).jsonp(obj) instead');
          this.statusCode = arguments[0];
          val = arguments[1];
        }
      }
      var app = this.app;
      var replacer = app.get('json replacer');
      var spaces = app.get('json spaces');
      var body = JSON.stringify(val, replacer, spaces);
      var callback = this.req.query[app.get('jsonp callback name')];
      if (!this.get('Content-Type')) {
        this.set('X-Content-Type-Options', 'nosniff');
        this.set('Content-Type', 'application/json');
      }
      if (Array.isArray(callback)) {
        callback = callback[0];
      }
      if (typeof callback === 'string' && callback.length !== 0) {
        this.charset = 'utf-8';
        this.set('X-Content-Type-Options', 'nosniff');
        this.set('Content-Type', 'text/javascript');
        callback = callback.replace(/[^\[\]\w$.]/g, '');
        body = body.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
        body = '/**/ typeof ' + callback + ' === \'function\' && ' + callback + '(' + body + ');';
      }
      return this.send(body);
    };
    res.sendStatus = function sendStatus(statusCode) {
      var body = statusCodes[statusCode] || String(statusCode);
      this.statusCode = statusCode;
      this.type('txt');
      return this.send(body);
    };
    res.sendFile = function sendFile(path, options, callback) {
      var done = callback;
      var req = this.req;
      var res = this;
      var next = req.next;
      var opts = options || {};
      if (!path) {
        throw new TypeError('path argument is required to res.sendFile');
      }
      if (typeof options === 'function') {
        done = options;
        opts = {};
      }
      if (!opts.root && !isAbsolute(path)) {
        throw new TypeError('path must be absolute or specify root to res.sendFile');
      }
      var pathname = encodeURI(path);
      var file = send(req, pathname, opts);
      sendfile(res, file, opts, function (err) {
        if (done) return done(err);
        if (err && err.code === 'EISDIR') return next();
        if (err && err.code !== 'ECONNABORTED' && err.syscall !== 'write') {
          next(err);
        }
      });
    };
    res.sendfile = function (path, options, callback) {
      var done = callback;
      var req = this.req;
      var res = this;
      var next = req.next;
      var opts = options || {};
      if (typeof options === 'function') {
        done = options;
        opts = {};
      }
      var file = send(req, path, opts);
      sendfile(res, file, opts, function (err) {
        if (done) return done(err);
        if (err && err.code === 'EISDIR') return next();
        if (err && err.code !== 'ECONNABORT' && err.syscall !== 'write') {
          next(err);
        }
      });
    };
    res.sendfile = deprecate.function(res.sendfile, 'res.sendfile: Use res.sendFile instead');
    res.download = function download(path, filename, callback) {
      var done = callback;
      var name = filename;
      if (typeof filename === 'function') {
        done = filename;
        name = null;
      }
      var headers = { 'Content-Disposition': contentDisposition(name || path) };
      var fullPath = resolve(path);
      return this.sendFile(fullPath, { headers: headers }, done);
    };
    res.contentType = res.type = function contentType(type) {
      var ct = type.indexOf('/') === -1 ? mime.lookup(type) : type;
      return this.set('Content-Type', ct);
    };
    res.format = function (obj) {
      var req = this.req;
      var next = req.next;
      var fn = obj.default;
      if (fn) delete obj.default;
      var keys = Object.keys(obj);
      var key = keys.length > 0 ? req.accepts(keys) : false;
      this.vary("Accept");
      if (key) {
        this.set('Content-Type', normalizeType(key).value);
        obj[key](req, this, next);
      } else if (fn) {
        fn();
      } else {
        var err = new Error('Not Acceptable');
        err.status = err.statusCode = 406;
        err.types = normalizeTypes(keys).map(function (o) {
          return o.value;
        });
        next(err);
      }
      return this;
    };
    res.attachment = function attachment(filename) {
      if (filename) {
        this.type(extname(filename));
      }
      this.set('Content-Disposition', contentDisposition(filename));
      return this;
    };
    res.append = function append(field, val) {
      var prev = this.get(field);
      var value = val;
      if (prev) {
        value = Array.isArray(prev) ? prev.concat(val) : Array.isArray(val) ? [prev].concat(val) : [prev, val];
      }
      return this.set(field, value);
    };
    res.set = res.header = function header(field, val) {
      if (arguments.length === 2) {
        var value = Array.isArray(val) ? val.map(String) : String(val);
        if (field.toLowerCase() === 'content-type' && !charsetRegExp.test(value)) {
          var charset = mime.charsets.lookup(value.split(';')[0]);
          if (charset) value += '; charset=' + charset.toLowerCase();
        }
        this.setHeader(field, value);
      } else {
        for (var key in field) {
          this.set(key, field[key]);
        }
      }
      return this;
    };
    res.get = function (field) {
      return this.getHeader(field);
    };
    res.clearCookie = function clearCookie(name, options) {
      var opts = merge({
        expires: new Date(1),
        path: '/'
      }, options);
      return this.cookie(name, '', opts);
    };
    res.cookie = function (name, value, options) {
      var opts = merge({}, options);
      var secret = this.req.secret;
      var signed = opts.signed;
      if (signed && !secret) {
        throw new Error('cookieParser("secret") required for signed cookies');
      }
      var val = typeof value === 'object' ? 'j:' + JSON.stringify(value) : String(value);
      if (signed) {
        val = 's:' + sign(val, secret);
      }
      if ('maxAge' in opts) {
        opts.expires = new Date(Date.now() + opts.maxAge);
        opts.maxAge /= 1000;
      }
      if (opts.path == null) {
        opts.path = '/';
      }
      this.append('Set-Cookie', cookie.serialize(name, String(val), opts));
      return this;
    };
    res.location = function location(url) {
      var loc = url;
      if (url === 'back') {
        loc = this.req.get('Referrer') || '/';
      }
      this.set('Location', loc);
      return this;
    };
    res.redirect = function redirect(url) {
      var address = url;
      var body;
      var status = 302;
      if (arguments.length === 2) {
        if (typeof arguments[0] === 'number') {
          status = arguments[0];
          address = arguments[1];
        } else {
          deprecate('res.redirect(url, status): Use res.redirect(status, url) instead');
          status = arguments[1];
        }
      }
      this.location(address);
      address = this.get('Location');
      this.format({
        text: function () {
          body = statusCodes[status] + '. Redirecting to ' + encodeURI(address);
        },
        html: function () {
          var u = escapeHtml(address);
          body = '<p>' + statusCodes[status] + '. Redirecting to <a href="' + u + '">' + u + '</a></p>';
        },
        default: function () {
          body = '';
        }
      });
      this.statusCode = status;
      this.set('Content-Length', Buffer.byteLength(body));
      if (this.req.method === 'HEAD') {
        this.end();
      } else {
        this.end(body);
      }
    };
    res.vary = function (field) {
      if (!field || Array.isArray(field) && !field.length) {
        deprecate('res.vary(): Provide a field name');
        return this;
      }
      vary(this, field);
      return this;
    };
    res.render = function render(view, options, callback) {
      var app = this.req.app;
      var done = callback;
      var opts = options || {};
      var req = this.req;
      var self = this;
      if (typeof options === 'function') {
        done = options;
        opts = {};
      }
      opts._locals = self.locals;
      done = done || function (err, str) {
        if (err) return req.next(err);
        self.send(str);
      };
      app.render(view, opts, done);
    };
    function sendfile(res, file, options, callback) {
      var done = false;
      var streaming;
      function onaborted() {
        if (done) return;
        done = true;
        var err = new Error('Request aborted');
        err.code = 'ECONNABORTED';
        callback(err);
      }
      function ondirectory() {
        if (done) return;
        done = true;
        var err = new Error('EISDIR, read');
        err.code = 'EISDIR';
        callback(err);
      }
      function onerror(err) {
        if (done) return;
        done = true;
        callback(err);
      }
      function onend() {
        if (done) return;
        done = true;
        callback();
      }
      function onfile() {
        streaming = false;
      }
      function onfinish(err) {
        if (err && err.code === 'ECONNRESET') return onaborted();
        if (err) return onerror(err);
        if (done) return;
        setImmediate(function () {
          if (streaming !== false && !done) {
            onaborted();
            return;
          }
          if (done) return;
          done = true;
          callback();
        });
      }
      function onstream() {
        streaming = true;
      }
      file.on('directory', ondirectory);
      file.on('end', onend);
      file.on('error', onerror);
      file.on('file', onfile);
      file.on('stream', onstream);
      onFinished(res, onfinish);
      if (options.headers) {
        file.on('headers', function headers(res) {
          var obj = options.headers;
          var keys = Object.keys(obj);
          for (var i = 0; i < keys.length; i++) {
            var k = keys[i];
            res.setHeader(k, obj[k]);
          }
        });
      }
      file.pipe(res);
    }
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic('40', ['41'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var Utils = $__require('41');
  var internals = {
    delimiter: '&',
    arrayPrefixGenerators: {
      brackets: function (prefix, key) {
        return prefix + '[]';
      },
      indices: function (prefix, key) {
        return prefix + '[' + key + ']';
      },
      repeat: function (prefix, key) {
        return prefix;
      }
    },
    strictNullHandling: false
  };
  internals.stringify = function (obj, prefix, generateArrayPrefix, strictNullHandling, filter) {
    if (typeof filter === 'function') {
      obj = filter(prefix, obj);
    } else if (Utils.isBuffer(obj)) {
      obj = obj.toString();
    } else if (obj instanceof Date) {
      obj = obj.toISOString();
    } else if (obj === null) {
      if (strictNullHandling) {
        return Utils.encode(prefix);
      }
      obj = '';
    }
    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean') {
      return [Utils.encode(prefix) + '=' + Utils.encode(obj)];
    }
    var values = [];
    if (typeof obj === 'undefined') {
      return values;
    }
    var objKeys = Array.isArray(filter) ? filter : Object.keys(obj);
    for (var i = 0, il = objKeys.length; i < il; ++i) {
      var key = objKeys[i];
      if (Array.isArray(obj)) {
        values = values.concat(internals.stringify(obj[key], generateArrayPrefix(prefix, key), generateArrayPrefix, strictNullHandling, filter));
      } else {
        values = values.concat(internals.stringify(obj[key], prefix + '[' + key + ']', generateArrayPrefix, strictNullHandling, filter));
      }
    }
    return values;
  };
  module.exports = function (obj, options) {
    options = options || {};
    var delimiter = typeof options.delimiter === 'undefined' ? internals.delimiter : options.delimiter;
    var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : internals.strictNullHandling;
    var objKeys;
    var filter;
    if (typeof options.filter === 'function') {
      filter = options.filter;
      obj = filter('', obj);
    } else if (Array.isArray(options.filter)) {
      objKeys = filter = options.filter;
    }
    var keys = [];
    if (typeof obj !== 'object' || obj === null) {
      return '';
    }
    var arrayFormat;
    if (options.arrayFormat in internals.arrayPrefixGenerators) {
      arrayFormat = options.arrayFormat;
    } else if ('indices' in options) {
      arrayFormat = options.indices ? 'indices' : 'repeat';
    } else {
      arrayFormat = 'indices';
    }
    var generateArrayPrefix = internals.arrayPrefixGenerators[arrayFormat];
    if (!objKeys) {
      objKeys = Object.keys(obj);
    }
    for (var i = 0, il = objKeys.length; i < il; ++i) {
      var key = objKeys[i];
      keys = keys.concat(internals.stringify(obj[key], key, generateArrayPrefix, strictNullHandling, filter));
    }
    return keys.join(delimiter);
  };
  return module.exports;
});
$__System.registerDynamic('41', [], true, function ($__require, exports, module) {
    var define,
        global = this || self,
        GLOBAL = global;
    // Load modules


    // Declare internals

    var internals = {};
    internals.hexTable = new Array(256);
    for (var h = 0; h < 256; ++h) {
        internals.hexTable[h] = '%' + ((h < 16 ? '0' : '') + h.toString(16)).toUpperCase();
    }

    exports.arrayToObject = function (source, options) {

        var obj = options.plainObjects ? Object.create(null) : {};
        for (var i = 0, il = source.length; i < il; ++i) {
            if (typeof source[i] !== 'undefined') {

                obj[i] = source[i];
            }
        }

        return obj;
    };

    exports.merge = function (target, source, options) {

        if (!source) {
            return target;
        }

        if (typeof source !== 'object') {
            if (Array.isArray(target)) {
                target.push(source);
            } else if (typeof target === 'object') {
                target[source] = true;
            } else {
                target = [target, source];
            }

            return target;
        }

        if (typeof target !== 'object') {
            target = [target].concat(source);
            return target;
        }

        if (Array.isArray(target) && !Array.isArray(source)) {

            target = exports.arrayToObject(target, options);
        }

        var keys = Object.keys(source);
        for (var k = 0, kl = keys.length; k < kl; ++k) {
            var key = keys[k];
            var value = source[key];

            if (!Object.prototype.hasOwnProperty.call(target, key)) {
                target[key] = value;
            } else {
                target[key] = exports.merge(target[key], value, options);
            }
        }

        return target;
    };

    exports.decode = function (str) {

        try {
            return decodeURIComponent(str.replace(/\+/g, ' '));
        } catch (e) {
            return str;
        }
    };

    exports.encode = function (str) {

        // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
        // It has been adapted here for stricter adherence to RFC 3986
        if (str.length === 0) {
            return str;
        }

        if (typeof str !== 'string') {
            str = '' + str;
        }

        var out = '';
        for (var i = 0, il = str.length; i < il; ++i) {
            var c = str.charCodeAt(i);

            if (c === 0x2D || // -
            c === 0x2E || // .
            c === 0x5F || // _
            c === 0x7E || // ~
            c >= 0x30 && c <= 0x39 || // 0-9
            c >= 0x41 && c <= 0x5A || // a-z
            c >= 0x61 && c <= 0x7A) {
                // A-Z

                out += str[i];
                continue;
            }

            if (c < 0x80) {
                out += internals.hexTable[c];
                continue;
            }

            if (c < 0x800) {
                out += internals.hexTable[0xC0 | c >> 6] + internals.hexTable[0x80 | c & 0x3F];
                continue;
            }

            if (c < 0xD800 || c >= 0xE000) {
                out += internals.hexTable[0xE0 | c >> 12] + internals.hexTable[0x80 | c >> 6 & 0x3F] + internals.hexTable[0x80 | c & 0x3F];
                continue;
            }

            ++i;
            c = 0x10000 + ((c & 0x3FF) << 10 | str.charCodeAt(i) & 0x3FF);
            out += internals.hexTable[0xF0 | c >> 18] + internals.hexTable[0x80 | c >> 12 & 0x3F] + internals.hexTable[0x80 | c >> 6 & 0x3F] + internals.hexTable[0x80 | c & 0x3F];
        }

        return out;
    };

    exports.compact = function (obj, refs) {

        if (typeof obj !== 'object' || obj === null) {

            return obj;
        }

        refs = refs || [];
        var lookup = refs.indexOf(obj);
        if (lookup !== -1) {
            return refs[lookup];
        }

        refs.push(obj);

        if (Array.isArray(obj)) {
            var compacted = [];

            for (var i = 0, il = obj.length; i < il; ++i) {
                if (typeof obj[i] !== 'undefined') {
                    compacted.push(obj[i]);
                }
            }

            return compacted;
        }

        var keys = Object.keys(obj);
        for (i = 0, il = keys.length; i < il; ++i) {
            var key = keys[i];
            obj[key] = exports.compact(obj[key], refs);
        }

        return obj;
    };

    exports.isRegExp = function (obj) {

        return Object.prototype.toString.call(obj) === '[object RegExp]';
    };

    exports.isBuffer = function (obj) {

        if (obj === null || typeof obj === 'undefined') {

            return false;
        }

        return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    };
    return module.exports;
});
$__System.registerDynamic('42', ['41'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var Utils = $__require('41');
  var internals = {
    delimiter: '&',
    depth: 5,
    arrayLimit: 20,
    parameterLimit: 1000,
    strictNullHandling: false,
    plainObjects: false,
    allowPrototypes: false
  };
  internals.parseValues = function (str, options) {
    var obj = {};
    var parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit);
    for (var i = 0, il = parts.length; i < il; ++i) {
      var part = parts[i];
      var pos = part.indexOf(']=') === -1 ? part.indexOf('=') : part.indexOf(']=') + 1;
      if (pos === -1) {
        obj[Utils.decode(part)] = '';
        if (options.strictNullHandling) {
          obj[Utils.decode(part)] = null;
        }
      } else {
        var key = Utils.decode(part.slice(0, pos));
        var val = Utils.decode(part.slice(pos + 1));
        if (!Object.prototype.hasOwnProperty.call(obj, key)) {
          obj[key] = val;
        } else {
          obj[key] = [].concat(obj[key]).concat(val);
        }
      }
    }
    return obj;
  };
  internals.parseObject = function (chain, val, options) {
    if (!chain.length) {
      return val;
    }
    var root = chain.shift();
    var obj;
    if (root === '[]') {
      obj = [];
      obj = obj.concat(internals.parseObject(chain, val, options));
    } else {
      obj = options.plainObjects ? Object.create(null) : {};
      var cleanRoot = root[0] === '[' && root[root.length - 1] === ']' ? root.slice(1, root.length - 1) : root;
      var index = parseInt(cleanRoot, 10);
      var indexString = '' + index;
      if (!isNaN(index) && root !== cleanRoot && indexString === cleanRoot && index >= 0 && options.parseArrays && index <= options.arrayLimit) {
        obj = [];
        obj[index] = internals.parseObject(chain, val, options);
      } else {
        obj[cleanRoot] = internals.parseObject(chain, val, options);
      }
    }
    return obj;
  };
  internals.parseKeys = function (key, val, options) {
    if (!key) {
      return;
    }
    if (options.allowDots) {
      key = key.replace(/\.([^\.\[]+)/g, '[$1]');
    }
    var parent = /^([^\[\]]*)/;
    var child = /(\[[^\[\]]*\])/g;
    var segment = parent.exec(key);
    var keys = [];
    if (segment[1]) {
      if (!options.plainObjects && Object.prototype.hasOwnProperty(segment[1])) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      keys.push(segment[1]);
    }
    var i = 0;
    while ((segment = child.exec(key)) !== null && i < options.depth) {
      ++i;
      if (!options.plainObjects && Object.prototype.hasOwnProperty(segment[1].replace(/\[|\]/g, ''))) {
        if (!options.allowPrototypes) {
          continue;
        }
      }
      keys.push(segment[1]);
    }
    if (segment) {
      keys.push('[' + key.slice(segment.index) + ']');
    }
    return internals.parseObject(keys, val, options);
  };
  module.exports = function (str, options) {
    options = options || {};
    options.delimiter = typeof options.delimiter === 'string' || Utils.isRegExp(options.delimiter) ? options.delimiter : internals.delimiter;
    options.depth = typeof options.depth === 'number' ? options.depth : internals.depth;
    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : internals.arrayLimit;
    options.parseArrays = options.parseArrays !== false;
    options.allowDots = options.allowDots !== false;
    options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : internals.plainObjects;
    options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : internals.allowPrototypes;
    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : internals.parameterLimit;
    options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : internals.strictNullHandling;
    if (str === '' || str === null || typeof str === 'undefined') {
      return options.plainObjects ? Object.create(null) : {};
    }
    var tempObj = typeof str === 'string' ? internals.parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};
    var keys = Object.keys(tempObj);
    for (var i = 0, il = keys.length; i < il; ++i) {
      var key = keys[i];
      var newObj = internals.parseKeys(key, tempObj[key], options);
      obj = Utils.merge(obj, newObj, options);
    }
    return Utils.compact(obj);
  };
  return module.exports;
});
$__System.registerDynamic('43', ['40', '42'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var Stringify = $__require('40');
  var Parse = $__require('42');
  var internals = {};
  module.exports = {
    stringify: Stringify,
    parse: Parse
  };
  return module.exports;
});
$__System.registerDynamic("33", ["43"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("43");
  return module.exports;
});
$__System.registerDynamic('c', ['19', '33'], true, function ($__require, exports, module) {
  /*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */

  'use strict';

  /**
   * Module dependencies.
   */

  var define,
      global = this || self,
      GLOBAL = global;
  var parseUrl = $__require('19');
  var qs = $__require('33');

  /**
   * @param {Object} options
   * @return {Function}
   * @api public
   */

  module.exports = function query(options) {
    var opts = Object.create(options || null);
    var queryparse = qs.parse;

    if (typeof options === 'function') {
      queryparse = options;
      opts = undefined;
    }

    if (opts !== undefined) {
      if (opts.allowDots === undefined) {
        opts.allowDots = false;
      }

      if (opts.allowPrototypes === undefined) {
        opts.allowPrototypes = true;
      }
    }

    return function query(req, res, next) {
      if (!req.query) {
        var val = parseUrl(req).query;
        req.query = queryparse(val, opts);
      }

      next();
    };
  };
  return module.exports;
});
$__System.registerDynamic('44', ['45', '46'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */

  var statuses = $__require('45');
  var inherits = $__require('46');

  function toIdentifier(str) {
    return str.split(' ').map(function (token) {
      return token.slice(0, 1).toUpperCase() + token.slice(1);
    }).join('').replace(/[^ _0-9a-z]/gi, '');
  }

  exports = module.exports = function httpError() {
    // so much arity going on ~_~
    var err;
    var msg;
    var status = 500;
    var props = {};
    for (var i = 0; i < arguments.length; i++) {
      var arg = arguments[i];
      if (arg instanceof Error) {
        err = arg;
        status = err.status || err.statusCode || status;
        continue;
      }
      switch (typeof arg) {
        case 'string':
          msg = arg;
          break;
        case 'number':
          status = arg;
          break;
        case 'object':
          props = arg;
          break;
      }
    }

    if (typeof status !== 'number' || !statuses[status]) {
      status = 500;
    }

    // constructor
    var HttpError = exports[status];

    if (!err) {
      // create error
      err = HttpError ? new HttpError(msg) : new Error(msg || statuses[status]);
      Error.captureStackTrace(err, httpError);
    }

    if (!HttpError || !(err instanceof HttpError)) {
      // add properties to generic error
      err.expose = status < 500;
      err.status = err.statusCode = status;
    }

    for (var key in props) {
      if (key !== 'status' && key !== 'statusCode') {
        err[key] = props[key];
      }
    }

    return err;
  };

  // create generic error objects
  var codes = statuses.codes.filter(function (num) {
    return num >= 400;
  });

  codes.forEach(function (code) {
    var name = toIdentifier(statuses[code]);
    var className = name.match(/Error$/) ? name : name + 'Error';

    if (code >= 500) {
      var ServerError = function ServerError(msg) {
        var self = new Error(msg != null ? msg : statuses[code]);
        Error.captureStackTrace(self, ServerError);
        self.__proto__ = ServerError.prototype;
        Object.defineProperty(self, 'name', {
          enumerable: false,
          configurable: true,
          value: className,
          writable: true
        });
        return self;
      };
      inherits(ServerError, Error);
      ServerError.prototype.status = ServerError.prototype.statusCode = code;
      ServerError.prototype.expose = false;
      exports[code] = exports[name] = ServerError;
      return;
    }

    var ClientError = function ClientError(msg) {
      var self = new Error(msg != null ? msg : statuses[code]);
      Error.captureStackTrace(self, ClientError);
      self.__proto__ = ClientError.prototype;
      Object.defineProperty(self, 'name', {
        enumerable: false,
        configurable: true,
        value: className,
        writable: true
      });
      return self;
    };
    inherits(ClientError, Error);
    ClientError.prototype.status = ClientError.prototype.statusCode = code;
    ClientError.prototype.expose = true;
    exports[code] = exports[name] = ClientError;
    return;
  });

  // backwards-compatibility
  exports["I'mateapot"] = exports.ImATeapot;
  return module.exports;
});
$__System.registerDynamic("47", ["44"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("44");
  return module.exports;
});
$__System.registerDynamic('48', ['7', '49'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var ReadStream = $__require('7').ReadStream;
  var Stream = $__require('49');
  module.exports = destroy;
  function destroy(stream) {
    if (stream instanceof ReadStream) {
      return destroyReadStream(stream);
    }
    if (!(stream instanceof Stream)) {
      return stream;
    }
    if (typeof stream.destroy === 'function') {
      stream.destroy();
    }
    return stream;
  }
  function destroyReadStream(stream) {
    stream.destroy();
    if (typeof stream.close === 'function') {
      stream.on('open', onOpenClose);
    }
    return stream;
  }
  function onOpenClose() {
    if (typeof this.fd === 'number') {
      this.close();
    }
  }
  return module.exports;
});
$__System.registerDynamic("4a", ["48"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("48");
  return module.exports;
});
$__System.registerDynamic('4b', [], true, function ($__require, exports, module) {
  /*!
   * range-parser
   * Copyright(c) 2012-2014 TJ Holowaychuk
   * MIT Licensed
   */

  'use strict';

  /**
   * Module exports.
   * @public
   */

  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = rangeParser;

  /**
   * Parse "Range" header `str` relative to the given file `size`.
   *
   * @param {Number} size
   * @param {String} str
   * @return {Array}
   * @public
   */

  function rangeParser(size, str) {
    var valid = true;
    var i = str.indexOf('=');

    if (-1 == i) return -2;

    var arr = str.slice(i + 1).split(',').map(function (range) {
      var range = range.split('-'),
          start = parseInt(range[0], 10),
          end = parseInt(range[1], 10);

      // -nnn
      if (isNaN(start)) {
        start = size - end;
        end = size - 1;
        // nnn-
      } else if (isNaN(end)) {
        end = size - 1;
      }

      // limit last-byte-pos to current length
      if (end > size - 1) end = size - 1;

      // invalid
      if (isNaN(start) || isNaN(end) || start > end || start < 0) valid = false;

      return {
        start: start,
        end: end
      };
    });

    arr.type = str.slice(0, i);

    return valid ? arr : -1;
  }
  return module.exports;
});
$__System.registerDynamic("25", ["4b"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("4b");
  return module.exports;
});
$__System.registerDynamic("4c", [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomsvc+xml": ["atomsvc"], "application/ccxml+xml": ["ccxml"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mdp"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["ecma"], "application/emma+xml": ["emma"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/font-tdpfr": ["pfr"], "application/font-woff": ["woff"], "application/font-woff2": ["woff2"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/java-archive": ["jar"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/prs.cww": ["cww"], "application/pskc+xml": ["pskcxml"], "application/rdf+xml": ["rdf"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/vnd.3gpp.pic-bw-large": ["plb"], "application/vnd.3gpp.pic-bw-small": ["psb"], "application/vnd.3gpp.pic-bw-var": ["pvb"], "application/vnd.3gpp2.tcap": ["tcap"], "application/vnd.3m.post-it-notes": ["pwn"], "application/vnd.accpac.simply.aso": ["aso"], "application/vnd.accpac.simply.imp": ["imp"], "application/vnd.acucobol": ["acu"], "application/vnd.acucorp": ["atc", "acutc"], "application/vnd.adobe.air-application-installer-package+zip": ["air"], "application/vnd.adobe.formscentral.fcdt": ["fcdt"], "application/vnd.adobe.fxp": ["fxp", "fxpl"], "application/vnd.adobe.xdp+xml": ["xdp"], "application/vnd.adobe.xfdf": ["xfdf"], "application/vnd.ahead.space": ["ahead"], "application/vnd.airzip.filesecure.azf": ["azf"], "application/vnd.airzip.filesecure.azs": ["azs"], "application/vnd.amazon.ebook": ["azw"], "application/vnd.americandynamics.acc": ["acc"], "application/vnd.amiga.ami": ["ami"], "application/vnd.android.package-archive": ["apk"], "application/vnd.anser-web-certificate-issue-initiation": ["cii"], "application/vnd.anser-web-funds-transfer-initiation": ["fti"], "application/vnd.antix.game-component": ["atx"], "application/vnd.apple.installer+xml": ["mpkg"], "application/vnd.apple.mpegurl": ["m3u8"], "application/vnd.aristanetworks.swi": ["swi"], "application/vnd.astraea-software.iota": ["iota"], "application/vnd.audiograph": ["aep"], "application/vnd.blueice.multipass": ["mpm"], "application/vnd.bmi": ["bmi"], "application/vnd.businessobjects": ["rep"], "application/vnd.chemdraw+xml": ["cdxml"], "application/vnd.chipnuts.karaoke-mmd": ["mmd"], "application/vnd.cinderella": ["cdy"], "application/vnd.claymore": ["cla"], "application/vnd.cloanto.rp9": ["rp9"], "application/vnd.clonk.c4group": ["c4g", "c4d", "c4f", "c4p", "c4u"], "application/vnd.cluetrust.cartomobile-config": ["c11amc"], "application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"], "application/vnd.commonspace": ["csp"], "application/vnd.contact.cmsg": ["cdbcmsg"], "application/vnd.cosmocaller": ["cmc"], "application/vnd.crick.clicker": ["clkx"], "application/vnd.crick.clicker.keyboard": ["clkk"], "application/vnd.crick.clicker.palette": ["clkp"], "application/vnd.crick.clicker.template": ["clkt"], "application/vnd.crick.clicker.wordbank": ["clkw"], "application/vnd.criticaltools.wbs+xml": ["wbs"], "application/vnd.ctc-posml": ["pml"], "application/vnd.cups-ppd": ["ppd"], "application/vnd.curl.car": ["car"], "application/vnd.curl.pcurl": ["pcurl"], "application/vnd.dart": ["dart"], "application/vnd.data-vision.rdz": ["rdz"], "application/vnd.dece.data": ["uvf", "uvvf", "uvd", "uvvd"], "application/vnd.dece.ttml+xml": ["uvt", "uvvt"], "application/vnd.dece.unspecified": ["uvx", "uvvx"], "application/vnd.dece.zip": ["uvz", "uvvz"], "application/vnd.denovo.fcselayout-link": ["fe_launch"], "application/vnd.dna": ["dna"], "application/vnd.dolby.mlp": ["mlp"], "application/vnd.dpgraph": ["dpg"], "application/vnd.dreamfactory": ["dfac"], "application/vnd.ds-keypoint": ["kpxx"], "application/vnd.dvb.ait": ["ait"], "application/vnd.dvb.service": ["svc"], "application/vnd.dynageo": ["geo"], "application/vnd.ecowin.chart": ["mag"], "application/vnd.enliven": ["nml"], "application/vnd.epson.esf": ["esf"], "application/vnd.epson.msf": ["msf"], "application/vnd.epson.quickanime": ["qam"], "application/vnd.epson.salt": ["slt"], "application/vnd.epson.ssf": ["ssf"], "application/vnd.eszigno3+xml": ["es3", "et3"], "application/vnd.ezpix-album": ["ez2"], "application/vnd.ezpix-package": ["ez3"], "application/vnd.fdf": ["fdf"], "application/vnd.fdsn.mseed": ["mseed"], "application/vnd.fdsn.seed": ["seed", "dataless"], "application/vnd.flographit": ["gph"], "application/vnd.fluxtime.clip": ["ftc"], "application/vnd.framemaker": ["fm", "frame", "maker", "book"], "application/vnd.frogans.fnc": ["fnc"], "application/vnd.frogans.ltf": ["ltf"], "application/vnd.fsc.weblaunch": ["fsc"], "application/vnd.fujitsu.oasys": ["oas"], "application/vnd.fujitsu.oasys2": ["oa2"], "application/vnd.fujitsu.oasys3": ["oa3"], "application/vnd.fujitsu.oasysgp": ["fg5"], "application/vnd.fujitsu.oasysprs": ["bh2"], "application/vnd.fujixerox.ddd": ["ddd"], "application/vnd.fujixerox.docuworks": ["xdw"], "application/vnd.fujixerox.docuworks.binder": ["xbd"], "application/vnd.fuzzysheet": ["fzs"], "application/vnd.genomatix.tuxedo": ["txd"], "application/vnd.geogebra.file": ["ggb"], "application/vnd.geogebra.tool": ["ggt"], "application/vnd.geometry-explorer": ["gex", "gre"], "application/vnd.geonext": ["gxt"], "application/vnd.geoplan": ["g2w"], "application/vnd.geospace": ["g3w"], "application/vnd.gmx": ["gmx"], "application/vnd.google-earth.kml+xml": ["kml"], "application/vnd.google-earth.kmz": ["kmz"], "application/vnd.grafeq": ["gqf", "gqs"], "application/vnd.groove-account": ["gac"], "application/vnd.groove-help": ["ghf"], "application/vnd.groove-identity-message": ["gim"], "application/vnd.groove-injector": ["grv"], "application/vnd.groove-tool-message": ["gtm"], "application/vnd.groove-tool-template": ["tpl"], "application/vnd.groove-vcard": ["vcg"], "application/vnd.hal+xml": ["hal"], "application/vnd.handheld-entertainment+xml": ["zmm"], "application/vnd.hbci": ["hbci"], "application/vnd.hhe.lesson-player": ["les"], "application/vnd.hp-hpgl": ["hpgl"], "application/vnd.hp-hpid": ["hpid"], "application/vnd.hp-hps": ["hps"], "application/vnd.hp-jlyt": ["jlt"], "application/vnd.hp-pcl": ["pcl"], "application/vnd.hp-pclxl": ["pclxl"], "application/vnd.ibm.minipay": ["mpy"], "application/vnd.ibm.modcap": ["afp", "listafp", "list3820"], "application/vnd.ibm.rights-management": ["irm"], "application/vnd.ibm.secure-container": ["sc"], "application/vnd.iccprofile": ["icc", "icm"], "application/vnd.igloader": ["igl"], "application/vnd.immervision-ivp": ["ivp"], "application/vnd.immervision-ivu": ["ivu"], "application/vnd.insors.igm": ["igm"], "application/vnd.intercon.formnet": ["xpw", "xpx"], "application/vnd.intergeo": ["i2g"], "application/vnd.intu.qbo": ["qbo"], "application/vnd.intu.qfx": ["qfx"], "application/vnd.ipunplugged.rcprofile": ["rcprofile"], "application/vnd.irepository.package+xml": ["irp"], "application/vnd.is-xpr": ["xpr"], "application/vnd.isac.fcs": ["fcs"], "application/vnd.jam": ["jam"], "application/vnd.jcp.javame.midlet-rms": ["rms"], "application/vnd.jisp": ["jisp"], "application/vnd.joost.joda-archive": ["joda"], "application/vnd.kahootz": ["ktz", "ktr"], "application/vnd.kde.karbon": ["karbon"], "application/vnd.kde.kchart": ["chrt"], "application/vnd.kde.kformula": ["kfo"], "application/vnd.kde.kivio": ["flw"], "application/vnd.kde.kontour": ["kon"], "application/vnd.kde.kpresenter": ["kpr", "kpt"], "application/vnd.kde.kspread": ["ksp"], "application/vnd.kde.kword": ["kwd", "kwt"], "application/vnd.kenameaapp": ["htke"], "application/vnd.kidspiration": ["kia"], "application/vnd.kinar": ["kne", "knp"], "application/vnd.koan": ["skp", "skd", "skt", "skm"], "application/vnd.kodak-descriptor": ["sse"], "application/vnd.las.las+xml": ["lasxml"], "application/vnd.llamagraphics.life-balance.desktop": ["lbd"], "application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"], "application/vnd.lotus-1-2-3": ["123"], "application/vnd.lotus-approach": ["apr"], "application/vnd.lotus-freelance": ["pre"], "application/vnd.lotus-notes": ["nsf"], "application/vnd.lotus-organizer": ["org"], "application/vnd.lotus-screencam": ["scm"], "application/vnd.lotus-wordpro": ["lwp"], "application/vnd.macports.portpkg": ["portpkg"], "application/vnd.mcd": ["mcd"], "application/vnd.medcalcdata": ["mc1"], "application/vnd.mediastation.cdkey": ["cdkey"], "application/vnd.mfer": ["mwf"], "application/vnd.mfmp": ["mfm"], "application/vnd.micrografx.flo": ["flo"], "application/vnd.micrografx.igx": ["igx"], "application/vnd.mif": ["mif"], "application/vnd.mobius.daf": ["daf"], "application/vnd.mobius.dis": ["dis"], "application/vnd.mobius.mbk": ["mbk"], "application/vnd.mobius.mqy": ["mqy"], "application/vnd.mobius.msl": ["msl"], "application/vnd.mobius.plc": ["plc"], "application/vnd.mobius.txf": ["txf"], "application/vnd.mophun.application": ["mpn"], "application/vnd.mophun.certificate": ["mpc"], "application/vnd.mozilla.xul+xml": ["xul"], "application/vnd.ms-artgalry": ["cil"], "application/vnd.ms-cab-compressed": ["cab"], "application/vnd.ms-excel": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"], "application/vnd.ms-excel.addin.macroenabled.12": ["xlam"], "application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"], "application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"], "application/vnd.ms-excel.template.macroenabled.12": ["xltm"], "application/vnd.ms-fontobject": ["eot"], "application/vnd.ms-htmlhelp": ["chm"], "application/vnd.ms-ims": ["ims"], "application/vnd.ms-lrm": ["lrm"], "application/vnd.ms-officetheme": ["thmx"], "application/vnd.ms-pki.seccat": ["cat"], "application/vnd.ms-pki.stl": ["stl"], "application/vnd.ms-powerpoint": ["ppt", "pps", "pot"], "application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"], "application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"], "application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"], "application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"], "application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"], "application/vnd.ms-project": ["mpp", "mpt"], "application/vnd.ms-word.document.macroenabled.12": ["docm"], "application/vnd.ms-word.template.macroenabled.12": ["dotm"], "application/vnd.ms-works": ["wps", "wks", "wcm", "wdb"], "application/vnd.ms-wpl": ["wpl"], "application/vnd.ms-xpsdocument": ["xps"], "application/vnd.mseq": ["mseq"], "application/vnd.musician": ["mus"], "application/vnd.muvee.style": ["msty"], "application/vnd.mynfc": ["taglet"], "application/vnd.neurolanguage.nlu": ["nlu"], "application/vnd.nitf": ["ntf", "nitf"], "application/vnd.noblenet-directory": ["nnd"], "application/vnd.noblenet-sealer": ["nns"], "application/vnd.noblenet-web": ["nnw"], "application/vnd.nokia.n-gage.data": ["ngdat"], "application/vnd.nokia.radio-preset": ["rpst"], "application/vnd.nokia.radio-presets": ["rpss"], "application/vnd.novadigm.edm": ["edm"], "application/vnd.novadigm.edx": ["edx"], "application/vnd.novadigm.ext": ["ext"], "application/vnd.oasis.opendocument.chart": ["odc"], "application/vnd.oasis.opendocument.chart-template": ["otc"], "application/vnd.oasis.opendocument.database": ["odb"], "application/vnd.oasis.opendocument.formula": ["odf"], "application/vnd.oasis.opendocument.formula-template": ["odft"], "application/vnd.oasis.opendocument.graphics": ["odg"], "application/vnd.oasis.opendocument.graphics-template": ["otg"], "application/vnd.oasis.opendocument.image": ["odi"], "application/vnd.oasis.opendocument.image-template": ["oti"], "application/vnd.oasis.opendocument.presentation": ["odp"], "application/vnd.oasis.opendocument.presentation-template": ["otp"], "application/vnd.oasis.opendocument.spreadsheet": ["ods"], "application/vnd.oasis.opendocument.spreadsheet-template": ["ots"], "application/vnd.oasis.opendocument.text": ["odt"], "application/vnd.oasis.opendocument.text-master": ["odm"], "application/vnd.oasis.opendocument.text-template": ["ott"], "application/vnd.oasis.opendocument.text-web": ["oth"], "application/vnd.olpc-sugar": ["xo"], "application/vnd.oma.dd2+xml": ["dd2"], "application/vnd.openofficeorg.extension": ["oxt"], "application/vnd.openxmlformats-officedocument.presentationml.presentation": ["pptx"], "application/vnd.openxmlformats-officedocument.presentationml.slide": ["sldx"], "application/vnd.openxmlformats-officedocument.presentationml.slideshow": ["ppsx"], "application/vnd.openxmlformats-officedocument.presentationml.template": ["potx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.template": ["xltx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.document": ["docx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.template": ["dotx"], "application/vnd.osgeo.mapguide.package": ["mgp"], "application/vnd.osgi.dp": ["dp"], "application/vnd.osgi.subsystem": ["esa"], "application/vnd.palm": ["pdb", "pqa", "oprc"], "application/vnd.pawaafile": ["paw"], "application/vnd.pg.format": ["str"], "application/vnd.pg.osasli": ["ei6"], "application/vnd.picsel": ["efif"], "application/vnd.pmi.widget": ["wg"], "application/vnd.pocketlearn": ["plf"], "application/vnd.powerbuilder6": ["pbd"], "application/vnd.previewsystems.box": ["box"], "application/vnd.proteus.magazine": ["mgz"], "application/vnd.publishare-delta-tree": ["qps"], "application/vnd.pvi.ptid1": ["ptid"], "application/vnd.quark.quarkxpress": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"], "application/vnd.realvnc.bed": ["bed"], "application/vnd.recordare.musicxml": ["mxl"], "application/vnd.recordare.musicxml+xml": ["musicxml"], "application/vnd.rig.cryptonote": ["cryptonote"], "application/vnd.rim.cod": ["cod"], "application/vnd.rn-realmedia": ["rm"], "application/vnd.rn-realmedia-vbr": ["rmvb"], "application/vnd.route66.link66+xml": ["link66"], "application/vnd.sailingtracker.track": ["st"], "application/vnd.seemail": ["see"], "application/vnd.sema": ["sema"], "application/vnd.semd": ["semd"], "application/vnd.semf": ["semf"], "application/vnd.shana.informed.formdata": ["ifm"], "application/vnd.shana.informed.formtemplate": ["itp"], "application/vnd.shana.informed.interchange": ["iif"], "application/vnd.shana.informed.package": ["ipk"], "application/vnd.simtech-mindmapper": ["twd", "twds"], "application/vnd.smaf": ["mmf"], "application/vnd.smart.teacher": ["teacher"], "application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"], "application/vnd.spotfire.dxp": ["dxp"], "application/vnd.spotfire.sfs": ["sfs"], "application/vnd.stardivision.calc": ["sdc"], "application/vnd.stardivision.draw": ["sda"], "application/vnd.stardivision.impress": ["sdd"], "application/vnd.stardivision.math": ["smf"], "application/vnd.stardivision.writer": ["sdw", "vor"], "application/vnd.stardivision.writer-global": ["sgl"], "application/vnd.stepmania.package": ["smzip"], "application/vnd.stepmania.stepchart": ["sm"], "application/vnd.sun.xml.calc": ["sxc"], "application/vnd.sun.xml.calc.template": ["stc"], "application/vnd.sun.xml.draw": ["sxd"], "application/vnd.sun.xml.draw.template": ["std"], "application/vnd.sun.xml.impress": ["sxi"], "application/vnd.sun.xml.impress.template": ["sti"], "application/vnd.sun.xml.math": ["sxm"], "application/vnd.sun.xml.writer": ["sxw"], "application/vnd.sun.xml.writer.global": ["sxg"], "application/vnd.sun.xml.writer.template": ["stw"], "application/vnd.sus-calendar": ["sus", "susp"], "application/vnd.svd": ["svd"], "application/vnd.symbian.install": ["sis", "sisx"], "application/vnd.syncml+xml": ["xsm"], "application/vnd.syncml.dm+wbxml": ["bdm"], "application/vnd.syncml.dm+xml": ["xdm"], "application/vnd.tao.intent-module-archive": ["tao"], "application/vnd.tcpdump.pcap": ["pcap", "cap", "dmp"], "application/vnd.tmobile-livetv": ["tmo"], "application/vnd.trid.tpt": ["tpt"], "application/vnd.triscape.mxs": ["mxs"], "application/vnd.trueapp": ["tra"], "application/vnd.ufdl": ["ufd", "ufdl"], "application/vnd.uiq.theme": ["utz"], "application/vnd.umajin": ["umj"], "application/vnd.unity": ["unityweb"], "application/vnd.uoml+xml": ["uoml"], "application/vnd.vcx": ["vcx"], "application/vnd.visio": ["vsd", "vst", "vss", "vsw"], "application/vnd.visionary": ["vis"], "application/vnd.vsf": ["vsf"], "application/vnd.wap.wbxml": ["wbxml"], "application/vnd.wap.wmlc": ["wmlc"], "application/vnd.wap.wmlscriptc": ["wmlsc"], "application/vnd.webturbo": ["wtb"], "application/vnd.wolfram.player": ["nbp"], "application/vnd.wordperfect": ["wpd"], "application/vnd.wqd": ["wqd"], "application/vnd.wt.stf": ["stf"], "application/vnd.xara": ["xar"], "application/vnd.xfdl": ["xfdl"], "application/vnd.yamaha.hv-dic": ["hvd"], "application/vnd.yamaha.hv-script": ["hvs"], "application/vnd.yamaha.hv-voice": ["hvp"], "application/vnd.yamaha.openscoreformat": ["osf"], "application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"], "application/vnd.yamaha.smaf-audio": ["saf"], "application/vnd.yamaha.smaf-phrase": ["spf"], "application/vnd.yellowriver-custom-menu": ["cmp"], "application/vnd.zul": ["zir", "zirz"], "application/vnd.zzazz.deck+xml": ["zaz"], "application/voicexml+xml": ["vxml"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/x-7z-compressed": ["7z"], "application/x-abiword": ["abw"], "application/x-ace-compressed": ["ace"], "application/x-apple-diskimage": ["dmg"], "application/x-authorware-bin": ["aab", "x32", "u32", "vox"], "application/x-authorware-map": ["aam"], "application/x-authorware-seg": ["aas"], "application/x-bcpio": ["bcpio"], "application/x-bittorrent": ["torrent"], "application/x-blorb": ["blb", "blorb"], "application/x-bzip": ["bz"], "application/x-bzip2": ["bz2", "boz"], "application/x-cbr": ["cbr", "cba", "cbt", "cbz", "cb7"], "application/x-cdlink": ["vcd"], "application/x-cfs-compressed": ["cfs"], "application/x-chat": ["chat"], "application/x-chess-pgn": ["pgn"], "application/x-chrome-extension": ["crx"], "application/x-conference": ["nsc"], "application/x-cpio": ["cpio"], "application/x-csh": ["csh"], "application/x-debian-package": ["deb", "udeb"], "application/x-dgc-compressed": ["dgc"], "application/x-director": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"], "application/x-doom": ["wad"], "application/x-dtbncx+xml": ["ncx"], "application/x-dtbook+xml": ["dtb"], "application/x-dtbresource+xml": ["res"], "application/x-dvi": ["dvi"], "application/x-envoy": ["evy"], "application/x-eva": ["eva"], "application/x-font-bdf": ["bdf"], "application/x-font-ghostscript": ["gsf"], "application/x-font-linux-psf": ["psf"], "application/x-font-otf": ["otf"], "application/x-font-pcf": ["pcf"], "application/x-font-snf": ["snf"], "application/x-font-ttf": ["ttf", "ttc"], "application/x-font-type1": ["pfa", "pfb", "pfm", "afm"], "application/x-freearc": ["arc"], "application/x-futuresplash": ["spl"], "application/x-gca-compressed": ["gca"], "application/x-glulx": ["ulx"], "application/x-gnumeric": ["gnumeric"], "application/x-gramps-xml": ["gramps"], "application/x-gtar": ["gtar"], "application/x-hdf": ["hdf"], "application/x-install-instructions": ["install"], "application/x-iso9660-image": ["iso"], "application/x-java-jnlp-file": ["jnlp"], "application/x-latex": ["latex"], "application/x-lua-bytecode": ["luac"], "application/x-lzh-compressed": ["lzh", "lha"], "application/x-mie": ["mie"], "application/x-mobipocket-ebook": ["prc", "mobi"], "application/x-ms-application": ["application"], "application/x-ms-shortcut": ["lnk"], "application/x-ms-wmd": ["wmd"], "application/x-ms-wmz": ["wmz"], "application/x-ms-xbap": ["xbap"], "application/x-msaccess": ["mdb"], "application/x-msbinder": ["obd"], "application/x-mscardfile": ["crd"], "application/x-msclip": ["clp"], "application/x-msdownload": ["exe", "dll", "com", "bat", "msi"], "application/x-msmediaview": ["mvb", "m13", "m14"], "application/x-msmetafile": ["wmf", "wmz", "emf", "emz"], "application/x-msmoney": ["mny"], "application/x-mspublisher": ["pub"], "application/x-msschedule": ["scd"], "application/x-msterminal": ["trm"], "application/x-mswrite": ["wri"], "application/x-netcdf": ["nc", "cdf"], "application/x-nzb": ["nzb"], "application/x-pkcs12": ["p12", "pfx"], "application/x-pkcs7-certificates": ["p7b", "spc"], "application/x-pkcs7-certreqresp": ["p7r"], "application/x-rar-compressed": ["rar"], "application/x-research-info-systems": ["ris"], "application/x-sh": ["sh"], "application/x-shar": ["shar"], "application/x-shockwave-flash": ["swf"], "application/x-silverlight-app": ["xap"], "application/x-sql": ["sql"], "application/x-stuffit": ["sit"], "application/x-stuffitx": ["sitx"], "application/x-subrip": ["srt"], "application/x-sv4cpio": ["sv4cpio"], "application/x-sv4crc": ["sv4crc"], "application/x-t3vm-image": ["t3"], "application/x-tads": ["gam"], "application/x-tar": ["tar"], "application/x-tcl": ["tcl"], "application/x-tex": ["tex"], "application/x-tex-tfm": ["tfm"], "application/x-texinfo": ["texinfo", "texi"], "application/x-tgif": ["obj"], "application/x-ustar": ["ustar"], "application/x-wais-source": ["src"], "application/x-web-app-manifest+json": ["webapp"], "application/x-x509-ca-cert": ["der", "crt"], "application/x-xfig": ["fig"], "application/x-xliff+xml": ["xlf"], "application/x-xpinstall": ["xpi"], "application/x-xz": ["xz"], "application/x-zmachine": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"], "application/xaml+xml": ["xaml"], "application/xcap-diff+xml": ["xdf"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xml": ["xml", "xsl", "xsd"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/adpcm": ["adp"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mp4": ["mp4a", "m4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/vnd.dece.audio": ["uva", "uvva"], "audio/vnd.digital-winds": ["eol"], "audio/vnd.dra": ["dra"], "audio/vnd.dts": ["dts"], "audio/vnd.dts.hd": ["dtshd"], "audio/vnd.lucent.voice": ["lvp"], "audio/vnd.ms-playready.media.pya": ["pya"], "audio/vnd.nuera.ecelp4800": ["ecelp4800"], "audio/vnd.nuera.ecelp7470": ["ecelp7470"], "audio/vnd.nuera.ecelp9600": ["ecelp9600"], "audio/vnd.rip": ["rip"], "audio/webm": ["weba"], "audio/x-aac": ["aac"], "audio/x-aiff": ["aif", "aiff", "aifc"], "audio/x-caf": ["caf"], "audio/x-flac": ["flac"], "audio/x-matroska": ["mka"], "audio/x-mpegurl": ["m3u"], "audio/x-ms-wax": ["wax"], "audio/x-ms-wma": ["wma"], "audio/x-pn-realaudio": ["ram", "ra"], "audio/x-pn-realaudio-plugin": ["rmp"], "audio/x-wav": ["wav"], "audio/xm": ["xm"], "chemical/x-cdx": ["cdx"], "chemical/x-cif": ["cif"], "chemical/x-cmdf": ["cmdf"], "chemical/x-cml": ["cml"], "chemical/x-csml": ["csml"], "chemical/x-xyz": ["xyz"], "font/opentype": ["otf"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/ief": ["ief"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/ktx": ["ktx"], "image/png": ["png"], "image/prs.btif": ["btif"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/tiff": ["tiff", "tif"], "image/vnd.adobe.photoshop": ["psd"], "image/vnd.dece.graphic": ["uvi", "uvvi", "uvg", "uvvg"], "image/vnd.djvu": ["djvu", "djv"], "image/vnd.dvb.subtitle": ["sub"], "image/vnd.dwg": ["dwg"], "image/vnd.dxf": ["dxf"], "image/vnd.fastbidsheet": ["fbs"], "image/vnd.fpx": ["fpx"], "image/vnd.fst": ["fst"], "image/vnd.fujixerox.edmics-mmr": ["mmr"], "image/vnd.fujixerox.edmics-rlc": ["rlc"], "image/vnd.ms-modi": ["mdi"], "image/vnd.ms-photo": ["wdp"], "image/vnd.net-fpx": ["npx"], "image/vnd.wap.wbmp": ["wbmp"], "image/vnd.xiff": ["xif"], "image/webp": ["webp"], "image/x-3ds": ["3ds"], "image/x-cmu-raster": ["ras"], "image/x-cmx": ["cmx"], "image/x-freehand": ["fh", "fhc", "fh4", "fh5", "fh7"], "image/x-icon": ["ico"], "image/x-mrsid-image": ["sid"], "image/x-pcx": ["pcx"], "image/x-pict": ["pic", "pct"], "image/x-portable-anymap": ["pnm"], "image/x-portable-bitmap": ["pbm"], "image/x-portable-graymap": ["pgm"], "image/x-portable-pixmap": ["ppm"], "image/x-rgb": ["rgb"], "image/x-tga": ["tga"], "image/x-xbitmap": ["xbm"], "image/x-xpixmap": ["xpm"], "image/x-xwindowdump": ["xwd"], "message/rfc822": ["eml", "mime"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/vnd.collada+xml": ["dae"], "model/vnd.dwf": ["dwf"], "model/vnd.gdl": ["gdl"], "model/vnd.gtw": ["gtw"], "model/vnd.mts": ["mts"], "model/vnd.vtu": ["vtu"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["x3db", "x3dbz"], "model/x3d+vrml": ["x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee"], "text/css": ["css"], "text/csv": ["csv"], "text/hjson": ["hjson"], "text/html": ["html", "htm"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/prs.lines.tag": ["dsc"], "text/richtext": ["rtx"], "text/sgml": ["sgml", "sgm"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vnd.curl": ["curl"], "text/vnd.curl.dcurl": ["dcurl"], "text/vnd.curl.mcurl": ["mcurl"], "text/vnd.curl.scurl": ["scurl"], "text/vnd.dvb.subtitle": ["sub"], "text/vnd.fly": ["fly"], "text/vnd.fmi.flexstor": ["flx"], "text/vnd.graphviz": ["gv"], "text/vnd.in3d.3dml": ["3dml"], "text/vnd.in3d.spot": ["spot"], "text/vnd.sun.j2me.app-descriptor": ["jad"], "text/vnd.wap.wml": ["wml"], "text/vnd.wap.wmlscript": ["wmls"], "text/vtt": ["vtt"], "text/x-asm": ["s", "asm"], "text/x-c": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"], "text/x-component": ["htc"], "text/x-fortran": ["f", "for", "f77", "f90"], "text/x-handlebars-template": ["hbs"], "text/x-java-source": ["java"], "text/x-lua": ["lua"], "text/x-markdown": ["markdown", "md", "mkd"], "text/x-nfo": ["nfo"], "text/x-opml": ["opml"], "text/x-pascal": ["p", "pas"], "text/x-sass": ["sass"], "text/x-scss": ["scss"], "text/x-setext": ["etx"], "text/x-sfv": ["sfv"], "text/x-uuencode": ["uu"], "text/x-vcalendar": ["vcs"], "text/x-vcard": ["vcf"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/jpeg": ["jpgv"], "video/jpm": ["jpm", "jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/vnd.dece.hd": ["uvh", "uvvh"], "video/vnd.dece.mobile": ["uvm", "uvvm"], "video/vnd.dece.pd": ["uvp", "uvvp"], "video/vnd.dece.sd": ["uvs", "uvvs"], "video/vnd.dece.video": ["uvv", "uvvv"], "video/vnd.dvb.file": ["dvb"], "video/vnd.fvt": ["fvt"], "video/vnd.mpegurl": ["mxu", "m4u"], "video/vnd.ms-playready.media.pyv": ["pyv"], "video/vnd.uvvu.mp4": ["uvu", "uvvu"], "video/vnd.vivo": ["viv"], "video/webm": ["webm"], "video/x-f4v": ["f4v"], "video/x-fli": ["fli"], "video/x-flv": ["flv"], "video/x-m4v": ["m4v"], "video/x-matroska": ["mkv", "mk3d", "mks"], "video/x-mng": ["mng"], "video/x-ms-asf": ["asf", "asx"], "video/x-ms-vob": ["vob"], "video/x-ms-wm": ["wm"], "video/x-ms-wmv": ["wmv"], "video/x-ms-wmx": ["wmx"], "video/x-ms-wvx": ["wvx"], "video/x-msvideo": ["avi"], "video/x-sgi-movie": ["movie"], "video/x-smv": ["smv"], "x-conference/x-cooltalk": ["ice"] };
  return module.exports;
});
$__System.registerDynamic('4d', ['9', '7', '4c', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    var path = $__require('9');
    var fs = $__require('7');
    function Mime() {
      this.types = Object.create(null);
      this.extensions = Object.create(null);
    }
    Mime.prototype.define = function (map) {
      for (var type in map) {
        var exts = map[type];
        for (var i = 0; i < exts.length; i++) {
          if (process.env.DEBUG_MIME && this.types[exts]) {
            console.warn(this._loading.replace(/.*\//, ''), 'changes "' + exts[i] + '" extension type from ' + this.types[exts] + ' to ' + type);
          }
          this.types[exts[i]] = type;
        }
        if (!this.extensions[type]) {
          this.extensions[type] = exts[0];
        }
      }
    };
    Mime.prototype.load = function (file) {
      this._loading = file;
      var map = {},
          content = fs.readFileSync(file, 'ascii'),
          lines = content.split(/[\r\n]+/);
      lines.forEach(function (line) {
        var fields = line.replace(/\s*#.*|^\s*|\s*$/g, '').split(/\s+/);
        map[fields.shift()] = fields;
      });
      this.define(map);
      this._loading = null;
    };
    Mime.prototype.lookup = function (path, fallback) {
      var ext = path.replace(/.*[\.\/\\]/, '').toLowerCase();
      return this.types[ext] || fallback || this.default_type;
    };
    Mime.prototype.extension = function (mimeType) {
      var type = mimeType.match(/^\s*([^;\s]*)(?:;|\s|$)/)[1].toLowerCase();
      return this.extensions[type];
    };
    var mime = new Mime();
    mime.define($__require('4c'));
    mime.default_type = mime.lookup('bin');
    mime.Mime = Mime;
    mime.charsets = { lookup: function (mimeType, fallback) {
        return (/^text\//.test(mimeType) ? 'UTF-8' : fallback
        );
      } };
    module.exports = mime;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic("4e", ["4d"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("4d");
  return module.exports;
});
$__System.registerDynamic('4f', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;

  /**
   * Expose `fresh()`.
   */

  module.exports = fresh;

  /**
   * Check freshness of `req` and `res` headers.
   *
   * When the cache is "fresh" __true__ is returned,
   * otherwise __false__ is returned to indicate that
   * the cache is now stale.
   *
   * @param {Object} req
   * @param {Object} res
   * @return {Boolean}
   * @api public
   */

  function fresh(req, res) {
    // defaults
    var etagMatches = true;
    var notModified = true;

    // fields
    var modifiedSince = req['if-modified-since'];
    var noneMatch = req['if-none-match'];
    var lastModified = res['last-modified'];
    var etag = res['etag'];
    var cc = req['cache-control'];

    // unconditional request
    if (!modifiedSince && !noneMatch) return false;

    // check for no-cache cache request directive
    if (cc && cc.indexOf('no-cache') !== -1) return false;

    // parse if-none-match
    if (noneMatch) noneMatch = noneMatch.split(/ *, */);

    // if-none-match
    if (noneMatch) {
      etagMatches = noneMatch.some(function (match) {
        return match === '*' || match === etag || match === 'W/' + etag;
      });
    }

    // if-modified-since
    if (modifiedSince) {
      modifiedSince = new Date(modifiedSince);
      lastModified = new Date(lastModified);
      notModified = lastModified <= modifiedSince;
    }

    return !!(etagMatches && notModified);
  }
  return module.exports;
});
$__System.registerDynamic("24", ["4f"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("4f");
  return module.exports;
});
$__System.registerDynamic('50', ['38', '7', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    'use strict';

    module.exports = etag;
    var crypto = $__require('38');
    var Stats = $__require('7').Stats;
    var base64PadCharRegExp = /=+$/;
    var toString = Object.prototype.toString;
    function entitytag(entity) {
      if (entity.length === 0) {
        return '"0-1B2M2Y8AsgTpgAmY7PhCfg"';
      }
      var hash = crypto.createHash('md5').update(entity, 'utf8').digest('base64').replace(base64PadCharRegExp, '');
      var len = typeof entity === 'string' ? Buffer.byteLength(entity, 'utf8') : entity.length;
      return '"' + len.toString(16) + '-' + hash + '"';
    }
    function etag(entity, options) {
      if (entity == null) {
        throw new TypeError('argument entity is required');
      }
      var isStats = isstats(entity);
      var weak = options && typeof options.weak === 'boolean' ? options.weak : isStats;
      if (!isStats && typeof entity !== 'string' && !Buffer.isBuffer(entity)) {
        throw new TypeError('argument entity must be string, Buffer, or fs.Stats');
      }
      var tag = isStats ? stattag(entity) : entitytag(entity);
      return weak ? 'W/' + tag : tag;
    }
    function isstats(obj) {
      if (typeof Stats === 'function' && obj instanceof Stats) {
        return true;
      }
      return obj && typeof obj === 'object' && 'ctime' in obj && toString.call(obj.ctime) === '[object Date]' && 'mtime' in obj && toString.call(obj.mtime) === '[object Date]' && 'ino' in obj && typeof obj.ino === 'number' && 'size' in obj && typeof obj.size === 'number';
    }
    function stattag(stat) {
      var mtime = stat.mtime.getTime().toString(16);
      var size = stat.size.toString(16);
      return '"' + size + '-' + mtime + '"';
    }
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic("35", ["50"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("50");
  return module.exports;
});
$__System.registerDynamic("51", [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = { "100": "Continue", "101": "Switching Protocols", "102": "Processing", "200": "OK", "201": "Created", "202": "Accepted", "203": "Non-Authoritative Information", "204": "No Content", "205": "Reset Content", "206": "Partial Content", "207": "Multi-Status", "208": "Already Reported", "226": "IM Used", "300": "Multiple Choices", "301": "Moved Permanently", "302": "Found", "303": "See Other", "304": "Not Modified", "305": "Use Proxy", "306": "(Unused)", "307": "Temporary Redirect", "308": "Permanent Redirect", "400": "Bad Request", "401": "Unauthorized", "402": "Payment Required", "403": "Forbidden", "404": "Not Found", "405": "Method Not Allowed", "406": "Not Acceptable", "407": "Proxy Authentication Required", "408": "Request Timeout", "409": "Conflict", "410": "Gone", "411": "Length Required", "412": "Precondition Failed", "413": "Payload Too Large", "414": "URI Too Long", "415": "Unsupported Media Type", "416": "Range Not Satisfiable", "417": "Expectation Failed", "418": "I'm a teapot", "422": "Unprocessable Entity", "423": "Locked", "424": "Failed Dependency", "425": "Unordered Collection", "426": "Upgrade Required", "428": "Precondition Required", "429": "Too Many Requests", "431": "Request Header Fields Too Large", "451": "Unavailable For Legal Reasons", "500": "Internal Server Error", "501": "Not Implemented", "502": "Bad Gateway", "503": "Service Unavailable", "504": "Gateway Timeout", "505": "HTTP Version Not Supported", "506": "Variant Also Negotiates", "507": "Insufficient Storage", "508": "Loop Detected", "509": "Bandwidth Limit Exceeded", "510": "Not Extended", "511": "Network Authentication Required" };
  return module.exports;
});
$__System.registerDynamic('52', ['51'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var codes = $__require('51');
  module.exports = status;
  status.codes = Object.keys(codes).map(function (code) {
    code = ~~code;
    var msg = codes[code];
    status[code] = msg;
    status[msg] = status[msg.toLowerCase()] = code;
    return code;
  });
  status.redirect = {
    300: true,
    301: true,
    302: true,
    303: true,
    305: true,
    307: true,
    308: true
  };
  status.empty = {
    204: true,
    205: true,
    304: true
  };
  status.retry = {
    502: true,
    503: true,
    504: true
  };
  function status(code) {
    if (typeof code === 'number') {
      if (!status[code]) throw new Error('invalid status code: ' + code);
      return code;
    }
    if (typeof code !== 'string') {
      throw new TypeError('code must be a number or string');
    }
    var n = parseInt(code, 10);
    if (!isNaN(n)) {
      if (!status[n]) throw new Error('invalid status code: ' + n);
      return n;
    }
    n = status[code.toLowerCase()];
    if (!n) throw new Error('invalid status message: "' + code + '"');
    return n;
  }
  return module.exports;
});
$__System.registerDynamic("45", ["52"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("52");
  return module.exports;
});
$__System.registerDynamic('53', ['47', '8', '12', '4a', '3d', '25', '49', '4e', '24', '9', '7', '35', '55', '54', '3f', '45', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    'use strict';

    var createError = $__require('47');
    var debug = $__require('8')('send');
    var deprecate = $__require('12')('send');
    var destroy = $__require('4a');
    var escapeHtml = $__require('3d'),
        parseRange = $__require('25'),
        Stream = $__require('49'),
        mime = $__require('4e'),
        fresh = $__require('24'),
        path = $__require('9'),
        fs = $__require('7'),
        normalize = path.normalize,
        join = path.join;
    var etag = $__require('35');
    var EventEmitter = $__require('55').EventEmitter;
    var ms = $__require('54');
    var onFinished = $__require('3f');
    var statuses = $__require('45');
    var extname = path.extname;
    var maxMaxAge = 60 * 60 * 24 * 365 * 1000;
    var resolve = path.resolve;
    var sep = path.sep;
    var toString = Object.prototype.toString;
    var upPathRegexp = /(?:^|[\\\/])\.\.(?:[\\\/]|$)/;
    module.exports = send;
    module.exports.mime = mime;
    var listenerCount = EventEmitter.listenerCount || function (emitter, type) {
      return emitter.listeners(type).length;
    };
    function send(req, path, options) {
      return new SendStream(req, path, options);
    }
    function SendStream(req, path, options) {
      var opts = options || {};
      this.options = opts;
      this.path = path;
      this.req = req;
      this._etag = opts.etag !== undefined ? Boolean(opts.etag) : true;
      this._dotfiles = opts.dotfiles !== undefined ? opts.dotfiles : 'ignore';
      if (this._dotfiles !== 'ignore' && this._dotfiles !== 'allow' && this._dotfiles !== 'deny') {
        throw new TypeError('dotfiles option must be "allow", "deny", or "ignore"');
      }
      this._hidden = Boolean(opts.hidden);
      if (opts.hidden !== undefined) {
        deprecate('hidden: use dotfiles: \'' + (this._hidden ? 'allow' : 'ignore') + '\' instead');
      }
      if (opts.dotfiles === undefined) {
        this._dotfiles = undefined;
      }
      this._extensions = opts.extensions !== undefined ? normalizeList(opts.extensions, 'extensions option') : [];
      this._index = opts.index !== undefined ? normalizeList(opts.index, 'index option') : ['index.html'];
      this._lastModified = opts.lastModified !== undefined ? Boolean(opts.lastModified) : true;
      this._maxage = opts.maxAge || opts.maxage;
      this._maxage = typeof this._maxage === 'string' ? ms(this._maxage) : Number(this._maxage);
      this._maxage = !isNaN(this._maxage) ? Math.min(Math.max(0, this._maxage), maxMaxAge) : 0;
      this._root = opts.root ? resolve(opts.root) : null;
      if (!this._root && opts.from) {
        this.from(opts.from);
      }
    }
    SendStream.prototype.__proto__ = Stream.prototype;
    SendStream.prototype.etag = deprecate.function(function etag(val) {
      val = Boolean(val);
      debug('etag %s', val);
      this._etag = val;
      return this;
    }, 'send.etag: pass etag as option');
    SendStream.prototype.hidden = deprecate.function(function hidden(val) {
      val = Boolean(val);
      debug('hidden %s', val);
      this._hidden = val;
      this._dotfiles = undefined;
      return this;
    }, 'send.hidden: use dotfiles option');
    SendStream.prototype.index = deprecate.function(function index(paths) {
      var index = !paths ? [] : normalizeList(paths, 'paths argument');
      debug('index %o', paths);
      this._index = index;
      return this;
    }, 'send.index: pass index as option');
    SendStream.prototype.root = function (path) {
      path = String(path);
      this._root = resolve(path);
      return this;
    };
    SendStream.prototype.from = deprecate.function(SendStream.prototype.root, 'send.from: pass root as option');
    SendStream.prototype.root = deprecate.function(SendStream.prototype.root, 'send.root: pass root as option');
    SendStream.prototype.maxage = deprecate.function(function maxage(maxAge) {
      maxAge = typeof maxAge === 'string' ? ms(maxAge) : Number(maxAge);
      if (isNaN(maxAge)) maxAge = 0;
      if (Infinity == maxAge) maxAge = 60 * 60 * 24 * 365 * 1000;
      debug('max-age %d', maxAge);
      this._maxage = maxAge;
      return this;
    }, 'send.maxage: pass maxAge as option');
    SendStream.prototype.error = function error(status, error) {
      if (listenerCount(this, 'error') !== 0) {
        return this.emit('error', createError(error, status, { expose: false }));
      }
      var res = this.res;
      var msg = statuses[status];
      res._headers = null;
      res.statusCode = status;
      res.setHeader('Content-Type', 'text/plain; charset=UTF-8');
      res.setHeader('Content-Length', Buffer.byteLength(msg));
      res.setHeader('X-Content-Type-Options', 'nosniff');
      res.end(msg);
    };
    SendStream.prototype.hasTrailingSlash = function () {
      return '/' == this.path[this.path.length - 1];
    };
    SendStream.prototype.isConditionalGET = function () {
      return this.req.headers['if-none-match'] || this.req.headers['if-modified-since'];
    };
    SendStream.prototype.removeContentHeaderFields = function removeContentHeaderFields() {
      var res = this.res;
      var headers = Object.keys(res._headers || {});
      for (var i = 0; i < headers.length; i++) {
        var header = headers[i];
        if (header.substr(0, 8) === 'content-' && header !== 'content-location') {
          res.removeHeader(header);
        }
      }
    };
    SendStream.prototype.notModified = function () {
      var res = this.res;
      debug('not modified');
      this.removeContentHeaderFields();
      res.statusCode = 304;
      res.end();
    };
    SendStream.prototype.headersAlreadySent = function headersAlreadySent() {
      var err = new Error('Can\'t set headers after they are sent.');
      debug('headers already sent');
      this.error(500, err);
    };
    SendStream.prototype.isCachable = function () {
      var res = this.res;
      return res.statusCode >= 200 && res.statusCode < 300 || 304 == res.statusCode;
    };
    SendStream.prototype.onStatError = function onStatError(error) {
      switch (error.code) {
        case 'ENAMETOOLONG':
        case 'ENOENT':
        case 'ENOTDIR':
          this.error(404, error);
          break;
        default:
          this.error(500, error);
          break;
      }
    };
    SendStream.prototype.isFresh = function () {
      return fresh(this.req.headers, this.res._headers);
    };
    SendStream.prototype.isRangeFresh = function isRangeFresh() {
      var ifRange = this.req.headers['if-range'];
      if (!ifRange) return true;
      return ~ifRange.indexOf('"') ? ~ifRange.indexOf(this.res._headers['etag']) : Date.parse(this.res._headers['last-modified']) <= Date.parse(ifRange);
    };
    SendStream.prototype.redirect = function redirect(path) {
      if (listenerCount(this, 'directory') !== 0) {
        this.emit('directory');
        return;
      }
      if (this.hasTrailingSlash()) {
        this.error(403);
        return;
      }
      var loc = path + '/';
      var msg = 'Redirecting to <a href="' + escapeHtml(loc) + '">' + escapeHtml(loc) + '</a>\n';
      var res = this.res;
      res.statusCode = 301;
      res.setHeader('Content-Type', 'text/html; charset=UTF-8');
      res.setHeader('Content-Length', Buffer.byteLength(msg));
      res.setHeader('X-Content-Type-Options', 'nosniff');
      res.setHeader('Location', loc);
      res.end(msg);
    };
    SendStream.prototype.pipe = function (res) {
      var self = this,
          args = arguments,
          root = this._root;
      this.res = res;
      var path = decode(this.path);
      if (path === -1) return this.error(400);
      if (~path.indexOf('\0')) return this.error(400);
      var parts;
      if (root !== null) {
        if (upPathRegexp.test(normalize('.' + sep + path))) {
          debug('malicious path "%s"', path);
          return this.error(403);
        }
        path = normalize(join(root, path));
        root = normalize(root + sep);
        parts = path.substr(root.length).split(sep);
      } else {
        if (upPathRegexp.test(path)) {
          debug('malicious path "%s"', path);
          return this.error(403);
        }
        parts = normalize(path).split(sep);
        path = resolve(path);
      }
      if (containsDotFile(parts)) {
        var access = this._dotfiles;
        if (access === undefined) {
          access = parts[parts.length - 1][0] === '.' ? this._hidden ? 'allow' : 'ignore' : 'allow';
        }
        debug('%s dotfile "%s"', access, path);
        switch (access) {
          case 'allow':
            break;
          case 'deny':
            return this.error(403);
          case 'ignore':
          default:
            return this.error(404);
        }
      }
      if (this._index.length && this.path[this.path.length - 1] === '/') {
        this.sendIndex(path);
        return res;
      }
      this.sendFile(path);
      return res;
    };
    SendStream.prototype.send = function (path, stat) {
      var len = stat.size;
      var options = this.options;
      var opts = {};
      var res = this.res;
      var req = this.req;
      var ranges = req.headers.range;
      var offset = options.start || 0;
      if (res._header) {
        return this.headersAlreadySent();
      }
      debug('pipe "%s"', path);
      this.setHeader(path, stat);
      this.type(path);
      if (this.isConditionalGET() && this.isCachable() && this.isFresh()) {
        return this.notModified();
      }
      len = Math.max(0, len - offset);
      if (options.end !== undefined) {
        var bytes = options.end - offset + 1;
        if (len > bytes) len = bytes;
      }
      if (ranges) {
        ranges = parseRange(len, ranges);
        if (!this.isRangeFresh()) {
          debug('range stale');
          ranges = -2;
        }
        if (-1 == ranges) {
          debug('range unsatisfiable');
          res.setHeader('Content-Range', 'bytes */' + stat.size);
          return this.error(416);
        }
        if (-2 != ranges && ranges.length === 1) {
          debug('range %j', ranges);
          res.statusCode = 206;
          res.setHeader('Content-Range', 'bytes ' + ranges[0].start + '-' + ranges[0].end + '/' + len);
          offset += ranges[0].start;
          len = ranges[0].end - ranges[0].start + 1;
        }
      }
      for (var prop in options) {
        opts[prop] = options[prop];
      }
      opts.start = offset;
      opts.end = Math.max(offset, offset + len - 1);
      res.setHeader('Content-Length', len);
      if ('HEAD' == req.method) return res.end();
      this.stream(path, opts);
    };
    SendStream.prototype.sendFile = function sendFile(path) {
      var i = 0;
      var self = this;
      debug('stat "%s"', path);
      fs.stat(path, function onstat(err, stat) {
        if (err && err.code === 'ENOENT' && !extname(path) && path[path.length - 1] !== sep) {
          return next(err);
        }
        if (err) return self.onStatError(err);
        if (stat.isDirectory()) return self.redirect(self.path);
        self.emit('file', path, stat);
        self.send(path, stat);
      });
      function next(err) {
        if (self._extensions.length <= i) {
          return err ? self.onStatError(err) : self.error(404);
        }
        var p = path + '.' + self._extensions[i++];
        debug('stat "%s"', p);
        fs.stat(p, function (err, stat) {
          if (err) return next(err);
          if (stat.isDirectory()) return next();
          self.emit('file', p, stat);
          self.send(p, stat);
        });
      }
    };
    SendStream.prototype.sendIndex = function sendIndex(path) {
      var i = -1;
      var self = this;
      function next(err) {
        if (++i >= self._index.length) {
          if (err) return self.onStatError(err);
          return self.error(404);
        }
        var p = join(path, self._index[i]);
        debug('stat "%s"', p);
        fs.stat(p, function (err, stat) {
          if (err) return next(err);
          if (stat.isDirectory()) return next();
          self.emit('file', p, stat);
          self.send(p, stat);
        });
      }
      next();
    };
    SendStream.prototype.stream = function (path, options) {
      var finished = false;
      var self = this;
      var res = this.res;
      var req = this.req;
      var stream = fs.createReadStream(path, options);
      this.emit('stream', stream);
      stream.pipe(res);
      onFinished(res, function onfinished() {
        finished = true;
        destroy(stream);
      });
      stream.on('error', function onerror(err) {
        if (finished) return;
        finished = true;
        destroy(stream);
        self.onStatError(err);
      });
      stream.on('end', function onend() {
        self.emit('end');
      });
    };
    SendStream.prototype.type = function (path) {
      var res = this.res;
      if (res.getHeader('Content-Type')) return;
      var type = mime.lookup(path);
      var charset = mime.charsets.lookup(type);
      debug('content-type %s', type);
      res.setHeader('Content-Type', type + (charset ? '; charset=' + charset : ''));
    };
    SendStream.prototype.setHeader = function setHeader(path, stat) {
      var res = this.res;
      this.emit('headers', res, path, stat);
      if (!res.getHeader('Accept-Ranges')) res.setHeader('Accept-Ranges', 'bytes');
      if (!res.getHeader('Cache-Control')) res.setHeader('Cache-Control', 'public, max-age=' + Math.floor(this._maxage / 1000));
      if (this._lastModified && !res.getHeader('Last-Modified')) {
        var modified = stat.mtime.toUTCString();
        debug('modified %s', modified);
        res.setHeader('Last-Modified', modified);
      }
      if (this._etag && !res.getHeader('ETag')) {
        var val = etag(stat);
        debug('etag %s', val);
        res.setHeader('ETag', val);
      }
    };
    function containsDotFile(parts) {
      for (var i = 0; i < parts.length; i++) {
        if (parts[i][0] === '.') {
          return true;
        }
      }
      return false;
    }
    function decode(path) {
      try {
        return decodeURIComponent(path);
      } catch (err) {
        return -1;
      }
    }
    function normalizeList(val, name) {
      var list = [].concat(val || []);
      for (var i = 0; i < list.length; i++) {
        if (typeof list[i] !== 'string') {
          throw new TypeError(name + ' must be array of strings or false');
        }
      }
      return list;
    }
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic("34", ["53"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("53");
  return module.exports;
});
$__System.registerDynamic('56', ['3d', '19', '9', '34', '57', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    'use strict';

    var escapeHtml = $__require('3d');
    var parseUrl = $__require('19');
    var resolve = $__require('9').resolve;
    var send = $__require('34');
    var url = $__require('57');
    module.exports = serveStatic;
    module.exports.mime = send.mime;
    function serveStatic(root, options) {
      if (!root) {
        throw new TypeError('root path required');
      }
      if (typeof root !== 'string') {
        throw new TypeError('root path must be a string');
      }
      var opts = Object.create(options || null);
      var fallthrough = opts.fallthrough !== false;
      var redirect = opts.redirect !== false;
      var setHeaders = opts.setHeaders;
      if (setHeaders && typeof setHeaders !== 'function') {
        throw new TypeError('option setHeaders must be function');
      }
      opts.maxage = opts.maxage || opts.maxAge || 0;
      opts.root = resolve(root);
      var onDirectory = redirect ? createRedirectDirectoryListener() : createNotFoundDirectoryListener();
      return function serveStatic(req, res, next) {
        if (req.method !== 'GET' && req.method !== 'HEAD') {
          if (fallthrough) {
            return next();
          }
          res.statusCode = 405;
          res.setHeader('Allow', 'GET, HEAD');
          res.setHeader('Content-Length', '0');
          res.end();
          return;
        }
        var forwardError = !fallthrough;
        var originalUrl = parseUrl.original(req);
        var path = parseUrl(req).pathname;
        if (path === '/' && originalUrl.pathname.substr(-1) !== '/') {
          path = '';
        }
        var stream = send(req, path, opts);
        stream.on('directory', onDirectory);
        if (setHeaders) {
          stream.on('headers', setHeaders);
        }
        if (fallthrough) {
          stream.on('file', function onFile() {
            forwardError = true;
          });
        }
        stream.on('error', function error(err) {
          if (forwardError || !(err.statusCode < 500)) {
            next(err);
            return;
          }
          next();
        });
        stream.pipe(res);
      };
    }
    function collapseLeadingSlashes(str) {
      for (var i = 0; i < str.length; i++) {
        if (str[i] !== '/') {
          break;
        }
      }
      return i > 1 ? '/' + str.substr(i) : str;
    }
    function createNotFoundDirectoryListener() {
      return function notFound() {
        this.error(404);
      };
    }
    function createRedirectDirectoryListener() {
      return function redirect() {
        if (this.hasTrailingSlash()) {
          this.error(404);
          return;
        }
        var originalUrl = parseUrl.original(this.req);
        originalUrl.path = null;
        originalUrl.pathname = collapseLeadingSlashes(originalUrl.pathname + '/');
        var loc = url.format(originalUrl);
        var msg = 'Redirecting to <a href="' + escapeHtml(loc) + '">' + escapeHtml(loc) + '</a>\n';
        var res = this.res;
        res.statusCode = 303;
        res.setHeader('Content-Type', 'text/html; charset=UTF-8');
        res.setHeader('Content-Length', Buffer.byteLength(msg));
        res.setHeader('X-Content-Type-Options', 'nosniff');
        res.setHeader('Location', loc);
        res.end(msg);
      };
    }
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic("58", ["56"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("56");
  return module.exports;
});
$__System.registerDynamic('59', ['55', '3', 'a', '14', 'b', '23', '3c', 'c', '58'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var EventEmitter = $__require('55').EventEmitter;
  var mixin = $__require('3');
  var proto = $__require('a');
  var Route = $__require('14');
  var Router = $__require('b');
  var req = $__require('23');
  var res = $__require('3c');
  exports = module.exports = createApplication;
  function createApplication() {
    var app = function (req, res, next) {
      app.handle(req, res, next);
    };
    mixin(app, EventEmitter.prototype, false);
    mixin(app, proto, false);
    app.request = {
      __proto__: req,
      app: app
    };
    app.response = {
      __proto__: res,
      app: app
    };
    app.init();
    return app;
  }
  exports.application = proto;
  exports.request = req;
  exports.response = res;
  exports.Route = Route;
  exports.Router = Router;
  exports.query = $__require('c');
  exports.static = $__require('58');
  ['json', 'urlencoded', 'bodyParser', 'compress', 'cookieSession', 'session', 'logger', 'cookieParser', 'favicon', 'responseTime', 'errorHandler', 'timeout', 'methodOverride', 'vhost', 'csrf', 'directory', 'limit', 'multipart', 'staticCache'].forEach(function (name) {
    Object.defineProperty(exports, name, {
      get: function () {
        throw new Error('Most middleware (like ' + name + ') is no longer bundled with Express and must be installed separately. Please see https://github.com/senchalabs/connect#middleware.');
      },
      configurable: true
    });
  });
  return module.exports;
});
$__System.registerDynamic('5a', ['59'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require('59');
  return module.exports;
});
$__System.registerDynamic("5b", ["5a"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("5a");
  return module.exports;
});
$__System.registerDynamic('5c', ['5d'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require('5d');
  return module.exports;
});
$__System.registerDynamic("5e", ["5c"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("5c");
  return module.exports;
});
$__System.registerDynamic('5f', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var ARIADOMPropertyConfig = {
    Properties: {
      // Global States and Properties
      'aria-current': 0, // state
      'aria-details': 0,
      'aria-disabled': 0, // state
      'aria-hidden': 0, // state
      'aria-invalid': 0, // state
      'aria-keyshortcuts': 0,
      'aria-label': 0,
      'aria-roledescription': 0,
      // Widget Attributes
      'aria-autocomplete': 0,
      'aria-checked': 0,
      'aria-expanded': 0,
      'aria-haspopup': 0,
      'aria-level': 0,
      'aria-modal': 0,
      'aria-multiline': 0,
      'aria-multiselectable': 0,
      'aria-orientation': 0,
      'aria-placeholder': 0,
      'aria-pressed': 0,
      'aria-readonly': 0,
      'aria-required': 0,
      'aria-selected': 0,
      'aria-sort': 0,
      'aria-valuemax': 0,
      'aria-valuemin': 0,
      'aria-valuenow': 0,
      'aria-valuetext': 0,
      // Live Region Attributes
      'aria-atomic': 0,
      'aria-busy': 0,
      'aria-live': 0,
      'aria-relevant': 0,
      // Drag-and-Drop Attributes
      'aria-dropeffect': 0,
      'aria-grabbed': 0,
      // Relationship Attributes
      'aria-activedescendant': 0,
      'aria-colcount': 0,
      'aria-colindex': 0,
      'aria-colspan': 0,
      'aria-controls': 0,
      'aria-describedby': 0,
      'aria-errormessage': 0,
      'aria-flowto': 0,
      'aria-labelledby': 0,
      'aria-owns': 0,
      'aria-posinset': 0,
      'aria-rowcount': 0,
      'aria-rowindex': 0,
      'aria-rowspan': 0,
      'aria-setsize': 0
    },
    DOMAttributeNames: {},
    DOMPropertyNames: {}
  };

  module.exports = ARIADOMPropertyConfig;
  return module.exports;
});
$__System.registerDynamic('60', ['63', '61', '62'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var _assign = $__require('63');
  var PooledClass = $__require('61');
  var getTextContentAccessor = $__require('62');
  function FallbackCompositionState(root) {
    this._root = root;
    this._startText = this.getText();
    this._fallbackText = null;
  }
  _assign(FallbackCompositionState.prototype, {
    destructor: function () {
      this._root = null;
      this._startText = null;
      this._fallbackText = null;
    },
    getText: function () {
      if ('value' in this._root) {
        return this._root.value;
      }
      return this._root[getTextContentAccessor()];
    },
    getData: function () {
      if (this._fallbackText) {
        return this._fallbackText;
      }
      var start;
      var startValue = this._startText;
      var startLength = startValue.length;
      var end;
      var endValue = this.getText();
      var endLength = endValue.length;
      for (start = 0; start < startLength; start++) {
        if (startValue[start] !== endValue[start]) {
          break;
        }
      }
      var minEnd = startLength - start;
      for (end = 1; end <= minEnd; end++) {
        if (startValue[startLength - end] !== endValue[endLength - end]) {
          break;
        }
      }
      var sliceTail = end > 1 ? 1 - end : undefined;
      this._fallbackText = endValue.slice(start, sliceTail);
      return this._fallbackText;
    }
  });
  PooledClass.addPoolingTo(FallbackCompositionState);
  module.exports = FallbackCompositionState;
  return module.exports;
});
$__System.registerDynamic('64', ['65'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var SyntheticEvent = $__require('65');
  var CompositionEventInterface = { data: null };
  function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);
  module.exports = SyntheticCompositionEvent;
  return module.exports;
});
$__System.registerDynamic('66', ['65'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var SyntheticEvent = $__require('65');
  var InputEventInterface = { data: null };
  function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);
  module.exports = SyntheticInputEvent;
  return module.exports;
});
$__System.registerDynamic('67', ['68', '69', '60', '64', '66'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var EventPropagators = $__require('68');
  var ExecutionEnvironment = $__require('69');
  var FallbackCompositionState = $__require('60');
  var SyntheticCompositionEvent = $__require('64');
  var SyntheticInputEvent = $__require('66');
  var END_KEYCODES = [9, 13, 27, 32];
  var START_KEYCODE = 229;
  var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;
  var documentMode = null;
  if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
    documentMode = document.documentMode;
  }
  var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();
  var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
  function isPresto() {
    var opera = window.opera;
    return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
  }
  var SPACEBAR_CODE = 32;
  var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
  var eventTypes = {
    beforeInput: {
      phasedRegistrationNames: {
        bubbled: 'onBeforeInput',
        captured: 'onBeforeInputCapture'
      },
      dependencies: ['topCompositionEnd', 'topKeyPress', 'topTextInput', 'topPaste']
    },
    compositionEnd: {
      phasedRegistrationNames: {
        bubbled: 'onCompositionEnd',
        captured: 'onCompositionEndCapture'
      },
      dependencies: ['topBlur', 'topCompositionEnd', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
    },
    compositionStart: {
      phasedRegistrationNames: {
        bubbled: 'onCompositionStart',
        captured: 'onCompositionStartCapture'
      },
      dependencies: ['topBlur', 'topCompositionStart', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
    },
    compositionUpdate: {
      phasedRegistrationNames: {
        bubbled: 'onCompositionUpdate',
        captured: 'onCompositionUpdateCapture'
      },
      dependencies: ['topBlur', 'topCompositionUpdate', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
    }
  };
  var hasSpaceKeypress = false;
  function isKeypressCommand(nativeEvent) {
    return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && !(nativeEvent.ctrlKey && nativeEvent.altKey);
  }
  function getCompositionEventType(topLevelType) {
    switch (topLevelType) {
      case 'topCompositionStart':
        return eventTypes.compositionStart;
      case 'topCompositionEnd':
        return eventTypes.compositionEnd;
      case 'topCompositionUpdate':
        return eventTypes.compositionUpdate;
    }
  }
  function isFallbackCompositionStart(topLevelType, nativeEvent) {
    return topLevelType === 'topKeyDown' && nativeEvent.keyCode === START_KEYCODE;
  }
  function isFallbackCompositionEnd(topLevelType, nativeEvent) {
    switch (topLevelType) {
      case 'topKeyUp':
        return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
      case 'topKeyDown':
        return nativeEvent.keyCode !== START_KEYCODE;
      case 'topKeyPress':
      case 'topMouseDown':
      case 'topBlur':
        return true;
      default:
        return false;
    }
  }
  function getDataFromCustomEvent(nativeEvent) {
    var detail = nativeEvent.detail;
    if (typeof detail === 'object' && 'data' in detail) {
      return detail.data;
    }
    return null;
  }
  var currentComposition = null;
  function extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var eventType;
    var fallbackData;
    if (canUseCompositionEvent) {
      eventType = getCompositionEventType(topLevelType);
    } else if (!currentComposition) {
      if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
        eventType = eventTypes.compositionStart;
      }
    } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
      eventType = eventTypes.compositionEnd;
    }
    if (!eventType) {
      return null;
    }
    if (useFallbackCompositionData) {
      if (!currentComposition && eventType === eventTypes.compositionStart) {
        currentComposition = FallbackCompositionState.getPooled(nativeEventTarget);
      } else if (eventType === eventTypes.compositionEnd) {
        if (currentComposition) {
          fallbackData = currentComposition.getData();
        }
      }
    }
    var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);
    if (fallbackData) {
      event.data = fallbackData;
    } else {
      var customData = getDataFromCustomEvent(nativeEvent);
      if (customData !== null) {
        event.data = customData;
      }
    }
    EventPropagators.accumulateTwoPhaseDispatches(event);
    return event;
  }
  function getNativeBeforeInputChars(topLevelType, nativeEvent) {
    switch (topLevelType) {
      case 'topCompositionEnd':
        return getDataFromCustomEvent(nativeEvent);
      case 'topKeyPress':
        var which = nativeEvent.which;
        if (which !== SPACEBAR_CODE) {
          return null;
        }
        hasSpaceKeypress = true;
        return SPACEBAR_CHAR;
      case 'topTextInput':
        var chars = nativeEvent.data;
        if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
          return null;
        }
        return chars;
      default:
        return null;
    }
  }
  function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
    if (currentComposition) {
      if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {
        var chars = currentComposition.getData();
        FallbackCompositionState.release(currentComposition);
        currentComposition = null;
        return chars;
      }
      return null;
    }
    switch (topLevelType) {
      case 'topPaste':
        return null;
      case 'topKeyPress':
        if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
          return String.fromCharCode(nativeEvent.which);
        }
        return null;
      case 'topCompositionEnd':
        return useFallbackCompositionData ? null : nativeEvent.data;
      default:
        return null;
    }
  }
  function extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var chars;
    if (canUseTextInputEvent) {
      chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
    } else {
      chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
    }
    if (!chars) {
      return null;
    }
    var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);
    event.data = chars;
    EventPropagators.accumulateTwoPhaseDispatches(event);
    return event;
  }
  var BeforeInputEventPlugin = {
    eventTypes: eventTypes,
    extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
      return [extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget)];
    }
  };
  module.exports = BeforeInputEventPlugin;
  return module.exports;
});
$__System.registerDynamic('6a', ['6b', '68', '69', '6c', '6d', '65', '6e', '6f', '70', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var EventPluginHub = $__require('6b');
    var EventPropagators = $__require('68');
    var ExecutionEnvironment = $__require('69');
    var ReactDOMComponentTree = $__require('6c');
    var ReactUpdates = $__require('6d');
    var SyntheticEvent = $__require('65');
    var getEventTarget = $__require('6e');
    var isEventSupported = $__require('6f');
    var isTextInputElement = $__require('70');
    var eventTypes = { change: {
        phasedRegistrationNames: {
          bubbled: 'onChange',
          captured: 'onChangeCapture'
        },
        dependencies: ['topBlur', 'topChange', 'topClick', 'topFocus', 'topInput', 'topKeyDown', 'topKeyUp', 'topSelectionChange']
      } };
    var activeElement = null;
    var activeElementInst = null;
    var activeElementValue = null;
    var activeElementValueProp = null;
    function shouldUseChangeEvent(elem) {
      var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
      return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
    }
    var doesChangeEventBubble = false;
    if (ExecutionEnvironment.canUseDOM) {
      doesChangeEventBubble = isEventSupported('change') && (!document.documentMode || document.documentMode > 8);
    }
    function manualDispatchChangeEvent(nativeEvent) {
      var event = SyntheticEvent.getPooled(eventTypes.change, activeElementInst, nativeEvent, getEventTarget(nativeEvent));
      EventPropagators.accumulateTwoPhaseDispatches(event);
      ReactUpdates.batchedUpdates(runEventInBatch, event);
    }
    function runEventInBatch(event) {
      EventPluginHub.enqueueEvents(event);
      EventPluginHub.processEventQueue(false);
    }
    function startWatchingForChangeEventIE8(target, targetInst) {
      activeElement = target;
      activeElementInst = targetInst;
      activeElement.attachEvent('onchange', manualDispatchChangeEvent);
    }
    function stopWatchingForChangeEventIE8() {
      if (!activeElement) {
        return;
      }
      activeElement.detachEvent('onchange', manualDispatchChangeEvent);
      activeElement = null;
      activeElementInst = null;
    }
    function getTargetInstForChangeEvent(topLevelType, targetInst) {
      if (topLevelType === 'topChange') {
        return targetInst;
      }
    }
    function handleEventsForChangeEventIE8(topLevelType, target, targetInst) {
      if (topLevelType === 'topFocus') {
        stopWatchingForChangeEventIE8();
        startWatchingForChangeEventIE8(target, targetInst);
      } else if (topLevelType === 'topBlur') {
        stopWatchingForChangeEventIE8();
      }
    }
    var isInputEventSupported = false;
    if (ExecutionEnvironment.canUseDOM) {
      isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 11);
    }
    var newValueProp = {
      get: function () {
        return activeElementValueProp.get.call(this);
      },
      set: function (val) {
        activeElementValue = '' + val;
        activeElementValueProp.set.call(this, val);
      }
    };
    function startWatchingForValueChange(target, targetInst) {
      activeElement = target;
      activeElementInst = targetInst;
      activeElementValue = target.value;
      activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');
      Object.defineProperty(activeElement, 'value', newValueProp);
      if (activeElement.attachEvent) {
        activeElement.attachEvent('onpropertychange', handlePropertyChange);
      } else {
        activeElement.addEventListener('propertychange', handlePropertyChange, false);
      }
    }
    function stopWatchingForValueChange() {
      if (!activeElement) {
        return;
      }
      delete activeElement.value;
      if (activeElement.detachEvent) {
        activeElement.detachEvent('onpropertychange', handlePropertyChange);
      } else {
        activeElement.removeEventListener('propertychange', handlePropertyChange, false);
      }
      activeElement = null;
      activeElementInst = null;
      activeElementValue = null;
      activeElementValueProp = null;
    }
    function handlePropertyChange(nativeEvent) {
      if (nativeEvent.propertyName !== 'value') {
        return;
      }
      var value = nativeEvent.srcElement.value;
      if (value === activeElementValue) {
        return;
      }
      activeElementValue = value;
      manualDispatchChangeEvent(nativeEvent);
    }
    function getTargetInstForInputEvent(topLevelType, targetInst) {
      if (topLevelType === 'topInput') {
        return targetInst;
      }
    }
    function handleEventsForInputEventIE(topLevelType, target, targetInst) {
      if (topLevelType === 'topFocus') {
        stopWatchingForValueChange();
        startWatchingForValueChange(target, targetInst);
      } else if (topLevelType === 'topBlur') {
        stopWatchingForValueChange();
      }
    }
    function getTargetInstForInputEventIE(topLevelType, targetInst) {
      if (topLevelType === 'topSelectionChange' || topLevelType === 'topKeyUp' || topLevelType === 'topKeyDown') {
        if (activeElement && activeElement.value !== activeElementValue) {
          activeElementValue = activeElement.value;
          return activeElementInst;
        }
      }
    }
    function shouldUseClickEvent(elem) {
      return elem.nodeName && elem.nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
    }
    function getTargetInstForClickEvent(topLevelType, targetInst) {
      if (topLevelType === 'topClick') {
        return targetInst;
      }
    }
    var ChangeEventPlugin = {
      eventTypes: eventTypes,
      extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
        var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;
        var getTargetInstFunc, handleEventFunc;
        if (shouldUseChangeEvent(targetNode)) {
          if (doesChangeEventBubble) {
            getTargetInstFunc = getTargetInstForChangeEvent;
          } else {
            handleEventFunc = handleEventsForChangeEventIE8;
          }
        } else if (isTextInputElement(targetNode)) {
          if (isInputEventSupported) {
            getTargetInstFunc = getTargetInstForInputEvent;
          } else {
            getTargetInstFunc = getTargetInstForInputEventIE;
            handleEventFunc = handleEventsForInputEventIE;
          }
        } else if (shouldUseClickEvent(targetNode)) {
          getTargetInstFunc = getTargetInstForClickEvent;
        }
        if (getTargetInstFunc) {
          var inst = getTargetInstFunc(topLevelType, targetInst);
          if (inst) {
            var event = SyntheticEvent.getPooled(eventTypes.change, inst, nativeEvent, nativeEventTarget);
            event.type = 'change';
            EventPropagators.accumulateTwoPhaseDispatches(event);
            return event;
          }
        }
        if (handleEventFunc) {
          handleEventFunc(topLevelType, targetNode, targetInst);
        }
      }
    };
    module.exports = ChangeEventPlugin;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('71', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  /**
   * Module that is injectable into `EventPluginHub`, that specifies a
   * deterministic ordering of `EventPlugin`s. A convenient way to reason about
   * plugins, without having to package every one of them. This is better than
   * having plugins be ordered in the same order that they are injected because
   * that ordering would be influenced by the packaging order.
   * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
   * preventing default on events is convenient in `SimpleEventPlugin` handlers.
   */

  var define,
      global = this || self,
      GLOBAL = global;
  var DefaultEventPluginOrder = ['ResponderEventPlugin', 'SimpleEventPlugin', 'TapEventPlugin', 'EnterLeaveEventPlugin', 'ChangeEventPlugin', 'SelectEventPlugin', 'BeforeInputEventPlugin'];

  module.exports = DefaultEventPluginOrder;
  return module.exports;
});
$__System.registerDynamic('72', ['68', '6c', '73'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var EventPropagators = $__require('68');
  var ReactDOMComponentTree = $__require('6c');
  var SyntheticMouseEvent = $__require('73');
  var eventTypes = {
    mouseEnter: {
      registrationName: 'onMouseEnter',
      dependencies: ['topMouseOut', 'topMouseOver']
    },
    mouseLeave: {
      registrationName: 'onMouseLeave',
      dependencies: ['topMouseOut', 'topMouseOver']
    }
  };
  var EnterLeaveEventPlugin = {
    eventTypes: eventTypes,
    extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
      if (topLevelType === 'topMouseOver' && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
        return null;
      }
      if (topLevelType !== 'topMouseOut' && topLevelType !== 'topMouseOver') {
        return null;
      }
      var win;
      if (nativeEventTarget.window === nativeEventTarget) {
        win = nativeEventTarget;
      } else {
        var doc = nativeEventTarget.ownerDocument;
        if (doc) {
          win = doc.defaultView || doc.parentWindow;
        } else {
          win = window;
        }
      }
      var from;
      var to;
      if (topLevelType === 'topMouseOut') {
        from = targetInst;
        var related = nativeEvent.relatedTarget || nativeEvent.toElement;
        to = related ? ReactDOMComponentTree.getClosestInstanceFromNode(related) : null;
      } else {
        from = null;
        to = targetInst;
      }
      if (from === to) {
        return null;
      }
      var fromNode = from == null ? win : ReactDOMComponentTree.getNodeFromInstance(from);
      var toNode = to == null ? win : ReactDOMComponentTree.getNodeFromInstance(to);
      var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, from, nativeEvent, nativeEventTarget);
      leave.type = 'mouseleave';
      leave.target = fromNode;
      leave.relatedTarget = toNode;
      var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, to, nativeEvent, nativeEventTarget);
      enter.type = 'mouseenter';
      enter.target = toNode;
      enter.relatedTarget = fromNode;
      EventPropagators.accumulateEnterLeaveDispatches(leave, enter, from, to);
      return [leave, enter];
    }
  };
  module.exports = EnterLeaveEventPlugin;
  return module.exports;
});
$__System.registerDynamic('74', ['75'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var DOMProperty = $__require('75');
  var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
  var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
  var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
  var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
  var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;
  var HTMLDOMPropertyConfig = {
    isCustomAttribute: RegExp.prototype.test.bind(new RegExp('^(data|aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$')),
    Properties: {
      accept: 0,
      acceptCharset: 0,
      accessKey: 0,
      action: 0,
      allowFullScreen: HAS_BOOLEAN_VALUE,
      allowTransparency: 0,
      alt: 0,
      as: 0,
      async: HAS_BOOLEAN_VALUE,
      autoComplete: 0,
      autoPlay: HAS_BOOLEAN_VALUE,
      capture: HAS_BOOLEAN_VALUE,
      cellPadding: 0,
      cellSpacing: 0,
      charSet: 0,
      challenge: 0,
      checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      cite: 0,
      classID: 0,
      className: 0,
      cols: HAS_POSITIVE_NUMERIC_VALUE,
      colSpan: 0,
      content: 0,
      contentEditable: 0,
      contextMenu: 0,
      controls: HAS_BOOLEAN_VALUE,
      coords: 0,
      crossOrigin: 0,
      data: 0,
      dateTime: 0,
      'default': HAS_BOOLEAN_VALUE,
      defer: HAS_BOOLEAN_VALUE,
      dir: 0,
      disabled: HAS_BOOLEAN_VALUE,
      download: HAS_OVERLOADED_BOOLEAN_VALUE,
      draggable: 0,
      encType: 0,
      form: 0,
      formAction: 0,
      formEncType: 0,
      formMethod: 0,
      formNoValidate: HAS_BOOLEAN_VALUE,
      formTarget: 0,
      frameBorder: 0,
      headers: 0,
      height: 0,
      hidden: HAS_BOOLEAN_VALUE,
      high: 0,
      href: 0,
      hrefLang: 0,
      htmlFor: 0,
      httpEquiv: 0,
      icon: 0,
      id: 0,
      inputMode: 0,
      integrity: 0,
      is: 0,
      keyParams: 0,
      keyType: 0,
      kind: 0,
      label: 0,
      lang: 0,
      list: 0,
      loop: HAS_BOOLEAN_VALUE,
      low: 0,
      manifest: 0,
      marginHeight: 0,
      marginWidth: 0,
      max: 0,
      maxLength: 0,
      media: 0,
      mediaGroup: 0,
      method: 0,
      min: 0,
      minLength: 0,
      multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      name: 0,
      nonce: 0,
      noValidate: HAS_BOOLEAN_VALUE,
      open: HAS_BOOLEAN_VALUE,
      optimum: 0,
      pattern: 0,
      placeholder: 0,
      playsInline: HAS_BOOLEAN_VALUE,
      poster: 0,
      preload: 0,
      profile: 0,
      radioGroup: 0,
      readOnly: HAS_BOOLEAN_VALUE,
      referrerPolicy: 0,
      rel: 0,
      required: HAS_BOOLEAN_VALUE,
      reversed: HAS_BOOLEAN_VALUE,
      role: 0,
      rows: HAS_POSITIVE_NUMERIC_VALUE,
      rowSpan: HAS_NUMERIC_VALUE,
      sandbox: 0,
      scope: 0,
      scoped: HAS_BOOLEAN_VALUE,
      scrolling: 0,
      seamless: HAS_BOOLEAN_VALUE,
      selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      shape: 0,
      size: HAS_POSITIVE_NUMERIC_VALUE,
      sizes: 0,
      span: HAS_POSITIVE_NUMERIC_VALUE,
      spellCheck: 0,
      src: 0,
      srcDoc: 0,
      srcLang: 0,
      srcSet: 0,
      start: HAS_NUMERIC_VALUE,
      step: 0,
      style: 0,
      summary: 0,
      tabIndex: 0,
      target: 0,
      title: 0,
      type: 0,
      useMap: 0,
      value: 0,
      width: 0,
      wmode: 0,
      wrap: 0,
      about: 0,
      datatype: 0,
      inlist: 0,
      prefix: 0,
      property: 0,
      resource: 0,
      'typeof': 0,
      vocab: 0,
      autoCapitalize: 0,
      autoCorrect: 0,
      autoSave: 0,
      color: 0,
      itemProp: 0,
      itemScope: HAS_BOOLEAN_VALUE,
      itemType: 0,
      itemID: 0,
      itemRef: 0,
      results: 0,
      security: 0,
      unselectable: 0
    },
    DOMAttributeNames: {
      acceptCharset: 'accept-charset',
      className: 'class',
      htmlFor: 'for',
      httpEquiv: 'http-equiv'
    },
    DOMPropertyNames: {}
  };
  module.exports = HTMLDOMPropertyConfig;
  return module.exports;
});
$__System.registerDynamic('76', ['77', '6c', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var DOMChildrenOperations = $__require('77');
    var ReactDOMComponentTree = $__require('6c');
    var ReactDOMIDOperations = { dangerouslyProcessChildrenUpdates: function (parentInst, updates) {
        var node = ReactDOMComponentTree.getNodeFromInstance(parentInst);
        DOMChildrenOperations.processUpdates(node, updates);
      } };
    module.exports = ReactDOMIDOperations;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('78', ['77', '76', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var DOMChildrenOperations = $__require('77');
    var ReactDOMIDOperations = $__require('76');
    var ReactComponentBrowserEnvironment = {
      processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,
      replaceNodeWithMarkup: DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup
    };
    module.exports = ReactComponentBrowserEnvironment;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('79', ['6c', '7a'], true, function ($__require, exports, module) {
    /* */
    'use strict';

    var define,
        global = this || self,
        GLOBAL = global;
    var ReactDOMComponentTree = $__require('6c');
    var focusNode = $__require('7a');
    var AutoFocusUtils = { focusDOMComponent: function () {
            focusNode(ReactDOMComponentTree.getNodeFromInstance(this));
        } };
    module.exports = AutoFocusUtils;
    return module.exports;
});
$__System.registerDynamic("7b", [], true, function ($__require, exports, module) {
  /* */
  "use strict";

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @typechecks
   */

  var define,
      global = this || self,
      GLOBAL = global;
  var _hyphenPattern = /-(.)/g;

  /**
   * Camelcases a hyphenated string, for example:
   *
   *   > camelize('background-color')
   *   < "backgroundColor"
   *
   * @param {string} string
   * @return {string}
   */
  function camelize(string) {
    return string.replace(_hyphenPattern, function (_, character) {
      return character.toUpperCase();
    });
  }

  module.exports = camelize;
  return module.exports;
});
$__System.registerDynamic('7c', ['7b'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var camelize = $__require('7b');
  var msPattern = /^-ms-/;
  function camelizeStyleName(string) {
    return camelize(string.replace(msPattern, 'ms-'));
  }
  module.exports = camelizeStyleName;
  return module.exports;
});
$__System.registerDynamic('7d', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  /**
   * CSS properties which accept numbers but are not in units of "px".
   */

  var define,
      global = this || self,
      GLOBAL = global;
  var isUnitlessNumber = {
    animationIterationCount: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    gridRow: true,
    gridColumn: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,

    // SVG-related properties
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  };

  /**
   * @param {string} prefix vendor-specific prefix, eg: Webkit
   * @param {string} key style name, eg: transitionDuration
   * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
   * WebkitTransitionDuration
   */
  function prefixKey(prefix, key) {
    return prefix + key.charAt(0).toUpperCase() + key.substring(1);
  }

  /**
   * Support style names that may come passed in prefixed by adding permutations
   * of vendor prefixes.
   */
  var prefixes = ['Webkit', 'ms', 'Moz', 'O'];

  // Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
  // infinite loop, because it iterates over the newly added props too.
  Object.keys(isUnitlessNumber).forEach(function (prop) {
    prefixes.forEach(function (prefix) {
      isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
    });
  });

  /**
   * Most style properties can be unset by doing .style[prop] = '' but IE8
   * doesn't like doing that with shorthand properties so for the properties that
   * IE8 breaks on, which are listed here, we instead unset each of the
   * individual properties. See http://bugs.jquery.com/ticket/12385.
   * The 4-value 'clock' properties like margin, padding, border-width seem to
   * behave without any problems. Curiously, list-style works too without any
   * special prodding.
   */
  var shorthandPropertyExpansions = {
    background: {
      backgroundAttachment: true,
      backgroundColor: true,
      backgroundImage: true,
      backgroundPositionX: true,
      backgroundPositionY: true,
      backgroundRepeat: true
    },
    backgroundPosition: {
      backgroundPositionX: true,
      backgroundPositionY: true
    },
    border: {
      borderWidth: true,
      borderStyle: true,
      borderColor: true
    },
    borderBottom: {
      borderBottomWidth: true,
      borderBottomStyle: true,
      borderBottomColor: true
    },
    borderLeft: {
      borderLeftWidth: true,
      borderLeftStyle: true,
      borderLeftColor: true
    },
    borderRight: {
      borderRightWidth: true,
      borderRightStyle: true,
      borderRightColor: true
    },
    borderTop: {
      borderTopWidth: true,
      borderTopStyle: true,
      borderTopColor: true
    },
    font: {
      fontStyle: true,
      fontVariant: true,
      fontWeight: true,
      fontSize: true,
      lineHeight: true,
      fontFamily: true
    },
    outline: {
      outlineWidth: true,
      outlineStyle: true,
      outlineColor: true
    }
  };

  var CSSProperty = {
    isUnitlessNumber: isUnitlessNumber,
    shorthandPropertyExpansions: shorthandPropertyExpansions
  };

  module.exports = CSSProperty;
  return module.exports;
});
$__System.registerDynamic('7e', ['7d', '7f', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var CSSProperty = $__require('7d');
    var warning = $__require('7f');
    var isUnitlessNumber = CSSProperty.isUnitlessNumber;
    var styleWarnings = {};
    function dangerousStyleValue(name, value, component) {
      var isEmpty = value == null || typeof value === 'boolean' || value === '';
      if (isEmpty) {
        return '';
      }
      var isNonNumeric = isNaN(value);
      if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
        return '' + value;
      }
      if (typeof value === 'string') {
        if ('production' !== 'production') {
          if (component && value !== '0') {
            var owner = component._currentElement._owner;
            var ownerName = owner ? owner.getName() : null;
            if (ownerName && !styleWarnings[ownerName]) {
              styleWarnings[ownerName] = {};
            }
            var warned = false;
            if (ownerName) {
              var warnings = styleWarnings[ownerName];
              warned = warnings[name];
              if (!warned) {
                warnings[name] = true;
              }
            }
            if (!warned) {
              'production' !== 'production' ? warning(false, 'a `%s` tag (owner: `%s`) was passed a numeric string value ' + 'for CSS property `%s` (value: `%s`) which will be treated ' + 'as a unitless number in a future version of React.', component._currentElement.type, ownerName || 'unknown', name, value) : void 0;
            }
          }
        }
        value = value.trim();
      }
      return value + 'px';
    }
    module.exports = dangerousStyleValue;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('80', [], true, function ($__require, exports, module) {
  /* */
  'use strict';

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @typechecks
   */

  var define,
      global = this || self,
      GLOBAL = global;
  var _uppercasePattern = /([A-Z])/g;

  /**
   * Hyphenates a camelcased string, for example:
   *
   *   > hyphenate('backgroundColor')
   *   < "background-color"
   *
   * For CSS style names, use `hyphenateStyleName` instead which works properly
   * with all vendor prefixes, including `ms`.
   *
   * @param {string} string
   * @return {string}
   */
  function hyphenate(string) {
    return string.replace(_uppercasePattern, '-$1').toLowerCase();
  }

  module.exports = hyphenate;
  return module.exports;
});
$__System.registerDynamic('81', ['80'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var hyphenate = $__require('80');
  var msPattern = /^ms-/;
  function hyphenateStyleName(string) {
    return hyphenate(string).replace(msPattern, '-ms-');
  }
  module.exports = hyphenateStyleName;
  return module.exports;
});
$__System.registerDynamic('82', [], true, function ($__require, exports, module) {
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   * @typechecks static-only
   */

  'use strict';

  /**
   * Memoizes the return value of a function that accepts one string argument.
   */

  var define,
      global = this || self,
      GLOBAL = global;
  function memoizeStringOnly(callback) {
    var cache = {};
    return function (string) {
      if (!cache.hasOwnProperty(string)) {
        cache[string] = callback.call(this, string);
      }
      return cache[string];
    };
  }

  module.exports = memoizeStringOnly;
  return module.exports;
});
$__System.registerDynamic('83', ['7d', '69', '84', '7c', '7e', '81', '82', '7f', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var CSSProperty = $__require('7d');
    var ExecutionEnvironment = $__require('69');
    var ReactInstrumentation = $__require('84');
    var camelizeStyleName = $__require('7c');
    var dangerousStyleValue = $__require('7e');
    var hyphenateStyleName = $__require('81');
    var memoizeStringOnly = $__require('82');
    var warning = $__require('7f');
    var processStyleName = memoizeStringOnly(function (styleName) {
      return hyphenateStyleName(styleName);
    });
    var hasShorthandPropertyBug = false;
    var styleFloatAccessor = 'cssFloat';
    if (ExecutionEnvironment.canUseDOM) {
      var tempStyle = document.createElement('div').style;
      try {
        tempStyle.font = '';
      } catch (e) {
        hasShorthandPropertyBug = true;
      }
      if (document.documentElement.style.cssFloat === undefined) {
        styleFloatAccessor = 'styleFloat';
      }
    }
    if ('production' !== 'production') {
      var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
      var badStyleValueWithSemicolonPattern = /;\s*$/;
      var warnedStyleNames = {};
      var warnedStyleValues = {};
      var warnedForNaNValue = false;
      var warnHyphenatedStyleName = function (name, owner) {
        if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
          return;
        }
        warnedStyleNames[name] = true;
        'production' !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName(name), checkRenderMessage(owner)) : void 0;
      };
      var warnBadVendoredStyleName = function (name, owner) {
        if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
          return;
        }
        warnedStyleNames[name] = true;
        'production' !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), checkRenderMessage(owner)) : void 0;
      };
      var warnStyleValueWithSemicolon = function (name, value, owner) {
        if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
          return;
        }
        warnedStyleValues[value] = true;
        'production' !== 'production' ? warning(false, 'Style property values shouldn\'t contain a semicolon.%s ' + 'Try "%s: %s" instead.', checkRenderMessage(owner), name, value.replace(badStyleValueWithSemicolonPattern, '')) : void 0;
      };
      var warnStyleValueIsNaN = function (name, value, owner) {
        if (warnedForNaNValue) {
          return;
        }
        warnedForNaNValue = true;
        'production' !== 'production' ? warning(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, checkRenderMessage(owner)) : void 0;
      };
      var checkRenderMessage = function (owner) {
        if (owner) {
          var name = owner.getName();
          if (name) {
            return ' Check the render method of `' + name + '`.';
          }
        }
        return '';
      };
      var warnValidStyle = function (name, value, component) {
        var owner;
        if (component) {
          owner = component._currentElement._owner;
        }
        if (name.indexOf('-') > -1) {
          warnHyphenatedStyleName(name, owner);
        } else if (badVendoredStyleNamePattern.test(name)) {
          warnBadVendoredStyleName(name, owner);
        } else if (badStyleValueWithSemicolonPattern.test(value)) {
          warnStyleValueWithSemicolon(name, value, owner);
        }
        if (typeof value === 'number' && isNaN(value)) {
          warnStyleValueIsNaN(name, value, owner);
        }
      };
    }
    var CSSPropertyOperations = {
      createMarkupForStyles: function (styles, component) {
        var serialized = '';
        for (var styleName in styles) {
          if (!styles.hasOwnProperty(styleName)) {
            continue;
          }
          var styleValue = styles[styleName];
          if ('production' !== 'production') {
            warnValidStyle(styleName, styleValue, component);
          }
          if (styleValue != null) {
            serialized += processStyleName(styleName) + ':';
            serialized += dangerousStyleValue(styleName, styleValue, component) + ';';
          }
        }
        return serialized || null;
      },
      setValueForStyles: function (node, styles, component) {
        if ('production' !== 'production') {
          ReactInstrumentation.debugTool.onHostOperation({
            instanceID: component._debugID,
            type: 'update styles',
            payload: styles
          });
        }
        var style = node.style;
        for (var styleName in styles) {
          if (!styles.hasOwnProperty(styleName)) {
            continue;
          }
          if ('production' !== 'production') {
            warnValidStyle(styleName, styles[styleName], component);
          }
          var styleValue = dangerousStyleValue(styleName, styles[styleName], component);
          if (styleName === 'float' || styleName === 'cssFloat') {
            styleName = styleFloatAccessor;
          }
          if (styleValue) {
            style[styleName] = styleValue;
          } else {
            var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
            if (expansion) {
              for (var individualStyleName in expansion) {
                style[individualStyleName] = '';
              }
            } else {
              style[styleName] = '';
            }
          }
        }
      }
    };
    module.exports = CSSPropertyOperations;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('85', ['86'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var escapeTextContentForBrowser = $__require('86');
  function quoteAttributeValueForBrowser(value) {
    return '"' + escapeTextContentForBrowser(value) + '"';
  }
  module.exports = quoteAttributeValueForBrowser;
  return module.exports;
});
$__System.registerDynamic('87', ['75', '6c', '84', '85', '7f', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var DOMProperty = $__require('75');
    var ReactDOMComponentTree = $__require('6c');
    var ReactInstrumentation = $__require('84');
    var quoteAttributeValueForBrowser = $__require('85');
    var warning = $__require('7f');
    var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + DOMProperty.ATTRIBUTE_NAME_START_CHAR + '][' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');
    var illegalAttributeNameCache = {};
    var validatedAttributeNameCache = {};
    function isAttributeNameSafe(attributeName) {
      if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
        return true;
      }
      if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
        return false;
      }
      if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
        validatedAttributeNameCache[attributeName] = true;
        return true;
      }
      illegalAttributeNameCache[attributeName] = true;
      'production' !== 'production' ? warning(false, 'Invalid attribute name: `%s`', attributeName) : void 0;
      return false;
    }
    function shouldIgnoreValue(propertyInfo, value) {
      return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
    }
    var DOMPropertyOperations = {
      createMarkupForID: function (id) {
        return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
      },
      setAttributeForID: function (node, id) {
        node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
      },
      createMarkupForRoot: function () {
        return DOMProperty.ROOT_ATTRIBUTE_NAME + '=""';
      },
      setAttributeForRoot: function (node) {
        node.setAttribute(DOMProperty.ROOT_ATTRIBUTE_NAME, '');
      },
      createMarkupForProperty: function (name, value) {
        var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
        if (propertyInfo) {
          if (shouldIgnoreValue(propertyInfo, value)) {
            return '';
          }
          var attributeName = propertyInfo.attributeName;
          if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
            return attributeName + '=""';
          }
          return attributeName + '=' + quoteAttributeValueForBrowser(value);
        } else if (DOMProperty.isCustomAttribute(name)) {
          if (value == null) {
            return '';
          }
          return name + '=' + quoteAttributeValueForBrowser(value);
        }
        return null;
      },
      createMarkupForCustomAttribute: function (name, value) {
        if (!isAttributeNameSafe(name) || value == null) {
          return '';
        }
        return name + '=' + quoteAttributeValueForBrowser(value);
      },
      setValueForProperty: function (node, name, value) {
        var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
        if (propertyInfo) {
          var mutationMethod = propertyInfo.mutationMethod;
          if (mutationMethod) {
            mutationMethod(node, value);
          } else if (shouldIgnoreValue(propertyInfo, value)) {
            this.deleteValueForProperty(node, name);
            return;
          } else if (propertyInfo.mustUseProperty) {
            node[propertyInfo.propertyName] = value;
          } else {
            var attributeName = propertyInfo.attributeName;
            var namespace = propertyInfo.attributeNamespace;
            if (namespace) {
              node.setAttributeNS(namespace, attributeName, '' + value);
            } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
              node.setAttribute(attributeName, '');
            } else {
              node.setAttribute(attributeName, '' + value);
            }
          }
        } else if (DOMProperty.isCustomAttribute(name)) {
          DOMPropertyOperations.setValueForAttribute(node, name, value);
          return;
        }
        if ('production' !== 'production') {
          var payload = {};
          payload[name] = value;
          ReactInstrumentation.debugTool.onHostOperation({
            instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
            type: 'update attribute',
            payload: payload
          });
        }
      },
      setValueForAttribute: function (node, name, value) {
        if (!isAttributeNameSafe(name)) {
          return;
        }
        if (value == null) {
          node.removeAttribute(name);
        } else {
          node.setAttribute(name, '' + value);
        }
        if ('production' !== 'production') {
          var payload = {};
          payload[name] = value;
          ReactInstrumentation.debugTool.onHostOperation({
            instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
            type: 'update attribute',
            payload: payload
          });
        }
      },
      deleteValueForAttribute: function (node, name) {
        node.removeAttribute(name);
        if ('production' !== 'production') {
          ReactInstrumentation.debugTool.onHostOperation({
            instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
            type: 'remove attribute',
            payload: name
          });
        }
      },
      deleteValueForProperty: function (node, name) {
        var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
        if (propertyInfo) {
          var mutationMethod = propertyInfo.mutationMethod;
          if (mutationMethod) {
            mutationMethod(node, undefined);
          } else if (propertyInfo.mustUseProperty) {
            var propName = propertyInfo.propertyName;
            if (propertyInfo.hasBooleanValue) {
              node[propName] = false;
            } else {
              node[propName] = '';
            }
          } else {
            node.removeAttribute(propertyInfo.attributeName);
          }
        } else if (DOMProperty.isCustomAttribute(name)) {
          node.removeAttribute(name);
        }
        if ('production' !== 'production') {
          ReactInstrumentation.debugTool.onHostOperation({
            instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
            type: 'remove attribute',
            payload: name
          });
        }
      }
    };
    module.exports = DOMPropertyOperations;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('88', ['89', '63', '87', '8a', '6c', '6d', '8b', '7f', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('89'),
        _assign = $__require('63');
    var DOMPropertyOperations = $__require('87');
    var LinkedValueUtils = $__require('8a');
    var ReactDOMComponentTree = $__require('6c');
    var ReactUpdates = $__require('6d');
    var invariant = $__require('8b');
    var warning = $__require('7f');
    var didWarnValueLink = false;
    var didWarnCheckedLink = false;
    var didWarnValueDefaultValue = false;
    var didWarnCheckedDefaultChecked = false;
    var didWarnControlledToUncontrolled = false;
    var didWarnUncontrolledToControlled = false;
    function forceUpdateIfMounted() {
      if (this._rootNodeID) {
        ReactDOMInput.updateWrapper(this);
      }
    }
    function isControlled(props) {
      var usesChecked = props.type === 'checkbox' || props.type === 'radio';
      return usesChecked ? props.checked != null : props.value != null;
    }
    var ReactDOMInput = {
      getHostProps: function (inst, props) {
        var value = LinkedValueUtils.getValue(props);
        var checked = LinkedValueUtils.getChecked(props);
        var hostProps = _assign({
          type: undefined,
          step: undefined,
          min: undefined,
          max: undefined
        }, props, {
          defaultChecked: undefined,
          defaultValue: undefined,
          value: value != null ? value : inst._wrapperState.initialValue,
          checked: checked != null ? checked : inst._wrapperState.initialChecked,
          onChange: inst._wrapperState.onChange
        });
        return hostProps;
      },
      mountWrapper: function (inst, props) {
        if ('production' !== 'production') {
          LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);
          var owner = inst._currentElement._owner;
          if (props.valueLink !== undefined && !didWarnValueLink) {
            'production' !== 'production' ? warning(false, '`valueLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
            didWarnValueLink = true;
          }
          if (props.checkedLink !== undefined && !didWarnCheckedLink) {
            'production' !== 'production' ? warning(false, '`checkedLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
            didWarnCheckedLink = true;
          }
          if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
            'production' !== 'production' ? warning(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
            didWarnCheckedDefaultChecked = true;
          }
          if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
            'production' !== 'production' ? warning(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
            didWarnValueDefaultValue = true;
          }
        }
        var defaultValue = props.defaultValue;
        inst._wrapperState = {
          initialChecked: props.checked != null ? props.checked : props.defaultChecked,
          initialValue: props.value != null ? props.value : defaultValue,
          listeners: null,
          onChange: _handleChange.bind(inst)
        };
        if ('production' !== 'production') {
          inst._wrapperState.controlled = isControlled(props);
        }
      },
      updateWrapper: function (inst) {
        var props = inst._currentElement.props;
        if ('production' !== 'production') {
          var controlled = isControlled(props);
          var owner = inst._currentElement._owner;
          if (!inst._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
            'production' !== 'production' ? warning(false, '%s is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
            didWarnUncontrolledToControlled = true;
          }
          if (inst._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
            'production' !== 'production' ? warning(false, '%s is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
            didWarnControlledToUncontrolled = true;
          }
        }
        var checked = props.checked;
        if (checked != null) {
          DOMPropertyOperations.setValueForProperty(ReactDOMComponentTree.getNodeFromInstance(inst), 'checked', checked || false);
        }
        var node = ReactDOMComponentTree.getNodeFromInstance(inst);
        var value = LinkedValueUtils.getValue(props);
        if (value != null) {
          var newValue = '' + value;
          if (newValue !== node.value) {
            node.value = newValue;
          }
        } else {
          if (props.value == null && props.defaultValue != null) {
            node.defaultValue = '' + props.defaultValue;
          }
          if (props.checked == null && props.defaultChecked != null) {
            node.defaultChecked = !!props.defaultChecked;
          }
        }
      },
      postMountWrapper: function (inst) {
        var props = inst._currentElement.props;
        var node = ReactDOMComponentTree.getNodeFromInstance(inst);
        switch (props.type) {
          case 'submit':
          case 'reset':
            break;
          case 'color':
          case 'date':
          case 'datetime':
          case 'datetime-local':
          case 'month':
          case 'time':
          case 'week':
            node.value = '';
            node.value = node.defaultValue;
            break;
          default:
            node.value = node.value;
            break;
        }
        var name = node.name;
        if (name !== '') {
          node.name = '';
        }
        node.defaultChecked = !node.defaultChecked;
        node.defaultChecked = !node.defaultChecked;
        if (name !== '') {
          node.name = name;
        }
      }
    };
    function _handleChange(event) {
      var props = this._currentElement.props;
      var returnValue = LinkedValueUtils.executeOnChange(props, event);
      ReactUpdates.asap(forceUpdateIfMounted, this);
      var name = props.name;
      if (props.type === 'radio' && name != null) {
        var rootNode = ReactDOMComponentTree.getNodeFromInstance(this);
        var queryRoot = rootNode;
        while (queryRoot.parentNode) {
          queryRoot = queryRoot.parentNode;
        }
        var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');
        for (var i = 0; i < group.length; i++) {
          var otherNode = group[i];
          if (otherNode === rootNode || otherNode.form !== rootNode.form) {
            continue;
          }
          var otherInstance = ReactDOMComponentTree.getInstanceFromNode(otherNode);
          !otherInstance ? 'production' !== 'production' ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : _prodInvariant('90') : void 0;
          ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
        }
      }
      return returnValue;
    }
    module.exports = ReactDOMInput;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('8c', ['63', '5d', '6c', '8d', '7f', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _assign = $__require('63');
    var React = $__require('5d');
    var ReactDOMComponentTree = $__require('6c');
    var ReactDOMSelect = $__require('8d');
    var warning = $__require('7f');
    var didWarnInvalidOptionChildren = false;
    function flattenChildren(children) {
      var content = '';
      React.Children.forEach(children, function (child) {
        if (child == null) {
          return;
        }
        if (typeof child === 'string' || typeof child === 'number') {
          content += child;
        } else if (!didWarnInvalidOptionChildren) {
          didWarnInvalidOptionChildren = true;
          'production' !== 'production' ? warning(false, 'Only strings and numbers are supported as <option> children.') : void 0;
        }
      });
      return content;
    }
    var ReactDOMOption = {
      mountWrapper: function (inst, props, hostParent) {
        if ('production' !== 'production') {
          'production' !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : void 0;
        }
        var selectValue = null;
        if (hostParent != null) {
          var selectParent = hostParent;
          if (selectParent._tag === 'optgroup') {
            selectParent = selectParent._hostParent;
          }
          if (selectParent != null && selectParent._tag === 'select') {
            selectValue = ReactDOMSelect.getSelectValueContext(selectParent);
          }
        }
        var selected = null;
        if (selectValue != null) {
          var value;
          if (props.value != null) {
            value = props.value + '';
          } else {
            value = flattenChildren(props.children);
          }
          selected = false;
          if (Array.isArray(selectValue)) {
            for (var i = 0; i < selectValue.length; i++) {
              if ('' + selectValue[i] === value) {
                selected = true;
                break;
              }
            }
          } else {
            selected = '' + selectValue === value;
          }
        }
        inst._wrapperState = { selected: selected };
      },
      postMountWrapper: function (inst) {
        var props = inst._currentElement.props;
        if (props.value != null) {
          var node = ReactDOMComponentTree.getNodeFromInstance(inst);
          node.setAttribute('value', props.value);
        }
      },
      getHostProps: function (inst, props) {
        var hostProps = _assign({
          selected: undefined,
          children: undefined
        }, props);
        if (inst._wrapperState.selected != null) {
          hostProps.selected = inst._wrapperState.selected;
        }
        var content = flattenChildren(props.children);
        if (content) {
          hostProps.children = content;
        }
        return hostProps;
      }
    };
    module.exports = ReactDOMOption;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('8d', ['63', '8a', '6c', '6d', '7f', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _assign = $__require('63');
    var LinkedValueUtils = $__require('8a');
    var ReactDOMComponentTree = $__require('6c');
    var ReactUpdates = $__require('6d');
    var warning = $__require('7f');
    var didWarnValueLink = false;
    var didWarnValueDefaultValue = false;
    function updateOptionsIfPendingUpdateAndMounted() {
      if (this._rootNodeID && this._wrapperState.pendingUpdate) {
        this._wrapperState.pendingUpdate = false;
        var props = this._currentElement.props;
        var value = LinkedValueUtils.getValue(props);
        if (value != null) {
          updateOptions(this, Boolean(props.multiple), value);
        }
      }
    }
    function getDeclarationErrorAddendum(owner) {
      if (owner) {
        var name = owner.getName();
        if (name) {
          return ' Check the render method of `' + name + '`.';
        }
      }
      return '';
    }
    var valuePropNames = ['value', 'defaultValue'];
    function checkSelectPropTypes(inst, props) {
      var owner = inst._currentElement._owner;
      LinkedValueUtils.checkPropTypes('select', props, owner);
      if (props.valueLink !== undefined && !didWarnValueLink) {
        'production' !== 'production' ? warning(false, '`valueLink` prop on `select` is deprecated; set `value` and `onChange` instead.') : void 0;
        didWarnValueLink = true;
      }
      for (var i = 0; i < valuePropNames.length; i++) {
        var propName = valuePropNames[i];
        if (props[propName] == null) {
          continue;
        }
        var isArray = Array.isArray(props[propName]);
        if (props.multiple && !isArray) {
          'production' !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
        } else if (!props.multiple && isArray) {
          'production' !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
        }
      }
    }
    function updateOptions(inst, multiple, propValue) {
      var selectedValue, i;
      var options = ReactDOMComponentTree.getNodeFromInstance(inst).options;
      if (multiple) {
        selectedValue = {};
        for (i = 0; i < propValue.length; i++) {
          selectedValue['' + propValue[i]] = true;
        }
        for (i = 0; i < options.length; i++) {
          var selected = selectedValue.hasOwnProperty(options[i].value);
          if (options[i].selected !== selected) {
            options[i].selected = selected;
          }
        }
      } else {
        selectedValue = '' + propValue;
        for (i = 0; i < options.length; i++) {
          if (options[i].value === selectedValue) {
            options[i].selected = true;
            return;
          }
        }
        if (options.length) {
          options[0].selected = true;
        }
      }
    }
    var ReactDOMSelect = {
      getHostProps: function (inst, props) {
        return _assign({}, props, {
          onChange: inst._wrapperState.onChange,
          value: undefined
        });
      },
      mountWrapper: function (inst, props) {
        if ('production' !== 'production') {
          checkSelectPropTypes(inst, props);
        }
        var value = LinkedValueUtils.getValue(props);
        inst._wrapperState = {
          pendingUpdate: false,
          initialValue: value != null ? value : props.defaultValue,
          listeners: null,
          onChange: _handleChange.bind(inst),
          wasMultiple: Boolean(props.multiple)
        };
        if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
          'production' !== 'production' ? warning(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
          didWarnValueDefaultValue = true;
        }
      },
      getSelectValueContext: function (inst) {
        return inst._wrapperState.initialValue;
      },
      postUpdateWrapper: function (inst) {
        var props = inst._currentElement.props;
        inst._wrapperState.initialValue = undefined;
        var wasMultiple = inst._wrapperState.wasMultiple;
        inst._wrapperState.wasMultiple = Boolean(props.multiple);
        var value = LinkedValueUtils.getValue(props);
        if (value != null) {
          inst._wrapperState.pendingUpdate = false;
          updateOptions(inst, Boolean(props.multiple), value);
        } else if (wasMultiple !== Boolean(props.multiple)) {
          if (props.defaultValue != null) {
            updateOptions(inst, Boolean(props.multiple), props.defaultValue);
          } else {
            updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
          }
        }
      }
    };
    function _handleChange(event) {
      var props = this._currentElement.props;
      var returnValue = LinkedValueUtils.executeOnChange(props, event);
      if (this._rootNodeID) {
        this._wrapperState.pendingUpdate = true;
      }
      ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
      return returnValue;
    }
    module.exports = ReactDOMSelect;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('8a', ['89', '5d', '8e', '8b', '7f', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('89');
    var React = $__require('5d');
    var ReactPropTypesSecret = $__require('8e');
    var invariant = $__require('8b');
    var warning = $__require('7f');
    var hasReadOnlyValue = {
      'button': true,
      'checkbox': true,
      'image': true,
      'hidden': true,
      'radio': true,
      'reset': true,
      'submit': true
    };
    function _assertSingleLink(inputProps) {
      !(inputProps.checkedLink == null || inputProps.valueLink == null) ? 'production' !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use checkedLink, you probably don\'t want to use valueLink and vice versa.') : _prodInvariant('87') : void 0;
    }
    function _assertValueLink(inputProps) {
      _assertSingleLink(inputProps);
      !(inputProps.value == null && inputProps.onChange == null) ? 'production' !== 'production' ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want to use value or onChange, you probably don\'t want to use valueLink.') : _prodInvariant('88') : void 0;
    }
    function _assertCheckedLink(inputProps) {
      _assertSingleLink(inputProps);
      !(inputProps.checked == null && inputProps.onChange == null) ? 'production' !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. If you want to use checked or onChange, you probably don\'t want to use checkedLink') : _prodInvariant('89') : void 0;
    }
    var propTypes = {
      value: function (props, propName, componentName) {
        if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
          return null;
        }
        return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
      },
      checked: function (props, propName, componentName) {
        if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
          return null;
        }
        return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
      },
      onChange: React.PropTypes.func
    };
    var loggedTypeFailures = {};
    function getDeclarationErrorAddendum(owner) {
      if (owner) {
        var name = owner.getName();
        if (name) {
          return ' Check the render method of `' + name + '`.';
        }
      }
      return '';
    }
    var LinkedValueUtils = {
      checkPropTypes: function (tagName, props, owner) {
        for (var propName in propTypes) {
          if (propTypes.hasOwnProperty(propName)) {
            var error = propTypes[propName](props, propName, tagName, 'prop', null, ReactPropTypesSecret);
          }
          if (error instanceof Error && !(error.message in loggedTypeFailures)) {
            loggedTypeFailures[error.message] = true;
            var addendum = getDeclarationErrorAddendum(owner);
            'production' !== 'production' ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : void 0;
          }
        }
      },
      getValue: function (inputProps) {
        if (inputProps.valueLink) {
          _assertValueLink(inputProps);
          return inputProps.valueLink.value;
        }
        return inputProps.value;
      },
      getChecked: function (inputProps) {
        if (inputProps.checkedLink) {
          _assertCheckedLink(inputProps);
          return inputProps.checkedLink.value;
        }
        return inputProps.checked;
      },
      executeOnChange: function (inputProps, event) {
        if (inputProps.valueLink) {
          _assertValueLink(inputProps);
          return inputProps.valueLink.requestChange(event.target.value);
        } else if (inputProps.checkedLink) {
          _assertCheckedLink(inputProps);
          return inputProps.checkedLink.requestChange(event.target.checked);
        } else if (inputProps.onChange) {
          return inputProps.onChange.call(undefined, event);
        }
      }
    };
    module.exports = LinkedValueUtils;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('8f', ['89', '63', '8a', '6c', '6d', '8b', '7f', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('89'),
        _assign = $__require('63');
    var LinkedValueUtils = $__require('8a');
    var ReactDOMComponentTree = $__require('6c');
    var ReactUpdates = $__require('6d');
    var invariant = $__require('8b');
    var warning = $__require('7f');
    var didWarnValueLink = false;
    var didWarnValDefaultVal = false;
    function forceUpdateIfMounted() {
      if (this._rootNodeID) {
        ReactDOMTextarea.updateWrapper(this);
      }
    }
    var ReactDOMTextarea = {
      getHostProps: function (inst, props) {
        !(props.dangerouslySetInnerHTML == null) ? 'production' !== 'production' ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : _prodInvariant('91') : void 0;
        var hostProps = _assign({}, props, {
          value: undefined,
          defaultValue: undefined,
          children: '' + inst._wrapperState.initialValue,
          onChange: inst._wrapperState.onChange
        });
        return hostProps;
      },
      mountWrapper: function (inst, props) {
        if ('production' !== 'production') {
          LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
          if (props.valueLink !== undefined && !didWarnValueLink) {
            'production' !== 'production' ? warning(false, '`valueLink` prop on `textarea` is deprecated; set `value` and `onChange` instead.') : void 0;
            didWarnValueLink = true;
          }
          if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
            'production' !== 'production' ? warning(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
            didWarnValDefaultVal = true;
          }
        }
        var value = LinkedValueUtils.getValue(props);
        var initialValue = value;
        if (value == null) {
          var defaultValue = props.defaultValue;
          var children = props.children;
          if (children != null) {
            if ('production' !== 'production') {
              'production' !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : void 0;
            }
            !(defaultValue == null) ? 'production' !== 'production' ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : _prodInvariant('92') : void 0;
            if (Array.isArray(children)) {
              !(children.length <= 1) ? 'production' !== 'production' ? invariant(false, '<textarea> can only have at most one child.') : _prodInvariant('93') : void 0;
              children = children[0];
            }
            defaultValue = '' + children;
          }
          if (defaultValue == null) {
            defaultValue = '';
          }
          initialValue = defaultValue;
        }
        inst._wrapperState = {
          initialValue: '' + initialValue,
          listeners: null,
          onChange: _handleChange.bind(inst)
        };
      },
      updateWrapper: function (inst) {
        var props = inst._currentElement.props;
        var node = ReactDOMComponentTree.getNodeFromInstance(inst);
        var value = LinkedValueUtils.getValue(props);
        if (value != null) {
          var newValue = '' + value;
          if (newValue !== node.value) {
            node.value = newValue;
          }
          if (props.defaultValue == null) {
            node.defaultValue = newValue;
          }
        }
        if (props.defaultValue != null) {
          node.defaultValue = props.defaultValue;
        }
      },
      postMountWrapper: function (inst) {
        var node = ReactDOMComponentTree.getNodeFromInstance(inst);
        node.value = node.textContent;
      }
    };
    function _handleChange(event) {
      var props = this._currentElement.props;
      var returnValue = LinkedValueUtils.executeOnChange(props, event);
      ReactUpdates.asap(forceUpdateIfMounted, this);
      return returnValue;
    }
    module.exports = ReactDOMTextarea;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('90', ['91', '92', '93', '94', '95', '7f', '96', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var ReactReconciler = $__require('91');
    var instantiateReactComponent = $__require('92');
    var KeyEscapeUtils = $__require('93');
    var shouldUpdateReactComponent = $__require('94');
    var traverseAllChildren = $__require('95');
    var warning = $__require('7f');
    var ReactComponentTreeHook;
    if (typeof process !== 'undefined' && process.env && 'production' === 'test') {
      ReactComponentTreeHook = $__require('96');
    }
    function instantiateChild(childInstances, child, name, selfDebugID) {
      var keyUnique = childInstances[name] === undefined;
      if ('production' !== 'production') {
        if (!ReactComponentTreeHook) {
          ReactComponentTreeHook = $__require('96');
        }
        if (!keyUnique) {
          'production' !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
        }
      }
      if (child != null && keyUnique) {
        childInstances[name] = instantiateReactComponent(child, true);
      }
    }
    var ReactChildReconciler = {
      instantiateChildren: function (nestedChildNodes, transaction, context, selfDebugID) {
        if (nestedChildNodes == null) {
          return null;
        }
        var childInstances = {};
        if ('production' !== 'production') {
          traverseAllChildren(nestedChildNodes, function (childInsts, child, name) {
            return instantiateChild(childInsts, child, name, selfDebugID);
          }, childInstances);
        } else {
          traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
        }
        return childInstances;
      },
      updateChildren: function (prevChildren, nextChildren, mountImages, removedNodes, transaction, hostParent, hostContainerInfo, context, selfDebugID) {
        if (!nextChildren && !prevChildren) {
          return;
        }
        var name;
        var prevChild;
        for (name in nextChildren) {
          if (!nextChildren.hasOwnProperty(name)) {
            continue;
          }
          prevChild = prevChildren && prevChildren[name];
          var prevElement = prevChild && prevChild._currentElement;
          var nextElement = nextChildren[name];
          if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
            ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
            nextChildren[name] = prevChild;
          } else {
            if (prevChild) {
              removedNodes[name] = ReactReconciler.getHostNode(prevChild);
              ReactReconciler.unmountComponent(prevChild, false);
            }
            var nextChildInstance = instantiateReactComponent(nextElement, true);
            nextChildren[name] = nextChildInstance;
            var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context, selfDebugID);
            mountImages.push(nextChildMountImage);
          }
        }
        for (name in prevChildren) {
          if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
            prevChild = prevChildren[name];
            removedNodes[name] = ReactReconciler.getHostNode(prevChild);
            ReactReconciler.unmountComponent(prevChild, false);
          }
        }
      },
      unmountChildren: function (renderedChildren, safely) {
        for (var name in renderedChildren) {
          if (renderedChildren.hasOwnProperty(name)) {
            var renderedChild = renderedChildren[name];
            ReactReconciler.unmountComponent(renderedChild, safely);
          }
        }
      }
    };
    module.exports = ReactChildReconciler;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('97', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2014-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  // The Symbol used to tag the ReactElement type. If there is no native Symbol
  // nor polyfill, then a plain number is used for performance.

  var define,
      global = this || self,
      GLOBAL = global;
  var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;

  module.exports = REACT_ELEMENT_TYPE;
  return module.exports;
});
$__System.registerDynamic('98', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  /* global Symbol */

  var define,
      global = this || self,
      GLOBAL = global;
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  module.exports = getIteratorFn;
  return module.exports;
});
$__System.registerDynamic('93', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  /**
   * Escape and wrap key so it is safe to use as a reactid
   *
   * @param {string} key to be escaped.
   * @return {string} the escaped key.
   */

  var define,
      global = this || self,
      GLOBAL = global;
  function escape(key) {
    var escapeRegex = /[=:]/g;
    var escaperLookup = {
      '=': '=0',
      ':': '=2'
    };
    var escapedString = ('' + key).replace(escapeRegex, function (match) {
      return escaperLookup[match];
    });

    return '$' + escapedString;
  }

  /**
   * Unescape and unwrap key for human-readable display
   *
   * @param {string} key to unescape.
   * @return {string} the unescaped key.
   */
  function unescape(key) {
    var unescapeRegex = /(=0|=2)/g;
    var unescaperLookup = {
      '=0': '=',
      '=2': ':'
    };
    var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);

    return ('' + keySubstring).replace(unescapeRegex, function (match) {
      return unescaperLookup[match];
    });
  }

  var KeyEscapeUtils = {
    escape: escape,
    unescape: unescape
  };

  module.exports = KeyEscapeUtils;
  return module.exports;
});
$__System.registerDynamic('95', ['89', '99', '97', '98', '8b', '93', '7f', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('89');
    var ReactCurrentOwner = $__require('99');
    var REACT_ELEMENT_TYPE = $__require('97');
    var getIteratorFn = $__require('98');
    var invariant = $__require('8b');
    var KeyEscapeUtils = $__require('93');
    var warning = $__require('7f');
    var SEPARATOR = '.';
    var SUBSEPARATOR = ':';
    var didWarnAboutMaps = false;
    function getComponentKey(component, index) {
      if (component && typeof component === 'object' && component.key != null) {
        return KeyEscapeUtils.escape(component.key);
      }
      return index.toString(36);
    }
    function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
      var type = typeof children;
      if (type === 'undefined' || type === 'boolean') {
        children = null;
      }
      if (children === null || type === 'string' || type === 'number' || type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {
        callback(traverseContext, children, nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
        return 1;
      }
      var child;
      var nextName;
      var subtreeCount = 0;
      var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
      if (Array.isArray(children)) {
        for (var i = 0; i < children.length; i++) {
          child = children[i];
          nextName = nextNamePrefix + getComponentKey(child, i);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      } else {
        var iteratorFn = getIteratorFn(children);
        if (iteratorFn) {
          var iterator = iteratorFn.call(children);
          var step;
          if (iteratorFn !== children.entries) {
            var ii = 0;
            while (!(step = iterator.next()).done) {
              child = step.value;
              nextName = nextNamePrefix + getComponentKey(child, ii++);
              subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
            }
          } else {
            if ('production' !== 'production') {
              var mapsAsChildrenAddendum = '';
              if (ReactCurrentOwner.current) {
                var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
                if (mapsAsChildrenOwnerName) {
                  mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
                }
              }
              'production' !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
              didWarnAboutMaps = true;
            }
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                child = entry[1];
                nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
                subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
              }
            }
          }
        } else if (type === 'object') {
          var addendum = '';
          if ('production' !== 'production') {
            addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
            if (children._isReactElement) {
              addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
            }
            if (ReactCurrentOwner.current) {
              var name = ReactCurrentOwner.current.getName();
              if (name) {
                addendum += ' Check the render method of `' + name + '`.';
              }
            }
          }
          var childrenString = String(children);
          !false ? 'production' !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
        }
      }
      return subtreeCount;
    }
    function traverseAllChildren(children, callback, traverseContext) {
      if (children == null) {
        return 0;
      }
      return traverseAllChildrenImpl(children, '', callback, traverseContext);
    }
    module.exports = traverseAllChildren;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('9a', ['93', '95', '7f', '96', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var KeyEscapeUtils = $__require('93');
    var traverseAllChildren = $__require('95');
    var warning = $__require('7f');
    var ReactComponentTreeHook;
    if (typeof process !== 'undefined' && process.env && 'production' === 'test') {
      ReactComponentTreeHook = $__require('96');
    }
    function flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID) {
      if (traverseContext && typeof traverseContext === 'object') {
        var result = traverseContext;
        var keyUnique = result[name] === undefined;
        if ('production' !== 'production') {
          if (!ReactComponentTreeHook) {
            ReactComponentTreeHook = $__require('96');
          }
          if (!keyUnique) {
            'production' !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
          }
        }
        if (keyUnique && child != null) {
          result[name] = child;
        }
      }
    }
    function flattenChildren(children, selfDebugID) {
      if (children == null) {
        return children;
      }
      var result = {};
      if ('production' !== 'production') {
        traverseAllChildren(children, function (traverseContext, child, name) {
          return flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID);
        }, result);
      } else {
        traverseAllChildren(children, flattenSingleChildIntoContext, result);
      }
      return result;
    }
    module.exports = flattenChildren;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('9b', ['89', '9c', '9d', '84', '99', '91', '90', '9e', '9a', '8b', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('89');
    var ReactComponentEnvironment = $__require('9c');
    var ReactInstanceMap = $__require('9d');
    var ReactInstrumentation = $__require('84');
    var ReactCurrentOwner = $__require('99');
    var ReactReconciler = $__require('91');
    var ReactChildReconciler = $__require('90');
    var emptyFunction = $__require('9e');
    var flattenChildren = $__require('9a');
    var invariant = $__require('8b');
    function makeInsertMarkup(markup, afterNode, toIndex) {
      return {
        type: 'INSERT_MARKUP',
        content: markup,
        fromIndex: null,
        fromNode: null,
        toIndex: toIndex,
        afterNode: afterNode
      };
    }
    function makeMove(child, afterNode, toIndex) {
      return {
        type: 'MOVE_EXISTING',
        content: null,
        fromIndex: child._mountIndex,
        fromNode: ReactReconciler.getHostNode(child),
        toIndex: toIndex,
        afterNode: afterNode
      };
    }
    function makeRemove(child, node) {
      return {
        type: 'REMOVE_NODE',
        content: null,
        fromIndex: child._mountIndex,
        fromNode: node,
        toIndex: null,
        afterNode: null
      };
    }
    function makeSetMarkup(markup) {
      return {
        type: 'SET_MARKUP',
        content: markup,
        fromIndex: null,
        fromNode: null,
        toIndex: null,
        afterNode: null
      };
    }
    function makeTextContent(textContent) {
      return {
        type: 'TEXT_CONTENT',
        content: textContent,
        fromIndex: null,
        fromNode: null,
        toIndex: null,
        afterNode: null
      };
    }
    function enqueue(queue, update) {
      if (update) {
        queue = queue || [];
        queue.push(update);
      }
      return queue;
    }
    function processQueue(inst, updateQueue) {
      ReactComponentEnvironment.processChildrenUpdates(inst, updateQueue);
    }
    var setChildrenForInstrumentation = emptyFunction;
    if ('production' !== 'production') {
      var getDebugID = function (inst) {
        if (!inst._debugID) {
          var internal;
          if (internal = ReactInstanceMap.get(inst)) {
            inst = internal;
          }
        }
        return inst._debugID;
      };
      setChildrenForInstrumentation = function (children) {
        var debugID = getDebugID(this);
        if (debugID !== 0) {
          ReactInstrumentation.debugTool.onSetChildren(debugID, children ? Object.keys(children).map(function (key) {
            return children[key]._debugID;
          }) : []);
        }
      };
    }
    var ReactMultiChild = { Mixin: {
        _reconcilerInstantiateChildren: function (nestedChildren, transaction, context) {
          if ('production' !== 'production') {
            var selfDebugID = getDebugID(this);
            if (this._currentElement) {
              try {
                ReactCurrentOwner.current = this._currentElement._owner;
                return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context, selfDebugID);
              } finally {
                ReactCurrentOwner.current = null;
              }
            }
          }
          return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
        },
        _reconcilerUpdateChildren: function (prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context) {
          var nextChildren;
          var selfDebugID = 0;
          if ('production' !== 'production') {
            selfDebugID = getDebugID(this);
            if (this._currentElement) {
              try {
                ReactCurrentOwner.current = this._currentElement._owner;
                nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
              } finally {
                ReactCurrentOwner.current = null;
              }
              ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
              return nextChildren;
            }
          }
          nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
          ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
          return nextChildren;
        },
        mountChildren: function (nestedChildren, transaction, context) {
          var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
          this._renderedChildren = children;
          var mountImages = [];
          var index = 0;
          for (var name in children) {
            if (children.hasOwnProperty(name)) {
              var child = children[name];
              var selfDebugID = 0;
              if ('production' !== 'production') {
                selfDebugID = getDebugID(this);
              }
              var mountImage = ReactReconciler.mountComponent(child, transaction, this, this._hostContainerInfo, context, selfDebugID);
              child._mountIndex = index++;
              mountImages.push(mountImage);
            }
          }
          if ('production' !== 'production') {
            setChildrenForInstrumentation.call(this, children);
          }
          return mountImages;
        },
        updateTextContent: function (nextContent) {
          var prevChildren = this._renderedChildren;
          ReactChildReconciler.unmountChildren(prevChildren, false);
          for (var name in prevChildren) {
            if (prevChildren.hasOwnProperty(name)) {
              !false ? 'production' !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
            }
          }
          var updates = [makeTextContent(nextContent)];
          processQueue(this, updates);
        },
        updateMarkup: function (nextMarkup) {
          var prevChildren = this._renderedChildren;
          ReactChildReconciler.unmountChildren(prevChildren, false);
          for (var name in prevChildren) {
            if (prevChildren.hasOwnProperty(name)) {
              !false ? 'production' !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
            }
          }
          var updates = [makeSetMarkup(nextMarkup)];
          processQueue(this, updates);
        },
        updateChildren: function (nextNestedChildrenElements, transaction, context) {
          this._updateChildren(nextNestedChildrenElements, transaction, context);
        },
        _updateChildren: function (nextNestedChildrenElements, transaction, context) {
          var prevChildren = this._renderedChildren;
          var removedNodes = {};
          var mountImages = [];
          var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context);
          if (!nextChildren && !prevChildren) {
            return;
          }
          var updates = null;
          var name;
          var nextIndex = 0;
          var lastIndex = 0;
          var nextMountIndex = 0;
          var lastPlacedNode = null;
          for (name in nextChildren) {
            if (!nextChildren.hasOwnProperty(name)) {
              continue;
            }
            var prevChild = prevChildren && prevChildren[name];
            var nextChild = nextChildren[name];
            if (prevChild === nextChild) {
              updates = enqueue(updates, this.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex));
              lastIndex = Math.max(prevChild._mountIndex, lastIndex);
              prevChild._mountIndex = nextIndex;
            } else {
              if (prevChild) {
                lastIndex = Math.max(prevChild._mountIndex, lastIndex);
              }
              updates = enqueue(updates, this._mountChildAtIndex(nextChild, mountImages[nextMountIndex], lastPlacedNode, nextIndex, transaction, context));
              nextMountIndex++;
            }
            nextIndex++;
            lastPlacedNode = ReactReconciler.getHostNode(nextChild);
          }
          for (name in removedNodes) {
            if (removedNodes.hasOwnProperty(name)) {
              updates = enqueue(updates, this._unmountChild(prevChildren[name], removedNodes[name]));
            }
          }
          if (updates) {
            processQueue(this, updates);
          }
          this._renderedChildren = nextChildren;
          if ('production' !== 'production') {
            setChildrenForInstrumentation.call(this, nextChildren);
          }
        },
        unmountChildren: function (safely) {
          var renderedChildren = this._renderedChildren;
          ReactChildReconciler.unmountChildren(renderedChildren, safely);
          this._renderedChildren = null;
        },
        moveChild: function (child, afterNode, toIndex, lastIndex) {
          if (child._mountIndex < lastIndex) {
            return makeMove(child, afterNode, toIndex);
          }
        },
        createChild: function (child, afterNode, mountImage) {
          return makeInsertMarkup(mountImage, afterNode, child._mountIndex);
        },
        removeChild: function (child, node) {
          return makeRemove(child, node);
        },
        _mountChildAtIndex: function (child, mountImage, afterNode, index, transaction, context) {
          child._mountIndex = index;
          return this.createChild(child, afterNode, mountImage);
        },
        _unmountChild: function (child, node) {
          var update = this.removeChild(child, node);
          child._mountIndex = null;
          return update;
        }
      } };
    module.exports = ReactMultiChild;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('9f', ['a0', '7f', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var ReactUpdateQueue = $__require('a0');
    var warning = $__require('7f');
    function warnNoop(publicInstance, callerName) {
      if ('production' !== 'production') {
        var constructor = publicInstance.constructor;
        'production' !== 'production' ? warning(false, '%s(...): Can only update a mounting component. ' + 'This usually means you called %s() outside componentWillMount() on the server. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
      }
    }
    var ReactServerUpdateQueue = function () {
      function ReactServerUpdateQueue(transaction) {
        _classCallCheck(this, ReactServerUpdateQueue);
        this.transaction = transaction;
      }
      ReactServerUpdateQueue.prototype.isMounted = function isMounted(publicInstance) {
        return false;
      };
      ReactServerUpdateQueue.prototype.enqueueCallback = function enqueueCallback(publicInstance, callback, callerName) {
        if (this.transaction.isInTransaction()) {
          ReactUpdateQueue.enqueueCallback(publicInstance, callback, callerName);
        }
      };
      ReactServerUpdateQueue.prototype.enqueueForceUpdate = function enqueueForceUpdate(publicInstance) {
        if (this.transaction.isInTransaction()) {
          ReactUpdateQueue.enqueueForceUpdate(publicInstance);
        } else {
          warnNoop(publicInstance, 'forceUpdate');
        }
      };
      ReactServerUpdateQueue.prototype.enqueueReplaceState = function enqueueReplaceState(publicInstance, completeState) {
        if (this.transaction.isInTransaction()) {
          ReactUpdateQueue.enqueueReplaceState(publicInstance, completeState);
        } else {
          warnNoop(publicInstance, 'replaceState');
        }
      };
      ReactServerUpdateQueue.prototype.enqueueSetState = function enqueueSetState(publicInstance, partialState) {
        if (this.transaction.isInTransaction()) {
          ReactUpdateQueue.enqueueSetState(publicInstance, partialState);
        } else {
          warnNoop(publicInstance, 'setState');
        }
      };
      return ReactServerUpdateQueue;
    }();
    module.exports = ReactServerUpdateQueue;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('a1', ['63', '61', 'a2', '84', '9f', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _assign = $__require('63');
    var PooledClass = $__require('61');
    var Transaction = $__require('a2');
    var ReactInstrumentation = $__require('84');
    var ReactServerUpdateQueue = $__require('9f');
    var TRANSACTION_WRAPPERS = [];
    if ('production' !== 'production') {
      TRANSACTION_WRAPPERS.push({
        initialize: ReactInstrumentation.debugTool.onBeginFlush,
        close: ReactInstrumentation.debugTool.onEndFlush
      });
    }
    var noopCallbackQueue = { enqueue: function () {} };
    function ReactServerRenderingTransaction(renderToStaticMarkup) {
      this.reinitializeTransaction();
      this.renderToStaticMarkup = renderToStaticMarkup;
      this.useCreateElement = false;
      this.updateQueue = new ReactServerUpdateQueue(this);
    }
    var Mixin = {
      getTransactionWrappers: function () {
        return TRANSACTION_WRAPPERS;
      },
      getReactMountReady: function () {
        return noopCallbackQueue;
      },
      getUpdateQueue: function () {
        return this.updateQueue;
      },
      destructor: function () {},
      checkpoint: function () {},
      rollback: function () {}
    };
    _assign(ReactServerRenderingTransaction.prototype, Transaction, Mixin);
    PooledClass.addPoolingTo(ReactServerRenderingTransaction);
    module.exports = ReactServerRenderingTransaction;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('a3', ['89', '63', '79', '83', 'a4', 'a5', '75', '87', '6b', 'a6', 'a7', 'a8', '6c', '88', '8c', '8d', '8f', '84', '9b', 'a1', '9e', '86', '8b', '6f', 'aa', 'a9', '7f', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('89'),
        _assign = $__require('63');
    var AutoFocusUtils = $__require('79');
    var CSSPropertyOperations = $__require('83');
    var DOMLazyTree = $__require('a4');
    var DOMNamespaces = $__require('a5');
    var DOMProperty = $__require('75');
    var DOMPropertyOperations = $__require('87');
    var EventPluginHub = $__require('6b');
    var EventPluginRegistry = $__require('a6');
    var ReactBrowserEventEmitter = $__require('a7');
    var ReactDOMComponentFlags = $__require('a8');
    var ReactDOMComponentTree = $__require('6c');
    var ReactDOMInput = $__require('88');
    var ReactDOMOption = $__require('8c');
    var ReactDOMSelect = $__require('8d');
    var ReactDOMTextarea = $__require('8f');
    var ReactInstrumentation = $__require('84');
    var ReactMultiChild = $__require('9b');
    var ReactServerRenderingTransaction = $__require('a1');
    var emptyFunction = $__require('9e');
    var escapeTextContentForBrowser = $__require('86');
    var invariant = $__require('8b');
    var isEventSupported = $__require('6f');
    var shallowEqual = $__require('aa');
    var validateDOMNesting = $__require('a9');
    var warning = $__require('7f');
    var Flags = ReactDOMComponentFlags;
    var deleteListener = EventPluginHub.deleteListener;
    var getNode = ReactDOMComponentTree.getNodeFromInstance;
    var listenTo = ReactBrowserEventEmitter.listenTo;
    var registrationNameModules = EventPluginRegistry.registrationNameModules;
    var CONTENT_TYPES = {
      'string': true,
      'number': true
    };
    var STYLE = 'style';
    var HTML = '__html';
    var RESERVED_PROPS = {
      children: null,
      dangerouslySetInnerHTML: null,
      suppressContentEditableWarning: null
    };
    var DOC_FRAGMENT_TYPE = 11;
    function getDeclarationErrorAddendum(internalInstance) {
      if (internalInstance) {
        var owner = internalInstance._currentElement._owner || null;
        if (owner) {
          var name = owner.getName();
          if (name) {
            return ' This DOM node was rendered by `' + name + '`.';
          }
        }
      }
      return '';
    }
    function friendlyStringify(obj) {
      if (typeof obj === 'object') {
        if (Array.isArray(obj)) {
          return '[' + obj.map(friendlyStringify).join(', ') + ']';
        } else {
          var pairs = [];
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
              pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
            }
          }
          return '{' + pairs.join(', ') + '}';
        }
      } else if (typeof obj === 'string') {
        return JSON.stringify(obj);
      } else if (typeof obj === 'function') {
        return '[function object]';
      }
      return String(obj);
    }
    var styleMutationWarning = {};
    function checkAndWarnForMutatedStyle(style1, style2, component) {
      if (style1 == null || style2 == null) {
        return;
      }
      if (shallowEqual(style1, style2)) {
        return;
      }
      var componentName = component._tag;
      var owner = component._currentElement._owner;
      var ownerName;
      if (owner) {
        ownerName = owner.getName();
      }
      var hash = ownerName + '|' + componentName;
      if (styleMutationWarning.hasOwnProperty(hash)) {
        return;
      }
      styleMutationWarning[hash] = true;
      'production' !== 'production' ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2)) : void 0;
    }
    function assertValidProps(component, props) {
      if (!props) {
        return;
      }
      if (voidElementTags[component._tag]) {
        !(props.children == null && props.dangerouslySetInnerHTML == null) ? 'production' !== 'production' ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : _prodInvariant('137', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : void 0;
      }
      if (props.dangerouslySetInnerHTML != null) {
        !(props.children == null) ? 'production' !== 'production' ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : _prodInvariant('60') : void 0;
        !(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML) ? 'production' !== 'production' ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : _prodInvariant('61') : void 0;
      }
      if ('production' !== 'production') {
        'production' !== 'production' ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : void 0;
        'production' !== 'production' ? warning(props.suppressContentEditableWarning || !props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : void 0;
        'production' !== 'production' ? warning(props.onFocusIn == null && props.onFocusOut == null, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.') : void 0;
      }
      !(props.style == null || typeof props.style === 'object') ? 'production' !== 'production' ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s', getDeclarationErrorAddendum(component)) : _prodInvariant('62', getDeclarationErrorAddendum(component)) : void 0;
    }
    function enqueuePutListener(inst, registrationName, listener, transaction) {
      if (transaction instanceof ReactServerRenderingTransaction) {
        return;
      }
      if ('production' !== 'production') {
        'production' !== 'production' ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), 'This browser doesn\'t support the `onScroll` event') : void 0;
      }
      var containerInfo = inst._hostContainerInfo;
      var isDocumentFragment = containerInfo._node && containerInfo._node.nodeType === DOC_FRAGMENT_TYPE;
      var doc = isDocumentFragment ? containerInfo._node : containerInfo._ownerDocument;
      listenTo(registrationName, doc);
      transaction.getReactMountReady().enqueue(putListener, {
        inst: inst,
        registrationName: registrationName,
        listener: listener
      });
    }
    function putListener() {
      var listenerToPut = this;
      EventPluginHub.putListener(listenerToPut.inst, listenerToPut.registrationName, listenerToPut.listener);
    }
    function inputPostMount() {
      var inst = this;
      ReactDOMInput.postMountWrapper(inst);
    }
    function textareaPostMount() {
      var inst = this;
      ReactDOMTextarea.postMountWrapper(inst);
    }
    function optionPostMount() {
      var inst = this;
      ReactDOMOption.postMountWrapper(inst);
    }
    var setAndValidateContentChildDev = emptyFunction;
    if ('production' !== 'production') {
      setAndValidateContentChildDev = function (content) {
        var hasExistingContent = this._contentDebugID != null;
        var debugID = this._debugID;
        var contentDebugID = -debugID;
        if (content == null) {
          if (hasExistingContent) {
            ReactInstrumentation.debugTool.onUnmountComponent(this._contentDebugID);
          }
          this._contentDebugID = null;
          return;
        }
        validateDOMNesting(null, String(content), this, this._ancestorInfo);
        this._contentDebugID = contentDebugID;
        if (hasExistingContent) {
          ReactInstrumentation.debugTool.onBeforeUpdateComponent(contentDebugID, content);
          ReactInstrumentation.debugTool.onUpdateComponent(contentDebugID);
        } else {
          ReactInstrumentation.debugTool.onBeforeMountComponent(contentDebugID, content, debugID);
          ReactInstrumentation.debugTool.onMountComponent(contentDebugID);
          ReactInstrumentation.debugTool.onSetChildren(debugID, [contentDebugID]);
        }
      };
    }
    var mediaEvents = {
      topAbort: 'abort',
      topCanPlay: 'canplay',
      topCanPlayThrough: 'canplaythrough',
      topDurationChange: 'durationchange',
      topEmptied: 'emptied',
      topEncrypted: 'encrypted',
      topEnded: 'ended',
      topError: 'error',
      topLoadedData: 'loadeddata',
      topLoadedMetadata: 'loadedmetadata',
      topLoadStart: 'loadstart',
      topPause: 'pause',
      topPlay: 'play',
      topPlaying: 'playing',
      topProgress: 'progress',
      topRateChange: 'ratechange',
      topSeeked: 'seeked',
      topSeeking: 'seeking',
      topStalled: 'stalled',
      topSuspend: 'suspend',
      topTimeUpdate: 'timeupdate',
      topVolumeChange: 'volumechange',
      topWaiting: 'waiting'
    };
    function trapBubbledEventsLocal() {
      var inst = this;
      !inst._rootNodeID ? 'production' !== 'production' ? invariant(false, 'Must be mounted to trap events') : _prodInvariant('63') : void 0;
      var node = getNode(inst);
      !node ? 'production' !== 'production' ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : _prodInvariant('64') : void 0;
      switch (inst._tag) {
        case 'iframe':
        case 'object':
          inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topLoad', 'load', node)];
          break;
        case 'video':
        case 'audio':
          inst._wrapperState.listeners = [];
          for (var event in mediaEvents) {
            if (mediaEvents.hasOwnProperty(event)) {
              inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(event, mediaEvents[event], node));
            }
          }
          break;
        case 'source':
          inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topError', 'error', node)];
          break;
        case 'img':
          inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topError', 'error', node), ReactBrowserEventEmitter.trapBubbledEvent('topLoad', 'load', node)];
          break;
        case 'form':
          inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topReset', 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent('topSubmit', 'submit', node)];
          break;
        case 'input':
        case 'select':
        case 'textarea':
          inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topInvalid', 'invalid', node)];
          break;
      }
    }
    function postUpdateSelectWrapper() {
      ReactDOMSelect.postUpdateWrapper(this);
    }
    var omittedCloseTags = {
      'area': true,
      'base': true,
      'br': true,
      'col': true,
      'embed': true,
      'hr': true,
      'img': true,
      'input': true,
      'keygen': true,
      'link': true,
      'meta': true,
      'param': true,
      'source': true,
      'track': true,
      'wbr': true
    };
    var newlineEatingTags = {
      'listing': true,
      'pre': true,
      'textarea': true
    };
    var voidElementTags = _assign({ 'menuitem': true }, omittedCloseTags);
    var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
    var validatedTagCache = {};
    var hasOwnProperty = {}.hasOwnProperty;
    function validateDangerousTag(tag) {
      if (!hasOwnProperty.call(validatedTagCache, tag)) {
        !VALID_TAG_REGEX.test(tag) ? 'production' !== 'production' ? invariant(false, 'Invalid tag: %s', tag) : _prodInvariant('65', tag) : void 0;
        validatedTagCache[tag] = true;
      }
    }
    function isCustomComponent(tagName, props) {
      return tagName.indexOf('-') >= 0 || props.is != null;
    }
    var globalIdCounter = 1;
    function ReactDOMComponent(element) {
      var tag = element.type;
      validateDangerousTag(tag);
      this._currentElement = element;
      this._tag = tag.toLowerCase();
      this._namespaceURI = null;
      this._renderedChildren = null;
      this._previousStyle = null;
      this._previousStyleCopy = null;
      this._hostNode = null;
      this._hostParent = null;
      this._rootNodeID = 0;
      this._domID = 0;
      this._hostContainerInfo = null;
      this._wrapperState = null;
      this._topLevelWrapper = null;
      this._flags = 0;
      if ('production' !== 'production') {
        this._ancestorInfo = null;
        setAndValidateContentChildDev.call(this, null);
      }
    }
    ReactDOMComponent.displayName = 'ReactDOMComponent';
    ReactDOMComponent.Mixin = {
      mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
        this._rootNodeID = globalIdCounter++;
        this._domID = hostContainerInfo._idCounter++;
        this._hostParent = hostParent;
        this._hostContainerInfo = hostContainerInfo;
        var props = this._currentElement.props;
        switch (this._tag) {
          case 'audio':
          case 'form':
          case 'iframe':
          case 'img':
          case 'link':
          case 'object':
          case 'source':
          case 'video':
            this._wrapperState = { listeners: null };
            transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
            break;
          case 'input':
            ReactDOMInput.mountWrapper(this, props, hostParent);
            props = ReactDOMInput.getHostProps(this, props);
            transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
            break;
          case 'option':
            ReactDOMOption.mountWrapper(this, props, hostParent);
            props = ReactDOMOption.getHostProps(this, props);
            break;
          case 'select':
            ReactDOMSelect.mountWrapper(this, props, hostParent);
            props = ReactDOMSelect.getHostProps(this, props);
            transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
            break;
          case 'textarea':
            ReactDOMTextarea.mountWrapper(this, props, hostParent);
            props = ReactDOMTextarea.getHostProps(this, props);
            transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
            break;
        }
        assertValidProps(this, props);
        var namespaceURI;
        var parentTag;
        if (hostParent != null) {
          namespaceURI = hostParent._namespaceURI;
          parentTag = hostParent._tag;
        } else if (hostContainerInfo._tag) {
          namespaceURI = hostContainerInfo._namespaceURI;
          parentTag = hostContainerInfo._tag;
        }
        if (namespaceURI == null || namespaceURI === DOMNamespaces.svg && parentTag === 'foreignobject') {
          namespaceURI = DOMNamespaces.html;
        }
        if (namespaceURI === DOMNamespaces.html) {
          if (this._tag === 'svg') {
            namespaceURI = DOMNamespaces.svg;
          } else if (this._tag === 'math') {
            namespaceURI = DOMNamespaces.mathml;
          }
        }
        this._namespaceURI = namespaceURI;
        if ('production' !== 'production') {
          var parentInfo;
          if (hostParent != null) {
            parentInfo = hostParent._ancestorInfo;
          } else if (hostContainerInfo._tag) {
            parentInfo = hostContainerInfo._ancestorInfo;
          }
          if (parentInfo) {
            validateDOMNesting(this._tag, null, this, parentInfo);
          }
          this._ancestorInfo = validateDOMNesting.updatedAncestorInfo(parentInfo, this._tag, this);
        }
        var mountImage;
        if (transaction.useCreateElement) {
          var ownerDocument = hostContainerInfo._ownerDocument;
          var el;
          if (namespaceURI === DOMNamespaces.html) {
            if (this._tag === 'script') {
              var div = ownerDocument.createElement('div');
              var type = this._currentElement.type;
              div.innerHTML = '<' + type + '></' + type + '>';
              el = div.removeChild(div.firstChild);
            } else if (props.is) {
              el = ownerDocument.createElement(this._currentElement.type, props.is);
            } else {
              el = ownerDocument.createElement(this._currentElement.type);
            }
          } else {
            el = ownerDocument.createElementNS(namespaceURI, this._currentElement.type);
          }
          ReactDOMComponentTree.precacheNode(this, el);
          this._flags |= Flags.hasCachedChildNodes;
          if (!this._hostParent) {
            DOMPropertyOperations.setAttributeForRoot(el);
          }
          this._updateDOMProperties(null, props, transaction);
          var lazyTree = DOMLazyTree(el);
          this._createInitialChildren(transaction, props, context, lazyTree);
          mountImage = lazyTree;
        } else {
          var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
          var tagContent = this._createContentMarkup(transaction, props, context);
          if (!tagContent && omittedCloseTags[this._tag]) {
            mountImage = tagOpen + '/>';
          } else {
            mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
          }
        }
        switch (this._tag) {
          case 'input':
            transaction.getReactMountReady().enqueue(inputPostMount, this);
            if (props.autoFocus) {
              transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
            }
            break;
          case 'textarea':
            transaction.getReactMountReady().enqueue(textareaPostMount, this);
            if (props.autoFocus) {
              transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
            }
            break;
          case 'select':
            if (props.autoFocus) {
              transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
            }
            break;
          case 'button':
            if (props.autoFocus) {
              transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
            }
            break;
          case 'option':
            transaction.getReactMountReady().enqueue(optionPostMount, this);
            break;
        }
        return mountImage;
      },
      _createOpenTagMarkupAndPutListeners: function (transaction, props) {
        var ret = '<' + this._currentElement.type;
        for (var propKey in props) {
          if (!props.hasOwnProperty(propKey)) {
            continue;
          }
          var propValue = props[propKey];
          if (propValue == null) {
            continue;
          }
          if (registrationNameModules.hasOwnProperty(propKey)) {
            if (propValue) {
              enqueuePutListener(this, propKey, propValue, transaction);
            }
          } else {
            if (propKey === STYLE) {
              if (propValue) {
                if ('production' !== 'production') {
                  this._previousStyle = propValue;
                }
                propValue = this._previousStyleCopy = _assign({}, props.style);
              }
              propValue = CSSPropertyOperations.createMarkupForStyles(propValue, this);
            }
            var markup = null;
            if (this._tag != null && isCustomComponent(this._tag, props)) {
              if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
                markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
              }
            } else {
              markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
            }
            if (markup) {
              ret += ' ' + markup;
            }
          }
        }
        if (transaction.renderToStaticMarkup) {
          return ret;
        }
        if (!this._hostParent) {
          ret += ' ' + DOMPropertyOperations.createMarkupForRoot();
        }
        ret += ' ' + DOMPropertyOperations.createMarkupForID(this._domID);
        return ret;
      },
      _createContentMarkup: function (transaction, props, context) {
        var ret = '';
        var innerHTML = props.dangerouslySetInnerHTML;
        if (innerHTML != null) {
          if (innerHTML.__html != null) {
            ret = innerHTML.__html;
          }
        } else {
          var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
          var childrenToUse = contentToUse != null ? null : props.children;
          if (contentToUse != null) {
            ret = escapeTextContentForBrowser(contentToUse);
            if ('production' !== 'production') {
              setAndValidateContentChildDev.call(this, contentToUse);
            }
          } else if (childrenToUse != null) {
            var mountImages = this.mountChildren(childrenToUse, transaction, context);
            ret = mountImages.join('');
          }
        }
        if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
          return '\n' + ret;
        } else {
          return ret;
        }
      },
      _createInitialChildren: function (transaction, props, context, lazyTree) {
        var innerHTML = props.dangerouslySetInnerHTML;
        if (innerHTML != null) {
          if (innerHTML.__html != null) {
            DOMLazyTree.queueHTML(lazyTree, innerHTML.__html);
          }
        } else {
          var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
          var childrenToUse = contentToUse != null ? null : props.children;
          if (contentToUse != null) {
            if ('production' !== 'production') {
              setAndValidateContentChildDev.call(this, contentToUse);
            }
            DOMLazyTree.queueText(lazyTree, contentToUse);
          } else if (childrenToUse != null) {
            var mountImages = this.mountChildren(childrenToUse, transaction, context);
            for (var i = 0; i < mountImages.length; i++) {
              DOMLazyTree.queueChild(lazyTree, mountImages[i]);
            }
          }
        }
      },
      receiveComponent: function (nextElement, transaction, context) {
        var prevElement = this._currentElement;
        this._currentElement = nextElement;
        this.updateComponent(transaction, prevElement, nextElement, context);
      },
      updateComponent: function (transaction, prevElement, nextElement, context) {
        var lastProps = prevElement.props;
        var nextProps = this._currentElement.props;
        switch (this._tag) {
          case 'input':
            lastProps = ReactDOMInput.getHostProps(this, lastProps);
            nextProps = ReactDOMInput.getHostProps(this, nextProps);
            break;
          case 'option':
            lastProps = ReactDOMOption.getHostProps(this, lastProps);
            nextProps = ReactDOMOption.getHostProps(this, nextProps);
            break;
          case 'select':
            lastProps = ReactDOMSelect.getHostProps(this, lastProps);
            nextProps = ReactDOMSelect.getHostProps(this, nextProps);
            break;
          case 'textarea':
            lastProps = ReactDOMTextarea.getHostProps(this, lastProps);
            nextProps = ReactDOMTextarea.getHostProps(this, nextProps);
            break;
        }
        assertValidProps(this, nextProps);
        this._updateDOMProperties(lastProps, nextProps, transaction);
        this._updateDOMChildren(lastProps, nextProps, transaction, context);
        switch (this._tag) {
          case 'input':
            ReactDOMInput.updateWrapper(this);
            break;
          case 'textarea':
            ReactDOMTextarea.updateWrapper(this);
            break;
          case 'select':
            transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
            break;
        }
      },
      _updateDOMProperties: function (lastProps, nextProps, transaction) {
        var propKey;
        var styleName;
        var styleUpdates;
        for (propKey in lastProps) {
          if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
            continue;
          }
          if (propKey === STYLE) {
            var lastStyle = this._previousStyleCopy;
            for (styleName in lastStyle) {
              if (lastStyle.hasOwnProperty(styleName)) {
                styleUpdates = styleUpdates || {};
                styleUpdates[styleName] = '';
              }
            }
            this._previousStyleCopy = null;
          } else if (registrationNameModules.hasOwnProperty(propKey)) {
            if (lastProps[propKey]) {
              deleteListener(this, propKey);
            }
          } else if (isCustomComponent(this._tag, lastProps)) {
            if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
              DOMPropertyOperations.deleteValueForAttribute(getNode(this), propKey);
            }
          } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
            DOMPropertyOperations.deleteValueForProperty(getNode(this), propKey);
          }
        }
        for (propKey in nextProps) {
          var nextProp = nextProps[propKey];
          var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps != null ? lastProps[propKey] : undefined;
          if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
            continue;
          }
          if (propKey === STYLE) {
            if (nextProp) {
              if ('production' !== 'production') {
                checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
                this._previousStyle = nextProp;
              }
              nextProp = this._previousStyleCopy = _assign({}, nextProp);
            } else {
              this._previousStyleCopy = null;
            }
            if (lastProp) {
              for (styleName in lastProp) {
                if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
                  styleUpdates = styleUpdates || {};
                  styleUpdates[styleName] = '';
                }
              }
              for (styleName in nextProp) {
                if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
                  styleUpdates = styleUpdates || {};
                  styleUpdates[styleName] = nextProp[styleName];
                }
              }
            } else {
              styleUpdates = nextProp;
            }
          } else if (registrationNameModules.hasOwnProperty(propKey)) {
            if (nextProp) {
              enqueuePutListener(this, propKey, nextProp, transaction);
            } else if (lastProp) {
              deleteListener(this, propKey);
            }
          } else if (isCustomComponent(this._tag, nextProps)) {
            if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
              DOMPropertyOperations.setValueForAttribute(getNode(this), propKey, nextProp);
            }
          } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
            var node = getNode(this);
            if (nextProp != null) {
              DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
            } else {
              DOMPropertyOperations.deleteValueForProperty(node, propKey);
            }
          }
        }
        if (styleUpdates) {
          CSSPropertyOperations.setValueForStyles(getNode(this), styleUpdates, this);
        }
      },
      _updateDOMChildren: function (lastProps, nextProps, transaction, context) {
        var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
        var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;
        var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
        var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;
        var lastChildren = lastContent != null ? null : lastProps.children;
        var nextChildren = nextContent != null ? null : nextProps.children;
        var lastHasContentOrHtml = lastContent != null || lastHtml != null;
        var nextHasContentOrHtml = nextContent != null || nextHtml != null;
        if (lastChildren != null && nextChildren == null) {
          this.updateChildren(null, transaction, context);
        } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
          this.updateTextContent('');
          if ('production' !== 'production') {
            ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
          }
        }
        if (nextContent != null) {
          if (lastContent !== nextContent) {
            this.updateTextContent('' + nextContent);
            if ('production' !== 'production') {
              setAndValidateContentChildDev.call(this, nextContent);
            }
          }
        } else if (nextHtml != null) {
          if (lastHtml !== nextHtml) {
            this.updateMarkup('' + nextHtml);
          }
          if ('production' !== 'production') {
            ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
          }
        } else if (nextChildren != null) {
          if ('production' !== 'production') {
            setAndValidateContentChildDev.call(this, null);
          }
          this.updateChildren(nextChildren, transaction, context);
        }
      },
      getHostNode: function () {
        return getNode(this);
      },
      unmountComponent: function (safely) {
        switch (this._tag) {
          case 'audio':
          case 'form':
          case 'iframe':
          case 'img':
          case 'link':
          case 'object':
          case 'source':
          case 'video':
            var listeners = this._wrapperState.listeners;
            if (listeners) {
              for (var i = 0; i < listeners.length; i++) {
                listeners[i].remove();
              }
            }
            break;
          case 'html':
          case 'head':
          case 'body':
            !false ? 'production' !== 'production' ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is impossible to unmount some top-level components (eg <html>, <head>, and <body>) reliably and efficiently. To fix this, have a single top-level component that never unmounts render these elements.', this._tag) : _prodInvariant('66', this._tag) : void 0;
            break;
        }
        this.unmountChildren(safely);
        ReactDOMComponentTree.uncacheNode(this);
        EventPluginHub.deleteAllListeners(this);
        this._rootNodeID = 0;
        this._domID = 0;
        this._wrapperState = null;
        if ('production' !== 'production') {
          setAndValidateContentChildDev.call(this, null);
        }
      },
      getPublicInstance: function () {
        return getNode(this);
      }
    };
    _assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);
    module.exports = ReactDOMComponent;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('ab', ['63', 'a4', '6c'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var _assign = $__require('63');
  var DOMLazyTree = $__require('a4');
  var ReactDOMComponentTree = $__require('6c');
  var ReactDOMEmptyComponent = function (instantiate) {
    this._currentElement = null;
    this._hostNode = null;
    this._hostParent = null;
    this._hostContainerInfo = null;
    this._domID = 0;
  };
  _assign(ReactDOMEmptyComponent.prototype, {
    mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
      var domID = hostContainerInfo._idCounter++;
      this._domID = domID;
      this._hostParent = hostParent;
      this._hostContainerInfo = hostContainerInfo;
      var nodeValue = ' react-empty: ' + this._domID + ' ';
      if (transaction.useCreateElement) {
        var ownerDocument = hostContainerInfo._ownerDocument;
        var node = ownerDocument.createComment(nodeValue);
        ReactDOMComponentTree.precacheNode(this, node);
        return DOMLazyTree(node);
      } else {
        if (transaction.renderToStaticMarkup) {
          return '';
        }
        return '<!--' + nodeValue + '-->';
      }
    },
    receiveComponent: function () {},
    getHostNode: function () {
      return ReactDOMComponentTree.getNodeFromInstance(this);
    },
    unmountComponent: function () {
      ReactDOMComponentTree.uncacheNode(this);
    }
  });
  module.exports = ReactDOMEmptyComponent;
  return module.exports;
});
$__System.registerDynamic('ac', ['89', '8b', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('89');
    var invariant = $__require('8b');
    function getLowestCommonAncestor(instA, instB) {
      !('_hostNode' in instA) ? 'production' !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
      !('_hostNode' in instB) ? 'production' !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
      var depthA = 0;
      for (var tempA = instA; tempA; tempA = tempA._hostParent) {
        depthA++;
      }
      var depthB = 0;
      for (var tempB = instB; tempB; tempB = tempB._hostParent) {
        depthB++;
      }
      while (depthA - depthB > 0) {
        instA = instA._hostParent;
        depthA--;
      }
      while (depthB - depthA > 0) {
        instB = instB._hostParent;
        depthB--;
      }
      var depth = depthA;
      while (depth--) {
        if (instA === instB) {
          return instA;
        }
        instA = instA._hostParent;
        instB = instB._hostParent;
      }
      return null;
    }
    function isAncestor(instA, instB) {
      !('_hostNode' in instA) ? 'production' !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;
      !('_hostNode' in instB) ? 'production' !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;
      while (instB) {
        if (instB === instA) {
          return true;
        }
        instB = instB._hostParent;
      }
      return false;
    }
    function getParentInstance(inst) {
      !('_hostNode' in inst) ? 'production' !== 'production' ? invariant(false, 'getParentInstance: Invalid argument.') : _prodInvariant('36') : void 0;
      return inst._hostParent;
    }
    function traverseTwoPhase(inst, fn, arg) {
      var path = [];
      while (inst) {
        path.push(inst);
        inst = inst._hostParent;
      }
      var i;
      for (i = path.length; i-- > 0;) {
        fn(path[i], 'captured', arg);
      }
      for (i = 0; i < path.length; i++) {
        fn(path[i], 'bubbled', arg);
      }
    }
    function traverseEnterLeave(from, to, fn, argFrom, argTo) {
      var common = from && to ? getLowestCommonAncestor(from, to) : null;
      var pathFrom = [];
      while (from && from !== common) {
        pathFrom.push(from);
        from = from._hostParent;
      }
      var pathTo = [];
      while (to && to !== common) {
        pathTo.push(to);
        to = to._hostParent;
      }
      var i;
      for (i = 0; i < pathFrom.length; i++) {
        fn(pathFrom[i], 'bubbled', argFrom);
      }
      for (i = pathTo.length; i-- > 0;) {
        fn(pathTo[i], 'captured', argTo);
      }
    }
    module.exports = {
      isAncestor: isAncestor,
      getLowestCommonAncestor: getLowestCommonAncestor,
      getParentInstance: getParentInstance,
      traverseTwoPhase: traverseTwoPhase,
      traverseEnterLeave: traverseEnterLeave
    };
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('ad', ['8b', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var invariant = $__require('8b');
    function toArray(obj) {
      var length = obj.length;
      !(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function')) ? 'production' !== 'production' ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : void 0;
      !(typeof length === 'number') ? 'production' !== 'production' ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : void 0;
      !(length === 0 || length - 1 in obj) ? 'production' !== 'production' ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : void 0;
      !(typeof obj.callee !== 'function') ? 'production' !== 'production' ? invariant(false, 'toArray: Object can\'t be `arguments`. Use rest params ' + '(function(...args) {}) or Array.from() instead.') : invariant(false) : void 0;
      if (obj.hasOwnProperty) {
        try {
          return Array.prototype.slice.call(obj);
        } catch (e) {}
      }
      var ret = Array(length);
      for (var ii = 0; ii < length; ii++) {
        ret[ii] = obj[ii];
      }
      return ret;
    }
    function hasArrayNature(obj) {
      return !!obj && (typeof obj == 'object' || typeof obj == 'function') && 'length' in obj && !('setInterval' in obj) && typeof obj.nodeType != 'number' && (Array.isArray(obj) || 'callee' in obj || 'item' in obj);
    }
    function createArrayFromMixed(obj) {
      if (!hasArrayNature(obj)) {
        return [obj];
      } else if (Array.isArray(obj)) {
        return obj.slice();
      } else {
        return toArray(obj);
      }
    }
    module.exports = createArrayFromMixed;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('ae', ['69', '8b', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var ExecutionEnvironment = $__require('69');
    var invariant = $__require('8b');
    var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
    var shouldWrap = {};
    var selectWrap = [1, '<select multiple="true">', '</select>'];
    var tableWrap = [1, '<table>', '</table>'];
    var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];
    var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];
    var markupWrap = {
      '*': [1, '?<div>', '</div>'],
      'area': [1, '<map>', '</map>'],
      'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
      'legend': [1, '<fieldset>', '</fieldset>'],
      'param': [1, '<object>', '</object>'],
      'tr': [2, '<table><tbody>', '</tbody></table>'],
      'optgroup': selectWrap,
      'option': selectWrap,
      'caption': tableWrap,
      'colgroup': tableWrap,
      'tbody': tableWrap,
      'tfoot': tableWrap,
      'thead': tableWrap,
      'td': trWrap,
      'th': trWrap
    };
    var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
    svgElements.forEach(function (nodeName) {
      markupWrap[nodeName] = svgWrap;
      shouldWrap[nodeName] = true;
    });
    function getMarkupWrap(nodeName) {
      !!!dummyNode ? 'production' !== 'production' ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : void 0;
      if (!markupWrap.hasOwnProperty(nodeName)) {
        nodeName = '*';
      }
      if (!shouldWrap.hasOwnProperty(nodeName)) {
        if (nodeName === '*') {
          dummyNode.innerHTML = '<link />';
        } else {
          dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
        }
        shouldWrap[nodeName] = !dummyNode.firstChild;
      }
      return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
    }
    module.exports = getMarkupWrap;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('af', ['69', 'ad', 'ae', '8b', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var ExecutionEnvironment = $__require('69');
    var createArrayFromMixed = $__require('ad');
    var getMarkupWrap = $__require('ae');
    var invariant = $__require('8b');
    var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
    var nodeNamePattern = /^\s*<(\w+)/;
    function getNodeName(markup) {
      var nodeNameMatch = markup.match(nodeNamePattern);
      return nodeNameMatch && nodeNameMatch[1].toLowerCase();
    }
    function createNodesFromMarkup(markup, handleScript) {
      var node = dummyNode;
      !!!dummyNode ? 'production' !== 'production' ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : void 0;
      var nodeName = getNodeName(markup);
      var wrap = nodeName && getMarkupWrap(nodeName);
      if (wrap) {
        node.innerHTML = wrap[1] + markup + wrap[2];
        var wrapDepth = wrap[0];
        while (wrapDepth--) {
          node = node.lastChild;
        }
      } else {
        node.innerHTML = markup;
      }
      var scripts = node.getElementsByTagName('script');
      if (scripts.length) {
        !handleScript ? 'production' !== 'production' ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : void 0;
        createArrayFromMixed(scripts).forEach(handleScript);
      }
      var nodes = Array.from(node.childNodes);
      while (node.lastChild) {
        node.removeChild(node.lastChild);
      }
      return nodes;
    }
    module.exports = createNodesFromMarkup;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('b0', ['89', 'a4', '69', 'af', '9e', '8b', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('89');
    var DOMLazyTree = $__require('a4');
    var ExecutionEnvironment = $__require('69');
    var createNodesFromMarkup = $__require('af');
    var emptyFunction = $__require('9e');
    var invariant = $__require('8b');
    var Danger = { dangerouslyReplaceNodeWithMarkup: function (oldChild, markup) {
        !ExecutionEnvironment.canUseDOM ? 'production' !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a worker thread. Make sure `window` and `document` are available globally before requiring React when unit testing or use ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('56') : void 0;
        !markup ? 'production' !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : _prodInvariant('57') : void 0;
        !(oldChild.nodeName !== 'HTML') ? 'production' !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the <html> node. This is because browser quirks make this unreliable and/or slow. If you want to render to the root you must use server rendering. See ReactDOMServer.renderToString().') : _prodInvariant('58') : void 0;
        if (typeof markup === 'string') {
          var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
          oldChild.parentNode.replaceChild(newChild, oldChild);
        } else {
          DOMLazyTree.replaceChildWithTree(oldChild, markup);
        }
      } };
    module.exports = Danger;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('77', ['a4', 'b0', '6c', '84', 'b1', 'b2', 'b3', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var DOMLazyTree = $__require('a4');
    var Danger = $__require('b0');
    var ReactDOMComponentTree = $__require('6c');
    var ReactInstrumentation = $__require('84');
    var createMicrosoftUnsafeLocalFunction = $__require('b1');
    var setInnerHTML = $__require('b2');
    var setTextContent = $__require('b3');
    function getNodeAfter(parentNode, node) {
      if (Array.isArray(node)) {
        node = node[1];
      }
      return node ? node.nextSibling : parentNode.firstChild;
    }
    var insertChildAt = createMicrosoftUnsafeLocalFunction(function (parentNode, childNode, referenceNode) {
      parentNode.insertBefore(childNode, referenceNode);
    });
    function insertLazyTreeChildAt(parentNode, childTree, referenceNode) {
      DOMLazyTree.insertTreeBefore(parentNode, childTree, referenceNode);
    }
    function moveChild(parentNode, childNode, referenceNode) {
      if (Array.isArray(childNode)) {
        moveDelimitedText(parentNode, childNode[0], childNode[1], referenceNode);
      } else {
        insertChildAt(parentNode, childNode, referenceNode);
      }
    }
    function removeChild(parentNode, childNode) {
      if (Array.isArray(childNode)) {
        var closingComment = childNode[1];
        childNode = childNode[0];
        removeDelimitedText(parentNode, childNode, closingComment);
        parentNode.removeChild(closingComment);
      }
      parentNode.removeChild(childNode);
    }
    function moveDelimitedText(parentNode, openingComment, closingComment, referenceNode) {
      var node = openingComment;
      while (true) {
        var nextNode = node.nextSibling;
        insertChildAt(parentNode, node, referenceNode);
        if (node === closingComment) {
          break;
        }
        node = nextNode;
      }
    }
    function removeDelimitedText(parentNode, startNode, closingComment) {
      while (true) {
        var node = startNode.nextSibling;
        if (node === closingComment) {
          break;
        } else {
          parentNode.removeChild(node);
        }
      }
    }
    function replaceDelimitedText(openingComment, closingComment, stringText) {
      var parentNode = openingComment.parentNode;
      var nodeAfterComment = openingComment.nextSibling;
      if (nodeAfterComment === closingComment) {
        if (stringText) {
          insertChildAt(parentNode, document.createTextNode(stringText), nodeAfterComment);
        }
      } else {
        if (stringText) {
          setTextContent(nodeAfterComment, stringText);
          removeDelimitedText(parentNode, nodeAfterComment, closingComment);
        } else {
          removeDelimitedText(parentNode, openingComment, closingComment);
        }
      }
      if ('production' !== 'production') {
        ReactInstrumentation.debugTool.onHostOperation({
          instanceID: ReactDOMComponentTree.getInstanceFromNode(openingComment)._debugID,
          type: 'replace text',
          payload: stringText
        });
      }
    }
    var dangerouslyReplaceNodeWithMarkup = Danger.dangerouslyReplaceNodeWithMarkup;
    if ('production' !== 'production') {
      dangerouslyReplaceNodeWithMarkup = function (oldChild, markup, prevInstance) {
        Danger.dangerouslyReplaceNodeWithMarkup(oldChild, markup);
        if (prevInstance._debugID !== 0) {
          ReactInstrumentation.debugTool.onHostOperation({
            instanceID: prevInstance._debugID,
            type: 'replace with',
            payload: markup.toString()
          });
        } else {
          var nextInstance = ReactDOMComponentTree.getInstanceFromNode(markup.node);
          if (nextInstance._debugID !== 0) {
            ReactInstrumentation.debugTool.onHostOperation({
              instanceID: nextInstance._debugID,
              type: 'mount',
              payload: markup.toString()
            });
          }
        }
      };
    }
    var DOMChildrenOperations = {
      dangerouslyReplaceNodeWithMarkup: dangerouslyReplaceNodeWithMarkup,
      replaceDelimitedText: replaceDelimitedText,
      processUpdates: function (parentNode, updates) {
        if ('production' !== 'production') {
          var parentNodeDebugID = ReactDOMComponentTree.getInstanceFromNode(parentNode)._debugID;
        }
        for (var k = 0; k < updates.length; k++) {
          var update = updates[k];
          switch (update.type) {
            case 'INSERT_MARKUP':
              insertLazyTreeChildAt(parentNode, update.content, getNodeAfter(parentNode, update.afterNode));
              if ('production' !== 'production') {
                ReactInstrumentation.debugTool.onHostOperation({
                  instanceID: parentNodeDebugID,
                  type: 'insert child',
                  payload: {
                    toIndex: update.toIndex,
                    content: update.content.toString()
                  }
                });
              }
              break;
            case 'MOVE_EXISTING':
              moveChild(parentNode, update.fromNode, getNodeAfter(parentNode, update.afterNode));
              if ('production' !== 'production') {
                ReactInstrumentation.debugTool.onHostOperation({
                  instanceID: parentNodeDebugID,
                  type: 'move child',
                  payload: {
                    fromIndex: update.fromIndex,
                    toIndex: update.toIndex
                  }
                });
              }
              break;
            case 'SET_MARKUP':
              setInnerHTML(parentNode, update.content);
              if ('production' !== 'production') {
                ReactInstrumentation.debugTool.onHostOperation({
                  instanceID: parentNodeDebugID,
                  type: 'replace children',
                  payload: update.content.toString()
                });
              }
              break;
            case 'TEXT_CONTENT':
              setTextContent(parentNode, update.content);
              if ('production' !== 'production') {
                ReactInstrumentation.debugTool.onHostOperation({
                  instanceID: parentNodeDebugID,
                  type: 'replace text',
                  payload: update.content.toString()
                });
              }
              break;
            case 'REMOVE_NODE':
              removeChild(parentNode, update.fromNode);
              if ('production' !== 'production') {
                ReactInstrumentation.debugTool.onHostOperation({
                  instanceID: parentNodeDebugID,
                  type: 'remove child',
                  payload: { fromIndex: update.fromIndex }
                });
              }
              break;
          }
        }
      }
    };
    module.exports = DOMChildrenOperations;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('b4', ['89', '63', '77', 'a4', '6c', '86', '8b', 'a9', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('89'),
        _assign = $__require('63');
    var DOMChildrenOperations = $__require('77');
    var DOMLazyTree = $__require('a4');
    var ReactDOMComponentTree = $__require('6c');
    var escapeTextContentForBrowser = $__require('86');
    var invariant = $__require('8b');
    var validateDOMNesting = $__require('a9');
    var ReactDOMTextComponent = function (text) {
      this._currentElement = text;
      this._stringText = '' + text;
      this._hostNode = null;
      this._hostParent = null;
      this._domID = 0;
      this._mountIndex = 0;
      this._closingComment = null;
      this._commentNodes = null;
    };
    _assign(ReactDOMTextComponent.prototype, {
      mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
        if ('production' !== 'production') {
          var parentInfo;
          if (hostParent != null) {
            parentInfo = hostParent._ancestorInfo;
          } else if (hostContainerInfo != null) {
            parentInfo = hostContainerInfo._ancestorInfo;
          }
          if (parentInfo) {
            validateDOMNesting(null, this._stringText, this, parentInfo);
          }
        }
        var domID = hostContainerInfo._idCounter++;
        var openingValue = ' react-text: ' + domID + ' ';
        var closingValue = ' /react-text ';
        this._domID = domID;
        this._hostParent = hostParent;
        if (transaction.useCreateElement) {
          var ownerDocument = hostContainerInfo._ownerDocument;
          var openingComment = ownerDocument.createComment(openingValue);
          var closingComment = ownerDocument.createComment(closingValue);
          var lazyTree = DOMLazyTree(ownerDocument.createDocumentFragment());
          DOMLazyTree.queueChild(lazyTree, DOMLazyTree(openingComment));
          if (this._stringText) {
            DOMLazyTree.queueChild(lazyTree, DOMLazyTree(ownerDocument.createTextNode(this._stringText)));
          }
          DOMLazyTree.queueChild(lazyTree, DOMLazyTree(closingComment));
          ReactDOMComponentTree.precacheNode(this, openingComment);
          this._closingComment = closingComment;
          return lazyTree;
        } else {
          var escapedText = escapeTextContentForBrowser(this._stringText);
          if (transaction.renderToStaticMarkup) {
            return escapedText;
          }
          return '<!--' + openingValue + '-->' + escapedText + '<!--' + closingValue + '-->';
        }
      },
      receiveComponent: function (nextText, transaction) {
        if (nextText !== this._currentElement) {
          this._currentElement = nextText;
          var nextStringText = '' + nextText;
          if (nextStringText !== this._stringText) {
            this._stringText = nextStringText;
            var commentNodes = this.getHostNode();
            DOMChildrenOperations.replaceDelimitedText(commentNodes[0], commentNodes[1], nextStringText);
          }
        }
      },
      getHostNode: function () {
        var hostNode = this._commentNodes;
        if (hostNode) {
          return hostNode;
        }
        if (!this._closingComment) {
          var openingComment = ReactDOMComponentTree.getNodeFromInstance(this);
          var node = openingComment.nextSibling;
          while (true) {
            !(node != null) ? 'production' !== 'production' ? invariant(false, 'Missing closing comment for text component %s', this._domID) : _prodInvariant('67', this._domID) : void 0;
            if (node.nodeType === 8 && node.nodeValue === ' /react-text ') {
              this._closingComment = node;
              break;
            }
            node = node.nextSibling;
          }
        }
        hostNode = [this._hostNode, this._closingComment];
        this._commentNodes = hostNode;
        return hostNode;
      },
      unmountComponent: function () {
        this._closingComment = null;
        this._commentNodes = null;
        ReactDOMComponentTree.uncacheNode(this);
      }
    });
    module.exports = ReactDOMTextComponent;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('b5', ['63', '6d', 'a2', '9e'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var _assign = $__require('63');
  var ReactUpdates = $__require('6d');
  var Transaction = $__require('a2');
  var emptyFunction = $__require('9e');
  var RESET_BATCHED_UPDATES = {
    initialize: emptyFunction,
    close: function () {
      ReactDefaultBatchingStrategy.isBatchingUpdates = false;
    }
  };
  var FLUSH_BATCHED_UPDATES = {
    initialize: emptyFunction,
    close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
  };
  var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];
  function ReactDefaultBatchingStrategyTransaction() {
    this.reinitializeTransaction();
  }
  _assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction, { getTransactionWrappers: function () {
      return TRANSACTION_WRAPPERS;
    } });
  var transaction = new ReactDefaultBatchingStrategyTransaction();
  var ReactDefaultBatchingStrategy = {
    isBatchingUpdates: false,
    batchedUpdates: function (callback, a, b, c, d, e) {
      var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;
      ReactDefaultBatchingStrategy.isBatchingUpdates = true;
      if (alreadyBatchingUpdates) {
        return callback(a, b, c, d, e);
      } else {
        return transaction.perform(callback, null, a, b, c, d, e);
      }
    }
  };
  module.exports = ReactDefaultBatchingStrategy;
  return module.exports;
});
$__System.registerDynamic('b6', [], true, function ($__require, exports, module) {
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @typechecks
   */

  'use strict';

  /**
   * Gets the scroll position of the supplied element or window.
   *
   * The return values are unbounded, unlike `getScrollPosition`. This means they
   * may be negative or exceed the element boundaries (which is possible using
   * inertial scrolling).
   *
   * @param {DOMWindow|DOMElement} scrollable
   * @return {object} Map with `x` and `y` keys.
   */

  var define,
      global = this || self,
      GLOBAL = global;
  function getUnboundedScrollPosition(scrollable) {
    if (scrollable === window) {
      return {
        x: window.pageXOffset || document.documentElement.scrollLeft,
        y: window.pageYOffset || document.documentElement.scrollTop
      };
    }
    return {
      x: scrollable.scrollLeft,
      y: scrollable.scrollTop
    };
  }

  module.exports = getUnboundedScrollPosition;
  return module.exports;
});
$__System.registerDynamic('b7', ['63', 'b8', '69', '61', '6c', '6d', '6e', 'b6', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _assign = $__require('63');
    var EventListener = $__require('b8');
    var ExecutionEnvironment = $__require('69');
    var PooledClass = $__require('61');
    var ReactDOMComponentTree = $__require('6c');
    var ReactUpdates = $__require('6d');
    var getEventTarget = $__require('6e');
    var getUnboundedScrollPosition = $__require('b6');
    function findParent(inst) {
      while (inst._hostParent) {
        inst = inst._hostParent;
      }
      var rootNode = ReactDOMComponentTree.getNodeFromInstance(inst);
      var container = rootNode.parentNode;
      return ReactDOMComponentTree.getClosestInstanceFromNode(container);
    }
    function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
      this.topLevelType = topLevelType;
      this.nativeEvent = nativeEvent;
      this.ancestors = [];
    }
    _assign(TopLevelCallbackBookKeeping.prototype, { destructor: function () {
        this.topLevelType = null;
        this.nativeEvent = null;
        this.ancestors.length = 0;
      } });
    PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);
    function handleTopLevelImpl(bookKeeping) {
      var nativeEventTarget = getEventTarget(bookKeeping.nativeEvent);
      var targetInst = ReactDOMComponentTree.getClosestInstanceFromNode(nativeEventTarget);
      var ancestor = targetInst;
      do {
        bookKeeping.ancestors.push(ancestor);
        ancestor = ancestor && findParent(ancestor);
      } while (ancestor);
      for (var i = 0; i < bookKeeping.ancestors.length; i++) {
        targetInst = bookKeeping.ancestors[i];
        ReactEventListener._handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
      }
    }
    function scrollValueMonitor(cb) {
      var scrollPosition = getUnboundedScrollPosition(window);
      cb(scrollPosition);
    }
    var ReactEventListener = {
      _enabled: true,
      _handleTopLevel: null,
      WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,
      setHandleTopLevel: function (handleTopLevel) {
        ReactEventListener._handleTopLevel = handleTopLevel;
      },
      setEnabled: function (enabled) {
        ReactEventListener._enabled = !!enabled;
      },
      isEnabled: function () {
        return ReactEventListener._enabled;
      },
      trapBubbledEvent: function (topLevelType, handlerBaseName, element) {
        if (!element) {
          return null;
        }
        return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
      },
      trapCapturedEvent: function (topLevelType, handlerBaseName, element) {
        if (!element) {
          return null;
        }
        return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
      },
      monitorScrollValue: function (refresh) {
        var callback = scrollValueMonitor.bind(null, refresh);
        EventListener.listen(window, 'scroll', callback);
      },
      dispatchEvent: function (topLevelType, nativeEvent) {
        if (!ReactEventListener._enabled) {
          return;
        }
        var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
        try {
          ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
        } finally {
          TopLevelCallbackBookKeeping.release(bookKeeping);
        }
      }
    };
    module.exports = ReactEventListener;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('b9', ['75', '6b', 'ba', '9c', 'bb', 'a7', 'bc', '6d'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var DOMProperty = $__require('75');
  var EventPluginHub = $__require('6b');
  var EventPluginUtils = $__require('ba');
  var ReactComponentEnvironment = $__require('9c');
  var ReactEmptyComponent = $__require('bb');
  var ReactBrowserEventEmitter = $__require('a7');
  var ReactHostComponent = $__require('bc');
  var ReactUpdates = $__require('6d');
  var ReactInjection = {
    Component: ReactComponentEnvironment.injection,
    DOMProperty: DOMProperty.injection,
    EmptyComponent: ReactEmptyComponent.injection,
    EventPluginHub: EventPluginHub.injection,
    EventPluginUtils: EventPluginUtils.injection,
    EventEmitter: ReactBrowserEventEmitter.injection,
    HostComponent: ReactHostComponent.injection,
    Updates: ReactUpdates.injection
  };
  module.exports = ReactInjection;
  return module.exports;
});
$__System.registerDynamic('bd', ['63', 'be', '61', 'a7', 'bf', '84', 'a2', 'a0', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _assign = $__require('63');
    var CallbackQueue = $__require('be');
    var PooledClass = $__require('61');
    var ReactBrowserEventEmitter = $__require('a7');
    var ReactInputSelection = $__require('bf');
    var ReactInstrumentation = $__require('84');
    var Transaction = $__require('a2');
    var ReactUpdateQueue = $__require('a0');
    var SELECTION_RESTORATION = {
      initialize: ReactInputSelection.getSelectionInformation,
      close: ReactInputSelection.restoreSelection
    };
    var EVENT_SUPPRESSION = {
      initialize: function () {
        var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
        ReactBrowserEventEmitter.setEnabled(false);
        return currentlyEnabled;
      },
      close: function (previouslyEnabled) {
        ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
      }
    };
    var ON_DOM_READY_QUEUEING = {
      initialize: function () {
        this.reactMountReady.reset();
      },
      close: function () {
        this.reactMountReady.notifyAll();
      }
    };
    var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];
    if ('production' !== 'production') {
      TRANSACTION_WRAPPERS.push({
        initialize: ReactInstrumentation.debugTool.onBeginFlush,
        close: ReactInstrumentation.debugTool.onEndFlush
      });
    }
    function ReactReconcileTransaction(useCreateElement) {
      this.reinitializeTransaction();
      this.renderToStaticMarkup = false;
      this.reactMountReady = CallbackQueue.getPooled(null);
      this.useCreateElement = useCreateElement;
    }
    var Mixin = {
      getTransactionWrappers: function () {
        return TRANSACTION_WRAPPERS;
      },
      getReactMountReady: function () {
        return this.reactMountReady;
      },
      getUpdateQueue: function () {
        return ReactUpdateQueue;
      },
      checkpoint: function () {
        return this.reactMountReady.checkpoint();
      },
      rollback: function (checkpoint) {
        this.reactMountReady.rollback(checkpoint);
      },
      destructor: function () {
        CallbackQueue.release(this.reactMountReady);
        this.reactMountReady = null;
      }
    };
    _assign(ReactReconcileTransaction.prototype, Transaction, Mixin);
    PooledClass.addPoolingTo(ReactReconcileTransaction);
    module.exports = ReactReconcileTransaction;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('c0', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var NS = {
    xlink: 'http://www.w3.org/1999/xlink',
    xml: 'http://www.w3.org/XML/1998/namespace'
  };

  // We use attributes for everything SVG so let's avoid some duplication and run
  // code instead.
  // The following are all specified in the HTML config already so we exclude here.
  // - class (as className)
  // - color
  // - height
  // - id
  // - lang
  // - max
  // - media
  // - method
  // - min
  // - name
  // - style
  // - target
  // - type
  // - width
  var ATTRS = {
    accentHeight: 'accent-height',
    accumulate: 0,
    additive: 0,
    alignmentBaseline: 'alignment-baseline',
    allowReorder: 'allowReorder',
    alphabetic: 0,
    amplitude: 0,
    arabicForm: 'arabic-form',
    ascent: 0,
    attributeName: 'attributeName',
    attributeType: 'attributeType',
    autoReverse: 'autoReverse',
    azimuth: 0,
    baseFrequency: 'baseFrequency',
    baseProfile: 'baseProfile',
    baselineShift: 'baseline-shift',
    bbox: 0,
    begin: 0,
    bias: 0,
    by: 0,
    calcMode: 'calcMode',
    capHeight: 'cap-height',
    clip: 0,
    clipPath: 'clip-path',
    clipRule: 'clip-rule',
    clipPathUnits: 'clipPathUnits',
    colorInterpolation: 'color-interpolation',
    colorInterpolationFilters: 'color-interpolation-filters',
    colorProfile: 'color-profile',
    colorRendering: 'color-rendering',
    contentScriptType: 'contentScriptType',
    contentStyleType: 'contentStyleType',
    cursor: 0,
    cx: 0,
    cy: 0,
    d: 0,
    decelerate: 0,
    descent: 0,
    diffuseConstant: 'diffuseConstant',
    direction: 0,
    display: 0,
    divisor: 0,
    dominantBaseline: 'dominant-baseline',
    dur: 0,
    dx: 0,
    dy: 0,
    edgeMode: 'edgeMode',
    elevation: 0,
    enableBackground: 'enable-background',
    end: 0,
    exponent: 0,
    externalResourcesRequired: 'externalResourcesRequired',
    fill: 0,
    fillOpacity: 'fill-opacity',
    fillRule: 'fill-rule',
    filter: 0,
    filterRes: 'filterRes',
    filterUnits: 'filterUnits',
    floodColor: 'flood-color',
    floodOpacity: 'flood-opacity',
    focusable: 0,
    fontFamily: 'font-family',
    fontSize: 'font-size',
    fontSizeAdjust: 'font-size-adjust',
    fontStretch: 'font-stretch',
    fontStyle: 'font-style',
    fontVariant: 'font-variant',
    fontWeight: 'font-weight',
    format: 0,
    from: 0,
    fx: 0,
    fy: 0,
    g1: 0,
    g2: 0,
    glyphName: 'glyph-name',
    glyphOrientationHorizontal: 'glyph-orientation-horizontal',
    glyphOrientationVertical: 'glyph-orientation-vertical',
    glyphRef: 'glyphRef',
    gradientTransform: 'gradientTransform',
    gradientUnits: 'gradientUnits',
    hanging: 0,
    horizAdvX: 'horiz-adv-x',
    horizOriginX: 'horiz-origin-x',
    ideographic: 0,
    imageRendering: 'image-rendering',
    'in': 0,
    in2: 0,
    intercept: 0,
    k: 0,
    k1: 0,
    k2: 0,
    k3: 0,
    k4: 0,
    kernelMatrix: 'kernelMatrix',
    kernelUnitLength: 'kernelUnitLength',
    kerning: 0,
    keyPoints: 'keyPoints',
    keySplines: 'keySplines',
    keyTimes: 'keyTimes',
    lengthAdjust: 'lengthAdjust',
    letterSpacing: 'letter-spacing',
    lightingColor: 'lighting-color',
    limitingConeAngle: 'limitingConeAngle',
    local: 0,
    markerEnd: 'marker-end',
    markerMid: 'marker-mid',
    markerStart: 'marker-start',
    markerHeight: 'markerHeight',
    markerUnits: 'markerUnits',
    markerWidth: 'markerWidth',
    mask: 0,
    maskContentUnits: 'maskContentUnits',
    maskUnits: 'maskUnits',
    mathematical: 0,
    mode: 0,
    numOctaves: 'numOctaves',
    offset: 0,
    opacity: 0,
    operator: 0,
    order: 0,
    orient: 0,
    orientation: 0,
    origin: 0,
    overflow: 0,
    overlinePosition: 'overline-position',
    overlineThickness: 'overline-thickness',
    paintOrder: 'paint-order',
    panose1: 'panose-1',
    pathLength: 'pathLength',
    patternContentUnits: 'patternContentUnits',
    patternTransform: 'patternTransform',
    patternUnits: 'patternUnits',
    pointerEvents: 'pointer-events',
    points: 0,
    pointsAtX: 'pointsAtX',
    pointsAtY: 'pointsAtY',
    pointsAtZ: 'pointsAtZ',
    preserveAlpha: 'preserveAlpha',
    preserveAspectRatio: 'preserveAspectRatio',
    primitiveUnits: 'primitiveUnits',
    r: 0,
    radius: 0,
    refX: 'refX',
    refY: 'refY',
    renderingIntent: 'rendering-intent',
    repeatCount: 'repeatCount',
    repeatDur: 'repeatDur',
    requiredExtensions: 'requiredExtensions',
    requiredFeatures: 'requiredFeatures',
    restart: 0,
    result: 0,
    rotate: 0,
    rx: 0,
    ry: 0,
    scale: 0,
    seed: 0,
    shapeRendering: 'shape-rendering',
    slope: 0,
    spacing: 0,
    specularConstant: 'specularConstant',
    specularExponent: 'specularExponent',
    speed: 0,
    spreadMethod: 'spreadMethod',
    startOffset: 'startOffset',
    stdDeviation: 'stdDeviation',
    stemh: 0,
    stemv: 0,
    stitchTiles: 'stitchTiles',
    stopColor: 'stop-color',
    stopOpacity: 'stop-opacity',
    strikethroughPosition: 'strikethrough-position',
    strikethroughThickness: 'strikethrough-thickness',
    string: 0,
    stroke: 0,
    strokeDasharray: 'stroke-dasharray',
    strokeDashoffset: 'stroke-dashoffset',
    strokeLinecap: 'stroke-linecap',
    strokeLinejoin: 'stroke-linejoin',
    strokeMiterlimit: 'stroke-miterlimit',
    strokeOpacity: 'stroke-opacity',
    strokeWidth: 'stroke-width',
    surfaceScale: 'surfaceScale',
    systemLanguage: 'systemLanguage',
    tableValues: 'tableValues',
    targetX: 'targetX',
    targetY: 'targetY',
    textAnchor: 'text-anchor',
    textDecoration: 'text-decoration',
    textRendering: 'text-rendering',
    textLength: 'textLength',
    to: 0,
    transform: 0,
    u1: 0,
    u2: 0,
    underlinePosition: 'underline-position',
    underlineThickness: 'underline-thickness',
    unicode: 0,
    unicodeBidi: 'unicode-bidi',
    unicodeRange: 'unicode-range',
    unitsPerEm: 'units-per-em',
    vAlphabetic: 'v-alphabetic',
    vHanging: 'v-hanging',
    vIdeographic: 'v-ideographic',
    vMathematical: 'v-mathematical',
    values: 0,
    vectorEffect: 'vector-effect',
    version: 0,
    vertAdvY: 'vert-adv-y',
    vertOriginX: 'vert-origin-x',
    vertOriginY: 'vert-origin-y',
    viewBox: 'viewBox',
    viewTarget: 'viewTarget',
    visibility: 0,
    widths: 0,
    wordSpacing: 'word-spacing',
    writingMode: 'writing-mode',
    x: 0,
    xHeight: 'x-height',
    x1: 0,
    x2: 0,
    xChannelSelector: 'xChannelSelector',
    xlinkActuate: 'xlink:actuate',
    xlinkArcrole: 'xlink:arcrole',
    xlinkHref: 'xlink:href',
    xlinkRole: 'xlink:role',
    xlinkShow: 'xlink:show',
    xlinkTitle: 'xlink:title',
    xlinkType: 'xlink:type',
    xmlBase: 'xml:base',
    xmlns: 0,
    xmlnsXlink: 'xmlns:xlink',
    xmlLang: 'xml:lang',
    xmlSpace: 'xml:space',
    y: 0,
    y1: 0,
    y2: 0,
    yChannelSelector: 'yChannelSelector',
    z: 0,
    zoomAndPan: 'zoomAndPan'
  };

  var SVGDOMPropertyConfig = {
    Properties: {},
    DOMAttributeNamespaces: {
      xlinkActuate: NS.xlink,
      xlinkArcrole: NS.xlink,
      xlinkHref: NS.xlink,
      xlinkRole: NS.xlink,
      xlinkShow: NS.xlink,
      xlinkTitle: NS.xlink,
      xlinkType: NS.xlink,
      xmlBase: NS.xml,
      xmlLang: NS.xml,
      xmlSpace: NS.xml
    },
    DOMAttributeNames: {}
  };

  Object.keys(ATTRS).forEach(function (key) {
    SVGDOMPropertyConfig.Properties[key] = 0;
    if (ATTRS[key]) {
      SVGDOMPropertyConfig.DOMAttributeNames[key] = ATTRS[key];
    }
  });

  module.exports = SVGDOMPropertyConfig;
  return module.exports;
});
$__System.registerDynamic('c1', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  /**
   * Given any node return the first leaf node without children.
   *
   * @param {DOMElement|DOMTextNode} node
   * @return {DOMElement|DOMTextNode}
   */

  var define,
      global = this || self,
      GLOBAL = global;
  function getLeafNode(node) {
    while (node && node.firstChild) {
      node = node.firstChild;
    }
    return node;
  }

  /**
   * Get the next sibling within a container. This will walk up the
   * DOM if a node's siblings have been exhausted.
   *
   * @param {DOMElement|DOMTextNode} node
   * @return {?DOMElement|DOMTextNode}
   */
  function getSiblingNode(node) {
    while (node) {
      if (node.nextSibling) {
        return node.nextSibling;
      }
      node = node.parentNode;
    }
  }

  /**
   * Get object describing the nodes which contain characters at offset.
   *
   * @param {DOMElement|DOMTextNode} root
   * @param {number} offset
   * @return {?object}
   */
  function getNodeForCharacterOffset(root, offset) {
    var node = getLeafNode(root);
    var nodeStart = 0;
    var nodeEnd = 0;

    while (node) {
      if (node.nodeType === 3) {
        nodeEnd = nodeStart + node.textContent.length;

        if (nodeStart <= offset && nodeEnd >= offset) {
          return {
            node: node,
            offset: offset - nodeStart
          };
        }

        nodeStart = nodeEnd;
      }

      node = getLeafNode(getSiblingNode(node));
    }
  }

  module.exports = getNodeForCharacterOffset;
  return module.exports;
});
$__System.registerDynamic('62', ['69'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var ExecutionEnvironment = $__require('69');

  var contentKey = null;

  /**
   * Gets the key used to access text content on a DOM node.
   *
   * @return {?string} Key used to access text content.
   * @internal
   */
  function getTextContentAccessor() {
    if (!contentKey && ExecutionEnvironment.canUseDOM) {
      // Prefer textContent to innerText because many browsers support both but
      // SVG <text> elements don't support innerText even when <div> does.
      contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
    }
    return contentKey;
  }

  module.exports = getTextContentAccessor;
  return module.exports;
});
$__System.registerDynamic('c2', ['69', 'c1', '62'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var ExecutionEnvironment = $__require('69');
  var getNodeForCharacterOffset = $__require('c1');
  var getTextContentAccessor = $__require('62');
  function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
    return anchorNode === focusNode && anchorOffset === focusOffset;
  }
  function getIEOffsets(node) {
    var selection = document.selection;
    var selectedRange = selection.createRange();
    var selectedLength = selectedRange.text.length;
    var fromStart = selectedRange.duplicate();
    fromStart.moveToElementText(node);
    fromStart.setEndPoint('EndToStart', selectedRange);
    var startOffset = fromStart.text.length;
    var endOffset = startOffset + selectedLength;
    return {
      start: startOffset,
      end: endOffset
    };
  }
  function getModernOffsets(node) {
    var selection = window.getSelection && window.getSelection();
    if (!selection || selection.rangeCount === 0) {
      return null;
    }
    var anchorNode = selection.anchorNode;
    var anchorOffset = selection.anchorOffset;
    var focusNode = selection.focusNode;
    var focusOffset = selection.focusOffset;
    var currentRange = selection.getRangeAt(0);
    try {
      currentRange.startContainer.nodeType;
      currentRange.endContainer.nodeType;
    } catch (e) {
      return null;
    }
    var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);
    var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;
    var tempRange = currentRange.cloneRange();
    tempRange.selectNodeContents(node);
    tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);
    var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);
    var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
    var end = start + rangeLength;
    var detectionRange = document.createRange();
    detectionRange.setStart(anchorNode, anchorOffset);
    detectionRange.setEnd(focusNode, focusOffset);
    var isBackward = detectionRange.collapsed;
    return {
      start: isBackward ? end : start,
      end: isBackward ? start : end
    };
  }
  function setIEOffsets(node, offsets) {
    var range = document.selection.createRange().duplicate();
    var start, end;
    if (offsets.end === undefined) {
      start = offsets.start;
      end = start;
    } else if (offsets.start > offsets.end) {
      start = offsets.end;
      end = offsets.start;
    } else {
      start = offsets.start;
      end = offsets.end;
    }
    range.moveToElementText(node);
    range.moveStart('character', start);
    range.setEndPoint('EndToStart', range);
    range.moveEnd('character', end - start);
    range.select();
  }
  function setModernOffsets(node, offsets) {
    if (!window.getSelection) {
      return;
    }
    var selection = window.getSelection();
    var length = node[getTextContentAccessor()].length;
    var start = Math.min(offsets.start, length);
    var end = offsets.end === undefined ? start : Math.min(offsets.end, length);
    if (!selection.extend && start > end) {
      var temp = end;
      end = start;
      start = temp;
    }
    var startMarker = getNodeForCharacterOffset(node, start);
    var endMarker = getNodeForCharacterOffset(node, end);
    if (startMarker && endMarker) {
      var range = document.createRange();
      range.setStart(startMarker.node, startMarker.offset);
      selection.removeAllRanges();
      if (start > end) {
        selection.addRange(range);
        selection.extend(endMarker.node, endMarker.offset);
      } else {
        range.setEnd(endMarker.node, endMarker.offset);
        selection.addRange(range);
      }
    }
  }
  var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);
  var ReactDOMSelection = {
    getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,
    setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
  };
  module.exports = ReactDOMSelection;
  return module.exports;
});
$__System.registerDynamic('c3', [], true, function ($__require, exports, module) {
  /* */
  'use strict';

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @typechecks
   */

  /**
   * @param {*} object The object to check.
   * @return {boolean} Whether or not the object is a DOM node.
   */

  var define,
      global = this || self,
      GLOBAL = global;
  function isNode(object) {
    return !!(object && (typeof Node === 'function' ? object instanceof Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
  }

  module.exports = isNode;
  return module.exports;
});
$__System.registerDynamic('c4', ['c3'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var isNode = $__require('c3');
  function isTextNode(object) {
    return isNode(object) && object.nodeType == 3;
  }
  module.exports = isTextNode;
  return module.exports;
});
$__System.registerDynamic('c5', ['c4'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var isTextNode = $__require('c4');
  function containsNode(outerNode, innerNode) {
    if (!outerNode || !innerNode) {
      return false;
    } else if (outerNode === innerNode) {
      return true;
    } else if (isTextNode(outerNode)) {
      return false;
    } else if (isTextNode(innerNode)) {
      return containsNode(outerNode, innerNode.parentNode);
    } else if ('contains' in outerNode) {
      return outerNode.contains(innerNode);
    } else if (outerNode.compareDocumentPosition) {
      return !!(outerNode.compareDocumentPosition(innerNode) & 16);
    } else {
      return false;
    }
  }
  module.exports = containsNode;
  return module.exports;
});
$__System.registerDynamic('7a', [], true, function ($__require, exports, module) {
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  /**
   * @param {DOMElement} node input/textarea to focus
   */

  var define,
      global = this || self,
      GLOBAL = global;
  function focusNode(node) {
    // IE8 can throw "Can't move focus to the control because it is invisible,
    // not enabled, or of a type that does not accept the focus." for all kinds of
    // reasons that are too expensive and fragile to test.
    try {
      node.focus();
    } catch (e) {}
  }

  module.exports = focusNode;
  return module.exports;
});
$__System.registerDynamic('bf', ['c2', 'c5', '7a', 'c6'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var ReactDOMSelection = $__require('c2');
  var containsNode = $__require('c5');
  var focusNode = $__require('7a');
  var getActiveElement = $__require('c6');
  function isInDocument(node) {
    return containsNode(document.documentElement, node);
  }
  var ReactInputSelection = {
    hasSelectionCapabilities: function (elem) {
      var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
      return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
    },
    getSelectionInformation: function () {
      var focusedElem = getActiveElement();
      return {
        focusedElem: focusedElem,
        selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
      };
    },
    restoreSelection: function (priorSelectionInformation) {
      var curFocusedElem = getActiveElement();
      var priorFocusedElem = priorSelectionInformation.focusedElem;
      var priorSelectionRange = priorSelectionInformation.selectionRange;
      if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
        if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
          ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
        }
        focusNode(priorFocusedElem);
      }
    },
    getSelection: function (input) {
      var selection;
      if ('selectionStart' in input) {
        selection = {
          start: input.selectionStart,
          end: input.selectionEnd
        };
      } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
        var range = document.selection.createRange();
        if (range.parentElement() === input) {
          selection = {
            start: -range.moveStart('character', -input.value.length),
            end: -range.moveEnd('character', -input.value.length)
          };
        }
      } else {
        selection = ReactDOMSelection.getOffsets(input);
      }
      return selection || {
        start: 0,
        end: 0
      };
    },
    setSelection: function (input, offsets) {
      var start = offsets.start;
      var end = offsets.end;
      if (end === undefined) {
        end = start;
      }
      if ('selectionStart' in input) {
        input.selectionStart = start;
        input.selectionEnd = Math.min(end, input.value.length);
      } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
        var range = input.createTextRange();
        range.collapse(true);
        range.moveStart('character', start);
        range.moveEnd('character', end - start);
        range.select();
      } else {
        ReactDOMSelection.setOffsets(input, offsets);
      }
    }
  };
  module.exports = ReactInputSelection;
  return module.exports;
});
$__System.registerDynamic('c6', [], true, function ($__require, exports, module) {
  /* */
  'use strict';

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @typechecks
   */

  /* eslint-disable fb-www/typeof-undefined */

  /**
   * Same as document.activeElement but wraps in a try-catch block. In IE it is
   * not safe to call document.activeElement if there is nothing focused.
   *
   * The activeElement will be null only if the document or document body is not
   * yet defined.
   */

  var define,
      global = this || self,
      GLOBAL = global;
  function getActiveElement() /*?DOMElement*/{
    if (typeof document === 'undefined') {
      return null;
    }
    try {
      return document.activeElement || document.body;
    } catch (e) {
      return document.body;
    }
  }

  module.exports = getActiveElement;
  return module.exports;
});
$__System.registerDynamic('70', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  /**
   * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
   */

  var define,
      global = this || self,
      GLOBAL = global;
  var supportedInputTypes = {
    'color': true,
    'date': true,
    'datetime': true,
    'datetime-local': true,
    'email': true,
    'month': true,
    'number': true,
    'password': true,
    'range': true,
    'search': true,
    'tel': true,
    'text': true,
    'time': true,
    'url': true,
    'week': true
  };

  function isTextInputElement(elem) {
    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();

    if (nodeName === 'input') {
      return !!supportedInputTypes[elem.type];
    }

    if (nodeName === 'textarea') {
      return true;
    }

    return false;
  }

  module.exports = isTextInputElement;
  return module.exports;
});
$__System.registerDynamic('c7', ['68', '69', '6c', 'bf', '65', 'c6', '70', 'aa'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var EventPropagators = $__require('68');
  var ExecutionEnvironment = $__require('69');
  var ReactDOMComponentTree = $__require('6c');
  var ReactInputSelection = $__require('bf');
  var SyntheticEvent = $__require('65');
  var getActiveElement = $__require('c6');
  var isTextInputElement = $__require('70');
  var shallowEqual = $__require('aa');
  var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;
  var eventTypes = { select: {
      phasedRegistrationNames: {
        bubbled: 'onSelect',
        captured: 'onSelectCapture'
      },
      dependencies: ['topBlur', 'topContextMenu', 'topFocus', 'topKeyDown', 'topKeyUp', 'topMouseDown', 'topMouseUp', 'topSelectionChange']
    } };
  var activeElement = null;
  var activeElementInst = null;
  var lastSelection = null;
  var mouseDown = false;
  var hasListener = false;
  function getSelection(node) {
    if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
      return {
        start: node.selectionStart,
        end: node.selectionEnd
      };
    } else if (window.getSelection) {
      var selection = window.getSelection();
      return {
        anchorNode: selection.anchorNode,
        anchorOffset: selection.anchorOffset,
        focusNode: selection.focusNode,
        focusOffset: selection.focusOffset
      };
    } else if (document.selection) {
      var range = document.selection.createRange();
      return {
        parentElement: range.parentElement(),
        text: range.text,
        top: range.boundingTop,
        left: range.boundingLeft
      };
    }
  }
  function constructSelectEvent(nativeEvent, nativeEventTarget) {
    if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
      return null;
    }
    var currentSelection = getSelection(activeElement);
    if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
      lastSelection = currentSelection;
      var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementInst, nativeEvent, nativeEventTarget);
      syntheticEvent.type = 'select';
      syntheticEvent.target = activeElement;
      EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);
      return syntheticEvent;
    }
    return null;
  }
  var SelectEventPlugin = {
    eventTypes: eventTypes,
    extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
      if (!hasListener) {
        return null;
      }
      var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;
      switch (topLevelType) {
        case 'topFocus':
          if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
            activeElement = targetNode;
            activeElementInst = targetInst;
            lastSelection = null;
          }
          break;
        case 'topBlur':
          activeElement = null;
          activeElementInst = null;
          lastSelection = null;
          break;
        case 'topMouseDown':
          mouseDown = true;
          break;
        case 'topContextMenu':
        case 'topMouseUp':
          mouseDown = false;
          return constructSelectEvent(nativeEvent, nativeEventTarget);
        case 'topSelectionChange':
          if (skipSelectionChangeEvent) {
            break;
          }
        case 'topKeyDown':
        case 'topKeyUp':
          return constructSelectEvent(nativeEvent, nativeEventTarget);
      }
      return null;
    },
    didPutListener: function (inst, registrationName, listener) {
      if (registrationName === 'onSelect') {
        hasListener = true;
      }
    }
  };
  module.exports = SelectEventPlugin;
  return module.exports;
});
$__System.registerDynamic('b8', ['9e', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var emptyFunction = $__require('9e');
    var EventListener = {
      listen: function listen(target, eventType, callback) {
        if (target.addEventListener) {
          target.addEventListener(eventType, callback, false);
          return { remove: function remove() {
              target.removeEventListener(eventType, callback, false);
            } };
        } else if (target.attachEvent) {
          target.attachEvent('on' + eventType, callback);
          return { remove: function remove() {
              target.detachEvent('on' + eventType, callback);
            } };
        }
      },
      capture: function capture(target, eventType, callback) {
        if (target.addEventListener) {
          target.addEventListener(eventType, callback, true);
          return { remove: function remove() {
              target.removeEventListener(eventType, callback, true);
            } };
        } else {
          if ('production' !== 'production') {
            console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
          }
          return { remove: emptyFunction };
        }
      },
      registerDefault: function registerDefault() {}
    };
    module.exports = EventListener;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('68', ['6b', 'ba', 'c8', 'c9', '7f', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var EventPluginHub = $__require('6b');
    var EventPluginUtils = $__require('ba');
    var accumulateInto = $__require('c8');
    var forEachAccumulated = $__require('c9');
    var warning = $__require('7f');
    var getListener = EventPluginHub.getListener;
    function listenerAtPhase(inst, event, propagationPhase) {
      var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
      return getListener(inst, registrationName);
    }
    function accumulateDirectionalDispatches(inst, phase, event) {
      if ('production' !== 'production') {
        'production' !== 'production' ? warning(inst, 'Dispatching inst must not be null') : void 0;
      }
      var listener = listenerAtPhase(inst, event, phase);
      if (listener) {
        event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
        event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
      }
    }
    function accumulateTwoPhaseDispatchesSingle(event) {
      if (event && event.dispatchConfig.phasedRegistrationNames) {
        EventPluginUtils.traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
      }
    }
    function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
      if (event && event.dispatchConfig.phasedRegistrationNames) {
        var targetInst = event._targetInst;
        var parentInst = targetInst ? EventPluginUtils.getParentInstance(targetInst) : null;
        EventPluginUtils.traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
      }
    }
    function accumulateDispatches(inst, ignoredDirection, event) {
      if (event && event.dispatchConfig.registrationName) {
        var registrationName = event.dispatchConfig.registrationName;
        var listener = getListener(inst, registrationName);
        if (listener) {
          event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
          event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
        }
      }
    }
    function accumulateDirectDispatchesSingle(event) {
      if (event && event.dispatchConfig.registrationName) {
        accumulateDispatches(event._targetInst, null, event);
      }
    }
    function accumulateTwoPhaseDispatches(events) {
      forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
    }
    function accumulateTwoPhaseDispatchesSkipTarget(events) {
      forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
    }
    function accumulateEnterLeaveDispatches(leave, enter, from, to) {
      EventPluginUtils.traverseEnterLeave(from, to, accumulateDispatches, leave, enter);
    }
    function accumulateDirectDispatches(events) {
      forEachAccumulated(events, accumulateDirectDispatchesSingle);
    }
    var EventPropagators = {
      accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
      accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
      accumulateDirectDispatches: accumulateDirectDispatches,
      accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
    };
    module.exports = EventPropagators;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('ca', ['65'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var SyntheticEvent = $__require('65');
  var AnimationEventInterface = {
    animationName: null,
    elapsedTime: null,
    pseudoElement: null
  };
  function SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticEvent.augmentClass(SyntheticAnimationEvent, AnimationEventInterface);
  module.exports = SyntheticAnimationEvent;
  return module.exports;
});
$__System.registerDynamic('cb', ['65'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var SyntheticEvent = $__require('65');
  var ClipboardEventInterface = { clipboardData: function (event) {
      return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
    } };
  function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);
  module.exports = SyntheticClipboardEvent;
  return module.exports;
});
$__System.registerDynamic('cc', ['cd'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var SyntheticUIEvent = $__require('cd');
  var FocusEventInterface = { relatedTarget: null };
  function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);
  module.exports = SyntheticFocusEvent;
  return module.exports;
});
$__System.registerDynamic('ce', ['cf'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var getEventCharCode = $__require('cf');
  var normalizeKey = {
    'Esc': 'Escape',
    'Spacebar': ' ',
    'Left': 'ArrowLeft',
    'Up': 'ArrowUp',
    'Right': 'ArrowRight',
    'Down': 'ArrowDown',
    'Del': 'Delete',
    'Win': 'OS',
    'Menu': 'ContextMenu',
    'Apps': 'ContextMenu',
    'Scroll': 'ScrollLock',
    'MozPrintableKey': 'Unidentified'
  };
  var translateToKey = {
    8: 'Backspace',
    9: 'Tab',
    12: 'Clear',
    13: 'Enter',
    16: 'Shift',
    17: 'Control',
    18: 'Alt',
    19: 'Pause',
    20: 'CapsLock',
    27: 'Escape',
    32: ' ',
    33: 'PageUp',
    34: 'PageDown',
    35: 'End',
    36: 'Home',
    37: 'ArrowLeft',
    38: 'ArrowUp',
    39: 'ArrowRight',
    40: 'ArrowDown',
    45: 'Insert',
    46: 'Delete',
    112: 'F1',
    113: 'F2',
    114: 'F3',
    115: 'F4',
    116: 'F5',
    117: 'F6',
    118: 'F7',
    119: 'F8',
    120: 'F9',
    121: 'F10',
    122: 'F11',
    123: 'F12',
    144: 'NumLock',
    145: 'ScrollLock',
    224: 'Meta'
  };
  function getEventKey(nativeEvent) {
    if (nativeEvent.key) {
      var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
      if (key !== 'Unidentified') {
        return key;
      }
    }
    if (nativeEvent.type === 'keypress') {
      var charCode = getEventCharCode(nativeEvent);
      return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
    }
    if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
      return translateToKey[nativeEvent.keyCode] || 'Unidentified';
    }
    return '';
  }
  module.exports = getEventKey;
  return module.exports;
});
$__System.registerDynamic('d0', ['cd', 'cf', 'ce', 'd1'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var SyntheticUIEvent = $__require('cd');
  var getEventCharCode = $__require('cf');
  var getEventKey = $__require('ce');
  var getEventModifierState = $__require('d1');
  var KeyboardEventInterface = {
    key: getEventKey,
    location: null,
    ctrlKey: null,
    shiftKey: null,
    altKey: null,
    metaKey: null,
    repeat: null,
    locale: null,
    getModifierState: getEventModifierState,
    charCode: function (event) {
      if (event.type === 'keypress') {
        return getEventCharCode(event);
      }
      return 0;
    },
    keyCode: function (event) {
      if (event.type === 'keydown' || event.type === 'keyup') {
        return event.keyCode;
      }
      return 0;
    },
    which: function (event) {
      if (event.type === 'keypress') {
        return getEventCharCode(event);
      }
      if (event.type === 'keydown' || event.type === 'keyup') {
        return event.keyCode;
      }
      return 0;
    }
  };
  function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);
  module.exports = SyntheticKeyboardEvent;
  return module.exports;
});
$__System.registerDynamic('d2', ['73'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var SyntheticMouseEvent = $__require('73');
  var DragEventInterface = { dataTransfer: null };
  function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);
  module.exports = SyntheticDragEvent;
  return module.exports;
});
$__System.registerDynamic('d3', ['cd', 'd1'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var SyntheticUIEvent = $__require('cd');
  var getEventModifierState = $__require('d1');
  var TouchEventInterface = {
    touches: null,
    targetTouches: null,
    changedTouches: null,
    altKey: null,
    metaKey: null,
    ctrlKey: null,
    shiftKey: null,
    getModifierState: getEventModifierState
  };
  function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);
  module.exports = SyntheticTouchEvent;
  return module.exports;
});
$__System.registerDynamic('d4', ['65'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var SyntheticEvent = $__require('65');
  var TransitionEventInterface = {
    propertyName: null,
    elapsedTime: null,
    pseudoElement: null
  };
  function SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticEvent.augmentClass(SyntheticTransitionEvent, TransitionEventInterface);
  module.exports = SyntheticTransitionEvent;
  return module.exports;
});
$__System.registerDynamic('65', ['63', '61', '9e', '7f', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _assign = $__require('63');
    var PooledClass = $__require('61');
    var emptyFunction = $__require('9e');
    var warning = $__require('7f');
    var didWarnForAddedNewProperty = false;
    var isProxySupported = typeof Proxy === 'function';
    var shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];
    var EventInterface = {
      type: null,
      target: null,
      currentTarget: emptyFunction.thatReturnsNull,
      eventPhase: null,
      bubbles: null,
      cancelable: null,
      timeStamp: function (event) {
        return event.timeStamp || Date.now();
      },
      defaultPrevented: null,
      isTrusted: null
    };
    function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
      if ('production' !== 'production') {
        delete this.nativeEvent;
        delete this.preventDefault;
        delete this.stopPropagation;
      }
      this.dispatchConfig = dispatchConfig;
      this._targetInst = targetInst;
      this.nativeEvent = nativeEvent;
      var Interface = this.constructor.Interface;
      for (var propName in Interface) {
        if (!Interface.hasOwnProperty(propName)) {
          continue;
        }
        if ('production' !== 'production') {
          delete this[propName];
        }
        var normalize = Interface[propName];
        if (normalize) {
          this[propName] = normalize(nativeEvent);
        } else {
          if (propName === 'target') {
            this.target = nativeEventTarget;
          } else {
            this[propName] = nativeEvent[propName];
          }
        }
      }
      var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
      if (defaultPrevented) {
        this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
      } else {
        this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
      }
      this.isPropagationStopped = emptyFunction.thatReturnsFalse;
      return this;
    }
    _assign(SyntheticEvent.prototype, {
      preventDefault: function () {
        this.defaultPrevented = true;
        var event = this.nativeEvent;
        if (!event) {
          return;
        }
        if (event.preventDefault) {
          event.preventDefault();
        } else if (typeof event.returnValue !== 'unknown') {
          event.returnValue = false;
        }
        this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
      },
      stopPropagation: function () {
        var event = this.nativeEvent;
        if (!event) {
          return;
        }
        if (event.stopPropagation) {
          event.stopPropagation();
        } else if (typeof event.cancelBubble !== 'unknown') {
          event.cancelBubble = true;
        }
        this.isPropagationStopped = emptyFunction.thatReturnsTrue;
      },
      persist: function () {
        this.isPersistent = emptyFunction.thatReturnsTrue;
      },
      isPersistent: emptyFunction.thatReturnsFalse,
      destructor: function () {
        var Interface = this.constructor.Interface;
        for (var propName in Interface) {
          if ('production' !== 'production') {
            Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
          } else {
            this[propName] = null;
          }
        }
        for (var i = 0; i < shouldBeReleasedProperties.length; i++) {
          this[shouldBeReleasedProperties[i]] = null;
        }
        if ('production' !== 'production') {
          Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));
          Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction));
          Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction));
        }
      }
    });
    SyntheticEvent.Interface = EventInterface;
    if ('production' !== 'production') {
      if (isProxySupported) {
        SyntheticEvent = new Proxy(SyntheticEvent, {
          construct: function (target, args) {
            return this.apply(target, Object.create(target.prototype), args);
          },
          apply: function (constructor, that, args) {
            return new Proxy(constructor.apply(that, args), { set: function (target, prop, value) {
                if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {
                  'production' !== 'production' ? warning(didWarnForAddedNewProperty || target.isPersistent(), 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re adding a new property in the synthetic event object. ' + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.') : void 0;
                  didWarnForAddedNewProperty = true;
                }
                target[prop] = value;
                return true;
              } });
          }
        });
      }
    }
    SyntheticEvent.augmentClass = function (Class, Interface) {
      var Super = this;
      var E = function () {};
      E.prototype = Super.prototype;
      var prototype = new E();
      _assign(prototype, Class.prototype);
      Class.prototype = prototype;
      Class.prototype.constructor = Class;
      Class.Interface = _assign({}, Super.Interface, Interface);
      Class.augmentClass = Super.augmentClass;
      PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
    };
    PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);
    module.exports = SyntheticEvent;
    function getPooledWarningPropertyDefinition(propName, getVal) {
      var isFunction = typeof getVal === 'function';
      return {
        configurable: true,
        set: set,
        get: get
      };
      function set(val) {
        var action = isFunction ? 'setting the method' : 'setting the property';
        warn(action, 'This is effectively a no-op');
        return val;
      }
      function get() {
        var action = isFunction ? 'accessing the method' : 'accessing the property';
        var result = isFunction ? 'This is a no-op function' : 'This is set to null';
        warn(action, result);
        return getVal;
      }
      function warn(action, result) {
        var warningCondition = false;
        'production' !== 'production' ? warning(warningCondition, 'This synthetic event is reused for performance reasons. If you\'re seeing this, ' + 'you\'re %s `%s` on a released/nullified synthetic event. %s. ' + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result) : void 0;
      }
    }
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('6e', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  /**
   * Gets the target node from a native browser event by accounting for
   * inconsistencies in browser DOM APIs.
   *
   * @param {object} nativeEvent Native browser event.
   * @return {DOMEventTarget} Target node.
   */

  var define,
      global = this || self,
      GLOBAL = global;
  function getEventTarget(nativeEvent) {
    var target = nativeEvent.target || nativeEvent.srcElement || window;

    // Normalize SVG <use> element events #4963
    if (target.correspondingUseElement) {
      target = target.correspondingUseElement;
    }

    // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
    // @see http://www.quirksmode.org/js/events_properties.html
    return target.nodeType === 3 ? target.parentNode : target;
  }

  module.exports = getEventTarget;
  return module.exports;
});
$__System.registerDynamic('cd', ['65', '6e'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var SyntheticEvent = $__require('65');
  var getEventTarget = $__require('6e');
  var UIEventInterface = {
    view: function (event) {
      if (event.view) {
        return event.view;
      }
      var target = getEventTarget(event);
      if (target.window === target) {
        return target;
      }
      var doc = target.ownerDocument;
      if (doc) {
        return doc.defaultView || doc.parentWindow;
      } else {
        return window;
      }
    },
    detail: function (event) {
      return event.detail || 0;
    }
  };
  function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);
  module.exports = SyntheticUIEvent;
  return module.exports;
});
$__System.registerDynamic('d1', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  /**
   * Translation from modifier key to the associated property in the event.
   * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
   */

  var define,
      global = this || self,
      GLOBAL = global;
  var modifierKeyToProp = {
    'Alt': 'altKey',
    'Control': 'ctrlKey',
    'Meta': 'metaKey',
    'Shift': 'shiftKey'
  };

  // IE8 does not implement getModifierState so we simply map it to the only
  // modifier keys exposed by the event itself, does not support Lock-keys.
  // Currently, all major browsers except Chrome seems to support Lock-keys.
  function modifierStateGetter(keyArg) {
    var syntheticEvent = this;
    var nativeEvent = syntheticEvent.nativeEvent;
    if (nativeEvent.getModifierState) {
      return nativeEvent.getModifierState(keyArg);
    }
    var keyProp = modifierKeyToProp[keyArg];
    return keyProp ? !!nativeEvent[keyProp] : false;
  }

  function getEventModifierState(nativeEvent) {
    return modifierStateGetter;
  }

  module.exports = getEventModifierState;
  return module.exports;
});
$__System.registerDynamic('73', ['cd', 'd5', 'd1'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var SyntheticUIEvent = $__require('cd');
  var ViewportMetrics = $__require('d5');
  var getEventModifierState = $__require('d1');
  var MouseEventInterface = {
    screenX: null,
    screenY: null,
    clientX: null,
    clientY: null,
    ctrlKey: null,
    shiftKey: null,
    altKey: null,
    metaKey: null,
    getModifierState: getEventModifierState,
    button: function (event) {
      var button = event.button;
      if ('which' in event) {
        return button;
      }
      return button === 2 ? 2 : button === 4 ? 1 : 0;
    },
    buttons: null,
    relatedTarget: function (event) {
      return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
    },
    pageX: function (event) {
      return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
    },
    pageY: function (event) {
      return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
    }
  };
  function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);
  module.exports = SyntheticMouseEvent;
  return module.exports;
});
$__System.registerDynamic('d6', ['73'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var SyntheticMouseEvent = $__require('73');
  var WheelEventInterface = {
    deltaX: function (event) {
      return 'deltaX' in event ? event.deltaX : 'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
    },
    deltaY: function (event) {
      return 'deltaY' in event ? event.deltaY : 'wheelDeltaY' in event ? -event.wheelDeltaY : 'wheelDelta' in event ? -event.wheelDelta : 0;
    },
    deltaZ: null,
    deltaMode: null
  };
  function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);
  module.exports = SyntheticWheelEvent;
  return module.exports;
});
$__System.registerDynamic('cf', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  /**
   * `charCode` represents the actual "character code" and is safe to use with
   * `String.fromCharCode`. As such, only keys that correspond to printable
   * characters produce a valid `charCode`, the only exception to this is Enter.
   * The Tab-key is considered non-printable and does not have a `charCode`,
   * presumably because it does not produce a tab-character in browsers.
   *
   * @param {object} nativeEvent Native browser event.
   * @return {number} Normalized `charCode` property.
   */

  var define,
      global = this || self,
      GLOBAL = global;
  function getEventCharCode(nativeEvent) {
    var charCode;
    var keyCode = nativeEvent.keyCode;

    if ('charCode' in nativeEvent) {
      charCode = nativeEvent.charCode;

      // FF does not set `charCode` for the Enter-key, check against `keyCode`.
      if (charCode === 0 && keyCode === 13) {
        charCode = 13;
      }
    } else {
      // IE8 does not implement `charCode`, but `keyCode` has the correct value.
      charCode = keyCode;
    }

    // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
    // Must not discard the (non-)printable Enter-key.
    if (charCode >= 32 || charCode === 13) {
      return charCode;
    }

    return 0;
  }

  module.exports = getEventCharCode;
  return module.exports;
});
$__System.registerDynamic('d7', ['89', 'b8', '68', '6c', 'ca', 'cb', '65', 'cc', 'd0', '73', 'd2', 'd3', 'd4', 'cd', 'd6', '9e', 'cf', '8b', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('89');
    var EventListener = $__require('b8');
    var EventPropagators = $__require('68');
    var ReactDOMComponentTree = $__require('6c');
    var SyntheticAnimationEvent = $__require('ca');
    var SyntheticClipboardEvent = $__require('cb');
    var SyntheticEvent = $__require('65');
    var SyntheticFocusEvent = $__require('cc');
    var SyntheticKeyboardEvent = $__require('d0');
    var SyntheticMouseEvent = $__require('73');
    var SyntheticDragEvent = $__require('d2');
    var SyntheticTouchEvent = $__require('d3');
    var SyntheticTransitionEvent = $__require('d4');
    var SyntheticUIEvent = $__require('cd');
    var SyntheticWheelEvent = $__require('d6');
    var emptyFunction = $__require('9e');
    var getEventCharCode = $__require('cf');
    var invariant = $__require('8b');
    var eventTypes = {};
    var topLevelEventsToDispatchConfig = {};
    ['abort', 'animationEnd', 'animationIteration', 'animationStart', 'blur', 'canPlay', 'canPlayThrough', 'click', 'contextMenu', 'copy', 'cut', 'doubleClick', 'drag', 'dragEnd', 'dragEnter', 'dragExit', 'dragLeave', 'dragOver', 'dragStart', 'drop', 'durationChange', 'emptied', 'encrypted', 'ended', 'error', 'focus', 'input', 'invalid', 'keyDown', 'keyPress', 'keyUp', 'load', 'loadedData', 'loadedMetadata', 'loadStart', 'mouseDown', 'mouseMove', 'mouseOut', 'mouseOver', 'mouseUp', 'paste', 'pause', 'play', 'playing', 'progress', 'rateChange', 'reset', 'scroll', 'seeked', 'seeking', 'stalled', 'submit', 'suspend', 'timeUpdate', 'touchCancel', 'touchEnd', 'touchMove', 'touchStart', 'transitionEnd', 'volumeChange', 'waiting', 'wheel'].forEach(function (event) {
      var capitalizedEvent = event[0].toUpperCase() + event.slice(1);
      var onEvent = 'on' + capitalizedEvent;
      var topEvent = 'top' + capitalizedEvent;
      var type = {
        phasedRegistrationNames: {
          bubbled: onEvent,
          captured: onEvent + 'Capture'
        },
        dependencies: [topEvent]
      };
      eventTypes[event] = type;
      topLevelEventsToDispatchConfig[topEvent] = type;
    });
    var onClickListeners = {};
    function getDictionaryKey(inst) {
      return '.' + inst._rootNodeID;
    }
    function isInteractive(tag) {
      return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
    }
    function shouldPreventMouseEvent(inst) {
      if (inst) {
        var disabled = inst._currentElement && inst._currentElement.props.disabled;
        if (disabled) {
          return isInteractive(inst._tag);
        }
      }
      return false;
    }
    var SimpleEventPlugin = {
      eventTypes: eventTypes,
      extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
        var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
        if (!dispatchConfig) {
          return null;
        }
        var EventConstructor;
        switch (topLevelType) {
          case 'topAbort':
          case 'topCanPlay':
          case 'topCanPlayThrough':
          case 'topDurationChange':
          case 'topEmptied':
          case 'topEncrypted':
          case 'topEnded':
          case 'topError':
          case 'topInput':
          case 'topInvalid':
          case 'topLoad':
          case 'topLoadedData':
          case 'topLoadedMetadata':
          case 'topLoadStart':
          case 'topPause':
          case 'topPlay':
          case 'topPlaying':
          case 'topProgress':
          case 'topRateChange':
          case 'topReset':
          case 'topSeeked':
          case 'topSeeking':
          case 'topStalled':
          case 'topSubmit':
          case 'topSuspend':
          case 'topTimeUpdate':
          case 'topVolumeChange':
          case 'topWaiting':
            EventConstructor = SyntheticEvent;
            break;
          case 'topKeyPress':
            if (getEventCharCode(nativeEvent) === 0) {
              return null;
            }
          case 'topKeyDown':
          case 'topKeyUp':
            EventConstructor = SyntheticKeyboardEvent;
            break;
          case 'topBlur':
          case 'topFocus':
            EventConstructor = SyntheticFocusEvent;
            break;
          case 'topClick':
            if (nativeEvent.button === 2) {
              return null;
            }
          case 'topDoubleClick':
          case 'topMouseDown':
          case 'topMouseMove':
          case 'topMouseUp':
            if (shouldPreventMouseEvent(targetInst)) {
              return null;
            }
          case 'topMouseOut':
          case 'topMouseOver':
          case 'topContextMenu':
            EventConstructor = SyntheticMouseEvent;
            break;
          case 'topDrag':
          case 'topDragEnd':
          case 'topDragEnter':
          case 'topDragExit':
          case 'topDragLeave':
          case 'topDragOver':
          case 'topDragStart':
          case 'topDrop':
            EventConstructor = SyntheticDragEvent;
            break;
          case 'topTouchCancel':
          case 'topTouchEnd':
          case 'topTouchMove':
          case 'topTouchStart':
            EventConstructor = SyntheticTouchEvent;
            break;
          case 'topAnimationEnd':
          case 'topAnimationIteration':
          case 'topAnimationStart':
            EventConstructor = SyntheticAnimationEvent;
            break;
          case 'topTransitionEnd':
            EventConstructor = SyntheticTransitionEvent;
            break;
          case 'topScroll':
            EventConstructor = SyntheticUIEvent;
            break;
          case 'topWheel':
            EventConstructor = SyntheticWheelEvent;
            break;
          case 'topCopy':
          case 'topCut':
          case 'topPaste':
            EventConstructor = SyntheticClipboardEvent;
            break;
        }
        !EventConstructor ? 'production' !== 'production' ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : _prodInvariant('86', topLevelType) : void 0;
        var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
        EventPropagators.accumulateTwoPhaseDispatches(event);
        return event;
      },
      didPutListener: function (inst, registrationName, listener) {
        if (registrationName === 'onClick' && !isInteractive(inst._tag)) {
          var key = getDictionaryKey(inst);
          var node = ReactDOMComponentTree.getNodeFromInstance(inst);
          if (!onClickListeners[key]) {
            onClickListeners[key] = EventListener.listen(node, 'click', emptyFunction);
          }
        }
      },
      willDeleteListener: function (inst, registrationName) {
        if (registrationName === 'onClick' && !isInteractive(inst._tag)) {
          var key = getDictionaryKey(inst);
          onClickListeners[key].remove();
          delete onClickListeners[key];
        }
      }
    };
    module.exports = SimpleEventPlugin;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('d8', ['5f', '67', '6a', '71', '72', '74', '78', 'a3', '6c', 'ab', 'ac', 'b4', 'b5', 'b7', 'b9', 'bd', 'c0', 'c7', 'd7'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var ARIADOMPropertyConfig = $__require('5f');
  var BeforeInputEventPlugin = $__require('67');
  var ChangeEventPlugin = $__require('6a');
  var DefaultEventPluginOrder = $__require('71');
  var EnterLeaveEventPlugin = $__require('72');
  var HTMLDOMPropertyConfig = $__require('74');
  var ReactComponentBrowserEnvironment = $__require('78');
  var ReactDOMComponent = $__require('a3');
  var ReactDOMComponentTree = $__require('6c');
  var ReactDOMEmptyComponent = $__require('ab');
  var ReactDOMTreeTraversal = $__require('ac');
  var ReactDOMTextComponent = $__require('b4');
  var ReactDefaultBatchingStrategy = $__require('b5');
  var ReactEventListener = $__require('b7');
  var ReactInjection = $__require('b9');
  var ReactReconcileTransaction = $__require('bd');
  var SVGDOMPropertyConfig = $__require('c0');
  var SelectEventPlugin = $__require('c7');
  var SimpleEventPlugin = $__require('d7');
  var alreadyInjected = false;
  function inject() {
    if (alreadyInjected) {
      return;
    }
    alreadyInjected = true;
    ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);
    ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
    ReactInjection.EventPluginUtils.injectComponentTree(ReactDOMComponentTree);
    ReactInjection.EventPluginUtils.injectTreeTraversal(ReactDOMTreeTraversal);
    ReactInjection.EventPluginHub.injectEventPluginsByName({
      SimpleEventPlugin: SimpleEventPlugin,
      EnterLeaveEventPlugin: EnterLeaveEventPlugin,
      ChangeEventPlugin: ChangeEventPlugin,
      SelectEventPlugin: SelectEventPlugin,
      BeforeInputEventPlugin: BeforeInputEventPlugin
    });
    ReactInjection.HostComponent.injectGenericComponentClass(ReactDOMComponent);
    ReactInjection.HostComponent.injectTextComponentClass(ReactDOMTextComponent);
    ReactInjection.DOMProperty.injectDOMPropertyConfig(ARIADOMPropertyConfig);
    ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
    ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);
    ReactInjection.EmptyComponent.injectEmptyComponentFactory(function (instantiate) {
      return new ReactDOMEmptyComponent(instantiate);
    });
    ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
    ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);
    ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
  }
  module.exports = { inject: inject };
  return module.exports;
});
$__System.registerDynamic('d9', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = '15.4.0';
  return module.exports;
});
$__System.registerDynamic('da', ['89', '99', '6c', '9d', 'db', '8b', '7f', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('89');
    var ReactCurrentOwner = $__require('99');
    var ReactDOMComponentTree = $__require('6c');
    var ReactInstanceMap = $__require('9d');
    var getHostComponentFromComposite = $__require('db');
    var invariant = $__require('8b');
    var warning = $__require('7f');
    function findDOMNode(componentOrElement) {
      if ('production' !== 'production') {
        var owner = ReactCurrentOwner.current;
        if (owner !== null) {
          'production' !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
          owner._warnedAboutRefsInRender = true;
        }
      }
      if (componentOrElement == null) {
        return null;
      }
      if (componentOrElement.nodeType === 1) {
        return componentOrElement;
      }
      var inst = ReactInstanceMap.get(componentOrElement);
      if (inst) {
        inst = getHostComponentFromComposite(inst);
        return inst ? ReactDOMComponentTree.getNodeFromInstance(inst) : null;
      }
      if (typeof componentOrElement.render === 'function') {
        !false ? 'production' !== 'production' ? invariant(false, 'findDOMNode was called on an unmounted component.') : _prodInvariant('44') : void 0;
      } else {
        !false ? 'production' !== 'production' ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : _prodInvariant('45', Object.keys(componentOrElement)) : void 0;
      }
    }
    module.exports = findDOMNode;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('db', ['dc'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var ReactNodeTypes = $__require('dc');
  function getHostComponentFromComposite(inst) {
    var type;
    while ((type = inst._renderedNodeType) === ReactNodeTypes.COMPOSITE) {
      inst = inst._renderedComponent;
    }
    if (type === ReactNodeTypes.HOST) {
      return inst._renderedComponent;
    } else if (type === ReactNodeTypes.EMPTY) {
      return null;
    }
  }
  module.exports = getHostComponentFromComposite;
  return module.exports;
});
$__System.registerDynamic('86', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2016-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * Based on the escape-html library, which is used under the MIT License below:
   *
   * Copyright (c) 2012-2013 TJ Holowaychuk
   * Copyright (c) 2015 Andreas Lubbe
   * Copyright (c) 2015 Tiancheng "Timothy" Gu
   *
   * Permission is hereby granted, free of charge, to any person obtaining
   * a copy of this software and associated documentation files (the
   * 'Software'), to deal in the Software without restriction, including
   * without limitation the rights to use, copy, modify, merge, publish,
   * distribute, sublicense, and/or sell copies of the Software, and to
   * permit persons to whom the Software is furnished to do so, subject to
   * the following conditions:
   *
   * The above copyright notice and this permission notice shall be
   * included in all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
   * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
   * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
   * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
   * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
   * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   *
   */

  'use strict';

  // code copied and modified from escape-html
  /**
   * Module variables.
   * @private
   */

  var define,
      global = this || self,
      GLOBAL = global;
  var matchHtmlRegExp = /["'&<>]/;

  /**
   * Escape special characters in the given string of html.
   *
   * @param  {string} string The string to escape for inserting into HTML
   * @return {string}
   * @public
   */

  function escapeHtml(string) {
    var str = '' + string;
    var match = matchHtmlRegExp.exec(str);

    if (!match) {
      return str;
    }

    var escape;
    var html = '';
    var index = 0;
    var lastIndex = 0;

    for (index = match.index; index < str.length; index++) {
      switch (str.charCodeAt(index)) {
        case 34:
          // "
          escape = '&quot;';
          break;
        case 38:
          // &
          escape = '&amp;';
          break;
        case 39:
          // '
          escape = '&#x27;'; // modified from escape-html; used to be '&#39'
          break;
        case 60:
          // <
          escape = '&lt;';
          break;
        case 62:
          // >
          escape = '&gt;';
          break;
        default:
          continue;
      }

      if (lastIndex !== index) {
        html += str.substring(lastIndex, index);
      }

      lastIndex = index + 1;
      html += escape;
    }

    return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
  }
  // end code copied and modified from escape-html


  /**
   * Escapes text to prevent scripting attacks.
   *
   * @param {*} text Text value to escape.
   * @return {string} An escaped string.
   */
  function escapeTextContentForBrowser(text) {
    if (typeof text === 'boolean' || typeof text === 'number') {
      // this shortcircuit helps perf for types that we know will never have
      // special characters, especially given that this function is used often
      // for numeric dom ids.
      return '' + text;
    }
    return escapeHtml(text);
  }

  module.exports = escapeTextContentForBrowser;
  return module.exports;
});
$__System.registerDynamic('b3', ['69', '86', 'b2'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var ExecutionEnvironment = $__require('69');
  var escapeTextContentForBrowser = $__require('86');
  var setInnerHTML = $__require('b2');
  var setTextContent = function (node, text) {
    if (text) {
      var firstChild = node.firstChild;
      if (firstChild && firstChild === node.lastChild && firstChild.nodeType === 3) {
        firstChild.nodeValue = text;
        return;
      }
    }
    node.textContent = text;
  };
  if (ExecutionEnvironment.canUseDOM) {
    if (!('textContent' in document.documentElement)) {
      setTextContent = function (node, text) {
        if (node.nodeType === 3) {
          node.nodeValue = text;
          return;
        }
        setInnerHTML(node, escapeTextContentForBrowser(text));
      };
    }
  }
  module.exports = setTextContent;
  return module.exports;
});
$__System.registerDynamic('a4', ['a5', 'b2', 'b1', 'b3'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var DOMNamespaces = $__require('a5');
  var setInnerHTML = $__require('b2');
  var createMicrosoftUnsafeLocalFunction = $__require('b1');
  var setTextContent = $__require('b3');
  var ELEMENT_NODE_TYPE = 1;
  var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
  var enableLazy = typeof document !== 'undefined' && typeof document.documentMode === 'number' || typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string' && /\bEdge\/\d/.test(navigator.userAgent);
  function insertTreeChildren(tree) {
    if (!enableLazy) {
      return;
    }
    var node = tree.node;
    var children = tree.children;
    if (children.length) {
      for (var i = 0; i < children.length; i++) {
        insertTreeBefore(node, children[i], null);
      }
    } else if (tree.html != null) {
      setInnerHTML(node, tree.html);
    } else if (tree.text != null) {
      setTextContent(node, tree.text);
    }
  }
  var insertTreeBefore = createMicrosoftUnsafeLocalFunction(function (parentNode, tree, referenceNode) {
    if (tree.node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE || tree.node.nodeType === ELEMENT_NODE_TYPE && tree.node.nodeName.toLowerCase() === 'object' && (tree.node.namespaceURI == null || tree.node.namespaceURI === DOMNamespaces.html)) {
      insertTreeChildren(tree);
      parentNode.insertBefore(tree.node, referenceNode);
    } else {
      parentNode.insertBefore(tree.node, referenceNode);
      insertTreeChildren(tree);
    }
  });
  function replaceChildWithTree(oldNode, newTree) {
    oldNode.parentNode.replaceChild(newTree.node, oldNode);
    insertTreeChildren(newTree);
  }
  function queueChild(parentTree, childTree) {
    if (enableLazy) {
      parentTree.children.push(childTree);
    } else {
      parentTree.node.appendChild(childTree.node);
    }
  }
  function queueHTML(tree, html) {
    if (enableLazy) {
      tree.html = html;
    } else {
      setInnerHTML(tree.node, html);
    }
  }
  function queueText(tree, text) {
    if (enableLazy) {
      tree.text = text;
    } else {
      setTextContent(tree.node, text);
    }
  }
  function toString() {
    return this.node.nodeName;
  }
  function DOMLazyTree(node) {
    return {
      node: node,
      children: [],
      html: null,
      text: null,
      toString: toString
    };
  }
  DOMLazyTree.insertTreeBefore = insertTreeBefore;
  DOMLazyTree.replaceChildWithTree = replaceChildWithTree;
  DOMLazyTree.queueChild = queueChild;
  DOMLazyTree.queueHTML = queueHTML;
  DOMLazyTree.queueText = queueText;
  module.exports = DOMLazyTree;
  return module.exports;
});
$__System.registerDynamic('ba', ['89', 'dd', '8b', '7f', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('89');
    var ReactErrorUtils = $__require('dd');
    var invariant = $__require('8b');
    var warning = $__require('7f');
    var ComponentTree;
    var TreeTraversal;
    var injection = {
      injectComponentTree: function (Injected) {
        ComponentTree = Injected;
        if ('production' !== 'production') {
          'production' !== 'production' ? warning(Injected && Injected.getNodeFromInstance && Injected.getInstanceFromNode, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.') : void 0;
        }
      },
      injectTreeTraversal: function (Injected) {
        TreeTraversal = Injected;
        if ('production' !== 'production') {
          'production' !== 'production' ? warning(Injected && Injected.isAncestor && Injected.getLowestCommonAncestor, 'EventPluginUtils.injection.injectTreeTraversal(...): Injected ' + 'module is missing isAncestor or getLowestCommonAncestor.') : void 0;
        }
      }
    };
    function isEndish(topLevelType) {
      return topLevelType === 'topMouseUp' || topLevelType === 'topTouchEnd' || topLevelType === 'topTouchCancel';
    }
    function isMoveish(topLevelType) {
      return topLevelType === 'topMouseMove' || topLevelType === 'topTouchMove';
    }
    function isStartish(topLevelType) {
      return topLevelType === 'topMouseDown' || topLevelType === 'topTouchStart';
    }
    var validateEventDispatches;
    if ('production' !== 'production') {
      validateEventDispatches = function (event) {
        var dispatchListeners = event._dispatchListeners;
        var dispatchInstances = event._dispatchInstances;
        var listenersIsArr = Array.isArray(dispatchListeners);
        var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;
        var instancesIsArr = Array.isArray(dispatchInstances);
        var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;
        'production' !== 'production' ? warning(instancesIsArr === listenersIsArr && instancesLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : void 0;
      };
    }
    function executeDispatch(event, simulated, listener, inst) {
      var type = event.type || 'unknown-event';
      event.currentTarget = EventPluginUtils.getNodeFromInstance(inst);
      if (simulated) {
        ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event);
      } else {
        ReactErrorUtils.invokeGuardedCallback(type, listener, event);
      }
      event.currentTarget = null;
    }
    function executeDispatchesInOrder(event, simulated) {
      var dispatchListeners = event._dispatchListeners;
      var dispatchInstances = event._dispatchInstances;
      if ('production' !== 'production') {
        validateEventDispatches(event);
      }
      if (Array.isArray(dispatchListeners)) {
        for (var i = 0; i < dispatchListeners.length; i++) {
          if (event.isPropagationStopped()) {
            break;
          }
          executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
        }
      } else if (dispatchListeners) {
        executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
      }
      event._dispatchListeners = null;
      event._dispatchInstances = null;
    }
    function executeDispatchesInOrderStopAtTrueImpl(event) {
      var dispatchListeners = event._dispatchListeners;
      var dispatchInstances = event._dispatchInstances;
      if ('production' !== 'production') {
        validateEventDispatches(event);
      }
      if (Array.isArray(dispatchListeners)) {
        for (var i = 0; i < dispatchListeners.length; i++) {
          if (event.isPropagationStopped()) {
            break;
          }
          if (dispatchListeners[i](event, dispatchInstances[i])) {
            return dispatchInstances[i];
          }
        }
      } else if (dispatchListeners) {
        if (dispatchListeners(event, dispatchInstances)) {
          return dispatchInstances;
        }
      }
      return null;
    }
    function executeDispatchesInOrderStopAtTrue(event) {
      var ret = executeDispatchesInOrderStopAtTrueImpl(event);
      event._dispatchInstances = null;
      event._dispatchListeners = null;
      return ret;
    }
    function executeDirectDispatch(event) {
      if ('production' !== 'production') {
        validateEventDispatches(event);
      }
      var dispatchListener = event._dispatchListeners;
      var dispatchInstance = event._dispatchInstances;
      !!Array.isArray(dispatchListener) ? 'production' !== 'production' ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : _prodInvariant('103') : void 0;
      event.currentTarget = dispatchListener ? EventPluginUtils.getNodeFromInstance(dispatchInstance) : null;
      var res = dispatchListener ? dispatchListener(event) : null;
      event.currentTarget = null;
      event._dispatchListeners = null;
      event._dispatchInstances = null;
      return res;
    }
    function hasDispatches(event) {
      return !!event._dispatchListeners;
    }
    var EventPluginUtils = {
      isEndish: isEndish,
      isMoveish: isMoveish,
      isStartish: isStartish,
      executeDirectDispatch: executeDirectDispatch,
      executeDispatchesInOrder: executeDispatchesInOrder,
      executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
      hasDispatches: hasDispatches,
      getInstanceFromNode: function (node) {
        return ComponentTree.getInstanceFromNode(node);
      },
      getNodeFromInstance: function (node) {
        return ComponentTree.getNodeFromInstance(node);
      },
      isAncestor: function (a, b) {
        return TreeTraversal.isAncestor(a, b);
      },
      getLowestCommonAncestor: function (a, b) {
        return TreeTraversal.getLowestCommonAncestor(a, b);
      },
      getParentInstance: function (inst) {
        return TreeTraversal.getParentInstance(inst);
      },
      traverseTwoPhase: function (target, fn, arg) {
        return TreeTraversal.traverseTwoPhase(target, fn, arg);
      },
      traverseEnterLeave: function (from, to, fn, argFrom, argTo) {
        return TreeTraversal.traverseEnterLeave(from, to, fn, argFrom, argTo);
      },
      injection: injection
    };
    module.exports = EventPluginUtils;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('c8', ['89', '8b', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('89');
    var invariant = $__require('8b');
    function accumulateInto(current, next) {
      !(next != null) ? 'production' !== 'production' ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : _prodInvariant('30') : void 0;
      if (current == null) {
        return next;
      }
      if (Array.isArray(current)) {
        if (Array.isArray(next)) {
          current.push.apply(current, next);
          return current;
        }
        current.push(next);
        return current;
      }
      if (Array.isArray(next)) {
        return [current].concat(next);
      }
      return [current, next];
    }
    module.exports = accumulateInto;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('c9', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  /**
   * @param {array} arr an "accumulation" of items which is either an Array or
   * a single item. Useful when paired with the `accumulate` module. This is a
   * simple utility that allows us to reason about a collection of items, but
   * handling the case when there is exactly one item (and we do not need to
   * allocate an array).
   */

  var define,
      global = this || self,
      GLOBAL = global;
  function forEachAccumulated(arr, cb, scope) {
    if (Array.isArray(arr)) {
      arr.forEach(cb, scope);
    } else if (arr) {
      cb.call(scope, arr);
    }
  }

  module.exports = forEachAccumulated;
  return module.exports;
});
$__System.registerDynamic('6b', ['89', 'a6', 'ba', 'dd', 'c8', 'c9', '8b', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('89');
    var EventPluginRegistry = $__require('a6');
    var EventPluginUtils = $__require('ba');
    var ReactErrorUtils = $__require('dd');
    var accumulateInto = $__require('c8');
    var forEachAccumulated = $__require('c9');
    var invariant = $__require('8b');
    var listenerBank = {};
    var eventQueue = null;
    var executeDispatchesAndRelease = function (event, simulated) {
      if (event) {
        EventPluginUtils.executeDispatchesInOrder(event, simulated);
        if (!event.isPersistent()) {
          event.constructor.release(event);
        }
      }
    };
    var executeDispatchesAndReleaseSimulated = function (e) {
      return executeDispatchesAndRelease(e, true);
    };
    var executeDispatchesAndReleaseTopLevel = function (e) {
      return executeDispatchesAndRelease(e, false);
    };
    var getDictionaryKey = function (inst) {
      return '.' + inst._rootNodeID;
    };
    var EventPluginHub = {
      injection: {
        injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,
        injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName
      },
      putListener: function (inst, registrationName, listener) {
        !(typeof listener === 'function') ? 'production' !== 'production' ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener) : _prodInvariant('94', registrationName, typeof listener) : void 0;
        var key = getDictionaryKey(inst);
        var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
        bankForRegistrationName[key] = listener;
        var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
        if (PluginModule && PluginModule.didPutListener) {
          PluginModule.didPutListener(inst, registrationName, listener);
        }
      },
      getListener: function (inst, registrationName) {
        var bankForRegistrationName = listenerBank[registrationName];
        var key = getDictionaryKey(inst);
        return bankForRegistrationName && bankForRegistrationName[key];
      },
      deleteListener: function (inst, registrationName) {
        var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
        if (PluginModule && PluginModule.willDeleteListener) {
          PluginModule.willDeleteListener(inst, registrationName);
        }
        var bankForRegistrationName = listenerBank[registrationName];
        if (bankForRegistrationName) {
          var key = getDictionaryKey(inst);
          delete bankForRegistrationName[key];
        }
      },
      deleteAllListeners: function (inst) {
        var key = getDictionaryKey(inst);
        for (var registrationName in listenerBank) {
          if (!listenerBank.hasOwnProperty(registrationName)) {
            continue;
          }
          if (!listenerBank[registrationName][key]) {
            continue;
          }
          var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
          if (PluginModule && PluginModule.willDeleteListener) {
            PluginModule.willDeleteListener(inst, registrationName);
          }
          delete listenerBank[registrationName][key];
        }
      },
      extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
        var events;
        var plugins = EventPluginRegistry.plugins;
        for (var i = 0; i < plugins.length; i++) {
          var possiblePlugin = plugins[i];
          if (possiblePlugin) {
            var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
            if (extractedEvents) {
              events = accumulateInto(events, extractedEvents);
            }
          }
        }
        return events;
      },
      enqueueEvents: function (events) {
        if (events) {
          eventQueue = accumulateInto(eventQueue, events);
        }
      },
      processEventQueue: function (simulated) {
        var processingEventQueue = eventQueue;
        eventQueue = null;
        if (simulated) {
          forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
        } else {
          forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
        }
        !!eventQueue ? 'production' !== 'production' ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : _prodInvariant('95') : void 0;
        ReactErrorUtils.rethrowCaughtError();
      },
      __purge: function () {
        listenerBank = {};
      },
      __getListenerBank: function () {
        return listenerBank;
      }
    };
    module.exports = EventPluginHub;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('de', ['6b'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var EventPluginHub = $__require('6b');
  function runEventQueueInBatch(events) {
    EventPluginHub.enqueueEvents(events);
    EventPluginHub.processEventQueue(false);
  }
  var ReactEventEmitterMixin = { handleTopLevel: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
      var events = EventPluginHub.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
      runEventQueueInBatch(events);
    } };
  module.exports = ReactEventEmitterMixin;
  return module.exports;
});
$__System.registerDynamic('d5', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var ViewportMetrics = {

    currentScrollLeft: 0,

    currentScrollTop: 0,

    refreshScrollValues: function (scrollPosition) {
      ViewportMetrics.currentScrollLeft = scrollPosition.x;
      ViewportMetrics.currentScrollTop = scrollPosition.y;
    }

  };

  module.exports = ViewportMetrics;
  return module.exports;
});
$__System.registerDynamic('df', ['69'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var ExecutionEnvironment = $__require('69');

  /**
   * Generate a mapping of standard vendor prefixes using the defined style property and event name.
   *
   * @param {string} styleProp
   * @param {string} eventName
   * @returns {object}
   */
  function makePrefixMap(styleProp, eventName) {
    var prefixes = {};

    prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
    prefixes['Webkit' + styleProp] = 'webkit' + eventName;
    prefixes['Moz' + styleProp] = 'moz' + eventName;
    prefixes['ms' + styleProp] = 'MS' + eventName;
    prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();

    return prefixes;
  }

  /**
   * A list of event names to a configurable list of vendor prefixes.
   */
  var vendorPrefixes = {
    animationend: makePrefixMap('Animation', 'AnimationEnd'),
    animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
    animationstart: makePrefixMap('Animation', 'AnimationStart'),
    transitionend: makePrefixMap('Transition', 'TransitionEnd')
  };

  /**
   * Event names that have already been detected and prefixed (if applicable).
   */
  var prefixedEventNames = {};

  /**
   * Element to check for prefixes on.
   */
  var style = {};

  /**
   * Bootstrap if a DOM exists.
   */
  if (ExecutionEnvironment.canUseDOM) {
    style = document.createElement('div').style;

    // On some platforms, in particular some releases of Android 4.x,
    // the un-prefixed "animation" and "transition" properties are defined on the
    // style object but the events that fire will still be prefixed, so we need
    // to check if the un-prefixed events are usable, and if not remove them from the map.
    if (!('AnimationEvent' in window)) {
      delete vendorPrefixes.animationend.animation;
      delete vendorPrefixes.animationiteration.animation;
      delete vendorPrefixes.animationstart.animation;
    }

    // Same as above
    if (!('TransitionEvent' in window)) {
      delete vendorPrefixes.transitionend.transition;
    }
  }

  /**
   * Attempts to determine the correct vendor prefixed event name.
   *
   * @param {string} eventName
   * @returns {string}
   */
  function getVendorPrefixedEventName(eventName) {
    if (prefixedEventNames[eventName]) {
      return prefixedEventNames[eventName];
    } else if (!vendorPrefixes[eventName]) {
      return eventName;
    }

    var prefixMap = vendorPrefixes[eventName];

    for (var styleProp in prefixMap) {
      if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
        return prefixedEventNames[eventName] = prefixMap[styleProp];
      }
    }

    return '';
  }

  module.exports = getVendorPrefixedEventName;
  return module.exports;
});
$__System.registerDynamic('6f', ['69'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var ExecutionEnvironment = $__require('69');

  var useHasFeature;
  if (ExecutionEnvironment.canUseDOM) {
    useHasFeature = document.implementation && document.implementation.hasFeature &&
    // always returns true in newer browsers as per the standard.
    // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
    document.implementation.hasFeature('', '') !== true;
  }

  /**
   * Checks if an event is supported in the current execution environment.
   *
   * NOTE: This will not work correctly for non-generic events such as `change`,
   * `reset`, `load`, `error`, and `select`.
   *
   * Borrows from Modernizr.
   *
   * @param {string} eventNameSuffix Event name, e.g. "click".
   * @param {?boolean} capture Check if the capture phase is supported.
   * @return {boolean} True if the event is supported.
   * @internal
   * @license Modernizr 3.0.0pre (Custom Build) | MIT
   */
  function isEventSupported(eventNameSuffix, capture) {
    if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
      return false;
    }

    var eventName = 'on' + eventNameSuffix;
    var isSupported = eventName in document;

    if (!isSupported) {
      var element = document.createElement('div');
      element.setAttribute(eventName, 'return;');
      isSupported = typeof element[eventName] === 'function';
    }

    if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
      // This is the only way to test support for the `wheel` event in IE9+.
      isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
    }

    return isSupported;
  }

  module.exports = isEventSupported;
  return module.exports;
});
$__System.registerDynamic('a7', ['63', 'a6', 'de', 'd5', 'df', '6f', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _assign = $__require('63');
    var EventPluginRegistry = $__require('a6');
    var ReactEventEmitterMixin = $__require('de');
    var ViewportMetrics = $__require('d5');
    var getVendorPrefixedEventName = $__require('df');
    var isEventSupported = $__require('6f');
    var hasEventPageXY;
    var alreadyListeningTo = {};
    var isMonitoringScrollValue = false;
    var reactTopListenersCounter = 0;
    var topEventMapping = {
      topAbort: 'abort',
      topAnimationEnd: getVendorPrefixedEventName('animationend') || 'animationend',
      topAnimationIteration: getVendorPrefixedEventName('animationiteration') || 'animationiteration',
      topAnimationStart: getVendorPrefixedEventName('animationstart') || 'animationstart',
      topBlur: 'blur',
      topCanPlay: 'canplay',
      topCanPlayThrough: 'canplaythrough',
      topChange: 'change',
      topClick: 'click',
      topCompositionEnd: 'compositionend',
      topCompositionStart: 'compositionstart',
      topCompositionUpdate: 'compositionupdate',
      topContextMenu: 'contextmenu',
      topCopy: 'copy',
      topCut: 'cut',
      topDoubleClick: 'dblclick',
      topDrag: 'drag',
      topDragEnd: 'dragend',
      topDragEnter: 'dragenter',
      topDragExit: 'dragexit',
      topDragLeave: 'dragleave',
      topDragOver: 'dragover',
      topDragStart: 'dragstart',
      topDrop: 'drop',
      topDurationChange: 'durationchange',
      topEmptied: 'emptied',
      topEncrypted: 'encrypted',
      topEnded: 'ended',
      topError: 'error',
      topFocus: 'focus',
      topInput: 'input',
      topKeyDown: 'keydown',
      topKeyPress: 'keypress',
      topKeyUp: 'keyup',
      topLoadedData: 'loadeddata',
      topLoadedMetadata: 'loadedmetadata',
      topLoadStart: 'loadstart',
      topMouseDown: 'mousedown',
      topMouseMove: 'mousemove',
      topMouseOut: 'mouseout',
      topMouseOver: 'mouseover',
      topMouseUp: 'mouseup',
      topPaste: 'paste',
      topPause: 'pause',
      topPlay: 'play',
      topPlaying: 'playing',
      topProgress: 'progress',
      topRateChange: 'ratechange',
      topScroll: 'scroll',
      topSeeked: 'seeked',
      topSeeking: 'seeking',
      topSelectionChange: 'selectionchange',
      topStalled: 'stalled',
      topSuspend: 'suspend',
      topTextInput: 'textInput',
      topTimeUpdate: 'timeupdate',
      topTouchCancel: 'touchcancel',
      topTouchEnd: 'touchend',
      topTouchMove: 'touchmove',
      topTouchStart: 'touchstart',
      topTransitionEnd: getVendorPrefixedEventName('transitionend') || 'transitionend',
      topVolumeChange: 'volumechange',
      topWaiting: 'waiting',
      topWheel: 'wheel'
    };
    var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);
    function getListeningForDocument(mountAt) {
      if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
        mountAt[topListenersIDKey] = reactTopListenersCounter++;
        alreadyListeningTo[mountAt[topListenersIDKey]] = {};
      }
      return alreadyListeningTo[mountAt[topListenersIDKey]];
    }
    var ReactBrowserEventEmitter = _assign({}, ReactEventEmitterMixin, {
      ReactEventListener: null,
      injection: { injectReactEventListener: function (ReactEventListener) {
          ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
          ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
        } },
      setEnabled: function (enabled) {
        if (ReactBrowserEventEmitter.ReactEventListener) {
          ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
        }
      },
      isEnabled: function () {
        return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
      },
      listenTo: function (registrationName, contentDocumentHandle) {
        var mountAt = contentDocumentHandle;
        var isListening = getListeningForDocument(mountAt);
        var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];
        for (var i = 0; i < dependencies.length; i++) {
          var dependency = dependencies[i];
          if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
            if (dependency === 'topWheel') {
              if (isEventSupported('wheel')) {
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'wheel', mountAt);
              } else if (isEventSupported('mousewheel')) {
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'mousewheel', mountAt);
              } else {
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'DOMMouseScroll', mountAt);
              }
            } else if (dependency === 'topScroll') {
              if (isEventSupported('scroll', true)) {
                ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topScroll', 'scroll', mountAt);
              } else {
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topScroll', 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
              }
            } else if (dependency === 'topFocus' || dependency === 'topBlur') {
              if (isEventSupported('focus', true)) {
                ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topFocus', 'focus', mountAt);
                ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topBlur', 'blur', mountAt);
              } else if (isEventSupported('focusin')) {
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topFocus', 'focusin', mountAt);
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topBlur', 'focusout', mountAt);
              }
              isListening.topBlur = true;
              isListening.topFocus = true;
            } else if (topEventMapping.hasOwnProperty(dependency)) {
              ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
            }
            isListening[dependency] = true;
          }
        }
      },
      trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
        return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
      },
      trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
        return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
      },
      supportsEventPageXY: function () {
        if (!document.createEvent) {
          return false;
        }
        var ev = document.createEvent('MouseEvent');
        return ev != null && 'pageX' in ev;
      },
      ensureScrollValueMonitoring: function () {
        if (hasEventPageXY === undefined) {
          hasEventPageXY = ReactBrowserEventEmitter.supportsEventPageXY();
        }
        if (!hasEventPageXY && !isMonitoringScrollValue) {
          var refresh = ViewportMetrics.refreshScrollValues;
          ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
          isMonitoringScrollValue = true;
        }
      }
    });
    module.exports = ReactBrowserEventEmitter;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('a8', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2015-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var ReactDOMComponentFlags = {
    hasCachedChildNodes: 1 << 0
  };

  module.exports = ReactDOMComponentFlags;
  return module.exports;
});
$__System.registerDynamic('6c', ['89', '75', 'a8', '8b', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('89');
    var DOMProperty = $__require('75');
    var ReactDOMComponentFlags = $__require('a8');
    var invariant = $__require('8b');
    var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
    var Flags = ReactDOMComponentFlags;
    var internalInstanceKey = '__reactInternalInstance$' + Math.random().toString(36).slice(2);
    function getRenderedHostOrTextFromComponent(component) {
      var rendered;
      while (rendered = component._renderedComponent) {
        component = rendered;
      }
      return component;
    }
    function precacheNode(inst, node) {
      var hostInst = getRenderedHostOrTextFromComponent(inst);
      hostInst._hostNode = node;
      node[internalInstanceKey] = hostInst;
    }
    function uncacheNode(inst) {
      var node = inst._hostNode;
      if (node) {
        delete node[internalInstanceKey];
        inst._hostNode = null;
      }
    }
    function precacheChildNodes(inst, node) {
      if (inst._flags & Flags.hasCachedChildNodes) {
        return;
      }
      var children = inst._renderedChildren;
      var childNode = node.firstChild;
      outer: for (var name in children) {
        if (!children.hasOwnProperty(name)) {
          continue;
        }
        var childInst = children[name];
        var childID = getRenderedHostOrTextFromComponent(childInst)._domID;
        if (childID === 0) {
          continue;
        }
        for (; childNode !== null; childNode = childNode.nextSibling) {
          if (childNode.nodeType === 1 && childNode.getAttribute(ATTR_NAME) === String(childID) || childNode.nodeType === 8 && childNode.nodeValue === ' react-text: ' + childID + ' ' || childNode.nodeType === 8 && childNode.nodeValue === ' react-empty: ' + childID + ' ') {
            precacheNode(childInst, childNode);
            continue outer;
          }
        }
        !false ? 'production' !== 'production' ? invariant(false, 'Unable to find element with ID %s.', childID) : _prodInvariant('32', childID) : void 0;
      }
      inst._flags |= Flags.hasCachedChildNodes;
    }
    function getClosestInstanceFromNode(node) {
      if (node[internalInstanceKey]) {
        return node[internalInstanceKey];
      }
      var parents = [];
      while (!node[internalInstanceKey]) {
        parents.push(node);
        if (node.parentNode) {
          node = node.parentNode;
        } else {
          return null;
        }
      }
      var closest;
      var inst;
      for (; node && (inst = node[internalInstanceKey]); node = parents.pop()) {
        closest = inst;
        if (parents.length) {
          precacheChildNodes(inst, node);
        }
      }
      return closest;
    }
    function getInstanceFromNode(node) {
      var inst = getClosestInstanceFromNode(node);
      if (inst != null && inst._hostNode === node) {
        return inst;
      } else {
        return null;
      }
    }
    function getNodeFromInstance(inst) {
      !(inst._hostNode !== undefined) ? 'production' !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
      if (inst._hostNode) {
        return inst._hostNode;
      }
      var parents = [];
      while (!inst._hostNode) {
        parents.push(inst);
        !inst._hostParent ? 'production' !== 'production' ? invariant(false, 'React DOM tree root should always have a node reference.') : _prodInvariant('34') : void 0;
        inst = inst._hostParent;
      }
      for (; parents.length; inst = parents.pop()) {
        precacheChildNodes(inst, inst._hostNode);
      }
      return inst._hostNode;
    }
    var ReactDOMComponentTree = {
      getClosestInstanceFromNode: getClosestInstanceFromNode,
      getInstanceFromNode: getInstanceFromNode,
      getNodeFromInstance: getNodeFromInstance,
      precacheChildNodes: precacheChildNodes,
      precacheNode: precacheNode,
      uncacheNode: uncacheNode
    };
    module.exports = ReactDOMComponentTree;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('a9', ['63', '9e', '7f', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _assign = $__require('63');
    var emptyFunction = $__require('9e');
    var warning = $__require('7f');
    var validateDOMNesting = emptyFunction;
    if ('production' !== 'production') {
      var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];
      var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template', 'foreignObject', 'desc', 'title'];
      var buttonScopeTags = inScopeTags.concat(['button']);
      var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];
      var emptyAncestorInfo = {
        current: null,
        formTag: null,
        aTagInScope: null,
        buttonTagInScope: null,
        nobrTagInScope: null,
        pTagInButtonScope: null,
        listItemTagAutoclosing: null,
        dlItemTagAutoclosing: null
      };
      var updatedAncestorInfo = function (oldInfo, tag, instance) {
        var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
        var info = {
          tag: tag,
          instance: instance
        };
        if (inScopeTags.indexOf(tag) !== -1) {
          ancestorInfo.aTagInScope = null;
          ancestorInfo.buttonTagInScope = null;
          ancestorInfo.nobrTagInScope = null;
        }
        if (buttonScopeTags.indexOf(tag) !== -1) {
          ancestorInfo.pTagInButtonScope = null;
        }
        if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
          ancestorInfo.listItemTagAutoclosing = null;
          ancestorInfo.dlItemTagAutoclosing = null;
        }
        ancestorInfo.current = info;
        if (tag === 'form') {
          ancestorInfo.formTag = info;
        }
        if (tag === 'a') {
          ancestorInfo.aTagInScope = info;
        }
        if (tag === 'button') {
          ancestorInfo.buttonTagInScope = info;
        }
        if (tag === 'nobr') {
          ancestorInfo.nobrTagInScope = info;
        }
        if (tag === 'p') {
          ancestorInfo.pTagInButtonScope = info;
        }
        if (tag === 'li') {
          ancestorInfo.listItemTagAutoclosing = info;
        }
        if (tag === 'dd' || tag === 'dt') {
          ancestorInfo.dlItemTagAutoclosing = info;
        }
        return ancestorInfo;
      };
      var isTagValidWithParent = function (tag, parentTag) {
        switch (parentTag) {
          case 'select':
            return tag === 'option' || tag === 'optgroup' || tag === '#text';
          case 'optgroup':
            return tag === 'option' || tag === '#text';
          case 'option':
            return tag === '#text';
          case 'tr':
            return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
          case 'tbody':
          case 'thead':
          case 'tfoot':
            return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
          case 'colgroup':
            return tag === 'col' || tag === 'template';
          case 'table':
            return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
          case 'head':
            return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
          case 'html':
            return tag === 'head' || tag === 'body';
          case '#document':
            return tag === 'html';
        }
        switch (tag) {
          case 'h1':
          case 'h2':
          case 'h3':
          case 'h4':
          case 'h5':
          case 'h6':
            return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';
          case 'rp':
          case 'rt':
            return impliedEndTags.indexOf(parentTag) === -1;
          case 'body':
          case 'caption':
          case 'col':
          case 'colgroup':
          case 'frame':
          case 'head':
          case 'html':
          case 'tbody':
          case 'td':
          case 'tfoot':
          case 'th':
          case 'thead':
          case 'tr':
            return parentTag == null;
        }
        return true;
      };
      var findInvalidAncestorForTag = function (tag, ancestorInfo) {
        switch (tag) {
          case 'address':
          case 'article':
          case 'aside':
          case 'blockquote':
          case 'center':
          case 'details':
          case 'dialog':
          case 'dir':
          case 'div':
          case 'dl':
          case 'fieldset':
          case 'figcaption':
          case 'figure':
          case 'footer':
          case 'header':
          case 'hgroup':
          case 'main':
          case 'menu':
          case 'nav':
          case 'ol':
          case 'p':
          case 'section':
          case 'summary':
          case 'ul':
          case 'pre':
          case 'listing':
          case 'table':
          case 'hr':
          case 'xmp':
          case 'h1':
          case 'h2':
          case 'h3':
          case 'h4':
          case 'h5':
          case 'h6':
            return ancestorInfo.pTagInButtonScope;
          case 'form':
            return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
          case 'li':
            return ancestorInfo.listItemTagAutoclosing;
          case 'dd':
          case 'dt':
            return ancestorInfo.dlItemTagAutoclosing;
          case 'button':
            return ancestorInfo.buttonTagInScope;
          case 'a':
            return ancestorInfo.aTagInScope;
          case 'nobr':
            return ancestorInfo.nobrTagInScope;
        }
        return null;
      };
      var findOwnerStack = function (instance) {
        if (!instance) {
          return [];
        }
        var stack = [];
        do {
          stack.push(instance);
        } while (instance = instance._currentElement._owner);
        stack.reverse();
        return stack;
      };
      var didWarn = {};
      validateDOMNesting = function (childTag, childText, childInstance, ancestorInfo) {
        ancestorInfo = ancestorInfo || emptyAncestorInfo;
        var parentInfo = ancestorInfo.current;
        var parentTag = parentInfo && parentInfo.tag;
        if (childText != null) {
          'production' !== 'production' ? warning(childTag == null, 'validateDOMNesting: when childText is passed, childTag should be null') : void 0;
          childTag = '#text';
        }
        var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
        var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
        var problematic = invalidParent || invalidAncestor;
        if (problematic) {
          var ancestorTag = problematic.tag;
          var ancestorInstance = problematic.instance;
          var childOwner = childInstance && childInstance._currentElement._owner;
          var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;
          var childOwners = findOwnerStack(childOwner);
          var ancestorOwners = findOwnerStack(ancestorOwner);
          var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
          var i;
          var deepestCommon = -1;
          for (i = 0; i < minStackLen; i++) {
            if (childOwners[i] === ancestorOwners[i]) {
              deepestCommon = i;
            } else {
              break;
            }
          }
          var UNKNOWN = '(unknown)';
          var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
            return inst.getName() || UNKNOWN;
          });
          var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
            return inst.getName() || UNKNOWN;
          });
          var ownerInfo = [].concat(deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag, invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');
          var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
          if (didWarn[warnKey]) {
            return;
          }
          didWarn[warnKey] = true;
          var tagDisplayName = childTag;
          var whitespaceInfo = '';
          if (childTag === '#text') {
            if (/\S/.test(childText)) {
              tagDisplayName = 'Text nodes';
            } else {
              tagDisplayName = 'Whitespace text nodes';
              whitespaceInfo = ' Make sure you don\'t have any extra whitespace between tags on ' + 'each line of your source code.';
            }
          } else {
            tagDisplayName = '<' + childTag + '>';
          }
          if (invalidParent) {
            var info = '';
            if (ancestorTag === 'table' && childTag === 'tr') {
              info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
            }
            'production' !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s ' + 'See %s.%s', tagDisplayName, ancestorTag, whitespaceInfo, ownerInfo, info) : void 0;
          } else {
            'production' !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>. See %s.', tagDisplayName, ancestorTag, ownerInfo) : void 0;
          }
        }
      };
      validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;
      validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
        ancestorInfo = ancestorInfo || emptyAncestorInfo;
        var parentInfo = ancestorInfo.current;
        var parentTag = parentInfo && parentInfo.tag;
        return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
      };
    }
    module.exports = validateDOMNesting;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('e0', ['a9', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var validateDOMNesting = $__require('a9');
    var DOC_NODE_TYPE = 9;
    function ReactDOMContainerInfo(topLevelWrapper, node) {
      var info = {
        _topLevelWrapper: topLevelWrapper,
        _idCounter: 1,
        _ownerDocument: node ? node.nodeType === DOC_NODE_TYPE ? node : node.ownerDocument : null,
        _node: node,
        _tag: node ? node.nodeName.toLowerCase() : null,
        _namespaceURI: node ? node.namespaceURI : null
      };
      if ('production' !== 'production') {
        info._ancestorInfo = node ? validateDOMNesting.updatedAncestorInfo(null, info._tag, null) : null;
      }
      return info;
    }
    module.exports = ReactDOMContainerInfo;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('e1', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var ReactDOMFeatureFlags = {
    useCreateElement: true,
    useFiber: false
  };

  module.exports = ReactDOMFeatureFlags;
  return module.exports;
});
$__System.registerDynamic('e2', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var MOD = 65521;

  // adler32 is not cryptographically strong, and is only used to sanity check that
  // markup generated on the server matches the markup generated on the client.
  // This implementation (a modified version of the SheetJS version) has been optimized
  // for our use case, at the expense of conforming to the adler32 specification
  // for non-ascii inputs.
  function adler32(data) {
    var a = 1;
    var b = 0;
    var i = 0;
    var l = data.length;
    var m = l & ~0x3;
    while (i < m) {
      var n = Math.min(i + 4096, m);
      for (; i < n; i += 4) {
        b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
      }
      a %= MOD;
      b %= MOD;
    }
    for (; i < l; i++) {
      b += a += data.charCodeAt(i);
    }
    a %= MOD;
    b %= MOD;
    return a | b << 16;
  }

  module.exports = adler32;
  return module.exports;
});
$__System.registerDynamic('e3', ['e2'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var adler32 = $__require('e2');
  var TAG_END = /\/?>/;
  var COMMENT_START = /^<\!\-\-/;
  var ReactMarkupChecksum = {
    CHECKSUM_ATTR_NAME: 'data-react-checksum',
    addChecksumToMarkup: function (markup) {
      var checksum = adler32(markup);
      if (COMMENT_START.test(markup)) {
        return markup;
      } else {
        return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
      }
    },
    canReuseMarkup: function (markup, element) {
      var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
      existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
      var markupChecksum = adler32(markup);
      return markupChecksum === existingChecksum;
    }
  };
  module.exports = ReactMarkupChecksum;
  return module.exports;
});
$__System.registerDynamic('a0', ['89', '99', '9d', '84', '6d', '8b', '7f', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('89');
    var ReactCurrentOwner = $__require('99');
    var ReactInstanceMap = $__require('9d');
    var ReactInstrumentation = $__require('84');
    var ReactUpdates = $__require('6d');
    var invariant = $__require('8b');
    var warning = $__require('7f');
    function enqueueUpdate(internalInstance) {
      ReactUpdates.enqueueUpdate(internalInstance);
    }
    function formatUnexpectedArgument(arg) {
      var type = typeof arg;
      if (type !== 'object') {
        return type;
      }
      var displayName = arg.constructor && arg.constructor.name || type;
      var keys = Object.keys(arg);
      if (keys.length > 0 && keys.length < 20) {
        return displayName + ' (keys: ' + keys.join(', ') + ')';
      }
      return displayName;
    }
    function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
      var internalInstance = ReactInstanceMap.get(publicInstance);
      if (!internalInstance) {
        if ('production' !== 'production') {
          var ctor = publicInstance.constructor;
          'production' !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, ctor && (ctor.displayName || ctor.name) || 'ReactClass') : void 0;
        }
        return null;
      }
      if ('production' !== 'production') {
        'production' !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition (such as ' + 'within `render` or another component\'s constructor). Render methods ' + 'should be a pure function of props and state; constructor ' + 'side-effects are an anti-pattern, but can be moved to ' + '`componentWillMount`.', callerName) : void 0;
      }
      return internalInstance;
    }
    var ReactUpdateQueue = {
      isMounted: function (publicInstance) {
        if ('production' !== 'production') {
          var owner = ReactCurrentOwner.current;
          if (owner !== null) {
            'production' !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
            owner._warnedAboutRefsInRender = true;
          }
        }
        var internalInstance = ReactInstanceMap.get(publicInstance);
        if (internalInstance) {
          return !!internalInstance._renderedComponent;
        } else {
          return false;
        }
      },
      enqueueCallback: function (publicInstance, callback, callerName) {
        ReactUpdateQueue.validateCallback(callback, callerName);
        var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);
        if (!internalInstance) {
          return null;
        }
        if (internalInstance._pendingCallbacks) {
          internalInstance._pendingCallbacks.push(callback);
        } else {
          internalInstance._pendingCallbacks = [callback];
        }
        enqueueUpdate(internalInstance);
      },
      enqueueCallbackInternal: function (internalInstance, callback) {
        if (internalInstance._pendingCallbacks) {
          internalInstance._pendingCallbacks.push(callback);
        } else {
          internalInstance._pendingCallbacks = [callback];
        }
        enqueueUpdate(internalInstance);
      },
      enqueueForceUpdate: function (publicInstance) {
        var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');
        if (!internalInstance) {
          return;
        }
        internalInstance._pendingForceUpdate = true;
        enqueueUpdate(internalInstance);
      },
      enqueueReplaceState: function (publicInstance, completeState) {
        var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');
        if (!internalInstance) {
          return;
        }
        internalInstance._pendingStateQueue = [completeState];
        internalInstance._pendingReplaceState = true;
        enqueueUpdate(internalInstance);
      },
      enqueueSetState: function (publicInstance, partialState) {
        if ('production' !== 'production') {
          ReactInstrumentation.debugTool.onSetState();
          'production' !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : void 0;
        }
        var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');
        if (!internalInstance) {
          return;
        }
        var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
        queue.push(partialState);
        enqueueUpdate(internalInstance);
      },
      enqueueElementInternal: function (internalInstance, nextElement, nextContext) {
        internalInstance._pendingElement = nextElement;
        internalInstance._context = nextContext;
        enqueueUpdate(internalInstance);
      },
      validateCallback: function (callback, callerName) {
        !(!callback || typeof callback === 'function') ? 'production' !== 'production' ? invariant(false, '%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.', callerName, formatUnexpectedArgument(callback)) : _prodInvariant('122', callerName, formatUnexpectedArgument(callback)) : void 0;
      }
    };
    module.exports = ReactUpdateQueue;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('be', ['89', '61', '8b', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('89');
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var PooledClass = $__require('61');
    var invariant = $__require('8b');
    var CallbackQueue = function () {
      function CallbackQueue(arg) {
        _classCallCheck(this, CallbackQueue);
        this._callbacks = null;
        this._contexts = null;
        this._arg = arg;
      }
      CallbackQueue.prototype.enqueue = function enqueue(callback, context) {
        this._callbacks = this._callbacks || [];
        this._callbacks.push(callback);
        this._contexts = this._contexts || [];
        this._contexts.push(context);
      };
      CallbackQueue.prototype.notifyAll = function notifyAll() {
        var callbacks = this._callbacks;
        var contexts = this._contexts;
        var arg = this._arg;
        if (callbacks && contexts) {
          !(callbacks.length === contexts.length) ? 'production' !== 'production' ? invariant(false, 'Mismatched list of contexts in callback queue') : _prodInvariant('24') : void 0;
          this._callbacks = null;
          this._contexts = null;
          for (var i = 0; i < callbacks.length; i++) {
            callbacks[i].call(contexts[i], arg);
          }
          callbacks.length = 0;
          contexts.length = 0;
        }
      };
      CallbackQueue.prototype.checkpoint = function checkpoint() {
        return this._callbacks ? this._callbacks.length : 0;
      };
      CallbackQueue.prototype.rollback = function rollback(len) {
        if (this._callbacks && this._contexts) {
          this._callbacks.length = len;
          this._contexts.length = len;
        }
      };
      CallbackQueue.prototype.reset = function reset() {
        this._callbacks = null;
        this._contexts = null;
      };
      CallbackQueue.prototype.destructor = function destructor() {
        this.reset();
      };
      return CallbackQueue;
    }();
    module.exports = PooledClass.addPoolingTo(CallbackQueue);
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('61', ['89', '8b', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('89');
    var invariant = $__require('8b');
    var oneArgumentPooler = function (copyFieldsFrom) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, copyFieldsFrom);
        return instance;
      } else {
        return new Klass(copyFieldsFrom);
      }
    };
    var twoArgumentPooler = function (a1, a2) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, a1, a2);
        return instance;
      } else {
        return new Klass(a1, a2);
      }
    };
    var threeArgumentPooler = function (a1, a2, a3) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, a1, a2, a3);
        return instance;
      } else {
        return new Klass(a1, a2, a3);
      }
    };
    var fourArgumentPooler = function (a1, a2, a3, a4) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, a1, a2, a3, a4);
        return instance;
      } else {
        return new Klass(a1, a2, a3, a4);
      }
    };
    var fiveArgumentPooler = function (a1, a2, a3, a4, a5) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, a1, a2, a3, a4, a5);
        return instance;
      } else {
        return new Klass(a1, a2, a3, a4, a5);
      }
    };
    var standardReleaser = function (instance) {
      var Klass = this;
      !(instance instanceof Klass) ? 'production' !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25') : void 0;
      instance.destructor();
      if (Klass.instancePool.length < Klass.poolSize) {
        Klass.instancePool.push(instance);
      }
    };
    var DEFAULT_POOL_SIZE = 10;
    var DEFAULT_POOLER = oneArgumentPooler;
    var addPoolingTo = function (CopyConstructor, pooler) {
      var NewKlass = CopyConstructor;
      NewKlass.instancePool = [];
      NewKlass.getPooled = pooler || DEFAULT_POOLER;
      if (!NewKlass.poolSize) {
        NewKlass.poolSize = DEFAULT_POOL_SIZE;
      }
      NewKlass.release = standardReleaser;
      return NewKlass;
    };
    var PooledClass = {
      addPoolingTo: addPoolingTo,
      oneArgumentPooler: oneArgumentPooler,
      twoArgumentPooler: twoArgumentPooler,
      threeArgumentPooler: threeArgumentPooler,
      fourArgumentPooler: fourArgumentPooler,
      fiveArgumentPooler: fiveArgumentPooler
    };
    module.exports = PooledClass;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('e4', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var ReactFeatureFlags = {
    // When true, call console.time() before and .timeEnd() after each top-level
    // render (both initial renders and updates). Useful when looking at prod-mode
    // timeline profiles in Chrome, for example.
    logTopLevelRenders: false
  };

  module.exports = ReactFeatureFlags;
  return module.exports;
});
$__System.registerDynamic('a2', ['89', '8b', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('89');
    var invariant = $__require('8b');
    var OBSERVED_ERROR = {};
    var TransactionImpl = {
      reinitializeTransaction: function () {
        this.transactionWrappers = this.getTransactionWrappers();
        if (this.wrapperInitData) {
          this.wrapperInitData.length = 0;
        } else {
          this.wrapperInitData = [];
        }
        this._isInTransaction = false;
      },
      _isInTransaction: false,
      getTransactionWrappers: null,
      isInTransaction: function () {
        return !!this._isInTransaction;
      },
      perform: function (method, scope, a, b, c, d, e, f) {
        !!this.isInTransaction() ? 'production' !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there is already an outstanding transaction.') : _prodInvariant('27') : void 0;
        var errorThrown;
        var ret;
        try {
          this._isInTransaction = true;
          errorThrown = true;
          this.initializeAll(0);
          ret = method.call(scope, a, b, c, d, e, f);
          errorThrown = false;
        } finally {
          try {
            if (errorThrown) {
              try {
                this.closeAll(0);
              } catch (err) {}
            } else {
              this.closeAll(0);
            }
          } finally {
            this._isInTransaction = false;
          }
        }
        return ret;
      },
      initializeAll: function (startIndex) {
        var transactionWrappers = this.transactionWrappers;
        for (var i = startIndex; i < transactionWrappers.length; i++) {
          var wrapper = transactionWrappers[i];
          try {
            this.wrapperInitData[i] = OBSERVED_ERROR;
            this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
          } finally {
            if (this.wrapperInitData[i] === OBSERVED_ERROR) {
              try {
                this.initializeAll(i + 1);
              } catch (err) {}
            }
          }
        }
      },
      closeAll: function (startIndex) {
        !this.isInTransaction() ? 'production' !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : _prodInvariant('28') : void 0;
        var transactionWrappers = this.transactionWrappers;
        for (var i = startIndex; i < transactionWrappers.length; i++) {
          var wrapper = transactionWrappers[i];
          var initData = this.wrapperInitData[i];
          var errorThrown;
          try {
            errorThrown = true;
            if (initData !== OBSERVED_ERROR && wrapper.close) {
              wrapper.close.call(this, initData);
            }
            errorThrown = false;
          } finally {
            if (errorThrown) {
              try {
                this.closeAll(i + 1);
              } catch (e) {}
            }
          }
        }
        this.wrapperInitData.length = 0;
      }
    };
    module.exports = TransactionImpl;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('6d', ['89', '63', 'be', '61', 'e4', '91', 'a2', '8b', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('89'),
        _assign = $__require('63');
    var CallbackQueue = $__require('be');
    var PooledClass = $__require('61');
    var ReactFeatureFlags = $__require('e4');
    var ReactReconciler = $__require('91');
    var Transaction = $__require('a2');
    var invariant = $__require('8b');
    var dirtyComponents = [];
    var updateBatchNumber = 0;
    var asapCallbackQueue = CallbackQueue.getPooled();
    var asapEnqueued = false;
    var batchingStrategy = null;
    function ensureInjected() {
      !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? 'production' !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching strategy') : _prodInvariant('123') : void 0;
    }
    var NESTED_UPDATES = {
      initialize: function () {
        this.dirtyComponentsLength = dirtyComponents.length;
      },
      close: function () {
        if (this.dirtyComponentsLength !== dirtyComponents.length) {
          dirtyComponents.splice(0, this.dirtyComponentsLength);
          flushBatchedUpdates();
        } else {
          dirtyComponents.length = 0;
        }
      }
    };
    var UPDATE_QUEUEING = {
      initialize: function () {
        this.callbackQueue.reset();
      },
      close: function () {
        this.callbackQueue.notifyAll();
      }
    };
    var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];
    function ReactUpdatesFlushTransaction() {
      this.reinitializeTransaction();
      this.dirtyComponentsLength = null;
      this.callbackQueue = CallbackQueue.getPooled();
      this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled(true);
    }
    _assign(ReactUpdatesFlushTransaction.prototype, Transaction, {
      getTransactionWrappers: function () {
        return TRANSACTION_WRAPPERS;
      },
      destructor: function () {
        this.dirtyComponentsLength = null;
        CallbackQueue.release(this.callbackQueue);
        this.callbackQueue = null;
        ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
        this.reconcileTransaction = null;
      },
      perform: function (method, scope, a) {
        return Transaction.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
      }
    });
    PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);
    function batchedUpdates(callback, a, b, c, d, e) {
      ensureInjected();
      return batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
    }
    function mountOrderComparator(c1, c2) {
      return c1._mountOrder - c2._mountOrder;
    }
    function runBatchedUpdates(transaction) {
      var len = transaction.dirtyComponentsLength;
      !(len === dirtyComponents.length) ? 'production' !== 'production' ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to match dirty-components array length (%s).', len, dirtyComponents.length) : _prodInvariant('124', len, dirtyComponents.length) : void 0;
      dirtyComponents.sort(mountOrderComparator);
      updateBatchNumber++;
      for (var i = 0; i < len; i++) {
        var component = dirtyComponents[i];
        var callbacks = component._pendingCallbacks;
        component._pendingCallbacks = null;
        var markerName;
        if (ReactFeatureFlags.logTopLevelRenders) {
          var namedComponent = component;
          if (component._currentElement.type.isReactTopLevelWrapper) {
            namedComponent = component._renderedComponent;
          }
          markerName = 'React update: ' + namedComponent.getName();
          console.time(markerName);
        }
        ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction, updateBatchNumber);
        if (markerName) {
          console.timeEnd(markerName);
        }
        if (callbacks) {
          for (var j = 0; j < callbacks.length; j++) {
            transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
          }
        }
      }
    }
    var flushBatchedUpdates = function () {
      while (dirtyComponents.length || asapEnqueued) {
        if (dirtyComponents.length) {
          var transaction = ReactUpdatesFlushTransaction.getPooled();
          transaction.perform(runBatchedUpdates, null, transaction);
          ReactUpdatesFlushTransaction.release(transaction);
        }
        if (asapEnqueued) {
          asapEnqueued = false;
          var queue = asapCallbackQueue;
          asapCallbackQueue = CallbackQueue.getPooled();
          queue.notifyAll();
          CallbackQueue.release(queue);
        }
      }
    };
    function enqueueUpdate(component) {
      ensureInjected();
      if (!batchingStrategy.isBatchingUpdates) {
        batchingStrategy.batchedUpdates(enqueueUpdate, component);
        return;
      }
      dirtyComponents.push(component);
      if (component._updateBatchNumber == null) {
        component._updateBatchNumber = updateBatchNumber + 1;
      }
    }
    function asap(callback, context) {
      !batchingStrategy.isBatchingUpdates ? 'production' !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context whereupdates are not being batched.') : _prodInvariant('125') : void 0;
      asapCallbackQueue.enqueue(callback, context);
      asapEnqueued = true;
    }
    var ReactUpdatesInjection = {
      injectReconcileTransaction: function (ReconcileTransaction) {
        !ReconcileTransaction ? 'production' !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : _prodInvariant('126') : void 0;
        ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
      },
      injectBatchingStrategy: function (_batchingStrategy) {
        !_batchingStrategy ? 'production' !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : _prodInvariant('127') : void 0;
        !(typeof _batchingStrategy.batchedUpdates === 'function') ? 'production' !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : _prodInvariant('128') : void 0;
        !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? 'production' !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : _prodInvariant('129') : void 0;
        batchingStrategy = _batchingStrategy;
      }
    };
    var ReactUpdates = {
      ReactReconcileTransaction: null,
      batchedUpdates: batchedUpdates,
      enqueueUpdate: enqueueUpdate,
      flushBatchedUpdates: flushBatchedUpdates,
      injection: ReactUpdatesInjection,
      asap: asap
    };
    module.exports = ReactUpdates;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('9c', ['89', '8b', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('89');
    var invariant = $__require('8b');
    var injected = false;
    var ReactComponentEnvironment = {
      replaceNodeWithMarkup: null,
      processChildrenUpdates: null,
      injection: { injectEnvironment: function (environment) {
          !!injected ? 'production' !== 'production' ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : _prodInvariant('104') : void 0;
          ReactComponentEnvironment.replaceNodeWithMarkup = environment.replaceNodeWithMarkup;
          ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
          injected = true;
        } }
    };
    module.exports = ReactComponentEnvironment;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('dd', ['13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var caughtError = null;
    function invokeGuardedCallback(name, func, a) {
      try {
        func(a);
      } catch (x) {
        if (caughtError === null) {
          caughtError = x;
        }
      }
    }
    var ReactErrorUtils = {
      invokeGuardedCallback: invokeGuardedCallback,
      invokeGuardedCallbackWithCatch: invokeGuardedCallback,
      rethrowCaughtError: function () {
        if (caughtError) {
          var error = caughtError;
          caughtError = null;
          throw error;
        }
      }
    };
    if ('production' !== 'production') {
      if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
        var fakeNode = document.createElement('react');
        ReactErrorUtils.invokeGuardedCallback = function (name, func, a) {
          var boundFunc = func.bind(null, a);
          var evtType = 'react-' + name;
          fakeNode.addEventListener(evtType, boundFunc, false);
          var evt = document.createEvent('Event');
          evt.initEvent(evtType, false, false);
          fakeNode.dispatchEvent(evt);
          fakeNode.removeEventListener(evtType, boundFunc, false);
        };
      }
    }
    module.exports = ReactErrorUtils;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('9d', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  /**
   * `ReactInstanceMap` maintains a mapping from a public facing stateful
   * instance (key) and the internal representation (value). This allows public
   * methods to accept the user facing instance as an argument and map them back
   * to internal methods.
   */

  // TODO: Replace this with ES6: var ReactInstanceMap = new Map();

  var define,
      global = this || self,
      GLOBAL = global;
  var ReactInstanceMap = {

    /**
     * This API should be called `delete` but we'd have to make sure to always
     * transform these to strings for IE support. When this transform is fully
     * supported we can rename it.
     */
    remove: function (key) {
      key._reactInternalInstance = undefined;
    },

    get: function (key) {
      return key._reactInternalInstance;
    },

    has: function (key) {
      return key._reactInternalInstance !== undefined;
    },

    set: function (key, value) {
      key._reactInternalInstance = value;
    }

  };

  module.exports = ReactInstanceMap;
  return module.exports;
});
$__System.registerDynamic('e5', ['e6', '8b', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('e6');
    var invariant = $__require('8b');
    var oneArgumentPooler = function (copyFieldsFrom) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, copyFieldsFrom);
        return instance;
      } else {
        return new Klass(copyFieldsFrom);
      }
    };
    var twoArgumentPooler = function (a1, a2) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, a1, a2);
        return instance;
      } else {
        return new Klass(a1, a2);
      }
    };
    var threeArgumentPooler = function (a1, a2, a3) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, a1, a2, a3);
        return instance;
      } else {
        return new Klass(a1, a2, a3);
      }
    };
    var fourArgumentPooler = function (a1, a2, a3, a4) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, a1, a2, a3, a4);
        return instance;
      } else {
        return new Klass(a1, a2, a3, a4);
      }
    };
    var fiveArgumentPooler = function (a1, a2, a3, a4, a5) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, a1, a2, a3, a4, a5);
        return instance;
      } else {
        return new Klass(a1, a2, a3, a4, a5);
      }
    };
    var standardReleaser = function (instance) {
      var Klass = this;
      !(instance instanceof Klass) ? 'production' !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25') : void 0;
      instance.destructor();
      if (Klass.instancePool.length < Klass.poolSize) {
        Klass.instancePool.push(instance);
      }
    };
    var DEFAULT_POOL_SIZE = 10;
    var DEFAULT_POOLER = oneArgumentPooler;
    var addPoolingTo = function (CopyConstructor, pooler) {
      var NewKlass = CopyConstructor;
      NewKlass.instancePool = [];
      NewKlass.getPooled = pooler || DEFAULT_POOLER;
      if (!NewKlass.poolSize) {
        NewKlass.poolSize = DEFAULT_POOL_SIZE;
      }
      NewKlass.release = standardReleaser;
      return NewKlass;
    };
    var PooledClass = {
      addPoolingTo: addPoolingTo,
      oneArgumentPooler: oneArgumentPooler,
      twoArgumentPooler: twoArgumentPooler,
      threeArgumentPooler: threeArgumentPooler,
      fourArgumentPooler: fourArgumentPooler,
      fiveArgumentPooler: fiveArgumentPooler
    };
    module.exports = PooledClass;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('e7', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  /**
   * Escape and wrap key so it is safe to use as a reactid
   *
   * @param {string} key to be escaped.
   * @return {string} the escaped key.
   */

  var define,
      global = this || self,
      GLOBAL = global;
  function escape(key) {
    var escapeRegex = /[=:]/g;
    var escaperLookup = {
      '=': '=0',
      ':': '=2'
    };
    var escapedString = ('' + key).replace(escapeRegex, function (match) {
      return escaperLookup[match];
    });

    return '$' + escapedString;
  }

  /**
   * Unescape and unwrap key for human-readable display
   *
   * @param {string} key to unescape.
   * @return {string} the unescaped key.
   */
  function unescape(key) {
    var unescapeRegex = /(=0|=2)/g;
    var unescaperLookup = {
      '=0': '=',
      '=2': ':'
    };
    var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);

    return ('' + keySubstring).replace(unescapeRegex, function (match) {
      return unescaperLookup[match];
    });
  }

  var KeyEscapeUtils = {
    escape: escape,
    unescape: unescape
  };

  module.exports = KeyEscapeUtils;
  return module.exports;
});
$__System.registerDynamic('e8', ['e6', '99', 'e9', 'ea', '8b', 'e7', '7f', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('e6');
    var ReactCurrentOwner = $__require('99');
    var REACT_ELEMENT_TYPE = $__require('e9');
    var getIteratorFn = $__require('ea');
    var invariant = $__require('8b');
    var KeyEscapeUtils = $__require('e7');
    var warning = $__require('7f');
    var SEPARATOR = '.';
    var SUBSEPARATOR = ':';
    var didWarnAboutMaps = false;
    function getComponentKey(component, index) {
      if (component && typeof component === 'object' && component.key != null) {
        return KeyEscapeUtils.escape(component.key);
      }
      return index.toString(36);
    }
    function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
      var type = typeof children;
      if (type === 'undefined' || type === 'boolean') {
        children = null;
      }
      if (children === null || type === 'string' || type === 'number' || type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {
        callback(traverseContext, children, nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
        return 1;
      }
      var child;
      var nextName;
      var subtreeCount = 0;
      var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
      if (Array.isArray(children)) {
        for (var i = 0; i < children.length; i++) {
          child = children[i];
          nextName = nextNamePrefix + getComponentKey(child, i);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      } else {
        var iteratorFn = getIteratorFn(children);
        if (iteratorFn) {
          var iterator = iteratorFn.call(children);
          var step;
          if (iteratorFn !== children.entries) {
            var ii = 0;
            while (!(step = iterator.next()).done) {
              child = step.value;
              nextName = nextNamePrefix + getComponentKey(child, ii++);
              subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
            }
          } else {
            if ('production' !== 'production') {
              var mapsAsChildrenAddendum = '';
              if (ReactCurrentOwner.current) {
                var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
                if (mapsAsChildrenOwnerName) {
                  mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
                }
              }
              'production' !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
              didWarnAboutMaps = true;
            }
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                child = entry[1];
                nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
                subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
              }
            }
          }
        } else if (type === 'object') {
          var addendum = '';
          if ('production' !== 'production') {
            addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
            if (children._isReactElement) {
              addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
            }
            if (ReactCurrentOwner.current) {
              var name = ReactCurrentOwner.current.getName();
              if (name) {
                addendum += ' Check the render method of `' + name + '`.';
              }
            }
          }
          var childrenString = String(children);
          !false ? 'production' !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
        }
      }
      return subtreeCount;
    }
    function traverseAllChildren(children, callback, traverseContext) {
      if (children == null) {
        return 0;
      }
      return traverseAllChildrenImpl(children, '', callback, traverseContext);
    }
    module.exports = traverseAllChildren;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('eb', ['e5', 'ec', '9e', 'e8'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var PooledClass = $__require('e5');
  var ReactElement = $__require('ec');
  var emptyFunction = $__require('9e');
  var traverseAllChildren = $__require('e8');
  var twoArgumentPooler = PooledClass.twoArgumentPooler;
  var fourArgumentPooler = PooledClass.fourArgumentPooler;
  var userProvidedKeyEscapeRegex = /\/+/g;
  function escapeUserProvidedKey(text) {
    return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
  }
  function ForEachBookKeeping(forEachFunction, forEachContext) {
    this.func = forEachFunction;
    this.context = forEachContext;
    this.count = 0;
  }
  ForEachBookKeeping.prototype.destructor = function () {
    this.func = null;
    this.context = null;
    this.count = 0;
  };
  PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);
  function forEachSingleChild(bookKeeping, child, name) {
    var func = bookKeeping.func,
        context = bookKeeping.context;
    func.call(context, child, bookKeeping.count++);
  }
  function forEachChildren(children, forEachFunc, forEachContext) {
    if (children == null) {
      return children;
    }
    var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
    traverseAllChildren(children, forEachSingleChild, traverseContext);
    ForEachBookKeeping.release(traverseContext);
  }
  function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
    this.result = mapResult;
    this.keyPrefix = keyPrefix;
    this.func = mapFunction;
    this.context = mapContext;
    this.count = 0;
  }
  MapBookKeeping.prototype.destructor = function () {
    this.result = null;
    this.keyPrefix = null;
    this.func = null;
    this.context = null;
    this.count = 0;
  };
  PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);
  function mapSingleChildIntoContext(bookKeeping, child, childKey) {
    var result = bookKeeping.result,
        keyPrefix = bookKeeping.keyPrefix,
        func = bookKeeping.func,
        context = bookKeeping.context;
    var mappedChild = func.call(context, child, bookKeeping.count++);
    if (Array.isArray(mappedChild)) {
      mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
    } else if (mappedChild != null) {
      if (ReactElement.isValidElement(mappedChild)) {
        mappedChild = ReactElement.cloneAndReplaceKey(mappedChild, keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
      }
      result.push(mappedChild);
    }
  }
  function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
    var escapedPrefix = '';
    if (prefix != null) {
      escapedPrefix = escapeUserProvidedKey(prefix) + '/';
    }
    var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
    traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
    MapBookKeeping.release(traverseContext);
  }
  function mapChildren(children, func, context) {
    if (children == null) {
      return children;
    }
    var result = [];
    mapIntoWithKeyPrefixInternal(children, result, null, func, context);
    return result;
  }
  function forEachSingleChildDummy(traverseContext, child, name) {
    return null;
  }
  function countChildren(children, context) {
    return traverseAllChildren(children, forEachSingleChildDummy, null);
  }
  function toArray(children) {
    var result = [];
    mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
    return result;
  }
  var ReactChildren = {
    forEach: forEachChildren,
    map: mapChildren,
    mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
    count: countChildren,
    toArray: toArray
  };
  module.exports = ReactChildren;
  return module.exports;
});
$__System.registerDynamic('ed', ['63', 'ee', 'ef', 'f0'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var _assign = $__require('63');
  var ReactComponent = $__require('ee');
  var ReactNoopUpdateQueue = $__require('ef');
  var emptyObject = $__require('f0');
  function ReactPureComponent(props, context, updater) {
    this.props = props;
    this.context = context;
    this.refs = emptyObject;
    this.updater = updater || ReactNoopUpdateQueue;
  }
  function ComponentDummy() {}
  ComponentDummy.prototype = ReactComponent.prototype;
  ReactPureComponent.prototype = new ComponentDummy();
  ReactPureComponent.prototype.constructor = ReactPureComponent;
  _assign(ReactPureComponent.prototype, ReactComponent.prototype);
  ReactPureComponent.prototype.isPureReactComponent = true;
  module.exports = ReactPureComponent;
  return module.exports;
});
$__System.registerDynamic('ee', ['e6', 'ef', 'f1', 'f0', '8b', '7f', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('e6');
    var ReactNoopUpdateQueue = $__require('ef');
    var canDefineProperty = $__require('f1');
    var emptyObject = $__require('f0');
    var invariant = $__require('8b');
    var warning = $__require('7f');
    function ReactComponent(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    ReactComponent.prototype.isReactComponent = {};
    ReactComponent.prototype.setState = function (partialState, callback) {
      !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? 'production' !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : _prodInvariant('85') : void 0;
      this.updater.enqueueSetState(this, partialState);
      if (callback) {
        this.updater.enqueueCallback(this, callback, 'setState');
      }
    };
    ReactComponent.prototype.forceUpdate = function (callback) {
      this.updater.enqueueForceUpdate(this);
      if (callback) {
        this.updater.enqueueCallback(this, callback, 'forceUpdate');
      }
    };
    if ('production' !== 'production') {
      var deprecatedAPIs = {
        isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
        replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
      };
      var defineDeprecationWarning = function (methodName, info) {
        if (canDefineProperty) {
          Object.defineProperty(ReactComponent.prototype, methodName, { get: function () {
              'production' !== 'production' ? warning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : void 0;
              return undefined;
            } });
        }
      };
      for (var fnName in deprecatedAPIs) {
        if (deprecatedAPIs.hasOwnProperty(fnName)) {
          defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
        }
      }
    }
    module.exports = ReactComponent;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('ef', ['7f', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var warning = $__require('7f');
    function warnNoop(publicInstance, callerName) {
      if ('production' !== 'production') {
        var constructor = publicInstance.constructor;
        'production' !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
      }
    }
    var ReactNoopUpdateQueue = {
      isMounted: function (publicInstance) {
        return false;
      },
      enqueueCallback: function (publicInstance, callback) {},
      enqueueForceUpdate: function (publicInstance) {
        warnNoop(publicInstance, 'forceUpdate');
      },
      enqueueReplaceState: function (publicInstance, completeState) {
        warnNoop(publicInstance, 'replaceState');
      },
      enqueueSetState: function (publicInstance, partialState) {
        warnNoop(publicInstance, 'setState');
      }
    };
    module.exports = ReactNoopUpdateQueue;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('f2', ['e6', '63', 'ee', 'ec', 'f3', 'ef', 'f0', '8b', '7f', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('e6'),
        _assign = $__require('63');
    var ReactComponent = $__require('ee');
    var ReactElement = $__require('ec');
    var ReactPropTypeLocationNames = $__require('f3');
    var ReactNoopUpdateQueue = $__require('ef');
    var emptyObject = $__require('f0');
    var invariant = $__require('8b');
    var warning = $__require('7f');
    var MIXINS_KEY = 'mixins';
    function identity(fn) {
      return fn;
    }
    var injectedMixins = [];
    var ReactClassInterface = {
      mixins: 'DEFINE_MANY',
      statics: 'DEFINE_MANY',
      propTypes: 'DEFINE_MANY',
      contextTypes: 'DEFINE_MANY',
      childContextTypes: 'DEFINE_MANY',
      getDefaultProps: 'DEFINE_MANY_MERGED',
      getInitialState: 'DEFINE_MANY_MERGED',
      getChildContext: 'DEFINE_MANY_MERGED',
      render: 'DEFINE_ONCE',
      componentWillMount: 'DEFINE_MANY',
      componentDidMount: 'DEFINE_MANY',
      componentWillReceiveProps: 'DEFINE_MANY',
      shouldComponentUpdate: 'DEFINE_ONCE',
      componentWillUpdate: 'DEFINE_MANY',
      componentDidUpdate: 'DEFINE_MANY',
      componentWillUnmount: 'DEFINE_MANY',
      updateComponent: 'OVERRIDE_BASE'
    };
    var RESERVED_SPEC_KEYS = {
      displayName: function (Constructor, displayName) {
        Constructor.displayName = displayName;
      },
      mixins: function (Constructor, mixins) {
        if (mixins) {
          for (var i = 0; i < mixins.length; i++) {
            mixSpecIntoComponent(Constructor, mixins[i]);
          }
        }
      },
      childContextTypes: function (Constructor, childContextTypes) {
        if ('production' !== 'production') {
          validateTypeDef(Constructor, childContextTypes, 'childContext');
        }
        Constructor.childContextTypes = _assign({}, Constructor.childContextTypes, childContextTypes);
      },
      contextTypes: function (Constructor, contextTypes) {
        if ('production' !== 'production') {
          validateTypeDef(Constructor, contextTypes, 'context');
        }
        Constructor.contextTypes = _assign({}, Constructor.contextTypes, contextTypes);
      },
      getDefaultProps: function (Constructor, getDefaultProps) {
        if (Constructor.getDefaultProps) {
          Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);
        } else {
          Constructor.getDefaultProps = getDefaultProps;
        }
      },
      propTypes: function (Constructor, propTypes) {
        if ('production' !== 'production') {
          validateTypeDef(Constructor, propTypes, 'prop');
        }
        Constructor.propTypes = _assign({}, Constructor.propTypes, propTypes);
      },
      statics: function (Constructor, statics) {
        mixStaticSpecIntoComponent(Constructor, statics);
      },
      autobind: function () {}
    };
    function validateTypeDef(Constructor, typeDef, location) {
      for (var propName in typeDef) {
        if (typeDef.hasOwnProperty(propName)) {
          'production' !== 'production' ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : void 0;
        }
      }
    }
    function validateMethodOverride(isAlreadyDefined, name) {
      var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;
      if (ReactClassMixin.hasOwnProperty(name)) {
        !(specPolicy === 'OVERRIDE_BASE') ? 'production' !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to override `%s` from your class specification. Ensure that your method names do not overlap with React methods.', name) : _prodInvariant('73', name) : void 0;
      }
      if (isAlreadyDefined) {
        !(specPolicy === 'DEFINE_MANY' || specPolicy === 'DEFINE_MANY_MERGED') ? 'production' !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('74', name) : void 0;
      }
    }
    function mixSpecIntoComponent(Constructor, spec) {
      if (!spec) {
        if ('production' !== 'production') {
          var typeofSpec = typeof spec;
          var isMixinValid = typeofSpec === 'object' && spec !== null;
          'production' !== 'production' ? warning(isMixinValid, '%s: You\'re attempting to include a mixin that is either null ' + 'or not an object. Check the mixins included by the component, ' + 'as well as any mixins they include themselves. ' + 'Expected object but got %s.', Constructor.displayName || 'ReactClass', spec === null ? null : typeofSpec) : void 0;
        }
        return;
      }
      !(typeof spec !== 'function') ? 'production' !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to use a component class or function as a mixin. Instead, just use a regular object.') : _prodInvariant('75') : void 0;
      !!ReactElement.isValidElement(spec) ? 'production' !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to use a component as a mixin. Instead, just use a regular object.') : _prodInvariant('76') : void 0;
      var proto = Constructor.prototype;
      var autoBindPairs = proto.__reactAutoBindPairs;
      if (spec.hasOwnProperty(MIXINS_KEY)) {
        RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
      }
      for (var name in spec) {
        if (!spec.hasOwnProperty(name)) {
          continue;
        }
        if (name === MIXINS_KEY) {
          continue;
        }
        var property = spec[name];
        var isAlreadyDefined = proto.hasOwnProperty(name);
        validateMethodOverride(isAlreadyDefined, name);
        if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
          RESERVED_SPEC_KEYS[name](Constructor, property);
        } else {
          var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
          var isFunction = typeof property === 'function';
          var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;
          if (shouldAutoBind) {
            autoBindPairs.push(name, property);
            proto[name] = property;
          } else {
            if (isAlreadyDefined) {
              var specPolicy = ReactClassInterface[name];
              !(isReactClassMethod && (specPolicy === 'DEFINE_MANY_MERGED' || specPolicy === 'DEFINE_MANY')) ? 'production' !== 'production' ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s when mixing in component specs.', specPolicy, name) : _prodInvariant('77', specPolicy, name) : void 0;
              if (specPolicy === 'DEFINE_MANY_MERGED') {
                proto[name] = createMergedResultFunction(proto[name], property);
              } else if (specPolicy === 'DEFINE_MANY') {
                proto[name] = createChainedFunction(proto[name], property);
              }
            } else {
              proto[name] = property;
              if ('production' !== 'production') {
                if (typeof property === 'function' && spec.displayName) {
                  proto[name].displayName = spec.displayName + '_' + name;
                }
              }
            }
          }
        }
      }
    }
    function mixStaticSpecIntoComponent(Constructor, statics) {
      if (!statics) {
        return;
      }
      for (var name in statics) {
        var property = statics[name];
        if (!statics.hasOwnProperty(name)) {
          continue;
        }
        var isReserved = name in RESERVED_SPEC_KEYS;
        !!isReserved ? 'production' !== 'production' ? invariant(false, 'ReactClass: You are attempting to define a reserved property, `%s`, that shouldn\'t be on the "statics" key. Define it as an instance property instead; it will still be accessible on the constructor.', name) : _prodInvariant('78', name) : void 0;
        var isInherited = name in Constructor;
        !!isInherited ? 'production' !== 'production' ? invariant(false, 'ReactClass: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('79', name) : void 0;
        Constructor[name] = property;
      }
    }
    function mergeIntoWithNoDuplicateKeys(one, two) {
      !(one && two && typeof one === 'object' && typeof two === 'object') ? 'production' !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : _prodInvariant('80') : void 0;
      for (var key in two) {
        if (two.hasOwnProperty(key)) {
          !(one[key] === undefined) ? 'production' !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Tried to merge two objects with the same key: `%s`. This conflict may be due to a mixin; in particular, this may be caused by two getInitialState() or getDefaultProps() methods returning objects with clashing keys.', key) : _prodInvariant('81', key) : void 0;
          one[key] = two[key];
        }
      }
      return one;
    }
    function createMergedResultFunction(one, two) {
      return function mergedResult() {
        var a = one.apply(this, arguments);
        var b = two.apply(this, arguments);
        if (a == null) {
          return b;
        } else if (b == null) {
          return a;
        }
        var c = {};
        mergeIntoWithNoDuplicateKeys(c, a);
        mergeIntoWithNoDuplicateKeys(c, b);
        return c;
      };
    }
    function createChainedFunction(one, two) {
      return function chainedFunction() {
        one.apply(this, arguments);
        two.apply(this, arguments);
      };
    }
    function bindAutoBindMethod(component, method) {
      var boundMethod = method.bind(component);
      if ('production' !== 'production') {
        boundMethod.__reactBoundContext = component;
        boundMethod.__reactBoundMethod = method;
        boundMethod.__reactBoundArguments = null;
        var componentName = component.constructor.displayName;
        var _bind = boundMethod.bind;
        boundMethod.bind = function (newThis) {
          for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          if (newThis !== component && newThis !== null) {
            'production' !== 'production' ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : void 0;
          } else if (!args.length) {
            'production' !== 'production' ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : void 0;
            return boundMethod;
          }
          var reboundMethod = _bind.apply(boundMethod, arguments);
          reboundMethod.__reactBoundContext = component;
          reboundMethod.__reactBoundMethod = method;
          reboundMethod.__reactBoundArguments = args;
          return reboundMethod;
        };
      }
      return boundMethod;
    }
    function bindAutoBindMethods(component) {
      var pairs = component.__reactAutoBindPairs;
      for (var i = 0; i < pairs.length; i += 2) {
        var autoBindKey = pairs[i];
        var method = pairs[i + 1];
        component[autoBindKey] = bindAutoBindMethod(component, method);
      }
    }
    var ReactClassMixin = {
      replaceState: function (newState, callback) {
        this.updater.enqueueReplaceState(this, newState);
        if (callback) {
          this.updater.enqueueCallback(this, callback, 'replaceState');
        }
      },
      isMounted: function () {
        return this.updater.isMounted(this);
      }
    };
    var ReactClassComponent = function () {};
    _assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);
    var ReactClass = {
      createClass: function (spec) {
        var Constructor = identity(function (props, context, updater) {
          if ('production' !== 'production') {
            'production' !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : void 0;
          }
          if (this.__reactAutoBindPairs.length) {
            bindAutoBindMethods(this);
          }
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
          this.state = null;
          var initialState = this.getInitialState ? this.getInitialState() : null;
          if ('production' !== 'production') {
            if (initialState === undefined && this.getInitialState._isMockFunction) {
              initialState = null;
            }
          }
          !(typeof initialState === 'object' && !Array.isArray(initialState)) ? 'production' !== 'production' ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : _prodInvariant('82', Constructor.displayName || 'ReactCompositeComponent') : void 0;
          this.state = initialState;
        });
        Constructor.prototype = new ReactClassComponent();
        Constructor.prototype.constructor = Constructor;
        Constructor.prototype.__reactAutoBindPairs = [];
        injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));
        mixSpecIntoComponent(Constructor, spec);
        if (Constructor.getDefaultProps) {
          Constructor.defaultProps = Constructor.getDefaultProps();
        }
        if ('production' !== 'production') {
          if (Constructor.getDefaultProps) {
            Constructor.getDefaultProps.isReactClassApproved = {};
          }
          if (Constructor.prototype.getInitialState) {
            Constructor.prototype.getInitialState.isReactClassApproved = {};
          }
        }
        !Constructor.prototype.render ? 'production' !== 'production' ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : _prodInvariant('83') : void 0;
        if ('production' !== 'production') {
          'production' !== 'production' ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : void 0;
          'production' !== 'production' ? warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component') : void 0;
        }
        for (var methodName in ReactClassInterface) {
          if (!Constructor.prototype[methodName]) {
            Constructor.prototype[methodName] = null;
          }
        }
        return Constructor;
      },
      injection: { injectMixin: function (mixin) {
          injectedMixins.push(mixin);
        } }
    };
    module.exports = ReactClass;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('f4', ['ec', 'f5', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var ReactElement = $__require('ec');
    var createDOMFactory = ReactElement.createFactory;
    if ('production' !== 'production') {
      var ReactElementValidator = $__require('f5');
      createDOMFactory = ReactElementValidator.createFactory;
    }
    var ReactDOMFactories = {
      a: createDOMFactory('a'),
      abbr: createDOMFactory('abbr'),
      address: createDOMFactory('address'),
      area: createDOMFactory('area'),
      article: createDOMFactory('article'),
      aside: createDOMFactory('aside'),
      audio: createDOMFactory('audio'),
      b: createDOMFactory('b'),
      base: createDOMFactory('base'),
      bdi: createDOMFactory('bdi'),
      bdo: createDOMFactory('bdo'),
      big: createDOMFactory('big'),
      blockquote: createDOMFactory('blockquote'),
      body: createDOMFactory('body'),
      br: createDOMFactory('br'),
      button: createDOMFactory('button'),
      canvas: createDOMFactory('canvas'),
      caption: createDOMFactory('caption'),
      cite: createDOMFactory('cite'),
      code: createDOMFactory('code'),
      col: createDOMFactory('col'),
      colgroup: createDOMFactory('colgroup'),
      data: createDOMFactory('data'),
      datalist: createDOMFactory('datalist'),
      dd: createDOMFactory('dd'),
      del: createDOMFactory('del'),
      details: createDOMFactory('details'),
      dfn: createDOMFactory('dfn'),
      dialog: createDOMFactory('dialog'),
      div: createDOMFactory('div'),
      dl: createDOMFactory('dl'),
      dt: createDOMFactory('dt'),
      em: createDOMFactory('em'),
      embed: createDOMFactory('embed'),
      fieldset: createDOMFactory('fieldset'),
      figcaption: createDOMFactory('figcaption'),
      figure: createDOMFactory('figure'),
      footer: createDOMFactory('footer'),
      form: createDOMFactory('form'),
      h1: createDOMFactory('h1'),
      h2: createDOMFactory('h2'),
      h3: createDOMFactory('h3'),
      h4: createDOMFactory('h4'),
      h5: createDOMFactory('h5'),
      h6: createDOMFactory('h6'),
      head: createDOMFactory('head'),
      header: createDOMFactory('header'),
      hgroup: createDOMFactory('hgroup'),
      hr: createDOMFactory('hr'),
      html: createDOMFactory('html'),
      i: createDOMFactory('i'),
      iframe: createDOMFactory('iframe'),
      img: createDOMFactory('img'),
      input: createDOMFactory('input'),
      ins: createDOMFactory('ins'),
      kbd: createDOMFactory('kbd'),
      keygen: createDOMFactory('keygen'),
      label: createDOMFactory('label'),
      legend: createDOMFactory('legend'),
      li: createDOMFactory('li'),
      link: createDOMFactory('link'),
      main: createDOMFactory('main'),
      map: createDOMFactory('map'),
      mark: createDOMFactory('mark'),
      menu: createDOMFactory('menu'),
      menuitem: createDOMFactory('menuitem'),
      meta: createDOMFactory('meta'),
      meter: createDOMFactory('meter'),
      nav: createDOMFactory('nav'),
      noscript: createDOMFactory('noscript'),
      object: createDOMFactory('object'),
      ol: createDOMFactory('ol'),
      optgroup: createDOMFactory('optgroup'),
      option: createDOMFactory('option'),
      output: createDOMFactory('output'),
      p: createDOMFactory('p'),
      param: createDOMFactory('param'),
      picture: createDOMFactory('picture'),
      pre: createDOMFactory('pre'),
      progress: createDOMFactory('progress'),
      q: createDOMFactory('q'),
      rp: createDOMFactory('rp'),
      rt: createDOMFactory('rt'),
      ruby: createDOMFactory('ruby'),
      s: createDOMFactory('s'),
      samp: createDOMFactory('samp'),
      script: createDOMFactory('script'),
      section: createDOMFactory('section'),
      select: createDOMFactory('select'),
      small: createDOMFactory('small'),
      source: createDOMFactory('source'),
      span: createDOMFactory('span'),
      strong: createDOMFactory('strong'),
      style: createDOMFactory('style'),
      sub: createDOMFactory('sub'),
      summary: createDOMFactory('summary'),
      sup: createDOMFactory('sup'),
      table: createDOMFactory('table'),
      tbody: createDOMFactory('tbody'),
      td: createDOMFactory('td'),
      textarea: createDOMFactory('textarea'),
      tfoot: createDOMFactory('tfoot'),
      th: createDOMFactory('th'),
      thead: createDOMFactory('thead'),
      time: createDOMFactory('time'),
      title: createDOMFactory('title'),
      tr: createDOMFactory('tr'),
      track: createDOMFactory('track'),
      u: createDOMFactory('u'),
      ul: createDOMFactory('ul'),
      'var': createDOMFactory('var'),
      video: createDOMFactory('video'),
      wbr: createDOMFactory('wbr'),
      circle: createDOMFactory('circle'),
      clipPath: createDOMFactory('clipPath'),
      defs: createDOMFactory('defs'),
      ellipse: createDOMFactory('ellipse'),
      g: createDOMFactory('g'),
      image: createDOMFactory('image'),
      line: createDOMFactory('line'),
      linearGradient: createDOMFactory('linearGradient'),
      mask: createDOMFactory('mask'),
      path: createDOMFactory('path'),
      pattern: createDOMFactory('pattern'),
      polygon: createDOMFactory('polygon'),
      polyline: createDOMFactory('polyline'),
      radialGradient: createDOMFactory('radialGradient'),
      rect: createDOMFactory('rect'),
      stop: createDOMFactory('stop'),
      svg: createDOMFactory('svg'),
      text: createDOMFactory('text'),
      tspan: createDOMFactory('tspan')
    };
    module.exports = ReactDOMFactories;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('f6', ['ec', 'f3', 'f7', '9e', 'ea', '7f', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var ReactElement = $__require('ec');
    var ReactPropTypeLocationNames = $__require('f3');
    var ReactPropTypesSecret = $__require('f7');
    var emptyFunction = $__require('9e');
    var getIteratorFn = $__require('ea');
    var warning = $__require('7f');
    var ANONYMOUS = '<<anonymous>>';
    var ReactPropTypes = {
      array: createPrimitiveTypeChecker('array'),
      bool: createPrimitiveTypeChecker('boolean'),
      func: createPrimitiveTypeChecker('function'),
      number: createPrimitiveTypeChecker('number'),
      object: createPrimitiveTypeChecker('object'),
      string: createPrimitiveTypeChecker('string'),
      symbol: createPrimitiveTypeChecker('symbol'),
      any: createAnyTypeChecker(),
      arrayOf: createArrayOfTypeChecker,
      element: createElementTypeChecker(),
      instanceOf: createInstanceTypeChecker,
      node: createNodeChecker(),
      objectOf: createObjectOfTypeChecker,
      oneOf: createEnumTypeChecker,
      oneOfType: createUnionTypeChecker,
      shape: createShapeTypeChecker
    };
    function is(x, y) {
      if (x === y) {
        return x !== 0 || 1 / x === 1 / y;
      } else {
        return x !== x && y !== y;
      }
    }
    function PropTypeError(message) {
      this.message = message;
      this.stack = '';
    }
    PropTypeError.prototype = Error.prototype;
    function createChainableTypeChecker(validate) {
      if ('production' !== 'production') {
        var manualPropTypeCallCache = {};
      }
      function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
        componentName = componentName || ANONYMOUS;
        propFullName = propFullName || propName;
        if ('production' !== 'production') {
          if (secret !== ReactPropTypesSecret && typeof console !== 'undefined') {
            var cacheKey = componentName + ':' + propName;
            if (!manualPropTypeCallCache[cacheKey]) {
              'production' !== 'production' ? warning(false, 'You are manually calling a React.PropTypes validation ' + 'function for the `%s` prop on `%s`. This is deprecated ' + 'and will not work in production with the next major version. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.', propFullName, componentName) : void 0;
              manualPropTypeCallCache[cacheKey] = true;
            }
          }
        }
        if (props[propName] == null) {
          var locationName = ReactPropTypeLocationNames[location];
          if (isRequired) {
            if (props[propName] === null) {
              return new PropTypeError('The ' + locationName + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
            }
            return new PropTypeError('The ' + locationName + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
          }
          return null;
        } else {
          return validate(props, propName, componentName, location, propFullName);
        }
      }
      var chainedCheckType = checkType.bind(null, false);
      chainedCheckType.isRequired = checkType.bind(null, true);
      return chainedCheckType;
    }
    function createPrimitiveTypeChecker(expectedType) {
      function validate(props, propName, componentName, location, propFullName, secret) {
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== expectedType) {
          var locationName = ReactPropTypeLocationNames[location];
          var preciseType = getPreciseType(propValue);
          return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function createAnyTypeChecker() {
      return createChainableTypeChecker(emptyFunction.thatReturns(null));
    }
    function createArrayOfTypeChecker(typeChecker) {
      function validate(props, propName, componentName, location, propFullName) {
        if (typeof typeChecker !== 'function') {
          return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
        }
        var propValue = props[propName];
        if (!Array.isArray(propValue)) {
          var locationName = ReactPropTypeLocationNames[location];
          var propType = getPropType(propValue);
          return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
        }
        for (var i = 0; i < propValue.length; i++) {
          var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function createElementTypeChecker() {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        if (!ReactElement.isValidElement(propValue)) {
          var locationName = ReactPropTypeLocationNames[location];
          var propType = getPropType(propValue);
          return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function createInstanceTypeChecker(expectedClass) {
      function validate(props, propName, componentName, location, propFullName) {
        if (!(props[propName] instanceof expectedClass)) {
          var locationName = ReactPropTypeLocationNames[location];
          var expectedClassName = expectedClass.name || ANONYMOUS;
          var actualClassName = getClassName(props[propName]);
          return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function createEnumTypeChecker(expectedValues) {
      if (!Array.isArray(expectedValues)) {
        'production' !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
        return emptyFunction.thatReturnsNull;
      }
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        for (var i = 0; i < expectedValues.length; i++) {
          if (is(propValue, expectedValues[i])) {
            return null;
          }
        }
        var locationName = ReactPropTypeLocationNames[location];
        var valuesString = JSON.stringify(expectedValues);
        return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
      }
      return createChainableTypeChecker(validate);
    }
    function createObjectOfTypeChecker(typeChecker) {
      function validate(props, propName, componentName, location, propFullName) {
        if (typeof typeChecker !== 'function') {
          return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
        }
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== 'object') {
          var locationName = ReactPropTypeLocationNames[location];
          return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
        }
        for (var key in propValue) {
          if (propValue.hasOwnProperty(key)) {
            var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function createUnionTypeChecker(arrayOfTypeCheckers) {
      if (!Array.isArray(arrayOfTypeCheckers)) {
        'production' !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
        return emptyFunction.thatReturnsNull;
      }
      function validate(props, propName, componentName, location, propFullName) {
        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
          var checker = arrayOfTypeCheckers[i];
          if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
            return null;
          }
        }
        var locationName = ReactPropTypeLocationNames[location];
        return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
      }
      return createChainableTypeChecker(validate);
    }
    function createNodeChecker() {
      function validate(props, propName, componentName, location, propFullName) {
        if (!isNode(props[propName])) {
          var locationName = ReactPropTypeLocationNames[location];
          return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function createShapeTypeChecker(shapeTypes) {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== 'object') {
          var locationName = ReactPropTypeLocationNames[location];
          return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
        }
        for (var key in shapeTypes) {
          var checker = shapeTypes[key];
          if (!checker) {
            continue;
          }
          var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error) {
            return error;
          }
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function isNode(propValue) {
      switch (typeof propValue) {
        case 'number':
        case 'string':
        case 'undefined':
          return true;
        case 'boolean':
          return !propValue;
        case 'object':
          if (Array.isArray(propValue)) {
            return propValue.every(isNode);
          }
          if (propValue === null || ReactElement.isValidElement(propValue)) {
            return true;
          }
          var iteratorFn = getIteratorFn(propValue);
          if (iteratorFn) {
            var iterator = iteratorFn.call(propValue);
            var step;
            if (iteratorFn !== propValue.entries) {
              while (!(step = iterator.next()).done) {
                if (!isNode(step.value)) {
                  return false;
                }
              }
            } else {
              while (!(step = iterator.next()).done) {
                var entry = step.value;
                if (entry) {
                  if (!isNode(entry[1])) {
                    return false;
                  }
                }
              }
            }
          } else {
            return false;
          }
          return true;
        default:
          return false;
      }
    }
    function isSymbol(propType, propValue) {
      if (propType === 'symbol') {
        return true;
      }
      if (propValue['@@toStringTag'] === 'Symbol') {
        return true;
      }
      if (typeof Symbol === 'function' && propValue instanceof Symbol) {
        return true;
      }
      return false;
    }
    function getPropType(propValue) {
      var propType = typeof propValue;
      if (Array.isArray(propValue)) {
        return 'array';
      }
      if (propValue instanceof RegExp) {
        return 'object';
      }
      if (isSymbol(propType, propValue)) {
        return 'symbol';
      }
      return propType;
    }
    function getPreciseType(propValue) {
      var propType = getPropType(propValue);
      if (propType === 'object') {
        if (propValue instanceof Date) {
          return 'date';
        } else if (propValue instanceof RegExp) {
          return 'regexp';
        }
      }
      return propType;
    }
    function getClassName(propValue) {
      if (!propValue.constructor || !propValue.constructor.name) {
        return ANONYMOUS;
      }
      return propValue.constructor.name;
    }
    module.exports = ReactPropTypes;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('f8', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = '15.4.0';
  return module.exports;
});
$__System.registerDynamic('f9', ['e6', 'ec', '8b', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('e6');
    var ReactElement = $__require('ec');
    var invariant = $__require('8b');
    function onlyChild(children) {
      !ReactElement.isValidElement(children) ? 'production' !== 'production' ? invariant(false, 'React.Children.only expected to receive a single React element child.') : _prodInvariant('143') : void 0;
      return children;
    }
    module.exports = onlyChild;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('e9', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2014-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  // The Symbol used to tag the ReactElement type. If there is no native Symbol
  // nor polyfill, then a plain number is used for performance.

  var define,
      global = this || self,
      GLOBAL = global;
  var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;

  module.exports = REACT_ELEMENT_TYPE;
  return module.exports;
});
$__System.registerDynamic('ec', ['63', '99', '7f', 'f1', 'e9', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _assign = $__require('63');
    var ReactCurrentOwner = $__require('99');
    var warning = $__require('7f');
    var canDefineProperty = $__require('f1');
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var REACT_ELEMENT_TYPE = $__require('e9');
    var RESERVED_PROPS = {
      key: true,
      ref: true,
      __self: true,
      __source: true
    };
    var specialPropKeyWarningShown, specialPropRefWarningShown;
    function hasValidRef(config) {
      if ('production' !== 'production') {
        if (hasOwnProperty.call(config, 'ref')) {
          var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
          if (getter && getter.isReactWarning) {
            return false;
          }
        }
      }
      return config.ref !== undefined;
    }
    function hasValidKey(config) {
      if ('production' !== 'production') {
        if (hasOwnProperty.call(config, 'key')) {
          var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
          if (getter && getter.isReactWarning) {
            return false;
          }
        }
      }
      return config.key !== undefined;
    }
    function defineKeyPropWarningGetter(props, displayName) {
      var warnAboutAccessingKey = function () {
        if (!specialPropKeyWarningShown) {
          specialPropKeyWarningShown = true;
          'production' !== 'production' ? warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
        }
      };
      warnAboutAccessingKey.isReactWarning = true;
      Object.defineProperty(props, 'key', {
        get: warnAboutAccessingKey,
        configurable: true
      });
    }
    function defineRefPropWarningGetter(props, displayName) {
      var warnAboutAccessingRef = function () {
        if (!specialPropRefWarningShown) {
          specialPropRefWarningShown = true;
          'production' !== 'production' ? warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
        }
      };
      warnAboutAccessingRef.isReactWarning = true;
      Object.defineProperty(props, 'ref', {
        get: warnAboutAccessingRef,
        configurable: true
      });
    }
    var ReactElement = function (type, key, ref, self, source, owner, props) {
      var element = {
        $$typeof: REACT_ELEMENT_TYPE,
        type: type,
        key: key,
        ref: ref,
        props: props,
        _owner: owner
      };
      if ('production' !== 'production') {
        element._store = {};
        if (canDefineProperty) {
          Object.defineProperty(element._store, 'validated', {
            configurable: false,
            enumerable: false,
            writable: true,
            value: false
          });
          Object.defineProperty(element, '_self', {
            configurable: false,
            enumerable: false,
            writable: false,
            value: self
          });
          Object.defineProperty(element, '_source', {
            configurable: false,
            enumerable: false,
            writable: false,
            value: source
          });
        } else {
          element._store.validated = false;
          element._self = self;
          element._source = source;
        }
        if (Object.freeze) {
          Object.freeze(element.props);
          Object.freeze(element);
        }
      }
      return element;
    };
    ReactElement.createElement = function (type, config, children) {
      var propName;
      var props = {};
      var key = null;
      var ref = null;
      var self = null;
      var source = null;
      if (config != null) {
        if (hasValidRef(config)) {
          ref = config.ref;
        }
        if (hasValidKey(config)) {
          key = '' + config.key;
        }
        self = config.__self === undefined ? null : config.__self;
        source = config.__source === undefined ? null : config.__source;
        for (propName in config) {
          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
            props[propName] = config[propName];
          }
        }
      }
      var childrenLength = arguments.length - 2;
      if (childrenLength === 1) {
        props.children = children;
      } else if (childrenLength > 1) {
        var childArray = Array(childrenLength);
        for (var i = 0; i < childrenLength; i++) {
          childArray[i] = arguments[i + 2];
        }
        if ('production' !== 'production') {
          if (Object.freeze) {
            Object.freeze(childArray);
          }
        }
        props.children = childArray;
      }
      if (type && type.defaultProps) {
        var defaultProps = type.defaultProps;
        for (propName in defaultProps) {
          if (props[propName] === undefined) {
            props[propName] = defaultProps[propName];
          }
        }
      }
      if ('production' !== 'production') {
        if (key || ref) {
          if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
            var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
            if (key) {
              defineKeyPropWarningGetter(props, displayName);
            }
            if (ref) {
              defineRefPropWarningGetter(props, displayName);
            }
          }
        }
      }
      return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
    };
    ReactElement.createFactory = function (type) {
      var factory = ReactElement.createElement.bind(null, type);
      factory.type = type;
      return factory;
    };
    ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {
      var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
      return newElement;
    };
    ReactElement.cloneElement = function (element, config, children) {
      var propName;
      var props = _assign({}, element.props);
      var key = element.key;
      var ref = element.ref;
      var self = element._self;
      var source = element._source;
      var owner = element._owner;
      if (config != null) {
        if (hasValidRef(config)) {
          ref = config.ref;
          owner = ReactCurrentOwner.current;
        }
        if (hasValidKey(config)) {
          key = '' + config.key;
        }
        var defaultProps;
        if (element.type && element.type.defaultProps) {
          defaultProps = element.type.defaultProps;
        }
        for (propName in config) {
          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
            if (config[propName] === undefined && defaultProps !== undefined) {
              props[propName] = defaultProps[propName];
            } else {
              props[propName] = config[propName];
            }
          }
        }
      }
      var childrenLength = arguments.length - 2;
      if (childrenLength === 1) {
        props.children = children;
      } else if (childrenLength > 1) {
        var childArray = Array(childrenLength);
        for (var i = 0; i < childrenLength; i++) {
          childArray[i] = arguments[i + 2];
        }
        props.children = childArray;
      }
      return ReactElement(element.type, key, ref, self, source, owner, props);
    };
    ReactElement.isValidElement = function (object) {
      return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
    };
    module.exports = ReactElement;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('f3', ['13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var ReactPropTypeLocationNames = {};
    if ('production' !== 'production') {
      ReactPropTypeLocationNames = {
        prop: 'prop',
        context: 'context',
        childContext: 'child context'
      };
    }
    module.exports = ReactPropTypeLocationNames;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('f7', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

  module.exports = ReactPropTypesSecret;
  return module.exports;
});
$__System.registerDynamic('fa', ['e6', 'f3', 'f7', '8b', '7f', '96', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('e6');
    var ReactPropTypeLocationNames = $__require('f3');
    var ReactPropTypesSecret = $__require('f7');
    var invariant = $__require('8b');
    var warning = $__require('7f');
    var ReactComponentTreeHook;
    if (typeof process !== 'undefined' && process.env && 'production' === 'test') {
      ReactComponentTreeHook = $__require('96');
    }
    var loggedTypeFailures = {};
    function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
      for (var typeSpecName in typeSpecs) {
        if (typeSpecs.hasOwnProperty(typeSpecName)) {
          var error;
          try {
            !(typeof typeSpecs[typeSpecName] === 'function') ? 'production' !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
            error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
          } catch (ex) {
            error = ex;
          }
          'production' !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error) : void 0;
          if (error instanceof Error && !(error.message in loggedTypeFailures)) {
            loggedTypeFailures[error.message] = true;
            var componentStackInfo = '';
            if ('production' !== 'production') {
              if (!ReactComponentTreeHook) {
                ReactComponentTreeHook = $__require('96');
              }
              if (debugID !== null) {
                componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
              } else if (element !== null) {
                componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
              }
            }
            'production' !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
          }
        }
      }
    }
    module.exports = checkReactTypeSpec;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('f1', ['13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var canDefineProperty = false;
    if ('production' !== 'production') {
      try {
        Object.defineProperty({}, 'x', { get: function () {} });
        canDefineProperty = true;
      } catch (x) {}
    }
    module.exports = canDefineProperty;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('ea', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  /* global Symbol */

  var define,
      global = this || self,
      GLOBAL = global;
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  module.exports = getIteratorFn;
  return module.exports;
});
$__System.registerDynamic('f5', ['99', '96', 'ec', 'fa', 'f1', 'ea', '7f', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var ReactCurrentOwner = $__require('99');
    var ReactComponentTreeHook = $__require('96');
    var ReactElement = $__require('ec');
    var checkReactTypeSpec = $__require('fa');
    var canDefineProperty = $__require('f1');
    var getIteratorFn = $__require('ea');
    var warning = $__require('7f');
    function getDeclarationErrorAddendum() {
      if (ReactCurrentOwner.current) {
        var name = ReactCurrentOwner.current.getName();
        if (name) {
          return ' Check the render method of `' + name + '`.';
        }
      }
      return '';
    }
    var ownerHasKeyUseWarning = {};
    function getCurrentComponentErrorInfo(parentType) {
      var info = getDeclarationErrorAddendum();
      if (!info) {
        var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
        if (parentName) {
          info = ' Check the top-level render call using <' + parentName + '>.';
        }
      }
      return info;
    }
    function validateExplicitKey(element, parentType) {
      if (!element._store || element._store.validated || element.key != null) {
        return;
      }
      element._store.validated = true;
      var memoizer = ownerHasKeyUseWarning.uniqueKey || (ownerHasKeyUseWarning.uniqueKey = {});
      var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
      if (memoizer[currentComponentErrorInfo]) {
        return;
      }
      memoizer[currentComponentErrorInfo] = true;
      var childOwner = '';
      if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
        childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
      }
      'production' !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, ReactComponentTreeHook.getCurrentStackAddendum(element)) : void 0;
    }
    function validateChildKeys(node, parentType) {
      if (typeof node !== 'object') {
        return;
      }
      if (Array.isArray(node)) {
        for (var i = 0; i < node.length; i++) {
          var child = node[i];
          if (ReactElement.isValidElement(child)) {
            validateExplicitKey(child, parentType);
          }
        }
      } else if (ReactElement.isValidElement(node)) {
        if (node._store) {
          node._store.validated = true;
        }
      } else if (node) {
        var iteratorFn = getIteratorFn(node);
        if (iteratorFn) {
          if (iteratorFn !== node.entries) {
            var iterator = iteratorFn.call(node);
            var step;
            while (!(step = iterator.next()).done) {
              if (ReactElement.isValidElement(step.value)) {
                validateExplicitKey(step.value, parentType);
              }
            }
          }
        }
      }
    }
    function validatePropTypes(element) {
      var componentClass = element.type;
      if (typeof componentClass !== 'function') {
        return;
      }
      var name = componentClass.displayName || componentClass.name;
      if (componentClass.propTypes) {
        checkReactTypeSpec(componentClass.propTypes, element.props, 'prop', name, element, null);
      }
      if (typeof componentClass.getDefaultProps === 'function') {
        'production' !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;
      }
    }
    var ReactElementValidator = {
      createElement: function (type, props, children) {
        var validType = typeof type === 'string' || typeof type === 'function';
        if (!validType) {
          'production' !== 'production' ? warning(false, 'React.createElement: type should not be null, undefined, boolean, or ' + 'number. It should be a string (for DOM elements) or a ReactClass ' + '(for composite components).%s', getDeclarationErrorAddendum()) : void 0;
        }
        var element = ReactElement.createElement.apply(this, arguments);
        if (element == null) {
          return element;
        }
        if (validType) {
          for (var i = 2; i < arguments.length; i++) {
            validateChildKeys(arguments[i], type);
          }
        }
        validatePropTypes(element);
        return element;
      },
      createFactory: function (type) {
        var validatedFactory = ReactElementValidator.createElement.bind(null, type);
        validatedFactory.type = type;
        if ('production' !== 'production') {
          if (canDefineProperty) {
            Object.defineProperty(validatedFactory, 'type', {
              enumerable: false,
              get: function () {
                'production' !== 'production' ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : void 0;
                Object.defineProperty(this, 'type', { value: type });
                return type;
              }
            });
          }
        }
        return validatedFactory;
      },
      cloneElement: function (element, props, children) {
        var newElement = ReactElement.cloneElement.apply(this, arguments);
        for (var i = 2; i < arguments.length; i++) {
          validateChildKeys(arguments[i], newElement.type);
        }
        validatePropTypes(newElement);
        return newElement;
      }
    };
    module.exports = ReactElementValidator;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('5d', ['63', 'eb', 'ee', 'ed', 'f2', 'f4', 'ec', 'f6', 'f8', 'f9', '7f', 'f5', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _assign = $__require('63');
    var ReactChildren = $__require('eb');
    var ReactComponent = $__require('ee');
    var ReactPureComponent = $__require('ed');
    var ReactClass = $__require('f2');
    var ReactDOMFactories = $__require('f4');
    var ReactElement = $__require('ec');
    var ReactPropTypes = $__require('f6');
    var ReactVersion = $__require('f8');
    var onlyChild = $__require('f9');
    var warning = $__require('7f');
    var createElement = ReactElement.createElement;
    var createFactory = ReactElement.createFactory;
    var cloneElement = ReactElement.cloneElement;
    if ('production' !== 'production') {
      var ReactElementValidator = $__require('f5');
      createElement = ReactElementValidator.createElement;
      createFactory = ReactElementValidator.createFactory;
      cloneElement = ReactElementValidator.cloneElement;
    }
    var __spread = _assign;
    if ('production' !== 'production') {
      var warned = false;
      __spread = function () {
        'production' !== 'production' ? warning(warned, 'React.__spread is deprecated and should not be used. Use ' + 'Object.assign directly or another helper function with similar ' + 'semantics. You may be seeing this warning due to your compiler. ' + 'See https://fb.me/react-spread-deprecation for more details.') : void 0;
        warned = true;
        return _assign.apply(null, arguments);
      };
    }
    var React = {
      Children: {
        map: ReactChildren.map,
        forEach: ReactChildren.forEach,
        count: ReactChildren.count,
        toArray: ReactChildren.toArray,
        only: onlyChild
      },
      Component: ReactComponent,
      PureComponent: ReactPureComponent,
      createElement: createElement,
      cloneElement: cloneElement,
      isValidElement: ReactElement.isValidElement,
      PropTypes: ReactPropTypes,
      createClass: ReactClass.createClass,
      createFactory: createFactory,
      createMixin: function (mixin) {
        return mixin;
      },
      DOM: ReactDOMFactories,
      version: ReactVersion,
      __spread: __spread
    };
    module.exports = React;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('dc', ['89', '5d', '8b', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('89');
    var React = $__require('5d');
    var invariant = $__require('8b');
    var ReactNodeTypes = {
      HOST: 0,
      COMPOSITE: 1,
      EMPTY: 2,
      getType: function (node) {
        if (node === null || node === false) {
          return ReactNodeTypes.EMPTY;
        } else if (React.isValidElement(node)) {
          if (typeof node.type === 'function') {
            return ReactNodeTypes.COMPOSITE;
          } else {
            return ReactNodeTypes.HOST;
          }
        }
        !false ? 'production' !== 'production' ? invariant(false, 'Unexpected node: %s', node) : _prodInvariant('26', node) : void 0;
      }
    };
    module.exports = ReactNodeTypes;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('fb', ['89', '8b', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('89');
    var invariant = $__require('8b');
    function isValidOwner(object) {
      return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
    }
    var ReactOwner = {
      addComponentAsRefTo: function (component, ref, owner) {
        !isValidOwner(owner) ? 'production' !== 'production' ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might be adding a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('119') : void 0;
        owner.attachRef(ref, component);
      },
      removeComponentAsRefFrom: function (component, ref, owner) {
        !isValidOwner(owner) ? 'production' !== 'production' ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might be removing a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('120') : void 0;
        var ownerPublicInstance = owner.getPublicInstance();
        if (ownerPublicInstance && ownerPublicInstance.refs[ref] === component.getPublicInstance()) {
          owner.detachRef(ref);
        }
      }
    };
    module.exports = ReactOwner;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('fc', ['fb', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var ReactOwner = $__require('fb');
    var ReactRef = {};
    function attachRef(ref, component, owner) {
      if (typeof ref === 'function') {
        ref(component.getPublicInstance());
      } else {
        ReactOwner.addComponentAsRefTo(component, ref, owner);
      }
    }
    function detachRef(ref, component, owner) {
      if (typeof ref === 'function') {
        ref(null);
      } else {
        ReactOwner.removeComponentAsRefFrom(component, ref, owner);
      }
    }
    ReactRef.attachRefs = function (instance, element) {
      if (element === null || typeof element !== 'object') {
        return;
      }
      var ref = element.ref;
      if (ref != null) {
        attachRef(ref, instance, element._owner);
      }
    };
    ReactRef.shouldUpdateRefs = function (prevElement, nextElement) {
      var prevRef = null;
      var prevOwner = null;
      if (prevElement !== null && typeof prevElement === 'object') {
        prevRef = prevElement.ref;
        prevOwner = prevElement._owner;
      }
      var nextRef = null;
      var nextOwner = null;
      if (nextElement !== null && typeof nextElement === 'object') {
        nextRef = nextElement.ref;
        nextOwner = nextElement._owner;
      }
      return prevRef !== nextRef || typeof nextRef === 'string' && nextOwner !== prevOwner;
    };
    ReactRef.detachRefs = function (instance, element) {
      if (element === null || typeof element !== 'object') {
        return;
      }
      var ref = element.ref;
      if (ref != null) {
        detachRef(ref, instance, element._owner);
      }
    };
    module.exports = ReactRef;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('91', ['fc', '84', '7f', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var ReactRef = $__require('fc');
    var ReactInstrumentation = $__require('84');
    var warning = $__require('7f');
    function attachRefs() {
      ReactRef.attachRefs(this, this._currentElement);
    }
    var ReactReconciler = {
      mountComponent: function (internalInstance, transaction, hostParent, hostContainerInfo, context, parentDebugID) {
        if ('production' !== 'production') {
          if (internalInstance._debugID !== 0) {
            ReactInstrumentation.debugTool.onBeforeMountComponent(internalInstance._debugID, internalInstance._currentElement, parentDebugID);
          }
        }
        var markup = internalInstance.mountComponent(transaction, hostParent, hostContainerInfo, context, parentDebugID);
        if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
          transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
        }
        if ('production' !== 'production') {
          if (internalInstance._debugID !== 0) {
            ReactInstrumentation.debugTool.onMountComponent(internalInstance._debugID);
          }
        }
        return markup;
      },
      getHostNode: function (internalInstance) {
        return internalInstance.getHostNode();
      },
      unmountComponent: function (internalInstance, safely) {
        if ('production' !== 'production') {
          if (internalInstance._debugID !== 0) {
            ReactInstrumentation.debugTool.onBeforeUnmountComponent(internalInstance._debugID);
          }
        }
        ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
        internalInstance.unmountComponent(safely);
        if ('production' !== 'production') {
          if (internalInstance._debugID !== 0) {
            ReactInstrumentation.debugTool.onUnmountComponent(internalInstance._debugID);
          }
        }
      },
      receiveComponent: function (internalInstance, nextElement, transaction, context) {
        var prevElement = internalInstance._currentElement;
        if (nextElement === prevElement && context === internalInstance._context) {
          return;
        }
        if ('production' !== 'production') {
          if (internalInstance._debugID !== 0) {
            ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, nextElement);
          }
        }
        var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);
        if (refsChanged) {
          ReactRef.detachRefs(internalInstance, prevElement);
        }
        internalInstance.receiveComponent(nextElement, transaction, context);
        if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
          transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
        }
        if ('production' !== 'production') {
          if (internalInstance._debugID !== 0) {
            ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
          }
        }
      },
      performUpdateIfNecessary: function (internalInstance, transaction, updateBatchNumber) {
        if (internalInstance._updateBatchNumber !== updateBatchNumber) {
          'production' !== 'production' ? warning(internalInstance._updateBatchNumber == null || internalInstance._updateBatchNumber === updateBatchNumber + 1, 'performUpdateIfNecessary: Unexpected batch number (current %s, ' + 'pending %s)', updateBatchNumber, internalInstance._updateBatchNumber) : void 0;
          return;
        }
        if ('production' !== 'production') {
          if (internalInstance._debugID !== 0) {
            ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, internalInstance._currentElement);
          }
        }
        internalInstance.performUpdateIfNecessary(transaction);
        if ('production' !== 'production') {
          if (internalInstance._debugID !== 0) {
            ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
          }
        }
      }
    };
    module.exports = ReactReconciler;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('fd', ['13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var ReactPropTypeLocationNames = {};
    if ('production' !== 'production') {
      ReactPropTypeLocationNames = {
        prop: 'prop',
        context: 'context',
        childContext: 'child context'
      };
    }
    module.exports = ReactPropTypeLocationNames;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('8e', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

  module.exports = ReactPropTypesSecret;
  return module.exports;
});
$__System.registerDynamic('fe', ['89', 'fd', '8e', '8b', '7f', '96', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('89');
    var ReactPropTypeLocationNames = $__require('fd');
    var ReactPropTypesSecret = $__require('8e');
    var invariant = $__require('8b');
    var warning = $__require('7f');
    var ReactComponentTreeHook;
    if (typeof process !== 'undefined' && process.env && 'production' === 'test') {
      ReactComponentTreeHook = $__require('96');
    }
    var loggedTypeFailures = {};
    function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
      for (var typeSpecName in typeSpecs) {
        if (typeSpecs.hasOwnProperty(typeSpecName)) {
          var error;
          try {
            !(typeof typeSpecs[typeSpecName] === 'function') ? 'production' !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
            error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
          } catch (ex) {
            error = ex;
          }
          'production' !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error) : void 0;
          if (error instanceof Error && !(error.message in loggedTypeFailures)) {
            loggedTypeFailures[error.message] = true;
            var componentStackInfo = '';
            if ('production' !== 'production') {
              if (!ReactComponentTreeHook) {
                ReactComponentTreeHook = $__require('96');
              }
              if (debugID !== null) {
                componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
              } else if (element !== null) {
                componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
              }
            }
            'production' !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
          }
        }
      }
    }
    module.exports = checkReactTypeSpec;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('f0', ['13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var emptyObject = {};
    if ('production' !== 'production') {
      Object.freeze(emptyObject);
    }
    module.exports = emptyObject;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('aa', [], true, function ($__require, exports, module) {
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @typechecks
   * 
   */

  /*eslint-disable no-self-compare */

  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var hasOwnProperty = Object.prototype.hasOwnProperty;

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      // Added the nonzero y check to make Flow happy, but it is redundant
      return x !== 0 || y !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }

  /**
   * Performs equality by iterating through keys on an object and returning false
   * when any key has values which are not strictly equal between the arguments.
   * Returns true when the values of all keys are strictly equal.
   */
  function shallowEqual(objA, objB) {
    if (is(objA, objB)) {
      return true;
    }

    if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
      return false;
    }

    var keysA = Object.keys(objA);
    var keysB = Object.keys(objB);

    if (keysA.length !== keysB.length) {
      return false;
    }

    // Test for A's keys different from B.
    for (var i = 0; i < keysA.length; i++) {
      if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
        return false;
      }
    }

    return true;
  }

  module.exports = shallowEqual;
  return module.exports;
});
$__System.registerDynamic('ff', ['89', '63', '5d', '9c', '99', 'dd', '9d', '84', 'dc', '91', 'fe', 'f0', '8b', 'aa', '94', '7f', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('89'),
        _assign = $__require('63');
    var React = $__require('5d');
    var ReactComponentEnvironment = $__require('9c');
    var ReactCurrentOwner = $__require('99');
    var ReactErrorUtils = $__require('dd');
    var ReactInstanceMap = $__require('9d');
    var ReactInstrumentation = $__require('84');
    var ReactNodeTypes = $__require('dc');
    var ReactReconciler = $__require('91');
    if ('production' !== 'production') {
      var checkReactTypeSpec = $__require('fe');
    }
    var emptyObject = $__require('f0');
    var invariant = $__require('8b');
    var shallowEqual = $__require('aa');
    var shouldUpdateReactComponent = $__require('94');
    var warning = $__require('7f');
    var CompositeTypes = {
      ImpureClass: 0,
      PureClass: 1,
      StatelessFunctional: 2
    };
    function StatelessComponent(Component) {}
    StatelessComponent.prototype.render = function () {
      var Component = ReactInstanceMap.get(this)._currentElement.type;
      var element = Component(this.props, this.context, this.updater);
      warnIfInvalidElement(Component, element);
      return element;
    };
    function warnIfInvalidElement(Component, element) {
      if ('production' !== 'production') {
        'production' !== 'production' ? warning(element === null || element === false || React.isValidElement(element), '%s(...): A valid React element (or null) must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : void 0;
        'production' !== 'production' ? warning(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component') : void 0;
      }
    }
    function shouldConstruct(Component) {
      return !!(Component.prototype && Component.prototype.isReactComponent);
    }
    function isPureComponent(Component) {
      return !!(Component.prototype && Component.prototype.isPureReactComponent);
    }
    function measureLifeCyclePerf(fn, debugID, timerType) {
      if (debugID === 0) {
        return fn();
      }
      ReactInstrumentation.debugTool.onBeginLifeCycleTimer(debugID, timerType);
      try {
        return fn();
      } finally {
        ReactInstrumentation.debugTool.onEndLifeCycleTimer(debugID, timerType);
      }
    }
    var nextMountID = 1;
    var ReactCompositeComponent = {
      construct: function (element) {
        this._currentElement = element;
        this._rootNodeID = 0;
        this._compositeType = null;
        this._instance = null;
        this._hostParent = null;
        this._hostContainerInfo = null;
        this._updateBatchNumber = null;
        this._pendingElement = null;
        this._pendingStateQueue = null;
        this._pendingReplaceState = false;
        this._pendingForceUpdate = false;
        this._renderedNodeType = null;
        this._renderedComponent = null;
        this._context = null;
        this._mountOrder = 0;
        this._topLevelWrapper = null;
        this._pendingCallbacks = null;
        this._calledComponentWillUnmount = false;
        if ('production' !== 'production') {
          this._warnedAboutRefsInRender = false;
        }
      },
      mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
        var _this = this;
        this._context = context;
        this._mountOrder = nextMountID++;
        this._hostParent = hostParent;
        this._hostContainerInfo = hostContainerInfo;
        var publicProps = this._currentElement.props;
        var publicContext = this._processContext(context);
        var Component = this._currentElement.type;
        var updateQueue = transaction.getUpdateQueue();
        var doConstruct = shouldConstruct(Component);
        var inst = this._constructComponent(doConstruct, publicProps, publicContext, updateQueue);
        var renderedElement;
        if (!doConstruct && (inst == null || inst.render == null)) {
          renderedElement = inst;
          warnIfInvalidElement(Component, renderedElement);
          !(inst === null || inst === false || React.isValidElement(inst)) ? 'production' !== 'production' ? invariant(false, '%s(...): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : _prodInvariant('105', Component.displayName || Component.name || 'Component') : void 0;
          inst = new StatelessComponent(Component);
          this._compositeType = CompositeTypes.StatelessFunctional;
        } else {
          if (isPureComponent(Component)) {
            this._compositeType = CompositeTypes.PureClass;
          } else {
            this._compositeType = CompositeTypes.ImpureClass;
          }
        }
        if ('production' !== 'production') {
          if (inst.render == null) {
            'production' !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', Component.displayName || Component.name || 'Component') : void 0;
          }
          var propsMutated = inst.props !== publicProps;
          var componentName = Component.displayName || Component.name || 'Component';
          'production' !== 'production' ? warning(inst.props === undefined || !propsMutated, '%s(...): When calling super() in `%s`, make sure to pass ' + 'up the same props that your component\'s constructor was passed.', componentName, componentName) : void 0;
        }
        inst.props = publicProps;
        inst.context = publicContext;
        inst.refs = emptyObject;
        inst.updater = updateQueue;
        this._instance = inst;
        ReactInstanceMap.set(inst, this);
        if ('production' !== 'production') {
          'production' !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : void 0;
          'production' !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : void 0;
          'production' !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : void 0;
          'production' !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : void 0;
          'production' !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : void 0;
          'production' !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : void 0;
          'production' !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : void 0;
        }
        var initialState = inst.state;
        if (initialState === undefined) {
          inst.state = initialState = null;
        }
        !(typeof initialState === 'object' && !Array.isArray(initialState)) ? 'production' !== 'production' ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : _prodInvariant('106', this.getName() || 'ReactCompositeComponent') : void 0;
        this._pendingStateQueue = null;
        this._pendingReplaceState = false;
        this._pendingForceUpdate = false;
        var markup;
        if (inst.unstable_handleError) {
          markup = this.performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context);
        } else {
          markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
        }
        if (inst.componentDidMount) {
          if ('production' !== 'production') {
            transaction.getReactMountReady().enqueue(function () {
              measureLifeCyclePerf(function () {
                return inst.componentDidMount();
              }, _this._debugID, 'componentDidMount');
            });
          } else {
            transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
          }
        }
        return markup;
      },
      _constructComponent: function (doConstruct, publicProps, publicContext, updateQueue) {
        if ('production' !== 'production') {
          ReactCurrentOwner.current = this;
          try {
            return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
          } finally {
            ReactCurrentOwner.current = null;
          }
        } else {
          return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
        }
      },
      _constructComponentWithoutOwner: function (doConstruct, publicProps, publicContext, updateQueue) {
        var Component = this._currentElement.type;
        if (doConstruct) {
          if ('production' !== 'production') {
            return measureLifeCyclePerf(function () {
              return new Component(publicProps, publicContext, updateQueue);
            }, this._debugID, 'ctor');
          } else {
            return new Component(publicProps, publicContext, updateQueue);
          }
        }
        if ('production' !== 'production') {
          return measureLifeCyclePerf(function () {
            return Component(publicProps, publicContext, updateQueue);
          }, this._debugID, 'render');
        } else {
          return Component(publicProps, publicContext, updateQueue);
        }
      },
      performInitialMountWithErrorHandling: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
        var markup;
        var checkpoint = transaction.checkpoint();
        try {
          markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
        } catch (e) {
          transaction.rollback(checkpoint);
          this._instance.unstable_handleError(e);
          if (this._pendingStateQueue) {
            this._instance.state = this._processPendingState(this._instance.props, this._instance.context);
          }
          checkpoint = transaction.checkpoint();
          this._renderedComponent.unmountComponent(true);
          transaction.rollback(checkpoint);
          markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
        }
        return markup;
      },
      performInitialMount: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
        var inst = this._instance;
        var debugID = 0;
        if ('production' !== 'production') {
          debugID = this._debugID;
        }
        if (inst.componentWillMount) {
          if ('production' !== 'production') {
            measureLifeCyclePerf(function () {
              return inst.componentWillMount();
            }, debugID, 'componentWillMount');
          } else {
            inst.componentWillMount();
          }
          if (this._pendingStateQueue) {
            inst.state = this._processPendingState(inst.props, inst.context);
          }
        }
        if (renderedElement === undefined) {
          renderedElement = this._renderValidatedComponent();
        }
        var nodeType = ReactNodeTypes.getType(renderedElement);
        this._renderedNodeType = nodeType;
        var child = this._instantiateReactComponent(renderedElement, nodeType !== ReactNodeTypes.EMPTY);
        this._renderedComponent = child;
        var markup = ReactReconciler.mountComponent(child, transaction, hostParent, hostContainerInfo, this._processChildContext(context), debugID);
        if ('production' !== 'production') {
          if (debugID !== 0) {
            var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
            ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
          }
        }
        return markup;
      },
      getHostNode: function () {
        return ReactReconciler.getHostNode(this._renderedComponent);
      },
      unmountComponent: function (safely) {
        if (!this._renderedComponent) {
          return;
        }
        var inst = this._instance;
        if (inst.componentWillUnmount && !inst._calledComponentWillUnmount) {
          inst._calledComponentWillUnmount = true;
          if (safely) {
            var name = this.getName() + '.componentWillUnmount()';
            ReactErrorUtils.invokeGuardedCallback(name, inst.componentWillUnmount.bind(inst));
          } else {
            if ('production' !== 'production') {
              measureLifeCyclePerf(function () {
                return inst.componentWillUnmount();
              }, this._debugID, 'componentWillUnmount');
            } else {
              inst.componentWillUnmount();
            }
          }
        }
        if (this._renderedComponent) {
          ReactReconciler.unmountComponent(this._renderedComponent, safely);
          this._renderedNodeType = null;
          this._renderedComponent = null;
          this._instance = null;
        }
        this._pendingStateQueue = null;
        this._pendingReplaceState = false;
        this._pendingForceUpdate = false;
        this._pendingCallbacks = null;
        this._pendingElement = null;
        this._context = null;
        this._rootNodeID = 0;
        this._topLevelWrapper = null;
        ReactInstanceMap.remove(inst);
      },
      _maskContext: function (context) {
        var Component = this._currentElement.type;
        var contextTypes = Component.contextTypes;
        if (!contextTypes) {
          return emptyObject;
        }
        var maskedContext = {};
        for (var contextName in contextTypes) {
          maskedContext[contextName] = context[contextName];
        }
        return maskedContext;
      },
      _processContext: function (context) {
        var maskedContext = this._maskContext(context);
        if ('production' !== 'production') {
          var Component = this._currentElement.type;
          if (Component.contextTypes) {
            this._checkContextTypes(Component.contextTypes, maskedContext, 'context');
          }
        }
        return maskedContext;
      },
      _processChildContext: function (currentContext) {
        var Component = this._currentElement.type;
        var inst = this._instance;
        var childContext;
        if (inst.getChildContext) {
          if ('production' !== 'production') {
            ReactInstrumentation.debugTool.onBeginProcessingChildContext();
            try {
              childContext = inst.getChildContext();
            } finally {
              ReactInstrumentation.debugTool.onEndProcessingChildContext();
            }
          } else {
            childContext = inst.getChildContext();
          }
        }
        if (childContext) {
          !(typeof Component.childContextTypes === 'object') ? 'production' !== 'production' ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().', this.getName() || 'ReactCompositeComponent') : _prodInvariant('107', this.getName() || 'ReactCompositeComponent') : void 0;
          if ('production' !== 'production') {
            this._checkContextTypes(Component.childContextTypes, childContext, 'childContext');
          }
          for (var name in childContext) {
            !(name in Component.childContextTypes) ? 'production' !== 'production' ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : _prodInvariant('108', this.getName() || 'ReactCompositeComponent', name) : void 0;
          }
          return _assign({}, currentContext, childContext);
        }
        return currentContext;
      },
      _checkContextTypes: function (typeSpecs, values, location) {
        if ('production' !== 'production') {
          checkReactTypeSpec(typeSpecs, values, location, this.getName(), null, this._debugID);
        }
      },
      receiveComponent: function (nextElement, transaction, nextContext) {
        var prevElement = this._currentElement;
        var prevContext = this._context;
        this._pendingElement = null;
        this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
      },
      performUpdateIfNecessary: function (transaction) {
        if (this._pendingElement != null) {
          ReactReconciler.receiveComponent(this, this._pendingElement, transaction, this._context);
        } else if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
          this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
        } else {
          this._updateBatchNumber = null;
        }
      },
      updateComponent: function (transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
        var inst = this._instance;
        !(inst != null) ? 'production' !== 'production' ? invariant(false, 'Attempted to update component `%s` that has already been unmounted (or failed to mount).', this.getName() || 'ReactCompositeComponent') : _prodInvariant('136', this.getName() || 'ReactCompositeComponent') : void 0;
        var willReceive = false;
        var nextContext;
        if (this._context === nextUnmaskedContext) {
          nextContext = inst.context;
        } else {
          nextContext = this._processContext(nextUnmaskedContext);
          willReceive = true;
        }
        var prevProps = prevParentElement.props;
        var nextProps = nextParentElement.props;
        if (prevParentElement !== nextParentElement) {
          willReceive = true;
        }
        if (willReceive && inst.componentWillReceiveProps) {
          if ('production' !== 'production') {
            measureLifeCyclePerf(function () {
              return inst.componentWillReceiveProps(nextProps, nextContext);
            }, this._debugID, 'componentWillReceiveProps');
          } else {
            inst.componentWillReceiveProps(nextProps, nextContext);
          }
        }
        var nextState = this._processPendingState(nextProps, nextContext);
        var shouldUpdate = true;
        if (!this._pendingForceUpdate) {
          if (inst.shouldComponentUpdate) {
            if ('production' !== 'production') {
              shouldUpdate = measureLifeCyclePerf(function () {
                return inst.shouldComponentUpdate(nextProps, nextState, nextContext);
              }, this._debugID, 'shouldComponentUpdate');
            } else {
              shouldUpdate = inst.shouldComponentUpdate(nextProps, nextState, nextContext);
            }
          } else {
            if (this._compositeType === CompositeTypes.PureClass) {
              shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState);
            }
          }
        }
        if ('production' !== 'production') {
          'production' !== 'production' ? warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : void 0;
        }
        this._updateBatchNumber = null;
        if (shouldUpdate) {
          this._pendingForceUpdate = false;
          this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
        } else {
          this._currentElement = nextParentElement;
          this._context = nextUnmaskedContext;
          inst.props = nextProps;
          inst.state = nextState;
          inst.context = nextContext;
        }
      },
      _processPendingState: function (props, context) {
        var inst = this._instance;
        var queue = this._pendingStateQueue;
        var replace = this._pendingReplaceState;
        this._pendingReplaceState = false;
        this._pendingStateQueue = null;
        if (!queue) {
          return inst.state;
        }
        if (replace && queue.length === 1) {
          return queue[0];
        }
        var nextState = _assign({}, replace ? queue[0] : inst.state);
        for (var i = replace ? 1 : 0; i < queue.length; i++) {
          var partial = queue[i];
          _assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
        }
        return nextState;
      },
      _performComponentUpdate: function (nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
        var _this2 = this;
        var inst = this._instance;
        var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
        var prevProps;
        var prevState;
        var prevContext;
        if (hasComponentDidUpdate) {
          prevProps = inst.props;
          prevState = inst.state;
          prevContext = inst.context;
        }
        if (inst.componentWillUpdate) {
          if ('production' !== 'production') {
            measureLifeCyclePerf(function () {
              return inst.componentWillUpdate(nextProps, nextState, nextContext);
            }, this._debugID, 'componentWillUpdate');
          } else {
            inst.componentWillUpdate(nextProps, nextState, nextContext);
          }
        }
        this._currentElement = nextElement;
        this._context = unmaskedContext;
        inst.props = nextProps;
        inst.state = nextState;
        inst.context = nextContext;
        this._updateRenderedComponent(transaction, unmaskedContext);
        if (hasComponentDidUpdate) {
          if ('production' !== 'production') {
            transaction.getReactMountReady().enqueue(function () {
              measureLifeCyclePerf(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), _this2._debugID, 'componentDidUpdate');
            });
          } else {
            transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
          }
        }
      },
      _updateRenderedComponent: function (transaction, context) {
        var prevComponentInstance = this._renderedComponent;
        var prevRenderedElement = prevComponentInstance._currentElement;
        var nextRenderedElement = this._renderValidatedComponent();
        var debugID = 0;
        if ('production' !== 'production') {
          debugID = this._debugID;
        }
        if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
          ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
        } else {
          var oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);
          ReactReconciler.unmountComponent(prevComponentInstance, false);
          var nodeType = ReactNodeTypes.getType(nextRenderedElement);
          this._renderedNodeType = nodeType;
          var child = this._instantiateReactComponent(nextRenderedElement, nodeType !== ReactNodeTypes.EMPTY);
          this._renderedComponent = child;
          var nextMarkup = ReactReconciler.mountComponent(child, transaction, this._hostParent, this._hostContainerInfo, this._processChildContext(context), debugID);
          if ('production' !== 'production') {
            if (debugID !== 0) {
              var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
              ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
            }
          }
          this._replaceNodeWithMarkup(oldHostNode, nextMarkup, prevComponentInstance);
        }
      },
      _replaceNodeWithMarkup: function (oldHostNode, nextMarkup, prevInstance) {
        ReactComponentEnvironment.replaceNodeWithMarkup(oldHostNode, nextMarkup, prevInstance);
      },
      _renderValidatedComponentWithoutOwnerOrContext: function () {
        var inst = this._instance;
        var renderedElement;
        if ('production' !== 'production') {
          renderedElement = measureLifeCyclePerf(function () {
            return inst.render();
          }, this._debugID, 'render');
        } else {
          renderedElement = inst.render();
        }
        if ('production' !== 'production') {
          if (renderedElement === undefined && inst.render._isMockFunction) {
            renderedElement = null;
          }
        }
        return renderedElement;
      },
      _renderValidatedComponent: function () {
        var renderedElement;
        if ('production' !== 'production' || this._compositeType !== CompositeTypes.StatelessFunctional) {
          ReactCurrentOwner.current = this;
          try {
            renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
          } finally {
            ReactCurrentOwner.current = null;
          }
        } else {
          renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
        }
        !(renderedElement === null || renderedElement === false || React.isValidElement(renderedElement)) ? 'production' !== 'production' ? invariant(false, '%s.render(): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : _prodInvariant('109', this.getName() || 'ReactCompositeComponent') : void 0;
        return renderedElement;
      },
      attachRef: function (ref, component) {
        var inst = this.getPublicInstance();
        !(inst != null) ? 'production' !== 'production' ? invariant(false, 'Stateless function components cannot have refs.') : _prodInvariant('110') : void 0;
        var publicComponentInstance = component.getPublicInstance();
        if ('production' !== 'production') {
          var componentName = component && component.getName ? component.getName() : 'a component';
          'production' !== 'production' ? warning(publicComponentInstance != null || component._compositeType !== CompositeTypes.StatelessFunctional, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : void 0;
        }
        var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
        refs[ref] = publicComponentInstance;
      },
      detachRef: function (ref) {
        var refs = this.getPublicInstance().refs;
        delete refs[ref];
      },
      getName: function () {
        var type = this._currentElement.type;
        var constructor = this._instance && this._instance.constructor;
        return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
      },
      getPublicInstance: function () {
        var inst = this._instance;
        if (this._compositeType === CompositeTypes.StatelessFunctional) {
          return null;
        }
        return inst;
      },
      _instantiateReactComponent: null
    };
    module.exports = ReactCompositeComponent;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('bb', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2014-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var emptyComponentFactory;

  var ReactEmptyComponentInjection = {
    injectEmptyComponentFactory: function (factory) {
      emptyComponentFactory = factory;
    }
  };

  var ReactEmptyComponent = {
    create: function (instantiate) {
      return emptyComponentFactory(instantiate);
    }
  };

  ReactEmptyComponent.injection = ReactEmptyComponentInjection;

  module.exports = ReactEmptyComponent;
  return module.exports;
});
$__System.registerDynamic('100', [], true, function ($__require, exports, module) {
	/* */
	'use strict';
	/* eslint-disable no-unused-vars */

	var define,
	    global = this || self,
	    GLOBAL = global;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}

			// Detect buggy property enumeration order in older V8 versions.

			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc'); // eslint-disable-line
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
				return false;
			}

			return true;
		} catch (e) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}

	module.exports = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;

		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);

			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}

			if (Object.getOwnPropertySymbols) {
				symbols = Object.getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}

		return to;
	};
	return module.exports;
});
$__System.registerDynamic("63", ["100"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("100");
  return module.exports;
});
$__System.registerDynamic('bc', ['89', '63', '8b', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('89'),
        _assign = $__require('63');
    var invariant = $__require('8b');
    var genericComponentClass = null;
    var tagToComponentClass = {};
    var textComponentClass = null;
    var ReactHostComponentInjection = {
      injectGenericComponentClass: function (componentClass) {
        genericComponentClass = componentClass;
      },
      injectTextComponentClass: function (componentClass) {
        textComponentClass = componentClass;
      },
      injectComponentClasses: function (componentClasses) {
        _assign(tagToComponentClass, componentClasses);
      }
    };
    function createInternalComponent(element) {
      !genericComponentClass ? 'production' !== 'production' ? invariant(false, 'There is no registered component for the tag %s', element.type) : _prodInvariant('111', element.type) : void 0;
      return new genericComponentClass(element);
    }
    function createInstanceForText(text) {
      return new textComponentClass(text);
    }
    function isTextComponent(component) {
      return component instanceof textComponentClass;
    }
    var ReactHostComponent = {
      createInternalComponent: createInternalComponent,
      createInstanceForText: createInstanceForText,
      isTextComponent: isTextComponent,
      injection: ReactHostComponentInjection
    };
    module.exports = ReactHostComponent;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('101', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var nextDebugID = 1;

  function getNextDebugID() {
    return nextDebugID++;
  }

  module.exports = getNextDebugID;
  return module.exports;
});
$__System.registerDynamic('92', ['89', '63', 'ff', 'bb', 'bc', '101', '8b', '7f', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('89'),
        _assign = $__require('63');
    var ReactCompositeComponent = $__require('ff');
    var ReactEmptyComponent = $__require('bb');
    var ReactHostComponent = $__require('bc');
    var getNextDebugID = $__require('101');
    var invariant = $__require('8b');
    var warning = $__require('7f');
    var ReactCompositeComponentWrapper = function (element) {
      this.construct(element);
    };
    _assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent, { _instantiateReactComponent: instantiateReactComponent });
    function getDeclarationErrorAddendum(owner) {
      if (owner) {
        var name = owner.getName();
        if (name) {
          return ' Check the render method of `' + name + '`.';
        }
      }
      return '';
    }
    function isInternalComponentType(type) {
      return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
    }
    function instantiateReactComponent(node, shouldHaveDebugID) {
      var instance;
      if (node === null || node === false) {
        instance = ReactEmptyComponent.create(instantiateReactComponent);
      } else if (typeof node === 'object') {
        var element = node;
        !(element && (typeof element.type === 'function' || typeof element.type === 'string')) ? 'production' !== 'production' ? invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', element.type == null ? element.type : typeof element.type, getDeclarationErrorAddendum(element._owner)) : _prodInvariant('130', element.type == null ? element.type : typeof element.type, getDeclarationErrorAddendum(element._owner)) : void 0;
        if (typeof element.type === 'string') {
          instance = ReactHostComponent.createInternalComponent(element);
        } else if (isInternalComponentType(element.type)) {
          instance = new element.type(element);
          if (!instance.getHostNode) {
            instance.getHostNode = instance.getNativeNode;
          }
        } else {
          instance = new ReactCompositeComponentWrapper(element);
        }
      } else if (typeof node === 'string' || typeof node === 'number') {
        instance = ReactHostComponent.createInstanceForText(node);
      } else {
        !false ? 'production' !== 'production' ? invariant(false, 'Encountered invalid React node of type %s', typeof node) : _prodInvariant('131', typeof node) : void 0;
      }
      if ('production' !== 'production') {
        'production' !== 'production' ? warning(typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.getHostNode === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : void 0;
      }
      instance._mountIndex = 0;
      instance._mountImage = null;
      if ('production' !== 'production') {
        instance._debugID = shouldHaveDebugID ? getNextDebugID() : 0;
      }
      if ('production' !== 'production') {
        if (Object.preventExtensions) {
          Object.preventExtensions(instance);
        }
      }
      return instance;
    }
    module.exports = instantiateReactComponent;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('a5', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var DOMNamespaces = {
    html: 'http://www.w3.org/1999/xhtml',
    mathml: 'http://www.w3.org/1998/Math/MathML',
    svg: 'http://www.w3.org/2000/svg'
  };

  module.exports = DOMNamespaces;
  return module.exports;
});
$__System.registerDynamic('b1', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  /* globals MSApp */

  'use strict';

  /**
   * Create a function which has 'unsafe' privileges (required by windows8 apps)
   */

  var define,
      global = this || self,
      GLOBAL = global;
  var createMicrosoftUnsafeLocalFunction = function (func) {
    if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
      return function (arg0, arg1, arg2, arg3) {
        MSApp.execUnsafeLocalFunction(function () {
          return func(arg0, arg1, arg2, arg3);
        });
      };
    } else {
      return func;
    }
  };

  module.exports = createMicrosoftUnsafeLocalFunction;
  return module.exports;
});
$__System.registerDynamic('b2', ['69', 'a5', 'b1', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var ExecutionEnvironment = $__require('69');
    var DOMNamespaces = $__require('a5');
    var WHITESPACE_TEST = /^[ \r\n\t\f]/;
    var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;
    var createMicrosoftUnsafeLocalFunction = $__require('b1');
    var reusableSVGContainer;
    var setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {
      if (node.namespaceURI === DOMNamespaces.svg && !('innerHTML' in node)) {
        reusableSVGContainer = reusableSVGContainer || document.createElement('div');
        reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';
        var svgNode = reusableSVGContainer.firstChild;
        while (svgNode.firstChild) {
          node.appendChild(svgNode.firstChild);
        }
      } else {
        node.innerHTML = html;
      }
    });
    if (ExecutionEnvironment.canUseDOM) {
      var testElement = document.createElement('div');
      testElement.innerHTML = ' ';
      if (testElement.innerHTML === '') {
        setInnerHTML = function (node, html) {
          if (node.parentNode) {
            node.parentNode.replaceChild(node, node);
          }
          if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
            node.innerHTML = String.fromCharCode(0xFEFF) + html;
            var textNode = node.firstChild;
            if (textNode.data.length === 1) {
              node.removeChild(textNode);
            } else {
              textNode.deleteData(0, 1);
            }
          } else {
            node.innerHTML = html;
          }
        };
      }
      testElement = null;
    }
    module.exports = setInnerHTML;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('94', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  /**
   * Given a `prevElement` and `nextElement`, determines if the existing
   * instance should be updated as opposed to being destroyed or replaced by a new
   * instance. Both arguments are elements. This ensures that this logic can
   * operate on stateless trees without any backing instance.
   *
   * @param {?object} prevElement
   * @param {?object} nextElement
   * @return {boolean} True if the existing instance should be updated.
   * @protected
   */

  var define,
      global = this || self,
      GLOBAL = global;
  function shouldUpdateReactComponent(prevElement, nextElement) {
    var prevEmpty = prevElement === null || prevElement === false;
    var nextEmpty = nextElement === null || nextElement === false;
    if (prevEmpty || nextEmpty) {
      return prevEmpty === nextEmpty;
    }

    var prevType = typeof prevElement;
    var nextType = typeof nextElement;
    if (prevType === 'string' || prevType === 'number') {
      return nextType === 'string' || nextType === 'number';
    } else {
      return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
    }
  }

  module.exports = shouldUpdateReactComponent;
  return module.exports;
});
$__System.registerDynamic('102', ['89', 'a4', '75', '5d', 'a7', '99', '6c', 'e0', 'e1', 'e4', '9d', '84', 'e3', '91', 'a0', '6d', 'f0', '92', '8b', 'b2', '94', '7f', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('89');
    var DOMLazyTree = $__require('a4');
    var DOMProperty = $__require('75');
    var React = $__require('5d');
    var ReactBrowserEventEmitter = $__require('a7');
    var ReactCurrentOwner = $__require('99');
    var ReactDOMComponentTree = $__require('6c');
    var ReactDOMContainerInfo = $__require('e0');
    var ReactDOMFeatureFlags = $__require('e1');
    var ReactFeatureFlags = $__require('e4');
    var ReactInstanceMap = $__require('9d');
    var ReactInstrumentation = $__require('84');
    var ReactMarkupChecksum = $__require('e3');
    var ReactReconciler = $__require('91');
    var ReactUpdateQueue = $__require('a0');
    var ReactUpdates = $__require('6d');
    var emptyObject = $__require('f0');
    var instantiateReactComponent = $__require('92');
    var invariant = $__require('8b');
    var setInnerHTML = $__require('b2');
    var shouldUpdateReactComponent = $__require('94');
    var warning = $__require('7f');
    var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
    var ROOT_ATTR_NAME = DOMProperty.ROOT_ATTRIBUTE_NAME;
    var ELEMENT_NODE_TYPE = 1;
    var DOC_NODE_TYPE = 9;
    var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
    var instancesByReactRootID = {};
    function firstDifferenceIndex(string1, string2) {
      var minLen = Math.min(string1.length, string2.length);
      for (var i = 0; i < minLen; i++) {
        if (string1.charAt(i) !== string2.charAt(i)) {
          return i;
        }
      }
      return string1.length === string2.length ? -1 : minLen;
    }
    function getReactRootElementInContainer(container) {
      if (!container) {
        return null;
      }
      if (container.nodeType === DOC_NODE_TYPE) {
        return container.documentElement;
      } else {
        return container.firstChild;
      }
    }
    function internalGetID(node) {
      return node.getAttribute && node.getAttribute(ATTR_NAME) || '';
    }
    function mountComponentIntoNode(wrapperInstance, container, transaction, shouldReuseMarkup, context) {
      var markerName;
      if (ReactFeatureFlags.logTopLevelRenders) {
        var wrappedElement = wrapperInstance._currentElement.props.child;
        var type = wrappedElement.type;
        markerName = 'React mount: ' + (typeof type === 'string' ? type : type.displayName || type.name);
        console.time(markerName);
      }
      var markup = ReactReconciler.mountComponent(wrapperInstance, transaction, null, ReactDOMContainerInfo(wrapperInstance, container), context, 0);
      if (markerName) {
        console.timeEnd(markerName);
      }
      wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance;
      ReactMount._mountImageIntoNode(markup, container, wrapperInstance, shouldReuseMarkup, transaction);
    }
    function batchedMountComponentIntoNode(componentInstance, container, shouldReuseMarkup, context) {
      var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(!shouldReuseMarkup && ReactDOMFeatureFlags.useCreateElement);
      transaction.perform(mountComponentIntoNode, null, componentInstance, container, transaction, shouldReuseMarkup, context);
      ReactUpdates.ReactReconcileTransaction.release(transaction);
    }
    function unmountComponentFromNode(instance, container, safely) {
      if ('production' !== 'production') {
        ReactInstrumentation.debugTool.onBeginFlush();
      }
      ReactReconciler.unmountComponent(instance, safely);
      if ('production' !== 'production') {
        ReactInstrumentation.debugTool.onEndFlush();
      }
      if (container.nodeType === DOC_NODE_TYPE) {
        container = container.documentElement;
      }
      while (container.lastChild) {
        container.removeChild(container.lastChild);
      }
    }
    function hasNonRootReactChild(container) {
      var rootEl = getReactRootElementInContainer(container);
      if (rootEl) {
        var inst = ReactDOMComponentTree.getInstanceFromNode(rootEl);
        return !!(inst && inst._hostParent);
      }
    }
    function nodeIsRenderedByOtherInstance(container) {
      var rootEl = getReactRootElementInContainer(container);
      return !!(rootEl && isReactNode(rootEl) && !ReactDOMComponentTree.getInstanceFromNode(rootEl));
    }
    function isValidContainer(node) {
      return !!(node && (node.nodeType === ELEMENT_NODE_TYPE || node.nodeType === DOC_NODE_TYPE || node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE));
    }
    function isReactNode(node) {
      return isValidContainer(node) && (node.hasAttribute(ROOT_ATTR_NAME) || node.hasAttribute(ATTR_NAME));
    }
    function getHostRootInstanceInContainer(container) {
      var rootEl = getReactRootElementInContainer(container);
      var prevHostInstance = rootEl && ReactDOMComponentTree.getInstanceFromNode(rootEl);
      return prevHostInstance && !prevHostInstance._hostParent ? prevHostInstance : null;
    }
    function getTopLevelWrapperInContainer(container) {
      var root = getHostRootInstanceInContainer(container);
      return root ? root._hostContainerInfo._topLevelWrapper : null;
    }
    var topLevelRootCounter = 1;
    var TopLevelWrapper = function () {
      this.rootID = topLevelRootCounter++;
    };
    TopLevelWrapper.prototype.isReactComponent = {};
    if ('production' !== 'production') {
      TopLevelWrapper.displayName = 'TopLevelWrapper';
    }
    TopLevelWrapper.prototype.render = function () {
      return this.props.child;
    };
    TopLevelWrapper.isReactTopLevelWrapper = true;
    var ReactMount = {
      TopLevelWrapper: TopLevelWrapper,
      _instancesByReactRootID: instancesByReactRootID,
      scrollMonitor: function (container, renderCallback) {
        renderCallback();
      },
      _updateRootComponent: function (prevComponent, nextElement, nextContext, container, callback) {
        ReactMount.scrollMonitor(container, function () {
          ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement, nextContext);
          if (callback) {
            ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
          }
        });
        return prevComponent;
      },
      _renderNewRootComponent: function (nextElement, container, shouldReuseMarkup, context) {
        'production' !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;
        !isValidContainer(container) ? 'production' !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : _prodInvariant('37') : void 0;
        ReactBrowserEventEmitter.ensureScrollValueMonitoring();
        var componentInstance = instantiateReactComponent(nextElement, false);
        ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context);
        var wrapperID = componentInstance._instance.rootID;
        instancesByReactRootID[wrapperID] = componentInstance;
        return componentInstance;
      },
      renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
        !(parentComponent != null && ReactInstanceMap.has(parentComponent)) ? 'production' !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : _prodInvariant('38') : void 0;
        return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
      },
      _renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
        ReactUpdateQueue.validateCallback(callback, 'ReactDOM.render');
        !React.isValidElement(nextElement) ? 'production' !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing a string like \'div\', pass ' + 'React.createElement(\'div\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' : nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : _prodInvariant('39', typeof nextElement === 'string' ? ' Instead of passing a string like \'div\', pass ' + 'React.createElement(\'div\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' : nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : void 0;
        'production' !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : void 0;
        var nextWrappedElement = React.createElement(TopLevelWrapper, { child: nextElement });
        var nextContext;
        if (parentComponent) {
          var parentInst = ReactInstanceMap.get(parentComponent);
          nextContext = parentInst._processChildContext(parentInst._context);
        } else {
          nextContext = emptyObject;
        }
        var prevComponent = getTopLevelWrapperInContainer(container);
        if (prevComponent) {
          var prevWrappedElement = prevComponent._currentElement;
          var prevElement = prevWrappedElement.props.child;
          if (shouldUpdateReactComponent(prevElement, nextElement)) {
            var publicInst = prevComponent._renderedComponent.getPublicInstance();
            var updatedCallback = callback && function () {
              callback.call(publicInst);
            };
            ReactMount._updateRootComponent(prevComponent, nextWrappedElement, nextContext, container, updatedCallback);
            return publicInst;
          } else {
            ReactMount.unmountComponentAtNode(container);
          }
        }
        var reactRootElement = getReactRootElementInContainer(container);
        var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
        var containerHasNonRootReactChild = hasNonRootReactChild(container);
        if ('production' !== 'production') {
          'production' !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : void 0;
          if (!containerHasReactMarkup || reactRootElement.nextSibling) {
            var rootElementSibling = reactRootElement;
            while (rootElementSibling) {
              if (internalGetID(rootElementSibling)) {
                'production' !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : void 0;
                break;
              }
              rootElementSibling = rootElementSibling.nextSibling;
            }
          }
        }
        var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
        var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, nextContext)._renderedComponent.getPublicInstance();
        if (callback) {
          callback.call(component);
        }
        return component;
      },
      render: function (nextElement, container, callback) {
        return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
      },
      unmountComponentAtNode: function (container) {
        'production' !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;
        !isValidContainer(container) ? 'production' !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : _prodInvariant('40') : void 0;
        if ('production' !== 'production') {
          'production' !== 'production' ? warning(!nodeIsRenderedByOtherInstance(container), 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by another copy of React.') : void 0;
        }
        var prevComponent = getTopLevelWrapperInContainer(container);
        if (!prevComponent) {
          var containerHasNonRootReactChild = hasNonRootReactChild(container);
          var isContainerReactRoot = container.nodeType === 1 && container.hasAttribute(ROOT_ATTR_NAME);
          if ('production' !== 'production') {
            'production' !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : void 0;
          }
          return false;
        }
        delete instancesByReactRootID[prevComponent._instance.rootID];
        ReactUpdates.batchedUpdates(unmountComponentFromNode, prevComponent, container, false);
        return true;
      },
      _mountImageIntoNode: function (markup, container, instance, shouldReuseMarkup, transaction) {
        !isValidContainer(container) ? 'production' !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : _prodInvariant('41') : void 0;
        if (shouldReuseMarkup) {
          var rootElement = getReactRootElementInContainer(container);
          if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
            ReactDOMComponentTree.precacheNode(instance, rootElement);
            return;
          } else {
            var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
            rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
            var rootMarkup = rootElement.outerHTML;
            rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);
            var normalizedMarkup = markup;
            if ('production' !== 'production') {
              var normalizer;
              if (container.nodeType === ELEMENT_NODE_TYPE) {
                normalizer = document.createElement('div');
                normalizer.innerHTML = markup;
                normalizedMarkup = normalizer.innerHTML;
              } else {
                normalizer = document.createElement('iframe');
                document.body.appendChild(normalizer);
                normalizer.contentDocument.write(markup);
                normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
                document.body.removeChild(normalizer);
              }
            }
            var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
            var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);
            !(container.nodeType !== DOC_NODE_TYPE) ? 'production' !== 'production' ? invariant(false, 'You\'re trying to render a component to the document using server rendering but the checksum was invalid. This usually means you rendered a different component type or props on the client from the one on the server, or your render() methods are impure. React cannot handle this case due to cross-browser quirks by rendering at the document root. You should look for environment dependent code in your components and ensure the props are the same client and server side:\n%s', difference) : _prodInvariant('42', difference) : void 0;
            if ('production' !== 'production') {
              'production' !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : void 0;
            }
          }
        }
        !(container.nodeType !== DOC_NODE_TYPE) ? 'production' !== 'production' ? invariant(false, 'You\'re trying to render a component to the document but you didn\'t use server rendering. We can\'t do this without using server rendering due to cross-browser quirks. See ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('43') : void 0;
        if (transaction.useCreateElement) {
          while (container.lastChild) {
            container.removeChild(container.lastChild);
          }
          DOMLazyTree.insertTreeBefore(container, markup, null);
        } else {
          setInnerHTML(container, markup);
          ReactDOMComponentTree.precacheNode(instance, container.firstChild);
        }
        if ('production' !== 'production') {
          var hostNode = ReactDOMComponentTree.getInstanceFromNode(container.firstChild);
          if (hostNode._debugID !== 0) {
            ReactInstrumentation.debugTool.onHostOperation({
              instanceID: hostNode._debugID,
              type: 'mount',
              payload: markup.toString()
            });
          }
        }
      }
    };
    module.exports = ReactMount;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('103', ['102'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var ReactMount = $__require('102');
  module.exports = ReactMount.renderSubtreeIntoContainer;
  return module.exports;
});
$__System.registerDynamic('104', ['7f', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var warning = $__require('7f');
    if ('production' !== 'production') {
      var processingChildContext = false;
      var warnInvalidSetState = function () {
        'production' !== 'production' ? warning(!processingChildContext, 'setState(...): Cannot call setState() inside getChildContext()') : void 0;
      };
    }
    var ReactInvalidSetStateWarningHook = {
      onBeginProcessingChildContext: function () {
        processingChildContext = true;
      },
      onEndProcessingChildContext: function () {
        processingChildContext = false;
      },
      onSetState: function () {
        warnInvalidSetState();
      }
    };
    module.exports = ReactInvalidSetStateWarningHook;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('105', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2016-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var history = [];

  var ReactHostOperationHistoryHook = {
    onHostOperation: function (operation) {
      history.push(operation);
    },
    clearHistory: function () {
      if (ReactHostOperationHistoryHook._preventClearing) {
        // Should only be used for tests.
        return;
      }

      history = [];
    },
    getHistory: function () {
      return history;
    }
  };

  module.exports = ReactHostOperationHistoryHook;
  return module.exports;
});
$__System.registerDynamic('69', [], true, function ($__require, exports, module) {
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

  /**
   * Simple, lightweight module assisting with the detection and context of
   * Worker. Helps avoid circular dependencies and allows code to reason about
   * whether or not they are in a Worker, even if they never include the main
   * `ReactWorker` dependency.
   */
  var ExecutionEnvironment = {

    canUseDOM: canUseDOM,

    canUseWorkers: typeof Worker !== 'undefined',

    canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),

    canUseViewport: canUseDOM && !!window.screen,

    isInWorker: !canUseDOM // For now, this is true - might change in the future.

  };

  module.exports = ExecutionEnvironment;
  return module.exports;
});
$__System.registerDynamic('106', ['69'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var ExecutionEnvironment = $__require('69');
  var performance;
  if (ExecutionEnvironment.canUseDOM) {
    performance = window.performance || window.msPerformance || window.webkitPerformance;
  }
  module.exports = performance || {};
  return module.exports;
});
$__System.registerDynamic('107', ['106'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var performance = $__require('106');
  var performanceNow;
  if (performance.now) {
    performanceNow = function performanceNow() {
      return performance.now();
    };
  } else {
    performanceNow = function performanceNow() {
      return Date.now();
    };
  }
  module.exports = performanceNow;
  return module.exports;
});
$__System.registerDynamic('108', ['104', '105', '96', '69', '107', '7f', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var ReactInvalidSetStateWarningHook = $__require('104');
    var ReactHostOperationHistoryHook = $__require('105');
    var ReactComponentTreeHook = $__require('96');
    var ExecutionEnvironment = $__require('69');
    var performanceNow = $__require('107');
    var warning = $__require('7f');
    var hooks = [];
    var didHookThrowForEvent = {};
    function callHook(event, fn, context, arg1, arg2, arg3, arg4, arg5) {
      try {
        fn.call(context, arg1, arg2, arg3, arg4, arg5);
      } catch (e) {
        'production' !== 'production' ? warning(didHookThrowForEvent[event], 'Exception thrown by hook while handling %s: %s', event, e + '\n' + e.stack) : void 0;
        didHookThrowForEvent[event] = true;
      }
    }
    function emitEvent(event, arg1, arg2, arg3, arg4, arg5) {
      for (var i = 0; i < hooks.length; i++) {
        var hook = hooks[i];
        var fn = hook[event];
        if (fn) {
          callHook(event, fn, hook, arg1, arg2, arg3, arg4, arg5);
        }
      }
    }
    var isProfiling = false;
    var flushHistory = [];
    var lifeCycleTimerStack = [];
    var currentFlushNesting = 0;
    var currentFlushMeasurements = [];
    var currentFlushStartTime = 0;
    var currentTimerDebugID = null;
    var currentTimerStartTime = 0;
    var currentTimerNestedFlushDuration = 0;
    var currentTimerType = null;
    var lifeCycleTimerHasWarned = false;
    function clearHistory() {
      ReactComponentTreeHook.purgeUnmountedComponents();
      ReactHostOperationHistoryHook.clearHistory();
    }
    function getTreeSnapshot(registeredIDs) {
      return registeredIDs.reduce(function (tree, id) {
        var ownerID = ReactComponentTreeHook.getOwnerID(id);
        var parentID = ReactComponentTreeHook.getParentID(id);
        tree[id] = {
          displayName: ReactComponentTreeHook.getDisplayName(id),
          text: ReactComponentTreeHook.getText(id),
          updateCount: ReactComponentTreeHook.getUpdateCount(id),
          childIDs: ReactComponentTreeHook.getChildIDs(id),
          ownerID: ownerID || parentID && ReactComponentTreeHook.getOwnerID(parentID) || 0,
          parentID: parentID
        };
        return tree;
      }, {});
    }
    function resetMeasurements() {
      var previousStartTime = currentFlushStartTime;
      var previousMeasurements = currentFlushMeasurements;
      var previousOperations = ReactHostOperationHistoryHook.getHistory();
      if (currentFlushNesting === 0) {
        currentFlushStartTime = 0;
        currentFlushMeasurements = [];
        clearHistory();
        return;
      }
      if (previousMeasurements.length || previousOperations.length) {
        var registeredIDs = ReactComponentTreeHook.getRegisteredIDs();
        flushHistory.push({
          duration: performanceNow() - previousStartTime,
          measurements: previousMeasurements || [],
          operations: previousOperations || [],
          treeSnapshot: getTreeSnapshot(registeredIDs)
        });
      }
      clearHistory();
      currentFlushStartTime = performanceNow();
      currentFlushMeasurements = [];
    }
    function checkDebugID(debugID) {
      var allowRoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (allowRoot && debugID === 0) {
        return;
      }
      if (!debugID) {
        'production' !== 'production' ? warning(false, 'ReactDebugTool: debugID may not be empty.') : void 0;
      }
    }
    function beginLifeCycleTimer(debugID, timerType) {
      if (currentFlushNesting === 0) {
        return;
      }
      if (currentTimerType && !lifeCycleTimerHasWarned) {
        'production' !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'Did not expect %s timer to start while %s timer is still in ' + 'progress for %s instance.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
        lifeCycleTimerHasWarned = true;
      }
      currentTimerStartTime = performanceNow();
      currentTimerNestedFlushDuration = 0;
      currentTimerDebugID = debugID;
      currentTimerType = timerType;
    }
    function endLifeCycleTimer(debugID, timerType) {
      if (currentFlushNesting === 0) {
        return;
      }
      if (currentTimerType !== timerType && !lifeCycleTimerHasWarned) {
        'production' !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'We did not expect %s timer to stop while %s timer is still in ' + 'progress for %s instance. Please report this as a bug in React.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
        lifeCycleTimerHasWarned = true;
      }
      if (isProfiling) {
        currentFlushMeasurements.push({
          timerType: timerType,
          instanceID: debugID,
          duration: performanceNow() - currentTimerStartTime - currentTimerNestedFlushDuration
        });
      }
      currentTimerStartTime = 0;
      currentTimerNestedFlushDuration = 0;
      currentTimerDebugID = null;
      currentTimerType = null;
    }
    function pauseCurrentLifeCycleTimer() {
      var currentTimer = {
        startTime: currentTimerStartTime,
        nestedFlushStartTime: performanceNow(),
        debugID: currentTimerDebugID,
        timerType: currentTimerType
      };
      lifeCycleTimerStack.push(currentTimer);
      currentTimerStartTime = 0;
      currentTimerNestedFlushDuration = 0;
      currentTimerDebugID = null;
      currentTimerType = null;
    }
    function resumeCurrentLifeCycleTimer() {
      var _lifeCycleTimerStack$ = lifeCycleTimerStack.pop(),
          startTime = _lifeCycleTimerStack$.startTime,
          nestedFlushStartTime = _lifeCycleTimerStack$.nestedFlushStartTime,
          debugID = _lifeCycleTimerStack$.debugID,
          timerType = _lifeCycleTimerStack$.timerType;
      var nestedFlushDuration = performanceNow() - nestedFlushStartTime;
      currentTimerStartTime = startTime;
      currentTimerNestedFlushDuration += nestedFlushDuration;
      currentTimerDebugID = debugID;
      currentTimerType = timerType;
    }
    var lastMarkTimeStamp = 0;
    var canUsePerformanceMeasure = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';
    function shouldMark(debugID) {
      if (!isProfiling || !canUsePerformanceMeasure) {
        return false;
      }
      var element = ReactComponentTreeHook.getElement(debugID);
      if (element == null || typeof element !== 'object') {
        return false;
      }
      var isHostElement = typeof element.type === 'string';
      if (isHostElement) {
        return false;
      }
      return true;
    }
    function markBegin(debugID, markType) {
      if (!shouldMark(debugID)) {
        return;
      }
      var markName = debugID + '::' + markType;
      lastMarkTimeStamp = performanceNow();
      performance.mark(markName);
    }
    function markEnd(debugID, markType) {
      if (!shouldMark(debugID)) {
        return;
      }
      var markName = debugID + '::' + markType;
      var displayName = ReactComponentTreeHook.getDisplayName(debugID) || 'Unknown';
      var timeStamp = performanceNow();
      if (timeStamp - lastMarkTimeStamp > 0.1) {
        var measurementName = displayName + ' [' + markType + ']';
        performance.measure(measurementName, markName);
      }
      performance.clearMarks(markName);
      performance.clearMeasures(measurementName);
    }
    var ReactDebugTool = {
      addHook: function (hook) {
        hooks.push(hook);
      },
      removeHook: function (hook) {
        for (var i = 0; i < hooks.length; i++) {
          if (hooks[i] === hook) {
            hooks.splice(i, 1);
            i--;
          }
        }
      },
      isProfiling: function () {
        return isProfiling;
      },
      beginProfiling: function () {
        if (isProfiling) {
          return;
        }
        isProfiling = true;
        flushHistory.length = 0;
        resetMeasurements();
        ReactDebugTool.addHook(ReactHostOperationHistoryHook);
      },
      endProfiling: function () {
        if (!isProfiling) {
          return;
        }
        isProfiling = false;
        resetMeasurements();
        ReactDebugTool.removeHook(ReactHostOperationHistoryHook);
      },
      getFlushHistory: function () {
        return flushHistory;
      },
      onBeginFlush: function () {
        currentFlushNesting++;
        resetMeasurements();
        pauseCurrentLifeCycleTimer();
        emitEvent('onBeginFlush');
      },
      onEndFlush: function () {
        resetMeasurements();
        currentFlushNesting--;
        resumeCurrentLifeCycleTimer();
        emitEvent('onEndFlush');
      },
      onBeginLifeCycleTimer: function (debugID, timerType) {
        checkDebugID(debugID);
        emitEvent('onBeginLifeCycleTimer', debugID, timerType);
        markBegin(debugID, timerType);
        beginLifeCycleTimer(debugID, timerType);
      },
      onEndLifeCycleTimer: function (debugID, timerType) {
        checkDebugID(debugID);
        endLifeCycleTimer(debugID, timerType);
        markEnd(debugID, timerType);
        emitEvent('onEndLifeCycleTimer', debugID, timerType);
      },
      onBeginProcessingChildContext: function () {
        emitEvent('onBeginProcessingChildContext');
      },
      onEndProcessingChildContext: function () {
        emitEvent('onEndProcessingChildContext');
      },
      onHostOperation: function (operation) {
        checkDebugID(operation.instanceID);
        emitEvent('onHostOperation', operation);
      },
      onSetState: function () {
        emitEvent('onSetState');
      },
      onSetChildren: function (debugID, childDebugIDs) {
        checkDebugID(debugID);
        childDebugIDs.forEach(checkDebugID);
        emitEvent('onSetChildren', debugID, childDebugIDs);
      },
      onBeforeMountComponent: function (debugID, element, parentDebugID) {
        checkDebugID(debugID);
        checkDebugID(parentDebugID, true);
        emitEvent('onBeforeMountComponent', debugID, element, parentDebugID);
        markBegin(debugID, 'mount');
      },
      onMountComponent: function (debugID) {
        checkDebugID(debugID);
        markEnd(debugID, 'mount');
        emitEvent('onMountComponent', debugID);
      },
      onBeforeUpdateComponent: function (debugID, element) {
        checkDebugID(debugID);
        emitEvent('onBeforeUpdateComponent', debugID, element);
        markBegin(debugID, 'update');
      },
      onUpdateComponent: function (debugID) {
        checkDebugID(debugID);
        markEnd(debugID, 'update');
        emitEvent('onUpdateComponent', debugID);
      },
      onBeforeUnmountComponent: function (debugID) {
        checkDebugID(debugID);
        emitEvent('onBeforeUnmountComponent', debugID);
        markBegin(debugID, 'unmount');
      },
      onUnmountComponent: function (debugID) {
        checkDebugID(debugID);
        markEnd(debugID, 'unmount');
        emitEvent('onUnmountComponent', debugID);
      },
      onTestEvent: function () {
        emitEvent('onTestEvent');
      }
    };
    ReactDebugTool.addDevtool = ReactDebugTool.addHook;
    ReactDebugTool.removeDevtool = ReactDebugTool.removeHook;
    ReactDebugTool.addHook(ReactInvalidSetStateWarningHook);
    ReactDebugTool.addHook(ReactComponentTreeHook);
    var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
    if (/[?&]react_perf\b/.test(url)) {
      ReactDebugTool.beginProfiling();
    }
    module.exports = ReactDebugTool;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('84', ['108', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var debugTool = null;
    if ('production' !== 'production') {
      var ReactDebugTool = $__require('108');
      debugTool = ReactDebugTool;
    }
    module.exports = { debugTool: debugTool };
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('a6', ['89', '8b', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('89');
    var invariant = $__require('8b');
    var eventPluginOrder = null;
    var namesToPlugins = {};
    function recomputePluginOrdering() {
      if (!eventPluginOrder) {
        return;
      }
      for (var pluginName in namesToPlugins) {
        var pluginModule = namesToPlugins[pluginName];
        var pluginIndex = eventPluginOrder.indexOf(pluginName);
        !(pluginIndex > -1) ? 'production' !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : _prodInvariant('96', pluginName) : void 0;
        if (EventPluginRegistry.plugins[pluginIndex]) {
          continue;
        }
        !pluginModule.extractEvents ? 'production' !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : _prodInvariant('97', pluginName) : void 0;
        EventPluginRegistry.plugins[pluginIndex] = pluginModule;
        var publishedEvents = pluginModule.eventTypes;
        for (var eventName in publishedEvents) {
          !publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName) ? 'production' !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : _prodInvariant('98', eventName, pluginName) : void 0;
        }
      }
    }
    function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {
      !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? 'production' !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : _prodInvariant('99', eventName) : void 0;
      EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;
      var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
      if (phasedRegistrationNames) {
        for (var phaseName in phasedRegistrationNames) {
          if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
            var phasedRegistrationName = phasedRegistrationNames[phaseName];
            publishRegistrationName(phasedRegistrationName, pluginModule, eventName);
          }
        }
        return true;
      } else if (dispatchConfig.registrationName) {
        publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);
        return true;
      }
      return false;
    }
    function publishRegistrationName(registrationName, pluginModule, eventName) {
      !!EventPluginRegistry.registrationNameModules[registrationName] ? 'production' !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : _prodInvariant('100', registrationName) : void 0;
      EventPluginRegistry.registrationNameModules[registrationName] = pluginModule;
      EventPluginRegistry.registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;
      if ('production' !== 'production') {
        var lowerCasedName = registrationName.toLowerCase();
        EventPluginRegistry.possibleRegistrationNames[lowerCasedName] = registrationName;
        if (registrationName === 'onDoubleClick') {
          EventPluginRegistry.possibleRegistrationNames.ondblclick = registrationName;
        }
      }
    }
    var EventPluginRegistry = {
      plugins: [],
      eventNameDispatchConfigs: {},
      registrationNameModules: {},
      registrationNameDependencies: {},
      possibleRegistrationNames: 'production' !== 'production' ? {} : null,
      injectEventPluginOrder: function (injectedEventPluginOrder) {
        !!eventPluginOrder ? 'production' !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : _prodInvariant('101') : void 0;
        eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
        recomputePluginOrdering();
      },
      injectEventPluginsByName: function (injectedNamesToPlugins) {
        var isOrderingDirty = false;
        for (var pluginName in injectedNamesToPlugins) {
          if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
            continue;
          }
          var pluginModule = injectedNamesToPlugins[pluginName];
          if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {
            !!namesToPlugins[pluginName] ? 'production' !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : _prodInvariant('102', pluginName) : void 0;
            namesToPlugins[pluginName] = pluginModule;
            isOrderingDirty = true;
          }
        }
        if (isOrderingDirty) {
          recomputePluginOrdering();
        }
      },
      getPluginModuleForEvent: function (event) {
        var dispatchConfig = event.dispatchConfig;
        if (dispatchConfig.registrationName) {
          return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
        }
        if (dispatchConfig.phasedRegistrationNames !== undefined) {
          var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
          for (var phase in phasedRegistrationNames) {
            if (!phasedRegistrationNames.hasOwnProperty(phase)) {
              continue;
            }
            var pluginModule = EventPluginRegistry.registrationNameModules[phasedRegistrationNames[phase]];
            if (pluginModule) {
              return pluginModule;
            }
          }
        }
        return null;
      },
      _resetEventPlugins: function () {
        eventPluginOrder = null;
        for (var pluginName in namesToPlugins) {
          if (namesToPlugins.hasOwnProperty(pluginName)) {
            delete namesToPlugins[pluginName];
          }
        }
        EventPluginRegistry.plugins.length = 0;
        var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
        for (var eventName in eventNameDispatchConfigs) {
          if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
            delete eventNameDispatchConfigs[eventName];
          }
        }
        var registrationNameModules = EventPluginRegistry.registrationNameModules;
        for (var registrationName in registrationNameModules) {
          if (registrationNameModules.hasOwnProperty(registrationName)) {
            delete registrationNameModules[registrationName];
          }
        }
        if ('production' !== 'production') {
          var possibleRegistrationNames = EventPluginRegistry.possibleRegistrationNames;
          for (var lowerCasedName in possibleRegistrationNames) {
            if (possibleRegistrationNames.hasOwnProperty(lowerCasedName)) {
              delete possibleRegistrationNames[lowerCasedName];
            }
          }
        }
      }
    };
    module.exports = EventPluginRegistry;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('109', ['75', 'a6', '96', '7f', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var DOMProperty = $__require('75');
    var EventPluginRegistry = $__require('a6');
    var ReactComponentTreeHook = $__require('96');
    var warning = $__require('7f');
    if ('production' !== 'production') {
      var reactProps = {
        children: true,
        dangerouslySetInnerHTML: true,
        key: true,
        ref: true,
        autoFocus: true,
        defaultValue: true,
        valueLink: true,
        defaultChecked: true,
        checkedLink: true,
        innerHTML: true,
        suppressContentEditableWarning: true,
        onFocusIn: true,
        onFocusOut: true
      };
      var warnedProperties = {};
      var validateProperty = function (tagName, name, debugID) {
        if (DOMProperty.properties.hasOwnProperty(name) || DOMProperty.isCustomAttribute(name)) {
          return true;
        }
        if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
          return true;
        }
        if (EventPluginRegistry.registrationNameModules.hasOwnProperty(name)) {
          return true;
        }
        warnedProperties[name] = true;
        var lowerCasedName = name.toLowerCase();
        var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;
        var registrationName = EventPluginRegistry.possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? EventPluginRegistry.possibleRegistrationNames[lowerCasedName] : null;
        if (standardName != null) {
          'production' !== 'production' ? warning(false, 'Unknown DOM property %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
          return true;
        } else if (registrationName != null) {
          'production' !== 'production' ? warning(false, 'Unknown event handler property %s. Did you mean `%s`?%s', name, registrationName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
          return true;
        } else {
          return false;
        }
      };
    }
    var warnUnknownProperties = function (debugID, element) {
      var unknownProps = [];
      for (var key in element.props) {
        var isValid = validateProperty(element.type, key, debugID);
        if (!isValid) {
          unknownProps.push(key);
        }
      }
      var unknownPropString = unknownProps.map(function (prop) {
        return '`' + prop + '`';
      }).join(', ');
      if (unknownProps.length === 1) {
        'production' !== 'production' ? warning(false, 'Unknown prop %s on <%s> tag. Remove this prop from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
      } else if (unknownProps.length > 1) {
        'production' !== 'production' ? warning(false, 'Unknown props %s on <%s> tag. Remove these props from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
      }
    };
    function handleElement(debugID, element) {
      if (element == null || typeof element.type !== 'string') {
        return;
      }
      if (element.type.indexOf('-') >= 0 || element.props.is) {
        return;
      }
      warnUnknownProperties(debugID, element);
    }
    var ReactDOMUnknownPropertyHook = {
      onBeforeMountComponent: function (debugID, element) {
        handleElement(debugID, element);
      },
      onBeforeUpdateComponent: function (debugID, element) {
        handleElement(debugID, element);
      }
    };
    module.exports = ReactDOMUnknownPropertyHook;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('10a', ['96', '7f', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var ReactComponentTreeHook = $__require('96');
    var warning = $__require('7f');
    var didWarnValueNull = false;
    function handleElement(debugID, element) {
      if (element == null) {
        return;
      }
      if (element.type !== 'input' && element.type !== 'textarea' && element.type !== 'select') {
        return;
      }
      if (element.props != null && element.props.value === null && !didWarnValueNull) {
        'production' !== 'production' ? warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using the empty string to clear the component or `undefined` ' + 'for uncontrolled components.%s', element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
        didWarnValueNull = true;
      }
    }
    var ReactDOMNullInputValuePropHook = {
      onBeforeMountComponent: function (debugID, element) {
        handleElement(debugID, element);
      },
      onBeforeUpdateComponent: function (debugID, element) {
        handleElement(debugID, element);
      }
    };
    module.exports = ReactDOMNullInputValuePropHook;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('89', [], true, function ($__require, exports, module) {
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */
  'use strict';

  /**
   * WARNING: DO NOT manually require this module.
   * This is a replacement for `invariant(...)` used by the error code system
   * and will _only_ be required by the corresponding babel pass.
   * It always throws.
   */

  var define,
      global = this || self,
      GLOBAL = global;
  function reactProdInvariant(code) {
    var argCount = arguments.length - 1;

    var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;

    for (var argIdx = 0; argIdx < argCount; argIdx++) {
      message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
    }

    message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';

    var error = new Error(message);
    error.name = 'Invariant Violation';
    error.framesToPop = 1; // we don't care about reactProdInvariant's own frame

    throw error;
  }

  module.exports = reactProdInvariant;
  return module.exports;
});
$__System.registerDynamic('75', ['89', '8b', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('89');
    var invariant = $__require('8b');
    function checkMask(value, bitmask) {
      return (value & bitmask) === bitmask;
    }
    var DOMPropertyInjection = {
      MUST_USE_PROPERTY: 0x1,
      HAS_BOOLEAN_VALUE: 0x4,
      HAS_NUMERIC_VALUE: 0x8,
      HAS_POSITIVE_NUMERIC_VALUE: 0x10 | 0x8,
      HAS_OVERLOADED_BOOLEAN_VALUE: 0x20,
      injectDOMPropertyConfig: function (domPropertyConfig) {
        var Injection = DOMPropertyInjection;
        var Properties = domPropertyConfig.Properties || {};
        var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
        var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
        var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
        var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};
        if (domPropertyConfig.isCustomAttribute) {
          DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
        }
        for (var propName in Properties) {
          !!DOMProperty.properties.hasOwnProperty(propName) ? 'production' !== 'production' ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property \'%s\' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.', propName) : _prodInvariant('48', propName) : void 0;
          var lowerCased = propName.toLowerCase();
          var propConfig = Properties[propName];
          var propertyInfo = {
            attributeName: lowerCased,
            attributeNamespace: null,
            propertyName: propName,
            mutationMethod: null,
            mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
            hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
            hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
            hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
            hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
          };
          !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? 'production' !== 'production' ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s', propName) : _prodInvariant('50', propName) : void 0;
          if ('production' !== 'production') {
            DOMProperty.getPossibleStandardName[lowerCased] = propName;
          }
          if (DOMAttributeNames.hasOwnProperty(propName)) {
            var attributeName = DOMAttributeNames[propName];
            propertyInfo.attributeName = attributeName;
            if ('production' !== 'production') {
              DOMProperty.getPossibleStandardName[attributeName] = propName;
            }
          }
          if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
            propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
          }
          if (DOMPropertyNames.hasOwnProperty(propName)) {
            propertyInfo.propertyName = DOMPropertyNames[propName];
          }
          if (DOMMutationMethods.hasOwnProperty(propName)) {
            propertyInfo.mutationMethod = DOMMutationMethods[propName];
          }
          DOMProperty.properties[propName] = propertyInfo;
        }
      }
    };
    var ATTRIBUTE_NAME_START_CHAR = ':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
    var DOMProperty = {
      ID_ATTRIBUTE_NAME: 'data-reactid',
      ROOT_ATTRIBUTE_NAME: 'data-reactroot',
      ATTRIBUTE_NAME_START_CHAR: ATTRIBUTE_NAME_START_CHAR,
      ATTRIBUTE_NAME_CHAR: ATTRIBUTE_NAME_START_CHAR + '\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040',
      properties: {},
      getPossibleStandardName: 'production' !== 'production' ? { autofocus: 'autoFocus' } : null,
      _isCustomAttributeFunctions: [],
      isCustomAttribute: function (attributeName) {
        for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
          var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
          if (isCustomAttributeFn(attributeName)) {
            return true;
          }
        }
        return false;
      },
      injection: DOMPropertyInjection
    };
    module.exports = DOMProperty;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('e6', [], true, function ($__require, exports, module) {
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */
  'use strict';

  /**
   * WARNING: DO NOT manually require this module.
   * This is a replacement for `invariant(...)` used by the error code system
   * and will _only_ be required by the corresponding babel pass.
   * It always throws.
   */

  var define,
      global = this || self,
      GLOBAL = global;
  function reactProdInvariant(code) {
    var argCount = arguments.length - 1;

    var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;

    for (var argIdx = 0; argIdx < argCount; argIdx++) {
      message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
    }

    message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';

    var error = new Error(message);
    error.name = 'Invariant Violation';
    error.framesToPop = 1; // we don't care about reactProdInvariant's own frame

    throw error;
  }

  module.exports = reactProdInvariant;
  return module.exports;
});
$__System.registerDynamic('99', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  /**
   * Keeps track of the current owner.
   *
   * The current owner is the component who should own any components that are
   * currently being constructed.
   */

  var define,
      global = this || self,
      GLOBAL = global;
  var ReactCurrentOwner = {

    /**
     * @internal
     * @type {ReactComponent}
     */
    current: null

  };

  module.exports = ReactCurrentOwner;
  return module.exports;
});
$__System.registerDynamic('8b', ['13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    function invariant(condition, format, a, b, c, d, e, f) {
      if ('production' !== 'production') {
        if (format === undefined) {
          throw new Error('invariant requires an error message argument');
        }
      }
      if (!condition) {
        var error;
        if (format === undefined) {
          error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
        } else {
          var args = [a, b, c, d, e, f];
          var argIndex = 0;
          error = new Error(format.replace(/%s/g, function () {
            return args[argIndex++];
          }));
          error.name = 'Invariant Violation';
        }
        error.framesToPop = 1;
        throw error;
      }
    }
    module.exports = invariant;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('96', ['e6', '99', '8b', '7f', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('e6');
    var ReactCurrentOwner = $__require('99');
    var invariant = $__require('8b');
    var warning = $__require('7f');
    function isNative(fn) {
      var funcToString = Function.prototype.toString;
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
      try {
        var source = funcToString.call(fn);
        return reIsNative.test(source);
      } catch (err) {
        return false;
      }
    }
    var canUseCollections = typeof Array.from === 'function' && typeof Map === 'function' && isNative(Map) && Map.prototype != null && typeof Map.prototype.keys === 'function' && isNative(Map.prototype.keys) && typeof Set === 'function' && isNative(Set) && Set.prototype != null && typeof Set.prototype.keys === 'function' && isNative(Set.prototype.keys);
    if (canUseCollections) {
      var itemMap = new Map();
      var rootIDSet = new Set();
      var setItem = function (id, item) {
        itemMap.set(id, item);
      };
      var getItem = function (id) {
        return itemMap.get(id);
      };
      var removeItem = function (id) {
        itemMap['delete'](id);
      };
      var getItemIDs = function () {
        return Array.from(itemMap.keys());
      };
      var addRoot = function (id) {
        rootIDSet.add(id);
      };
      var removeRoot = function (id) {
        rootIDSet['delete'](id);
      };
      var getRootIDs = function () {
        return Array.from(rootIDSet.keys());
      };
    } else {
      var itemByKey = {};
      var rootByKey = {};
      var getKeyFromID = function (id) {
        return '.' + id;
      };
      var getIDFromKey = function (key) {
        return parseInt(key.substr(1), 10);
      };
      var setItem = function (id, item) {
        var key = getKeyFromID(id);
        itemByKey[key] = item;
      };
      var getItem = function (id) {
        var key = getKeyFromID(id);
        return itemByKey[key];
      };
      var removeItem = function (id) {
        var key = getKeyFromID(id);
        delete itemByKey[key];
      };
      var getItemIDs = function () {
        return Object.keys(itemByKey).map(getIDFromKey);
      };
      var addRoot = function (id) {
        var key = getKeyFromID(id);
        rootByKey[key] = true;
      };
      var removeRoot = function (id) {
        var key = getKeyFromID(id);
        delete rootByKey[key];
      };
      var getRootIDs = function () {
        return Object.keys(rootByKey).map(getIDFromKey);
      };
    }
    var unmountedIDs = [];
    function purgeDeep(id) {
      var item = getItem(id);
      if (item) {
        var childIDs = item.childIDs;
        removeItem(id);
        childIDs.forEach(purgeDeep);
      }
    }
    function describeComponentFrame(name, source, ownerName) {
      return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
    }
    function getDisplayName(element) {
      if (element == null) {
        return '#empty';
      } else if (typeof element === 'string' || typeof element === 'number') {
        return '#text';
      } else if (typeof element.type === 'string') {
        return element.type;
      } else {
        return element.type.displayName || element.type.name || 'Unknown';
      }
    }
    function describeID(id) {
      var name = ReactComponentTreeHook.getDisplayName(id);
      var element = ReactComponentTreeHook.getElement(id);
      var ownerID = ReactComponentTreeHook.getOwnerID(id);
      var ownerName;
      if (ownerID) {
        ownerName = ReactComponentTreeHook.getDisplayName(ownerID);
      }
      'production' !== 'production' ? warning(element, 'ReactComponentTreeHook: Missing React element for debugID %s when ' + 'building stack', id) : void 0;
      return describeComponentFrame(name, element && element._source, ownerName);
    }
    var ReactComponentTreeHook = {
      onSetChildren: function (id, nextChildIDs) {
        var item = getItem(id);
        !item ? 'production' !== 'production' ? invariant(false, 'Item must have been set') : _prodInvariant('144') : void 0;
        item.childIDs = nextChildIDs;
        for (var i = 0; i < nextChildIDs.length; i++) {
          var nextChildID = nextChildIDs[i];
          var nextChild = getItem(nextChildID);
          !nextChild ? 'production' !== 'production' ? invariant(false, 'Expected hook events to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('140') : void 0;
          !(nextChild.childIDs != null || typeof nextChild.element !== 'object' || nextChild.element == null) ? 'production' !== 'production' ? invariant(false, 'Expected onSetChildren() to fire for a container child before its parent includes it in onSetChildren().') : _prodInvariant('141') : void 0;
          !nextChild.isMounted ? 'production' !== 'production' ? invariant(false, 'Expected onMountComponent() to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('71') : void 0;
          if (nextChild.parentID == null) {
            nextChild.parentID = id;
          }
          !(nextChild.parentID === id) ? 'production' !== 'production' ? invariant(false, 'Expected onBeforeMountComponent() parent and onSetChildren() to be consistent (%s has parents %s and %s).', nextChildID, nextChild.parentID, id) : _prodInvariant('142', nextChildID, nextChild.parentID, id) : void 0;
        }
      },
      onBeforeMountComponent: function (id, element, parentID) {
        var item = {
          element: element,
          parentID: parentID,
          text: null,
          childIDs: [],
          isMounted: false,
          updateCount: 0
        };
        setItem(id, item);
      },
      onBeforeUpdateComponent: function (id, element) {
        var item = getItem(id);
        if (!item || !item.isMounted) {
          return;
        }
        item.element = element;
      },
      onMountComponent: function (id) {
        var item = getItem(id);
        !item ? 'production' !== 'production' ? invariant(false, 'Item must have been set') : _prodInvariant('144') : void 0;
        item.isMounted = true;
        var isRoot = item.parentID === 0;
        if (isRoot) {
          addRoot(id);
        }
      },
      onUpdateComponent: function (id) {
        var item = getItem(id);
        if (!item || !item.isMounted) {
          return;
        }
        item.updateCount++;
      },
      onUnmountComponent: function (id) {
        var item = getItem(id);
        if (item) {
          item.isMounted = false;
          var isRoot = item.parentID === 0;
          if (isRoot) {
            removeRoot(id);
          }
        }
        unmountedIDs.push(id);
      },
      purgeUnmountedComponents: function () {
        if (ReactComponentTreeHook._preventPurging) {
          return;
        }
        for (var i = 0; i < unmountedIDs.length; i++) {
          var id = unmountedIDs[i];
          purgeDeep(id);
        }
        unmountedIDs.length = 0;
      },
      isMounted: function (id) {
        var item = getItem(id);
        return item ? item.isMounted : false;
      },
      getCurrentStackAddendum: function (topElement) {
        var info = '';
        if (topElement) {
          var name = getDisplayName(topElement);
          var owner = topElement._owner;
          info += describeComponentFrame(name, topElement._source, owner && owner.getName());
        }
        var currentOwner = ReactCurrentOwner.current;
        var id = currentOwner && currentOwner._debugID;
        info += ReactComponentTreeHook.getStackAddendumByID(id);
        return info;
      },
      getStackAddendumByID: function (id) {
        var info = '';
        while (id) {
          info += describeID(id);
          id = ReactComponentTreeHook.getParentID(id);
        }
        return info;
      },
      getChildIDs: function (id) {
        var item = getItem(id);
        return item ? item.childIDs : [];
      },
      getDisplayName: function (id) {
        var element = ReactComponentTreeHook.getElement(id);
        if (!element) {
          return null;
        }
        return getDisplayName(element);
      },
      getElement: function (id) {
        var item = getItem(id);
        return item ? item.element : null;
      },
      getOwnerID: function (id) {
        var element = ReactComponentTreeHook.getElement(id);
        if (!element || !element._owner) {
          return null;
        }
        return element._owner._debugID;
      },
      getParentID: function (id) {
        var item = getItem(id);
        return item ? item.parentID : null;
      },
      getSource: function (id) {
        var item = getItem(id);
        var element = item ? item.element : null;
        var source = element != null ? element._source : null;
        return source;
      },
      getText: function (id) {
        var element = ReactComponentTreeHook.getElement(id);
        if (typeof element === 'string') {
          return element;
        } else if (typeof element === 'number') {
          return '' + element;
        } else {
          return null;
        }
      },
      getUpdateCount: function (id) {
        var item = getItem(id);
        return item ? item.updateCount : 0;
      },
      getRootIDs: getRootIDs,
      getRegisteredIDs: getItemIDs
    };
    module.exports = ReactComponentTreeHook;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic("9e", [], true, function ($__require, exports, module) {
  /* */
  "use strict";

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  var define,
      global = this || self,
      GLOBAL = global;
  function makeEmptyFunction(arg) {
    return function () {
      return arg;
    };
  }

  /**
   * This function accepts and discards inputs; it has no side effects. This is
   * primarily useful idiomatically for overridable function endpoints which
   * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
   */
  var emptyFunction = function emptyFunction() {};

  emptyFunction.thatReturns = makeEmptyFunction;
  emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
  emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
  emptyFunction.thatReturnsNull = makeEmptyFunction(null);
  emptyFunction.thatReturnsThis = function () {
    return this;
  };
  emptyFunction.thatReturnsArgument = function (arg) {
    return arg;
  };

  module.exports = emptyFunction;
  return module.exports;
});
$__System.registerDynamic('7f', ['9e', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var emptyFunction = $__require('9e');
    var warning = emptyFunction;
    if ('production' !== 'production') {
      (function () {
        var printWarning = function printWarning(format) {
          for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          var argIndex = 0;
          var message = 'Warning: ' + format.replace(/%s/g, function () {
            return args[argIndex++];
          });
          if (typeof console !== 'undefined') {
            console.error(message);
          }
          try {
            throw new Error(message);
          } catch (x) {}
        };
        warning = function warning(condition, format) {
          if (format === undefined) {
            throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
          }
          if (format.indexOf('Failed Composite propType: ') === 0) {
            return;
          }
          if (!condition) {
            for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
              args[_key2 - 2] = arguments[_key2];
            }
            printWarning.apply(undefined, [format].concat(args));
          }
        };
      })();
    }
    module.exports = warning;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('10b', ['75', '96', '7f', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var DOMProperty = $__require('75');
    var ReactComponentTreeHook = $__require('96');
    var warning = $__require('7f');
    var warnedProperties = {};
    var rARIA = new RegExp('^(aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');
    function validateProperty(tagName, name, debugID) {
      if (warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
        return true;
      }
      if (rARIA.test(name)) {
        var lowerCasedName = name.toLowerCase();
        var standardName = DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;
        if (standardName == null) {
          warnedProperties[name] = true;
          return false;
        }
        if (name !== standardName) {
          'production' !== 'production' ? warning(false, 'Unknown ARIA attribute %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
          warnedProperties[name] = true;
          return true;
        }
      }
      return true;
    }
    function warnInvalidARIAProps(debugID, element) {
      var invalidProps = [];
      for (var key in element.props) {
        var isValid = validateProperty(element.type, key, debugID);
        if (!isValid) {
          invalidProps.push(key);
        }
      }
      var unknownPropString = invalidProps.map(function (prop) {
        return '`' + prop + '`';
      }).join(', ');
      if (invalidProps.length === 1) {
        'production' !== 'production' ? warning(false, 'Invalid aria prop %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
      } else if (invalidProps.length > 1) {
        'production' !== 'production' ? warning(false, 'Invalid aria props %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
      }
    }
    function handleElement(debugID, element) {
      if (element == null || typeof element.type !== 'string') {
        return;
      }
      if (element.type.indexOf('-') >= 0 || element.props.is) {
        return;
      }
      warnInvalidARIAProps(debugID, element);
    }
    var ReactDOMInvalidARIAHook = {
      onBeforeMountComponent: function (debugID, element) {
        if ('production' !== 'production') {
          handleElement(debugID, element);
        }
      },
      onBeforeUpdateComponent: function (debugID, element) {
        if ('production' !== 'production') {
          handleElement(debugID, element);
        }
      }
    };
    module.exports = ReactDOMInvalidARIAHook;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('10c', ['6c', 'd8', '102', '91', '6d', 'd9', 'da', 'db', '103', '7f', '69', '84', '109', '10a', '10b', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var ReactDOMComponentTree = $__require('6c');
    var ReactDefaultInjection = $__require('d8');
    var ReactMount = $__require('102');
    var ReactReconciler = $__require('91');
    var ReactUpdates = $__require('6d');
    var ReactVersion = $__require('d9');
    var findDOMNode = $__require('da');
    var getHostComponentFromComposite = $__require('db');
    var renderSubtreeIntoContainer = $__require('103');
    var warning = $__require('7f');
    ReactDefaultInjection.inject();
    var ReactDOM = {
      findDOMNode: findDOMNode,
      render: ReactMount.render,
      unmountComponentAtNode: ReactMount.unmountComponentAtNode,
      version: ReactVersion,
      unstable_batchedUpdates: ReactUpdates.batchedUpdates,
      unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
    };
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
        ComponentTree: {
          getClosestInstanceFromNode: ReactDOMComponentTree.getClosestInstanceFromNode,
          getNodeFromInstance: function (inst) {
            if (inst._renderedComponent) {
              inst = getHostComponentFromComposite(inst);
            }
            if (inst) {
              return ReactDOMComponentTree.getNodeFromInstance(inst);
            } else {
              return null;
            }
          }
        },
        Mount: ReactMount,
        Reconciler: ReactReconciler
      });
    }
    if ('production' !== 'production') {
      var ExecutionEnvironment = $__require('69');
      if (ExecutionEnvironment.canUseDOM && window.top === window.self) {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
          if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
            var showFileUrlMessage = window.location.protocol.indexOf('http') === -1 && navigator.userAgent.indexOf('Firefox') === -1;
            console.debug('Download the React DevTools ' + (showFileUrlMessage ? 'and use an HTTP server (instead of a file: URL) ' : '') + 'for a better development experience: ' + 'https://fb.me/react-devtools');
          }
        }
        var testFunc = function testFn() {};
        'production' !== 'production' ? warning((testFunc.name || testFunc.toString()).indexOf('testFn') !== -1, 'It looks like you\'re using a minified copy of the development build ' + 'of React. When deploying React apps to production, make sure to use ' + 'the production build which skips development warnings and is faster. ' + 'See https://fb.me/react-minification for more details.') : void 0;
        var ieCompatibilityMode = document.documentMode && document.documentMode < 8;
        'production' !== 'production' ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : void 0;
        var expectedFeatures = [Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.trim];
        for (var i = 0; i < expectedFeatures.length; i++) {
          if (!expectedFeatures[i]) {
            'production' !== 'production' ? warning(false, 'One or more ES5 shims expected by React are not available: ' + 'https://fb.me/react-warning-polyfills') : void 0;
            break;
          }
        }
      }
    }
    if ('production' !== 'production') {
      var ReactInstrumentation = $__require('84');
      var ReactDOMUnknownPropertyHook = $__require('109');
      var ReactDOMNullInputValuePropHook = $__require('10a');
      var ReactDOMInvalidARIAHook = $__require('10b');
      ReactInstrumentation.debugTool.addHook(ReactDOMUnknownPropertyHook);
      ReactInstrumentation.debugTool.addHook(ReactDOMNullInputValuePropHook);
      ReactInstrumentation.debugTool.addHook(ReactDOMInvalidARIAHook);
    }
    module.exports = ReactDOM;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('10d', ['10c'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require('10c');
  return module.exports;
});
$__System.registerDynamic("10e", ["10d"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("10d");
  return module.exports;
});
$__System.registerDynamic('10f', ['110'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var utils = $__require('110');
  function InterceptorManager() {
    this.handlers = [];
  }
  InterceptorManager.prototype.use = function use(fulfilled, rejected) {
    this.handlers.push({
      fulfilled: fulfilled,
      rejected: rejected
    });
    return this.handlers.length - 1;
  };
  InterceptorManager.prototype.eject = function eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  };
  InterceptorManager.prototype.forEach = function forEach(fn) {
    utils.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  };
  module.exports = InterceptorManager;
  return module.exports;
});
$__System.registerDynamic('111', ['110'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var utils = $__require('110');
  module.exports = function transformData(data, headers, fns) {
    utils.forEach(fns, function transform(fn) {
      data = fn(data, headers);
    });
    return data;
  };
  return module.exports;
});
$__System.registerDynamic('112', ['110', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var utils = $__require('110');
    module.exports = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('113', ['114'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var createError = $__require('114');
  module.exports = function settle(resolve, reject, response) {
    var validateStatus = response.config.validateStatus;
    if (!response.status || !validateStatus || validateStatus(response.status)) {
      resolve(response);
    } else {
      reject(createError('Request failed with status code ' + response.status, response.config, null, response));
    }
  };
  return module.exports;
});
$__System.registerDynamic('115', ['110'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var utils = $__require('110');
  function encode(val) {
    return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
  }
  module.exports = function buildURL(url, params, paramsSerializer) {
    if (!params) {
      return url;
    }
    var serializedParams;
    if (paramsSerializer) {
      serializedParams = paramsSerializer(params);
    } else if (utils.isURLSearchParams(params)) {
      serializedParams = params.toString();
    } else {
      var parts = [];
      utils.forEach(params, function serialize(val, key) {
        if (val === null || typeof val === 'undefined') {
          return;
        }
        if (utils.isArray(val)) {
          key = key + '[]';
        }
        if (!utils.isArray(val)) {
          val = [val];
        }
        utils.forEach(val, function parseValue(v) {
          if (utils.isDate(v)) {
            v = v.toISOString();
          } else if (utils.isObject(v)) {
            v = JSON.stringify(v);
          }
          parts.push(encode(key) + '=' + encode(v));
        });
      });
      serializedParams = parts.join('&');
    }
    if (serializedParams) {
      url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
    }
    return url;
  };
  return module.exports;
});
$__System.registerDynamic('116', ['110'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var utils = $__require('110');
  module.exports = function parseHeaders(headers) {
    var parsed = {};
    var key;
    var val;
    var i;
    if (!headers) {
      return parsed;
    }
    utils.forEach(headers.split('\n'), function parser(line) {
      i = line.indexOf(':');
      key = utils.trim(line.substr(0, i)).toLowerCase();
      val = utils.trim(line.substr(i + 1));
      if (key) {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    });
    return parsed;
  };
  return module.exports;
});
$__System.registerDynamic('117', ['110'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var utils = $__require('110');
  module.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
    var msie = /(msie|trident)/i.test(navigator.userAgent);
    var urlParsingNode = document.createElement('a');
    var originURL;
    function resolveURL(url) {
      var href = url;
      if (msie) {
        urlParsingNode.setAttribute('href', href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute('href', href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin(requestURL) {
      var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }() : function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  }();
  return module.exports;
});
$__System.registerDynamic('118', [], true, function ($__require, exports, module) {
  /* */
  'use strict';

  /**
   * Update an Error with the specified config, error code, and response.
   *
   * @param {Error} error The error to update.
   * @param {Object} config The config.
   * @param {string} [code] The error code (for example, 'ECONNABORTED').
   @ @param {Object} [response] The response.
   * @returns {Error} The error.
   */

  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = function enhanceError(error, config, code, response) {
    error.config = config;
    if (code) {
      error.code = code;
    }
    error.response = response;
    return error;
  };
  return module.exports;
});
$__System.registerDynamic('114', ['118'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var enhanceError = $__require('118');
  module.exports = function createError(message, config, code, response) {
    var error = new Error(message);
    return enhanceError(error, config, code, response);
  };
  return module.exports;
});
$__System.registerDynamic('119', [], true, function ($__require, exports, module) {
  /* */
  'use strict';

  // btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js

  var define,
      global = this || self,
      GLOBAL = global;
  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

  function E() {
    this.message = 'String contains an invalid character';
  }
  E.prototype = new Error();
  E.prototype.code = 5;
  E.prototype.name = 'InvalidCharacterError';

  function btoa(input) {
    var str = String(input);
    var output = '';
    for (
    // initialize result and counter
    var block, charCode, idx = 0, map = chars;
    // if the next str index does not exist:
    //   change the mapping table to "="
    //   check if d has no fractional digits
    str.charAt(idx | 0) || (map = '=', idx % 1);
    // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
    output += map.charAt(63 & block >> 8 - idx % 1 * 8)) {
      charCode = str.charCodeAt(idx += 3 / 4);
      if (charCode > 0xFF) {
        throw new E();
      }
      block = block << 8 | charCode;
    }
    return output;
  }

  module.exports = btoa;
  return module.exports;
});
$__System.registerDynamic('11a', [], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = function bind(fn, thisArg) {
    return function wrap() {
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      return fn.apply(thisArg, args);
    };
  };
  return module.exports;
});
$__System.registerDynamic('110', ['11a'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var bind = $__require('11a');
  var toString = Object.prototype.toString;
  function isArray(val) {
    return toString.call(val) === '[object Array]';
  }
  function isArrayBuffer(val) {
    return toString.call(val) === '[object ArrayBuffer]';
  }
  function isFormData(val) {
    return typeof FormData !== 'undefined' && val instanceof FormData;
  }
  function isArrayBufferView(val) {
    var result;
    if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
      result = ArrayBuffer.isView(val);
    } else {
      result = val && val.buffer && val.buffer instanceof ArrayBuffer;
    }
    return result;
  }
  function isString(val) {
    return typeof val === 'string';
  }
  function isNumber(val) {
    return typeof val === 'number';
  }
  function isUndefined(val) {
    return typeof val === 'undefined';
  }
  function isObject(val) {
    return val !== null && typeof val === 'object';
  }
  function isDate(val) {
    return toString.call(val) === '[object Date]';
  }
  function isFile(val) {
    return toString.call(val) === '[object File]';
  }
  function isBlob(val) {
    return toString.call(val) === '[object Blob]';
  }
  function isFunction(val) {
    return toString.call(val) === '[object Function]';
  }
  function isStream(val) {
    return isObject(val) && isFunction(val.pipe);
  }
  function isURLSearchParams(val) {
    return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
  }
  function trim(str) {
    return str.replace(/^\s*/, '').replace(/\s*$/, '');
  }
  function isStandardBrowserEnv() {
    return typeof window !== 'undefined' && typeof document !== 'undefined' && typeof document.createElement === 'function';
  }
  function forEach(obj, fn) {
    if (obj === null || typeof obj === 'undefined') {
      return;
    }
    if (typeof obj !== 'object' && !isArray(obj)) {
      obj = [obj];
    }
    if (isArray(obj)) {
      for (var i = 0, l = obj.length; i < l; i++) {
        fn.call(null, obj[i], i, obj);
      }
    } else {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          fn.call(null, obj[key], key, obj);
        }
      }
    }
  }
  function merge() {
    var result = {};
    function assignValue(val, key) {
      if (typeof result[key] === 'object' && typeof val === 'object') {
        result[key] = merge(result[key], val);
      } else {
        result[key] = val;
      }
    }
    for (var i = 0, l = arguments.length; i < l; i++) {
      forEach(arguments[i], assignValue);
    }
    return result;
  }
  function extend(a, b, thisArg) {
    forEach(b, function assignValue(val, key) {
      if (thisArg && typeof val === 'function') {
        a[key] = bind(val, thisArg);
      } else {
        a[key] = val;
      }
    });
    return a;
  }
  module.exports = {
    isArray: isArray,
    isArrayBuffer: isArrayBuffer,
    isFormData: isFormData,
    isArrayBufferView: isArrayBufferView,
    isString: isString,
    isNumber: isNumber,
    isObject: isObject,
    isUndefined: isUndefined,
    isDate: isDate,
    isFile: isFile,
    isBlob: isBlob,
    isFunction: isFunction,
    isStream: isStream,
    isURLSearchParams: isURLSearchParams,
    isStandardBrowserEnv: isStandardBrowserEnv,
    forEach: forEach,
    merge: merge,
    extend: extend,
    trim: trim
  };
  return module.exports;
});
$__System.registerDynamic('11b', ['110'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var utils = $__require('110');
  module.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
    return {
      write: function write(name, value, expires, path, domain, secure) {
        var cookie = [];
        cookie.push(name + '=' + encodeURIComponent(value));
        if (utils.isNumber(expires)) {
          cookie.push('expires=' + new Date(expires).toGMTString());
        }
        if (utils.isString(path)) {
          cookie.push('path=' + path);
        }
        if (utils.isString(domain)) {
          cookie.push('domain=' + domain);
        }
        if (secure === true) {
          cookie.push('secure');
        }
        document.cookie = cookie.join('; ');
      },
      read: function read(name) {
        var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
        return match ? decodeURIComponent(match[3]) : null;
      },
      remove: function remove(name) {
        this.write(name, '', Date.now() - 86400000);
      }
    };
  }() : function nonStandardBrowserEnv() {
    return {
      write: function write() {},
      read: function read() {
        return null;
      },
      remove: function remove() {}
    };
  }();
  return module.exports;
});
$__System.registerDynamic('11c', ['110', '113', '115', '116', '117', '114', '119', '11b', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var utils = $__require('110');
    var settle = $__require('113');
    var buildURL = $__require('115');
    var parseHeaders = $__require('116');
    var isURLSameOrigin = $__require('117');
    var createError = $__require('114');
    var btoa = typeof window !== 'undefined' && window.btoa || $__require('119');
    module.exports = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;
        if (utils.isFormData(requestData)) {
          delete requestHeaders['Content-Type'];
        }
        var request = new XMLHttpRequest();
        var loadEvent = 'onreadystatechange';
        var xDomain = false;
        if ('production' !== 'test' && typeof window !== 'undefined' && window.XDomainRequest && !('withCredentials' in request) && !isURLSameOrigin(config.url)) {
          request = new window.XDomainRequest();
          loadEvent = 'onload';
          xDomain = true;
          request.onprogress = function handleProgress() {};
          request.ontimeout = function handleTimeout() {};
        }
        if (config.auth) {
          var username = config.auth.username || '';
          var password = config.auth.password || '';
          requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
        }
        request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);
        request.timeout = config.timeout;
        request[loadEvent] = function handleLoad() {
          if (!request || request.readyState !== 4 && !xDomain) {
            return;
          }
          if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
            return;
          }
          var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status === 1223 ? 204 : request.status,
            statusText: request.status === 1223 ? 'No Content' : request.statusText,
            headers: responseHeaders,
            config: config,
            request: request
          };
          settle(resolve, reject, response);
          request = null;
        };
        request.onerror = function handleError() {
          reject(createError('Network Error', config));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED'));
          request = null;
        };
        if (utils.isStandardBrowserEnv()) {
          var cookies = $__require('11b');
          var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined;
          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }
        if ('setRequestHeader' in request) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
              delete requestHeaders[key];
            } else {
              request.setRequestHeader(key, val);
            }
          });
        }
        if (config.withCredentials) {
          request.withCredentials = true;
        }
        if (config.responseType) {
          try {
            request.responseType = config.responseType;
          } catch (e) {
            if (request.responseType !== 'json') {
              throw e;
            }
          }
        }
        if (typeof config.onDownloadProgress === 'function') {
          request.addEventListener('progress', config.onDownloadProgress);
        }
        if (typeof config.onUploadProgress === 'function' && request.upload) {
          request.upload.addEventListener('progress', config.onUploadProgress);
        }
        if (config.cancelToken) {
          config.cancelToken.promise.then(function onCanceled(cancel) {
            if (!request) {
              return;
            }
            request.abort();
            reject(cancel);
            request = null;
          });
        }
        if (requestData === undefined) {
          requestData = null;
        }
        request.send(requestData);
      });
    };
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('11d', ['110', '112', '11c', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var utils = $__require('110');
    var normalizeHeaderName = $__require('112');
    var PROTECTION_PREFIX = /^\)\]\}',?\n/;
    var DEFAULT_CONTENT_TYPE = { 'Content-Type': 'application/x-www-form-urlencoded' };
    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
        headers['Content-Type'] = value;
      }
    }
    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== 'undefined') {
        adapter = $__require('11c');
      } else if (typeof process !== 'undefined') {
        adapter = $__require('11c');
      }
      return adapter;
    }
    module.exports = {
      adapter: getDefaultAdapter(),
      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, 'Content-Type');
        if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
          return data.toString();
        }
        if (utils.isObject(data)) {
          setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
          return JSON.stringify(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        if (typeof data === 'string') {
          data = data.replace(PROTECTION_PREFIX, '');
          try {
            data = JSON.parse(data);
          } catch (e) {}
        }
        return data;
      }],
      headers: {
        common: { 'Accept': 'application/json, text/plain, */*' },
        patch: utils.merge(DEFAULT_CONTENT_TYPE),
        post: utils.merge(DEFAULT_CONTENT_TYPE),
        put: utils.merge(DEFAULT_CONTENT_TYPE)
      },
      timeout: 0,
      xsrfCookieName: 'XSRF-TOKEN',
      xsrfHeaderName: 'X-XSRF-TOKEN',
      maxContentLength: -1,
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      }
    };
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('11e', ['110', '111', '11f', '11d'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var utils = $__require('110');
  var transformData = $__require('111');
  var isCancel = $__require('11f');
  var defaults = $__require('11d');
  function throwIfCancellationRequested(config) {
    if (config.cancelToken) {
      config.cancelToken.throwIfRequested();
    }
  }
  module.exports = function dispatchRequest(config) {
    throwIfCancellationRequested(config);
    config.headers = config.headers || {};
    config.data = transformData(config.data, config.headers, config.transformRequest);
    config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers || {});
    utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) {
      delete config.headers[method];
    });
    var adapter = config.adapter || defaults.adapter;
    return adapter(config).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config);
      response.data = transformData(response.data, response.headers, config.transformResponse);
      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel(reason)) {
        throwIfCancellationRequested(config);
        if (reason && reason.response) {
          reason.response.data = transformData(reason.response.data, reason.response.headers, config.transformResponse);
        }
      }
      return Promise.reject(reason);
    });
  };
  return module.exports;
});
$__System.registerDynamic('120', [], true, function ($__require, exports, module) {
  /* */
  'use strict';

  /**
   * Determines whether the specified URL is absolute
   *
   * @param {string} url The URL to test
   * @returns {boolean} True if the specified URL is absolute, otherwise false
   */

  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = function isAbsoluteURL(url) {
    // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
    // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
    // by any combination of letters, digits, plus, period, or hyphen.
    return (/^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url)
    );
  };
  return module.exports;
});
$__System.registerDynamic('121', [], true, function ($__require, exports, module) {
  /* */
  'use strict';

  /**
   * Creates a new URL by combining the specified URLs
   *
   * @param {string} baseURL The base URL
   * @param {string} relativeURL The relative URL
   * @returns {string} The combined URL
   */

  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = function combineURLs(baseURL, relativeURL) {
    return baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '');
  };
  return module.exports;
});
$__System.registerDynamic('122', ['11d', '110', '10f', '11e', '120', '121'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var defaults = $__require('11d');
  var utils = $__require('110');
  var InterceptorManager = $__require('10f');
  var dispatchRequest = $__require('11e');
  var isAbsoluteURL = $__require('120');
  var combineURLs = $__require('121');
  function Axios(defaultConfig) {
    this.defaults = utils.merge(defaults, defaultConfig);
    this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }
  Axios.prototype.request = function request(config) {
    if (typeof config === 'string') {
      config = utils.merge({ url: arguments[0] }, arguments[1]);
    }
    config = utils.merge(defaults, this.defaults, { method: 'get' }, config);
    if (config.baseURL && !isAbsoluteURL(config.url)) {
      config.url = combineURLs(config.baseURL, config.url);
    }
    var chain = [dispatchRequest, undefined];
    var promise = Promise.resolve(config);
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      chain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      chain.push(interceptor.fulfilled, interceptor.rejected);
    });
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }
    return promise;
  };
  utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
    Axios.prototype[method] = function (url, config) {
      return this.request(utils.merge(config || {}, {
        method: method,
        url: url
      }));
    };
  });
  utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
    Axios.prototype[method] = function (url, data, config) {
      return this.request(utils.merge(config || {}, {
        method: method,
        url: url,
        data: data
      }));
    };
  });
  module.exports = Axios;
  return module.exports;
});
$__System.registerDynamic('123', [], true, function ($__require, exports, module) {
  /* */
  'use strict';

  /**
   * A `Cancel` is an object that is thrown when an operation is canceled.
   *
   * @class
   * @param {string=} message The message.
   */

  var define,
      global = this || self,
      GLOBAL = global;
  function Cancel(message) {
    this.message = message;
  }

  Cancel.prototype.toString = function toString() {
    return 'Cancel' + (this.message ? ': ' + this.message : '');
  };

  Cancel.prototype.__CANCEL__ = true;

  module.exports = Cancel;
  return module.exports;
});
$__System.registerDynamic('124', ['123'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var Cancel = $__require('123');
  function CancelToken(executor) {
    if (typeof executor !== 'function') {
      throw new TypeError('executor must be a function.');
    }
    var resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    var token = this;
    executor(function cancel(message) {
      if (token.reason) {
        return;
      }
      token.reason = new Cancel(message);
      resolvePromise(token.reason);
    });
  }
  CancelToken.prototype.throwIfRequested = function throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  };
  CancelToken.source = function source() {
    var cancel;
    var token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token: token,
      cancel: cancel
    };
  };
  module.exports = CancelToken;
  return module.exports;
});
$__System.registerDynamic('11f', [], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = function isCancel(value) {
    return !!(value && value.__CANCEL__);
  };
  return module.exports;
});
$__System.registerDynamic('125', [], true, function ($__require, exports, module) {
  /* */
  'use strict';

  /**
   * Syntactic sugar for invoking a function and expanding an array for arguments.
   *
   * Common use case would be to use `Function.prototype.apply`.
   *
   *  ```js
   *  function f(x, y, z) {}
   *  var args = [1, 2, 3];
   *  f.apply(null, args);
   *  ```
   *
   * With `spread` this example can be re-written.
   *
   *  ```js
   *  spread(function(x, y, z) {})([1, 2, 3]);
   *  ```
   *
   * @param {Function} callback
   * @returns {Function}
   */

  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = function spread(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  };
  return module.exports;
});
$__System.registerDynamic('126', ['110', '11a', '122', '123', '124', '11f', '125'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var utils = $__require('110');
  var bind = $__require('11a');
  var Axios = $__require('122');
  function createInstance(defaultConfig) {
    var context = new Axios(defaultConfig);
    var instance = bind(Axios.prototype.request, context);
    utils.extend(instance, Axios.prototype, context);
    utils.extend(instance, context);
    return instance;
  }
  var axios = createInstance();
  axios.Axios = Axios;
  axios.create = function create(defaultConfig) {
    return createInstance(defaultConfig);
  };
  axios.Cancel = $__require('123');
  axios.CancelToken = $__require('124');
  axios.isCancel = $__require('11f');
  axios.all = function all(promises) {
    return Promise.all(promises);
  };
  axios.spread = $__require('125');
  module.exports = axios;
  module.exports.default = axios;
  return module.exports;
});
$__System.registerDynamic('127', ['126'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  module.exports = $__require('126');
  return module.exports;
});
$__System.registerDynamic("128", ["127"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("127");
  return module.exports;
});
$__System.registerDynamic('129', ['12b', '32', '12c', '8', '12a', '27'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var bytes = $__require('12b');
  var contentType = $__require('32');
  var createError = $__require('12c');
  var debug = $__require('8')('body-parser:json');
  var read = $__require('12a');
  var typeis = $__require('27');
  module.exports = json;
  var FIRST_CHAR_REGEXP = /^[\x20\x09\x0a\x0d]*(.)/;
  function json(options) {
    var opts = options || {};
    var limit = typeof opts.limit !== 'number' ? bytes.parse(opts.limit || '100kb') : opts.limit;
    var inflate = opts.inflate !== false;
    var reviver = opts.reviver;
    var strict = opts.strict !== false;
    var type = opts.type || 'application/json';
    var verify = opts.verify || false;
    if (verify !== false && typeof verify !== 'function') {
      throw new TypeError('option verify must be function');
    }
    var shouldParse = typeof type !== 'function' ? typeChecker(type) : type;
    function parse(body) {
      if (body.length === 0) {
        return {};
      }
      if (strict) {
        var first = firstchar(body);
        if (first !== '{' && first !== '[') {
          debug('strict violation');
          throw new SyntaxError('Unexpected token ' + first);
        }
      }
      debug('parse json');
      return JSON.parse(body, reviver);
    }
    return function jsonParser(req, res, next) {
      if (req._body) {
        debug('body already parsed');
        next();
        return;
      }
      req.body = req.body || {};
      if (!typeis.hasBody(req)) {
        debug('skip empty body');
        next();
        return;
      }
      debug('content-type %j', req.headers['content-type']);
      if (!shouldParse(req)) {
        debug('skip parsing');
        next();
        return;
      }
      var charset = getCharset(req) || 'utf-8';
      if (charset.substr(0, 4) !== 'utf-') {
        debug('invalid charset');
        next(createError(415, 'unsupported charset "' + charset.toUpperCase() + '"', { charset: charset }));
        return;
      }
      read(req, res, next, parse, debug, {
        encoding: charset,
        inflate: inflate,
        limit: limit,
        verify: verify
      });
    };
  }
  function firstchar(str) {
    var match = FIRST_CHAR_REGEXP.exec(str);
    return match ? match[1] : '';
  }
  function getCharset(req) {
    try {
      return contentType.parse(req).parameters.charset.toLowerCase();
    } catch (e) {
      return undefined;
    }
  }
  function typeChecker(type) {
    return function checkType(req) {
      return Boolean(typeis(req, type));
    };
  }
  return module.exports;
});
$__System.registerDynamic('12d', ['12b', '8', '12a', '27'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var bytes = $__require('12b');
  var debug = $__require('8')('body-parser:raw');
  var read = $__require('12a');
  var typeis = $__require('27');
  module.exports = raw;
  function raw(options) {
    var opts = options || {};
    var inflate = opts.inflate !== false;
    var limit = typeof opts.limit !== 'number' ? bytes.parse(opts.limit || '100kb') : opts.limit;
    var type = opts.type || 'application/octet-stream';
    var verify = opts.verify || false;
    if (verify !== false && typeof verify !== 'function') {
      throw new TypeError('option verify must be function');
    }
    var shouldParse = typeof type !== 'function' ? typeChecker(type) : type;
    function parse(buf) {
      return buf;
    }
    return function rawParser(req, res, next) {
      if (req._body) {
        debug('body already parsed');
        next();
        return;
      }
      req.body = req.body || {};
      if (!typeis.hasBody(req)) {
        debug('skip empty body');
        next();
        return;
      }
      debug('content-type %j', req.headers['content-type']);
      if (!shouldParse(req)) {
        debug('skip parsing');
        next();
        return;
      }
      read(req, res, next, parse, debug, {
        encoding: null,
        inflate: inflate,
        limit: limit,
        verify: verify
      });
    };
  }
  function typeChecker(type) {
    return function checkType(req) {
      return Boolean(typeis(req, type));
    };
  }
  return module.exports;
});
$__System.registerDynamic('12e', ['12b', '32', '8', '12a', '27'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var bytes = $__require('12b');
  var contentType = $__require('32');
  var debug = $__require('8')('body-parser:text');
  var read = $__require('12a');
  var typeis = $__require('27');
  module.exports = text;
  function text(options) {
    var opts = options || {};
    var defaultCharset = opts.defaultCharset || 'utf-8';
    var inflate = opts.inflate !== false;
    var limit = typeof opts.limit !== 'number' ? bytes.parse(opts.limit || '100kb') : opts.limit;
    var type = opts.type || 'text/plain';
    var verify = opts.verify || false;
    if (verify !== false && typeof verify !== 'function') {
      throw new TypeError('option verify must be function');
    }
    var shouldParse = typeof type !== 'function' ? typeChecker(type) : type;
    function parse(buf) {
      return buf;
    }
    return function textParser(req, res, next) {
      if (req._body) {
        debug('body already parsed');
        next();
        return;
      }
      req.body = req.body || {};
      if (!typeis.hasBody(req)) {
        debug('skip empty body');
        next();
        return;
      }
      debug('content-type %j', req.headers['content-type']);
      if (!shouldParse(req)) {
        debug('skip parsing');
        next();
        return;
      }
      var charset = getCharset(req) || defaultCharset;
      read(req, res, next, parse, debug, {
        encoding: charset,
        inflate: inflate,
        limit: limit,
        verify: verify
      });
    };
  }
  function getCharset(req) {
    try {
      return contentType.parse(req).parameters.charset.toLowerCase();
    } catch (e) {
      return undefined;
    }
  }
  function typeChecker(type) {
    return function checkType(req) {
      return Boolean(typeis(req, type));
    };
  }
  return module.exports;
});
$__System.registerDynamic('12f', [], true, function ($__require, exports, module) {
  /*!
   * content-type
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */

  'use strict';

  /**
   * RegExp to match *( ";" parameter ) in RFC 7231 sec 3.1.1.1
   *
   * parameter     = token "=" ( token / quoted-string )
   * token         = 1*tchar
   * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
   *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
   *               / DIGIT / ALPHA
   *               ; any VCHAR, except delimiters
   * quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE
   * qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text
   * obs-text      = %x80-FF
   * quoted-pair   = "\" ( HTAB / SP / VCHAR / obs-text )
   */

  var define,
      global = this || self,
      GLOBAL = global;
  var paramRegExp = /; *([!#$%&'\*\+\-\.\^_`\|~0-9A-Za-z]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'\*\+\-\.\^_`\|~0-9A-Za-z]+) */g;
  var textRegExp = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/;
  var tokenRegExp = /^[!#$%&'\*\+\-\.\^_`\|~0-9A-Za-z]+$/;

  /**
   * RegExp to match quoted-pair in RFC 7230 sec 3.2.6
   *
   * quoted-pair = "\" ( HTAB / SP / VCHAR / obs-text )
   * obs-text    = %x80-FF
   */
  var qescRegExp = /\\([\u000b\u0020-\u00ff])/g;

  /**
   * RegExp to match chars that must be quoted-pair in RFC 7230 sec 3.2.6
   */
  var quoteRegExp = /([\\"])/g;

  /**
   * RegExp to match type in RFC 6838
   *
   * media-type = type "/" subtype
   * type       = token
   * subtype    = token
   */
  var typeRegExp = /^[!#$%&'\*\+\-\.\^_`\|~0-9A-Za-z]+\/[!#$%&'\*\+\-\.\^_`\|~0-9A-Za-z]+$/;

  /**
   * Module exports.
   * @public
   */

  exports.format = format;
  exports.parse = parse;

  /**
   * Format object to media type.
   *
   * @param {object} obj
   * @return {string}
   * @public
   */

  function format(obj) {
    if (!obj || typeof obj !== 'object') {
      throw new TypeError('argument obj is required');
    }

    var parameters = obj.parameters;
    var type = obj.type;

    if (!type || !typeRegExp.test(type)) {
      throw new TypeError('invalid type');
    }

    var string = type;

    // append parameters
    if (parameters && typeof parameters === 'object') {
      var param;
      var params = Object.keys(parameters).sort();

      for (var i = 0; i < params.length; i++) {
        param = params[i];

        if (!tokenRegExp.test(param)) {
          throw new TypeError('invalid parameter name');
        }

        string += '; ' + param + '=' + qstring(parameters[param]);
      }
    }

    return string;
  }

  /**
   * Parse media type to object.
   *
   * @param {string|object} string
   * @return {Object}
   * @public
   */

  function parse(string) {
    if (!string) {
      throw new TypeError('argument string is required');
    }

    if (typeof string === 'object') {
      // support req/res-like objects as argument
      string = getcontenttype(string);

      if (typeof string !== 'string') {
        throw new TypeError('content-type header is missing from object');
      }
    }

    if (typeof string !== 'string') {
      throw new TypeError('argument string is required to be a string');
    }

    var index = string.indexOf(';');
    var type = index !== -1 ? string.substr(0, index).trim() : string.trim();

    if (!typeRegExp.test(type)) {
      throw new TypeError('invalid media type');
    }

    var key;
    var match;
    var obj = new ContentType(type.toLowerCase());
    var value;

    paramRegExp.lastIndex = index;

    while (match = paramRegExp.exec(string)) {
      if (match.index !== index) {
        throw new TypeError('invalid parameter format');
      }

      index += match[0].length;
      key = match[1].toLowerCase();
      value = match[2];

      if (value[0] === '"') {
        // remove quotes and escapes
        value = value.substr(1, value.length - 2).replace(qescRegExp, '$1');
      }

      obj.parameters[key] = value;
    }

    if (index !== -1 && index !== string.length) {
      throw new TypeError('invalid parameter format');
    }

    return obj;
  }

  /**
   * Get content-type from req/res objects.
   *
   * @param {object}
   * @return {Object}
   * @private
   */

  function getcontenttype(obj) {
    if (typeof obj.getHeader === 'function') {
      // res-like
      return obj.getHeader('content-type');
    }

    if (typeof obj.headers === 'object') {
      // req-like
      return obj.headers && obj.headers['content-type'];
    }
  }

  /**
   * Quote a string if necessary.
   *
   * @param {string} val
   * @return {string}
   * @private
   */

  function qstring(val) {
    var str = String(val);

    // no need to quote tokens
    if (tokenRegExp.test(str)) {
      return str;
    }

    if (str.length > 0 && !textRegExp.test(str)) {
      throw new TypeError('invalid parameter value');
    }

    return '"' + str.replace(quoteRegExp, '\\$1') + '"';
  }

  /**
   * Class to represent a content type.
   * @private
   */
  function ContentType(type) {
    this.parameters = Object.create(null);
    this.type = type;
  }
  return module.exports;
});
$__System.registerDynamic("32", ["12f"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("12f");
  return module.exports;
});
$__System.registerDynamic('130', [], true, function ($__require, exports, module) {
  /*!
   * depd
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */

  'use strict';

  /**
   * Module exports.
   * @public
   */

  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = depd;

  /**
   * Create deprecate for namespace in caller.
   */

  function depd(namespace) {
    if (!namespace) {
      throw new TypeError('argument namespace is required');
    }

    function deprecate(message) {
      // no-op in browser
    }

    deprecate._file = undefined;
    deprecate._ignored = true;
    deprecate._namespace = namespace;
    deprecate._traced = false;
    deprecate._warned = Object.create(null);

    deprecate.function = wrapfunction;
    deprecate.property = wrapproperty;

    return deprecate;
  }

  /**
   * Return a wrapped function in a deprecation message.
   *
   * This is a no-op version of the wrapper, which does nothing but call
   * validation.
   */

  function wrapfunction(fn, message) {
    if (typeof fn !== 'function') {
      throw new TypeError('argument fn must be a function');
    }

    return fn;
  }

  /**
   * Wrap property in a deprecation message.
   *
   * This is a no-op version of the wrapper, which does nothing but call
   * validation.
   */

  function wrapproperty(obj, prop, message) {
    if (!obj || typeof obj !== 'object' && typeof obj !== 'function') {
      throw new TypeError('argument obj must be object');
    }

    var descriptor = Object.getOwnPropertyDescriptor(obj, prop);

    if (!descriptor) {
      throw new TypeError('must call property on owner object');
    }

    if (!descriptor.configurable) {
      throw new TypeError('property must be configurable');
    }

    return;
  }
  return module.exports;
});
$__System.registerDynamic("12", ["130"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("130");
  return module.exports;
});
$__System.registerDynamic("131", [], true, function ($__require, exports, module) {
	var define,
	    global = this || self,
	    GLOBAL = global;
	/* */
	module.exports = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);

	function setProtoOf(obj, proto) {
		obj.__proto__ = proto;
		return obj;
	}

	function mixinProperties(obj, proto) {
		for (var prop in proto) {
			obj[prop] = proto[prop];
		}
		return obj;
	}
	return module.exports;
});
$__System.registerDynamic("132", ["131"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("131");
  return module.exports;
});
$__System.registerDynamic("133", [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = { "100": "Continue", "101": "Switching Protocols", "102": "Processing", "200": "OK", "201": "Created", "202": "Accepted", "203": "Non-Authoritative Information", "204": "No Content", "205": "Reset Content", "206": "Partial Content", "207": "Multi-Status", "208": "Already Reported", "226": "IM Used", "300": "Multiple Choices", "301": "Moved Permanently", "302": "Found", "303": "See Other", "304": "Not Modified", "305": "Use Proxy", "306": "(Unused)", "307": "Temporary Redirect", "308": "Permanent Redirect", "400": "Bad Request", "401": "Unauthorized", "402": "Payment Required", "403": "Forbidden", "404": "Not Found", "405": "Method Not Allowed", "406": "Not Acceptable", "407": "Proxy Authentication Required", "408": "Request Timeout", "409": "Conflict", "410": "Gone", "411": "Length Required", "412": "Precondition Failed", "413": "Payload Too Large", "414": "URI Too Long", "415": "Unsupported Media Type", "416": "Range Not Satisfiable", "417": "Expectation Failed", "418": "I'm a teapot", "421": "Misdirected Request", "422": "Unprocessable Entity", "423": "Locked", "424": "Failed Dependency", "425": "Unordered Collection", "426": "Upgrade Required", "428": "Precondition Required", "429": "Too Many Requests", "431": "Request Header Fields Too Large", "451": "Unavailable For Legal Reasons", "500": "Internal Server Error", "501": "Not Implemented", "502": "Bad Gateway", "503": "Service Unavailable", "504": "Gateway Timeout", "505": "HTTP Version Not Supported", "506": "Variant Also Negotiates", "507": "Insufficient Storage", "508": "Loop Detected", "509": "Bandwidth Limit Exceeded", "510": "Not Extended", "511": "Network Authentication Required" };
  return module.exports;
});
$__System.registerDynamic('134', ['133'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var codes = $__require('133');
  module.exports = status;
  status.codes = populateStatusesMap(status, codes);
  status.redirect = {
    300: true,
    301: true,
    302: true,
    303: true,
    305: true,
    307: true,
    308: true
  };
  status.empty = {
    204: true,
    205: true,
    304: true
  };
  status.retry = {
    502: true,
    503: true,
    504: true
  };
  function populateStatusesMap(statuses, codes) {
    var arr = [];
    Object.keys(codes).forEach(function forEachCode(code) {
      var message = codes[code];
      var status = Number(code);
      statuses[status] = message;
      statuses[message] = status;
      statuses[message.toLowerCase()] = status;
      arr.push(status);
    });
    return arr;
  }
  function status(code) {
    if (typeof code === 'number') {
      if (!status[code]) throw new Error('invalid status code: ' + code);
      return code;
    }
    if (typeof code !== 'string') {
      throw new TypeError('code must be a number or string');
    }
    var n = parseInt(code, 10);
    if (!isNaN(n)) {
      if (!status[n]) throw new Error('invalid status code: ' + n);
      return n;
    }
    n = status[code.toLowerCase()];
    if (!n) throw new Error('invalid status message: "' + code + '"');
    return n;
  }
  return module.exports;
});
$__System.registerDynamic("135", ["134"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("134");
  return module.exports;
});
$__System.registerDynamic('136', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  if (typeof Object.create === 'function') {
    // implementation from standard node.js 'util' module
    module.exports = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    };
  } else {
    // old school shim for old browsers
    module.exports = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function () {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    };
  }
  return module.exports;
});
$__System.registerDynamic("137", ["136"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("136");
  return module.exports;
});
$__System.registerDynamic('138', ['132', '135', '137'], true, function ($__require, exports, module) {
  /*!
   * http-errors
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   */

  'use strict';

  /**
   * Module dependencies.
   * @private
   */

  var define,
      global = this || self,
      GLOBAL = global;
  var setPrototypeOf = $__require('132');
  var statuses = $__require('135');
  var inherits = $__require('137');

  /**
   * Module exports.
   * @public
   */

  module.exports = createError;
  module.exports.HttpError = createHttpErrorConstructor();

  // Populate exports for all constructors
  populateConstructorExports(module.exports, statuses.codes, module.exports.HttpError);

  /**
   * Create a new HTTP Error.
   *
   * @returns {Error}
   * @public
   */

  function createError() {
    // so much arity going on ~_~
    var err;
    var msg;
    var status = 500;
    var props = {};
    for (var i = 0; i < arguments.length; i++) {
      var arg = arguments[i];
      if (arg instanceof Error) {
        err = arg;
        status = err.status || err.statusCode || status;
        continue;
      }
      switch (typeof arg) {
        case 'string':
          msg = arg;
          break;
        case 'number':
          status = arg;
          break;
        case 'object':
          props = arg;
          break;
      }
    }

    if (typeof status !== 'number' || !statuses[status]) {
      status = 500;
    }

    // constructor
    var HttpError = createError[status];

    if (!err) {
      // create error
      err = HttpError ? new HttpError(msg) : new Error(msg || statuses[status]);
      Error.captureStackTrace(err, createError);
    }

    if (!HttpError || !(err instanceof HttpError)) {
      // add properties to generic error
      err.expose = status < 500;
      err.status = err.statusCode = status;
    }

    for (var key in props) {
      if (key !== 'status' && key !== 'statusCode') {
        err[key] = props[key];
      }
    }

    return err;
  }

  /**
   * Create HTTP error abstract base class.
   * @private
   */

  function createHttpErrorConstructor() {
    function HttpError() {
      throw new TypeError('cannot construct abstract class');
    }

    inherits(HttpError, Error);

    return HttpError;
  }

  /**
   * Create a constructor for a client error.
   * @private
   */

  function createClientErrorConstructor(HttpError, name, code) {
    var className = name.match(/Error$/) ? name : name + 'Error';

    function ClientError(message) {
      // create the error object
      var err = new Error(message != null ? message : statuses[code]);

      // capture a stack trace to the construction point
      Error.captureStackTrace(err, ClientError);

      // adjust the [[Prototype]]
      setPrototypeOf(err, ClientError.prototype);

      // redefine the error name
      Object.defineProperty(err, 'name', {
        enumerable: false,
        configurable: true,
        value: className,
        writable: true
      });

      return err;
    }

    inherits(ClientError, HttpError);

    ClientError.prototype.status = code;
    ClientError.prototype.statusCode = code;
    ClientError.prototype.expose = true;

    return ClientError;
  }

  /**
   * Create a constructor for a server error.
   * @private
   */

  function createServerErrorConstructor(HttpError, name, code) {
    var className = name.match(/Error$/) ? name : name + 'Error';

    function ServerError(message) {
      // create the error object
      var err = new Error(message != null ? message : statuses[code]);

      // capture a stack trace to the construction point
      Error.captureStackTrace(err, ServerError);

      // adjust the [[Prototype]]
      setPrototypeOf(err, ServerError.prototype);

      // redefine the error name
      Object.defineProperty(err, 'name', {
        enumerable: false,
        configurable: true,
        value: className,
        writable: true
      });

      return err;
    }

    inherits(ServerError, HttpError);

    ServerError.prototype.status = code;
    ServerError.prototype.statusCode = code;
    ServerError.prototype.expose = false;

    return ServerError;
  }

  /**
   * Populate the exports object with constructors for every error class.
   * @private
   */

  function populateConstructorExports(exports, codes, HttpError) {
    codes.forEach(function forEachCode(code) {
      var CodeError;
      var name = toIdentifier(statuses[code]);

      switch (String(code).charAt(0)) {
        case '4':
          CodeError = createClientErrorConstructor(HttpError, name, code);
          break;
        case '5':
          CodeError = createServerErrorConstructor(HttpError, name, code);
          break;
      }

      if (CodeError) {
        // export the constructor
        exports[code] = CodeError;
        exports[name] = CodeError;
      }
    });

    // backwards-compatibility
    exports["I'mateapot"] = exports.ImATeapot;
  }

  /**
   * Convert a string of words to a JavaScript identifier.
   * @private
   */

  function toIdentifier(str) {
    return str.split(' ').map(function (token) {
      return token.slice(0, 1).toUpperCase() + token.slice(1);
    }).join('').replace(/[^ _0-9a-z]/gi, '');
  }
  return module.exports;
});
$__System.registerDynamic("12c", ["138"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("138");
  return module.exports;
});
$__System.registerDynamic('139', [], true, function ($__require, exports, module) {
  /*!
   * bytes
   * Copyright(c) 2012-2014 TJ Holowaychuk
   * Copyright(c) 2015 Jed Watson
   * MIT Licensed
   */

  'use strict';

  /**
   * Module exports.
   * @public
   */

  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = bytes;
  module.exports.format = format;
  module.exports.parse = parse;

  /**
   * Module variables.
   * @private
   */

  var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;

  var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;

  var map = {
    b: 1,
    kb: 1 << 10,
    mb: 1 << 20,
    gb: 1 << 30,
    tb: (1 << 30) * 1024
  };

  // TODO: use is-finite module?
  var numberIsFinite = Number.isFinite || function (v) {
    return typeof v === 'number' && isFinite(v);
  };

  var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb)$/i;

  /**
   * Convert the given value in bytes into a string or parse to string to an integer in bytes.
   *
   * @param {string|number} value
   * @param {{
   *  case: [string],
   *  decimalPlaces: [number]
   *  fixedDecimals: [boolean]
   *  thousandsSeparator: [string]
   *  unitSeparator: [string]
   *  }} [options] bytes options.
   *
   * @returns {string|number|null}
   */

  function bytes(value, options) {
    if (typeof value === 'string') {
      return parse(value);
    }

    if (typeof value === 'number') {
      return format(value, options);
    }

    return null;
  }

  /**
   * Format the given value in bytes into a string.
   *
   * If the value is negative, it is kept as such. If it is a float,
   * it is rounded.
   *
   * @param {number} value
   * @param {object} [options]
   * @param {number} [options.decimalPlaces=2]
   * @param {number} [options.fixedDecimals=false]
   * @param {string} [options.thousandsSeparator=]
   * @param {string} [options.unitSeparator=]
   *
   * @returns {string|null}
   * @public
   */

  function format(value, options) {
    if (!numberIsFinite(value)) {
      return null;
    }

    var mag = Math.abs(value);
    var thousandsSeparator = options && options.thousandsSeparator || '';
    var unitSeparator = options && options.unitSeparator || '';
    var decimalPlaces = options && options.decimalPlaces !== undefined ? options.decimalPlaces : 2;
    var fixedDecimals = Boolean(options && options.fixedDecimals);
    var unit = 'B';

    if (mag >= map.tb) {
      unit = 'TB';
    } else if (mag >= map.gb) {
      unit = 'GB';
    } else if (mag >= map.mb) {
      unit = 'MB';
    } else if (mag >= map.kb) {
      unit = 'kB';
    }

    var val = value / map[unit.toLowerCase()];
    var str = val.toFixed(decimalPlaces);

    if (!fixedDecimals) {
      str = str.replace(formatDecimalsRegExp, '$1');
    }

    if (thousandsSeparator) {
      str = str.replace(formatThousandsRegExp, thousandsSeparator);
    }

    return str + unitSeparator + unit;
  }

  /**
   * Parse the string value into an integer in bytes.
   *
   * If no unit is given, it is assumed the value is in bytes.
   *
   * @param {number|string} val
   *
   * @returns {number|null}
   * @public
   */

  function parse(val) {
    if (typeof val === 'number' && !isNaN(val)) {
      return val;
    }

    if (typeof val !== 'string') {
      return null;
    }

    // Test if the string passed is valid
    var results = parseRegExp.exec(val);
    var floatValue;
    var unit = 'b';

    if (!results) {
      // Nothing could be extracted from the given string
      floatValue = parseInt(val, 10);
      unit = 'b';
    } else {
      // Retrieve the value and the unit
      floatValue = parseFloat(results[1]);
      unit = results[4].toLowerCase();
    }

    return Math.floor(map[unit] * floatValue);
  }
  return module.exports;
});
$__System.registerDynamic("12b", ["139"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("139");
  return module.exports;
});
$__System.registerDynamic('13a', ['12b', '13c', '13b', '2a', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer, process) {
    'use strict';

    var bytes = $__require('12b');
    var iconv = $__require('13c');
    var unpipe = $__require('13b');
    module.exports = getRawBody;
    var iconvEncodingMessageRegExp = /^Encoding not recognized: /;
    function getDecoder(encoding) {
      if (!encoding) return null;
      try {
        return iconv.getDecoder(encoding);
      } catch (e) {
        if (!iconvEncodingMessageRegExp.test(e.message)) throw e;
        throw createError(415, 'specified encoding unsupported', 'encoding.unsupported', { encoding: encoding });
      }
    }
    function getRawBody(stream, options, callback) {
      var done = callback;
      var opts = options || {};
      if (options === true || typeof options === 'string') {
        opts = { encoding: options };
      }
      if (typeof options === 'function') {
        done = options;
        opts = {};
      }
      if (done !== undefined && typeof done !== 'function') {
        throw new TypeError('argument callback must be a function');
      }
      if (!done && !global.Promise) {
        throw new TypeError('argument callback is required');
      }
      var encoding = opts.encoding !== true ? opts.encoding : 'utf-8';
      var limit = bytes.parse(opts.limit);
      var length = opts.length != null && !isNaN(opts.length) ? parseInt(opts.length, 10) : null;
      if (done) {
        return readStream(stream, encoding, length, limit, done);
      }
      return new Promise(function executor(resolve, reject) {
        readStream(stream, encoding, length, limit, function onRead(err, buf) {
          if (err) return reject(err);
          resolve(buf);
        });
      });
    }
    function halt(stream) {
      unpipe(stream);
      if (typeof stream.pause === 'function') {
        stream.pause();
      }
    }
    function createError(status, message, type, props) {
      var error = new Error();
      Error.captureStackTrace(error, createError);
      for (var prop in props) {
        error[prop] = props[prop];
      }
      error.message = message;
      error.status = status;
      error.statusCode = status;
      Object.defineProperty(error, 'type', {
        value: type,
        enumerable: true,
        writable: true,
        configurable: true
      });
      return error;
    }
    function readStream(stream, encoding, length, limit, callback) {
      var complete = false;
      var sync = true;
      if (limit !== null && length !== null && length > limit) {
        return done(createError(413, 'request entity too large', 'entity.too.large', {
          expected: length,
          length: length,
          limit: limit
        }));
      }
      var state = stream._readableState;
      if (stream._decoder || state && (state.encoding || state.decoder)) {
        return done(createError(500, 'stream encoding should not be set', 'stream.encoding.set'));
      }
      var received = 0;
      var decoder;
      try {
        decoder = getDecoder(encoding);
      } catch (err) {
        return done(err);
      }
      var buffer = decoder ? '' : [];
      stream.on('aborted', onAborted);
      stream.on('close', cleanup);
      stream.on('data', onData);
      stream.on('end', onEnd);
      stream.on('error', onEnd);
      sync = false;
      function done() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        complete = true;
        if (sync) {
          process.nextTick(invokeCallback);
        } else {
          invokeCallback();
        }
        function invokeCallback() {
          cleanup();
          if (args[0]) {
            halt(stream);
          }
          callback.apply(null, args);
        }
      }
      function onAborted() {
        if (complete) return;
        done(createError(400, 'request aborted', 'request.aborted', {
          code: 'ECONNABORTED',
          expected: length,
          length: length,
          received: received
        }));
      }
      function onData(chunk) {
        if (complete) return;
        received += chunk.length;
        decoder ? buffer += decoder.write(chunk) : buffer.push(chunk);
        if (limit !== null && received > limit) {
          done(createError(413, 'request entity too large', 'entity.too.large', {
            limit: limit,
            received: received
          }));
        }
      }
      function onEnd(err) {
        if (complete) return;
        if (err) return done(err);
        if (length !== null && received !== length) {
          done(createError(400, 'request size did not match content length', 'request.size.invalid', {
            expected: length,
            length: length,
            received: received
          }));
        } else {
          var string = decoder ? buffer + (decoder.end() || '') : Buffer.concat(buffer);
          done(null, string);
        }
      }
      function cleanup() {
        buffer = null;
        stream.removeListener('aborted', onAborted);
        stream.removeListener('data', onData);
        stream.removeListener('end', onEnd);
        stream.removeListener('error', onEnd);
        stream.removeListener('close', cleanup);
      }
    }
  })($__require('2a').Buffer, $__require('13'));
  return module.exports;
});
$__System.registerDynamic("13d", ["13a"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("13a");
  return module.exports;
});
$__System.registerDynamic('13e', [], true, function ($__require, exports, module) {
    /* */
    "use strict";

    var define,
        global = this || self,
        GLOBAL = global;
    var BOMChar = '\uFEFF';

    exports.PrependBOM = PrependBOMWrapper;
    function PrependBOMWrapper(encoder, options) {
        this.encoder = encoder;
        this.addBOM = true;
    }

    PrependBOMWrapper.prototype.write = function (str) {
        if (this.addBOM) {
            str = BOMChar + str;
            this.addBOM = false;
        }

        return this.encoder.write(str);
    };

    PrependBOMWrapper.prototype.end = function () {
        return this.encoder.end();
    };

    //------------------------------------------------------------------------------

    exports.StripBOM = StripBOMWrapper;
    function StripBOMWrapper(decoder, options) {
        this.decoder = decoder;
        this.pass = false;
        this.options = options || {};
    }

    StripBOMWrapper.prototype.write = function (buf) {
        var res = this.decoder.write(buf);
        if (this.pass || !res) return res;

        if (res[0] === BOMChar) {
            res = res.slice(1);
            if (typeof this.options.stripBOM === 'function') this.options.stripBOM();
        }

        this.pass = true;
        return res;
    };

    StripBOMWrapper.prototype.end = function () {
        return this.decoder.end();
    };
    return module.exports;
});
$__System.registerDynamic("13f", ["140", "2a"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    "use strict";

    module.exports = {
      utf8: {
        type: "_internal",
        bomAware: true
      },
      cesu8: {
        type: "_internal",
        bomAware: true
      },
      unicode11utf8: "utf8",
      ucs2: {
        type: "_internal",
        bomAware: true
      },
      utf16le: "ucs2",
      binary: { type: "_internal" },
      base64: { type: "_internal" },
      hex: { type: "_internal" },
      _internal: InternalCodec
    };
    function InternalCodec(codecOptions, iconv) {
      this.enc = codecOptions.encodingName;
      this.bomAware = codecOptions.bomAware;
      if (this.enc === "base64") this.encoder = InternalEncoderBase64;else if (this.enc === "cesu8") {
        this.enc = "utf8";
        this.encoder = InternalEncoderCesu8;
        if (new Buffer("eda080", 'hex').toString().length == 3) {
          this.decoder = InternalDecoderCesu8;
          this.defaultCharUnicode = iconv.defaultCharUnicode;
        }
      }
    }
    InternalCodec.prototype.encoder = InternalEncoder;
    InternalCodec.prototype.decoder = InternalDecoder;
    var StringDecoder = $__require("140").StringDecoder;
    if (!StringDecoder.prototype.end) StringDecoder.prototype.end = function () {};
    function InternalDecoder(options, codec) {
      StringDecoder.call(this, codec.enc);
    }
    InternalDecoder.prototype = StringDecoder.prototype;
    function InternalEncoder(options, codec) {
      this.enc = codec.enc;
    }
    InternalEncoder.prototype.write = function (str) {
      return new Buffer(str, this.enc);
    };
    InternalEncoder.prototype.end = function () {};
    function InternalEncoderBase64(options, codec) {
      this.prevStr = '';
    }
    InternalEncoderBase64.prototype.write = function (str) {
      str = this.prevStr + str;
      var completeQuads = str.length - str.length % 4;
      this.prevStr = str.slice(completeQuads);
      str = str.slice(0, completeQuads);
      return new Buffer(str, "base64");
    };
    InternalEncoderBase64.prototype.end = function () {
      return new Buffer(this.prevStr, "base64");
    };
    function InternalEncoderCesu8(options, codec) {}
    InternalEncoderCesu8.prototype.write = function (str) {
      var buf = new Buffer(str.length * 3),
          bufIdx = 0;
      for (var i = 0; i < str.length; i++) {
        var charCode = str.charCodeAt(i);
        if (charCode < 0x80) buf[bufIdx++] = charCode;else if (charCode < 0x800) {
          buf[bufIdx++] = 0xC0 + (charCode >>> 6);
          buf[bufIdx++] = 0x80 + (charCode & 0x3f);
        } else {
          buf[bufIdx++] = 0xE0 + (charCode >>> 12);
          buf[bufIdx++] = 0x80 + (charCode >>> 6 & 0x3f);
          buf[bufIdx++] = 0x80 + (charCode & 0x3f);
        }
      }
      return buf.slice(0, bufIdx);
    };
    InternalEncoderCesu8.prototype.end = function () {};
    function InternalDecoderCesu8(options, codec) {
      this.acc = 0;
      this.contBytes = 0;
      this.accBytes = 0;
      this.defaultCharUnicode = codec.defaultCharUnicode;
    }
    InternalDecoderCesu8.prototype.write = function (buf) {
      var acc = this.acc,
          contBytes = this.contBytes,
          accBytes = this.accBytes,
          res = '';
      for (var i = 0; i < buf.length; i++) {
        var curByte = buf[i];
        if ((curByte & 0xC0) !== 0x80) {
          if (contBytes > 0) {
            res += this.defaultCharUnicode;
            contBytes = 0;
          }
          if (curByte < 0x80) {
            res += String.fromCharCode(curByte);
          } else if (curByte < 0xE0) {
            acc = curByte & 0x1F;
            contBytes = 1;
            accBytes = 1;
          } else if (curByte < 0xF0) {
            acc = curByte & 0x0F;
            contBytes = 2;
            accBytes = 1;
          } else {
            res += this.defaultCharUnicode;
          }
        } else {
          if (contBytes > 0) {
            acc = acc << 6 | curByte & 0x3f;
            contBytes--;
            accBytes++;
            if (contBytes === 0) {
              if (accBytes === 2 && acc < 0x80 && acc > 0) res += this.defaultCharUnicode;else if (accBytes === 3 && acc < 0x800) res += this.defaultCharUnicode;else res += String.fromCharCode(acc);
            }
          } else {
            res += this.defaultCharUnicode;
          }
        }
      }
      this.acc = acc;
      this.contBytes = contBytes;
      this.accBytes = accBytes;
      return res;
    };
    InternalDecoderCesu8.prototype.end = function () {
      var res = 0;
      if (this.contBytes > 0) res += this.defaultCharUnicode;
      return res;
    };
  })($__require("2a").Buffer);
  return module.exports;
});
$__System.registerDynamic('141', ['2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    "use strict";

    exports.utf16be = Utf16BECodec;
    function Utf16BECodec() {}
    Utf16BECodec.prototype.encoder = Utf16BEEncoder;
    Utf16BECodec.prototype.decoder = Utf16BEDecoder;
    Utf16BECodec.prototype.bomAware = true;
    function Utf16BEEncoder() {}
    Utf16BEEncoder.prototype.write = function (str) {
      var buf = new Buffer(str, 'ucs2');
      for (var i = 0; i < buf.length; i += 2) {
        var tmp = buf[i];
        buf[i] = buf[i + 1];
        buf[i + 1] = tmp;
      }
      return buf;
    };
    Utf16BEEncoder.prototype.end = function () {};
    function Utf16BEDecoder() {
      this.overflowByte = -1;
    }
    Utf16BEDecoder.prototype.write = function (buf) {
      if (buf.length == 0) return '';
      var buf2 = new Buffer(buf.length + 1),
          i = 0,
          j = 0;
      if (this.overflowByte !== -1) {
        buf2[0] = buf[0];
        buf2[1] = this.overflowByte;
        i = 1;
        j = 2;
      }
      for (; i < buf.length - 1; i += 2, j += 2) {
        buf2[j] = buf[i + 1];
        buf2[j + 1] = buf[i];
      }
      this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
      return buf2.slice(0, j).toString('ucs2');
    };
    Utf16BEDecoder.prototype.end = function () {};
    exports.utf16 = Utf16Codec;
    function Utf16Codec(codecOptions, iconv) {
      this.iconv = iconv;
    }
    Utf16Codec.prototype.encoder = Utf16Encoder;
    Utf16Codec.prototype.decoder = Utf16Decoder;
    function Utf16Encoder(options, codec) {
      options = options || {};
      if (options.addBOM === undefined) options.addBOM = true;
      this.encoder = codec.iconv.getEncoder('utf-16le', options);
    }
    Utf16Encoder.prototype.write = function (str) {
      return this.encoder.write(str);
    };
    Utf16Encoder.prototype.end = function () {
      return this.encoder.end();
    };
    function Utf16Decoder(options, codec) {
      this.decoder = null;
      this.initialBytes = [];
      this.initialBytesLen = 0;
      this.options = options || {};
      this.iconv = codec.iconv;
    }
    Utf16Decoder.prototype.write = function (buf) {
      if (!this.decoder) {
        this.initialBytes.push(buf);
        this.initialBytesLen += buf.length;
        if (this.initialBytesLen < 16) return '';
        var buf = Buffer.concat(this.initialBytes),
            encoding = detectEncoding(buf, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);
        this.initialBytes.length = this.initialBytesLen = 0;
      }
      return this.decoder.write(buf);
    };
    Utf16Decoder.prototype.end = function () {
      if (!this.decoder) {
        var buf = Buffer.concat(this.initialBytes),
            encoding = detectEncoding(buf, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);
        var res = this.decoder.write(buf),
            trail = this.decoder.end();
        return trail ? res + trail : res;
      }
      return this.decoder.end();
    };
    function detectEncoding(buf, defaultEncoding) {
      var enc = defaultEncoding || 'utf-16le';
      if (buf.length >= 2) {
        if (buf[0] == 0xFE && buf[1] == 0xFF) enc = 'utf-16be';else if (buf[0] == 0xFF && buf[1] == 0xFE) enc = 'utf-16le';else {
          var asciiCharsLE = 0,
              asciiCharsBE = 0,
              _len = Math.min(buf.length - buf.length % 2, 64);
          for (var i = 0; i < _len; i += 2) {
            if (buf[i] === 0 && buf[i + 1] !== 0) asciiCharsBE++;
            if (buf[i] !== 0 && buf[i + 1] === 0) asciiCharsLE++;
          }
          if (asciiCharsBE > asciiCharsLE) enc = 'utf-16be';else if (asciiCharsBE < asciiCharsLE) enc = 'utf-16le';
        }
      }
      return enc;
    }
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic("142", ["2a"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    "use strict";

    exports.utf7 = Utf7Codec;
    exports.unicode11utf7 = 'utf7';
    function Utf7Codec(codecOptions, iconv) {
      this.iconv = iconv;
    }
    ;
    Utf7Codec.prototype.encoder = Utf7Encoder;
    Utf7Codec.prototype.decoder = Utf7Decoder;
    Utf7Codec.prototype.bomAware = true;
    var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
    function Utf7Encoder(options, codec) {
      this.iconv = codec.iconv;
    }
    Utf7Encoder.prototype.write = function (str) {
      return new Buffer(str.replace(nonDirectChars, function (chunk) {
        return "+" + (chunk === '+' ? '' : this.iconv.encode(chunk, 'utf16-be').toString('base64').replace(/=+$/, '')) + "-";
      }.bind(this)));
    };
    Utf7Encoder.prototype.end = function () {};
    function Utf7Decoder(options, codec) {
      this.iconv = codec.iconv;
      this.inBase64 = false;
      this.base64Accum = '';
    }
    var base64Regex = /[A-Za-z0-9\/+]/;
    var base64Chars = [];
    for (var i = 0; i < 256; i++) base64Chars[i] = base64Regex.test(String.fromCharCode(i));
    var plusChar = '+'.charCodeAt(0),
        minusChar = '-'.charCodeAt(0),
        andChar = '&'.charCodeAt(0);
    Utf7Decoder.prototype.write = function (buf) {
      var res = "",
          lastI = 0,
          inBase64 = this.inBase64,
          base64Accum = this.base64Accum;
      for (var i = 0; i < buf.length; i++) {
        if (!inBase64) {
          if (buf[i] == plusChar) {
            res += this.iconv.decode(buf.slice(lastI, i), "ascii");
            lastI = i + 1;
            inBase64 = true;
          }
        } else {
          if (!base64Chars[buf[i]]) {
            if (i == lastI && buf[i] == minusChar) {
              res += "+";
            } else {
              var b64str = base64Accum + buf.slice(lastI, i).toString();
              res += this.iconv.decode(new Buffer(b64str, 'base64'), "utf16-be");
            }
            if (buf[i] != minusChar) i--;
            lastI = i + 1;
            inBase64 = false;
            base64Accum = '';
          }
        }
      }
      if (!inBase64) {
        res += this.iconv.decode(buf.slice(lastI), "ascii");
      } else {
        var b64str = base64Accum + buf.slice(lastI).toString();
        var canBeDecoded = b64str.length - b64str.length % 8;
        base64Accum = b64str.slice(canBeDecoded);
        b64str = b64str.slice(0, canBeDecoded);
        res += this.iconv.decode(new Buffer(b64str, 'base64'), "utf16-be");
      }
      this.inBase64 = inBase64;
      this.base64Accum = base64Accum;
      return res;
    };
    Utf7Decoder.prototype.end = function () {
      var res = "";
      if (this.inBase64 && this.base64Accum.length > 0) res = this.iconv.decode(new Buffer(this.base64Accum, 'base64'), "utf16-be");
      this.inBase64 = false;
      this.base64Accum = '';
      return res;
    };
    exports.utf7imap = Utf7IMAPCodec;
    function Utf7IMAPCodec(codecOptions, iconv) {
      this.iconv = iconv;
    }
    ;
    Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
    Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
    Utf7IMAPCodec.prototype.bomAware = true;
    function Utf7IMAPEncoder(options, codec) {
      this.iconv = codec.iconv;
      this.inBase64 = false;
      this.base64Accum = new Buffer(6);
      this.base64AccumIdx = 0;
    }
    Utf7IMAPEncoder.prototype.write = function (str) {
      var inBase64 = this.inBase64,
          base64Accum = this.base64Accum,
          base64AccumIdx = this.base64AccumIdx,
          buf = new Buffer(str.length * 5 + 10),
          bufIdx = 0;
      for (var i = 0; i < str.length; i++) {
        var uChar = str.charCodeAt(i);
        if (0x20 <= uChar && uChar <= 0x7E) {
          if (inBase64) {
            if (base64AccumIdx > 0) {
              bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
              base64AccumIdx = 0;
            }
            buf[bufIdx++] = minusChar;
            inBase64 = false;
          }
          if (!inBase64) {
            buf[bufIdx++] = uChar;
            if (uChar === andChar) buf[bufIdx++] = minusChar;
          }
        } else {
          if (!inBase64) {
            buf[bufIdx++] = andChar;
            inBase64 = true;
          }
          if (inBase64) {
            base64Accum[base64AccumIdx++] = uChar >> 8;
            base64Accum[base64AccumIdx++] = uChar & 0xFF;
            if (base64AccumIdx == base64Accum.length) {
              bufIdx += buf.write(base64Accum.toString('base64').replace(/\//g, ','), bufIdx);
              base64AccumIdx = 0;
            }
          }
        }
      }
      this.inBase64 = inBase64;
      this.base64AccumIdx = base64AccumIdx;
      return buf.slice(0, bufIdx);
    };
    Utf7IMAPEncoder.prototype.end = function () {
      var buf = new Buffer(10),
          bufIdx = 0;
      if (this.inBase64) {
        if (this.base64AccumIdx > 0) {
          bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
          this.base64AccumIdx = 0;
        }
        buf[bufIdx++] = minusChar;
        this.inBase64 = false;
      }
      return buf.slice(0, bufIdx);
    };
    function Utf7IMAPDecoder(options, codec) {
      this.iconv = codec.iconv;
      this.inBase64 = false;
      this.base64Accum = '';
    }
    var base64IMAPChars = base64Chars.slice();
    base64IMAPChars[','.charCodeAt(0)] = true;
    Utf7IMAPDecoder.prototype.write = function (buf) {
      var res = "",
          lastI = 0,
          inBase64 = this.inBase64,
          base64Accum = this.base64Accum;
      for (var i = 0; i < buf.length; i++) {
        if (!inBase64) {
          if (buf[i] == andChar) {
            res += this.iconv.decode(buf.slice(lastI, i), "ascii");
            lastI = i + 1;
            inBase64 = true;
          }
        } else {
          if (!base64IMAPChars[buf[i]]) {
            if (i == lastI && buf[i] == minusChar) {
              res += "&";
            } else {
              var b64str = base64Accum + buf.slice(lastI, i).toString().replace(/,/g, '/');
              res += this.iconv.decode(new Buffer(b64str, 'base64'), "utf16-be");
            }
            if (buf[i] != minusChar) i--;
            lastI = i + 1;
            inBase64 = false;
            base64Accum = '';
          }
        }
      }
      if (!inBase64) {
        res += this.iconv.decode(buf.slice(lastI), "ascii");
      } else {
        var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, '/');
        var canBeDecoded = b64str.length - b64str.length % 8;
        base64Accum = b64str.slice(canBeDecoded);
        b64str = b64str.slice(0, canBeDecoded);
        res += this.iconv.decode(new Buffer(b64str, 'base64'), "utf16-be");
      }
      this.inBase64 = inBase64;
      this.base64Accum = base64Accum;
      return res;
    };
    Utf7IMAPDecoder.prototype.end = function () {
      var res = "";
      if (this.inBase64 && this.base64Accum.length > 0) res = this.iconv.decode(new Buffer(this.base64Accum, 'base64'), "utf16-be");
      this.inBase64 = false;
      this.base64Accum = '';
      return res;
    };
  })($__require("2a").Buffer);
  return module.exports;
});
$__System.registerDynamic("143", ["2a"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    "use strict";

    exports._sbcs = SBCSCodec;
    function SBCSCodec(codecOptions, iconv) {
      if (!codecOptions) throw new Error("SBCS codec is called without the data.");
      if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256) throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
      if (codecOptions.chars.length === 128) {
        var asciiString = "";
        for (var i = 0; i < 128; i++) asciiString += String.fromCharCode(i);
        codecOptions.chars = asciiString + codecOptions.chars;
      }
      this.decodeBuf = new Buffer(codecOptions.chars, 'ucs2');
      var encodeBuf = new Buffer(65536);
      encodeBuf.fill(iconv.defaultCharSingleByte.charCodeAt(0));
      for (var i = 0; i < codecOptions.chars.length; i++) encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
      this.encodeBuf = encodeBuf;
    }
    SBCSCodec.prototype.encoder = SBCSEncoder;
    SBCSCodec.prototype.decoder = SBCSDecoder;
    function SBCSEncoder(options, codec) {
      this.encodeBuf = codec.encodeBuf;
    }
    SBCSEncoder.prototype.write = function (str) {
      var buf = new Buffer(str.length);
      for (var i = 0; i < str.length; i++) buf[i] = this.encodeBuf[str.charCodeAt(i)];
      return buf;
    };
    SBCSEncoder.prototype.end = function () {};
    function SBCSDecoder(options, codec) {
      this.decodeBuf = codec.decodeBuf;
    }
    SBCSDecoder.prototype.write = function (buf) {
      var decodeBuf = this.decodeBuf;
      var newBuf = new Buffer(buf.length * 2);
      var idx1 = 0,
          idx2 = 0;
      for (var i = 0; i < buf.length; i++) {
        idx1 = buf[i] * 2;
        idx2 = i * 2;
        newBuf[idx2] = decodeBuf[idx1];
        newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
      }
      return newBuf.toString('ucs2');
    };
    SBCSDecoder.prototype.end = function () {};
  })($__require("2a").Buffer);
  return module.exports;
});
$__System.registerDynamic("144", [], true, function ($__require, exports, module) {
    /* */
    "use strict";

    // Manually added data to be used by sbcs codec in addition to generated one.

    var define,
        global = this || self,
        GLOBAL = global;
    module.exports = {
        // Not supported by iconv, not sure why.
        "10029": "maccenteuro",
        "maccenteuro": {
            "type": "_sbcs",
            "chars": ""
        },

        "808": "cp808",
        "ibm808": "cp808",
        "cp808": {
            "type": "_sbcs",
            "chars": ""
        },

        // Aliases of generated encodings.
        "ascii8bit": "ascii",
        "usascii": "ascii",
        "ansix34": "ascii",
        "ansix341968": "ascii",
        "ansix341986": "ascii",
        "csascii": "ascii",
        "cp367": "ascii",
        "ibm367": "ascii",
        "isoir6": "ascii",
        "iso646us": "ascii",
        "iso646irv": "ascii",
        "us": "ascii",

        "latin1": "iso88591",
        "latin2": "iso88592",
        "latin3": "iso88593",
        "latin4": "iso88594",
        "latin5": "iso88599",
        "latin6": "iso885910",
        "latin7": "iso885913",
        "latin8": "iso885914",
        "latin9": "iso885915",
        "latin10": "iso885916",

        "csisolatin1": "iso88591",
        "csisolatin2": "iso88592",
        "csisolatin3": "iso88593",
        "csisolatin4": "iso88594",
        "csisolatincyrillic": "iso88595",
        "csisolatinarabic": "iso88596",
        "csisolatingreek": "iso88597",
        "csisolatinhebrew": "iso88598",
        "csisolatin5": "iso88599",
        "csisolatin6": "iso885910",

        "l1": "iso88591",
        "l2": "iso88592",
        "l3": "iso88593",
        "l4": "iso88594",
        "l5": "iso88599",
        "l6": "iso885910",
        "l7": "iso885913",
        "l8": "iso885914",
        "l9": "iso885915",
        "l10": "iso885916",

        "isoir14": "iso646jp",
        "isoir57": "iso646cn",
        "isoir100": "iso88591",
        "isoir101": "iso88592",
        "isoir109": "iso88593",
        "isoir110": "iso88594",
        "isoir144": "iso88595",
        "isoir127": "iso88596",
        "isoir126": "iso88597",
        "isoir138": "iso88598",
        "isoir148": "iso88599",
        "isoir157": "iso885910",
        "isoir166": "tis620",
        "isoir179": "iso885913",
        "isoir199": "iso885914",
        "isoir203": "iso885915",
        "isoir226": "iso885916",

        "cp819": "iso88591",
        "ibm819": "iso88591",

        "cyrillic": "iso88595",

        "arabic": "iso88596",
        "arabic8": "iso88596",
        "ecma114": "iso88596",
        "asmo708": "iso88596",

        "greek": "iso88597",
        "greek8": "iso88597",
        "ecma118": "iso88597",
        "elot928": "iso88597",

        "hebrew": "iso88598",
        "hebrew8": "iso88598",

        "turkish": "iso88599",
        "turkish8": "iso88599",

        "thai": "iso885911",
        "thai8": "iso885911",

        "celtic": "iso885914",
        "celtic8": "iso885914",
        "isoceltic": "iso885914",

        "tis6200": "tis620",
        "tis62025291": "tis620",
        "tis62025330": "tis620",

        "10000": "macroman",
        "10006": "macgreek",
        "10007": "maccyrillic",
        "10079": "maciceland",
        "10081": "macturkish",

        "cspc8codepage437": "cp437",
        "cspc775baltic": "cp775",
        "cspc850multilingual": "cp850",
        "cspcp852": "cp852",
        "cspc862latinhebrew": "cp862",
        "cpgr": "cp869",

        "msee": "cp1250",
        "mscyrl": "cp1251",
        "msansi": "cp1252",
        "msgreek": "cp1253",
        "msturk": "cp1254",
        "mshebr": "cp1255",
        "msarab": "cp1256",
        "winbaltrim": "cp1257",

        "cp20866": "koi8r",
        "20866": "koi8r",
        "ibm878": "koi8r",
        "cskoi8r": "koi8r",

        "cp21866": "koi8u",
        "21866": "koi8u",
        "ibm1168": "koi8u",

        "strk10482002": "rk1048",

        "tcvn5712": "tcvn",
        "tcvn57121": "tcvn",

        "gb198880": "iso646cn",
        "cn": "iso646cn",

        "csiso14jisc6220ro": "iso646jp",
        "jisc62201969ro": "iso646jp",
        "jp": "iso646jp",

        "cshproman8": "hproman8",
        "r8": "hproman8",
        "roman8": "hproman8",
        "xroman8": "hproman8",
        "ibm1051": "hproman8",

        "mac": "macintosh",
        "csmacintosh": "macintosh"
    };
    return module.exports;
});
$__System.registerDynamic("145", [], true, function ($__require, exports, module) {
  /* */
  "use strict";

  // Generated data for sbcs codec. Don't edit manually. Regenerate using generation/gen-sbcs.js script.

  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = {
    "437": "cp437",
    "737": "cp737",
    "775": "cp775",
    "850": "cp850",
    "852": "cp852",
    "855": "cp855",
    "856": "cp856",
    "857": "cp857",
    "858": "cp858",
    "860": "cp860",
    "861": "cp861",
    "862": "cp862",
    "863": "cp863",
    "864": "cp864",
    "865": "cp865",
    "866": "cp866",
    "869": "cp869",
    "874": "windows874",
    "922": "cp922",
    "1046": "cp1046",
    "1124": "cp1124",
    "1125": "cp1125",
    "1129": "cp1129",
    "1133": "cp1133",
    "1161": "cp1161",
    "1162": "cp1162",
    "1163": "cp1163",
    "1250": "windows1250",
    "1251": "windows1251",
    "1252": "windows1252",
    "1253": "windows1253",
    "1254": "windows1254",
    "1255": "windows1255",
    "1256": "windows1256",
    "1257": "windows1257",
    "1258": "windows1258",
    "28591": "iso88591",
    "28592": "iso88592",
    "28593": "iso88593",
    "28594": "iso88594",
    "28595": "iso88595",
    "28596": "iso88596",
    "28597": "iso88597",
    "28598": "iso88598",
    "28599": "iso88599",
    "28600": "iso885910",
    "28601": "iso885911",
    "28603": "iso885913",
    "28604": "iso885914",
    "28605": "iso885915",
    "28606": "iso885916",
    "windows874": {
      "type": "_sbcs",
      "chars": ""
    },
    "win874": "windows874",
    "cp874": "windows874",
    "windows1250": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1250": "windows1250",
    "cp1250": "windows1250",
    "windows1251": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1251": "windows1251",
    "cp1251": "windows1251",
    "windows1252": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1252": "windows1252",
    "cp1252": "windows1252",
    "windows1253": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1253": "windows1253",
    "cp1253": "windows1253",
    "windows1254": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1254": "windows1254",
    "cp1254": "windows1254",
    "windows1255": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1255": "windows1255",
    "cp1255": "windows1255",
    "windows1256": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1256": "windows1256",
    "cp1256": "windows1256",
    "windows1257": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1257": "windows1257",
    "cp1257": "windows1257",
    "windows1258": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1258": "windows1258",
    "cp1258": "windows1258",
    "iso88591": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28591": "iso88591",
    "iso88592": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28592": "iso88592",
    "iso88593": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28593": "iso88593",
    "iso88594": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28594": "iso88594",
    "iso88595": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28595": "iso88595",
    "iso88596": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28596": "iso88596",
    "iso88597": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28597": "iso88597",
    "iso88598": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28598": "iso88598",
    "iso88599": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28599": "iso88599",
    "iso885910": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28600": "iso885910",
    "iso885911": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28601": "iso885911",
    "iso885913": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28603": "iso885913",
    "iso885914": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28604": "iso885914",
    "iso885915": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28605": "iso885915",
    "iso885916": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28606": "iso885916",
    "cp437": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm437": "cp437",
    "csibm437": "cp437",
    "cp737": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm737": "cp737",
    "csibm737": "cp737",
    "cp775": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm775": "cp775",
    "csibm775": "cp775",
    "cp850": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm850": "cp850",
    "csibm850": "cp850",
    "cp852": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm852": "cp852",
    "csibm852": "cp852",
    "cp855": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm855": "cp855",
    "csibm855": "cp855",
    "cp856": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm856": "cp856",
    "csibm856": "cp856",
    "cp857": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm857": "cp857",
    "csibm857": "cp857",
    "cp858": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm858": "cp858",
    "csibm858": "cp858",
    "cp860": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm860": "cp860",
    "csibm860": "cp860",
    "cp861": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm861": "cp861",
    "csibm861": "cp861",
    "cp862": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm862": "cp862",
    "csibm862": "cp862",
    "cp863": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm863": "cp863",
    "csibm863": "cp863",
    "cp864": {
      "type": "_sbcs",
      "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    },
    "ibm864": "cp864",
    "csibm864": "cp864",
    "cp865": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm865": "cp865",
    "csibm865": "cp865",
    "cp866": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm866": "cp866",
    "csibm866": "cp866",
    "cp869": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm869": "cp869",
    "csibm869": "cp869",
    "cp922": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm922": "cp922",
    "csibm922": "cp922",
    "cp1046": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1046": "cp1046",
    "csibm1046": "cp1046",
    "cp1124": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1124": "cp1124",
    "csibm1124": "cp1124",
    "cp1125": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1125": "cp1125",
    "csibm1125": "cp1125",
    "cp1129": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1129": "cp1129",
    "csibm1129": "cp1129",
    "cp1133": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1133": "cp1133",
    "csibm1133": "cp1133",
    "cp1161": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1161": "cp1161",
    "csibm1161": "cp1161",
    "cp1162": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1162": "cp1162",
    "csibm1162": "cp1162",
    "cp1163": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1163": "cp1163",
    "csibm1163": "cp1163",
    "maccroatian": {
      "type": "_sbcs",
      "chars": ""
    },
    "maccyrillic": {
      "type": "_sbcs",
      "chars": ""
    },
    "macgreek": {
      "type": "_sbcs",
      "chars": ""
    },
    "maciceland": {
      "type": "_sbcs",
      "chars": ""
    },
    "macroman": {
      "type": "_sbcs",
      "chars": ""
    },
    "macromania": {
      "type": "_sbcs",
      "chars": ""
    },
    "macthai": {
      "type": "_sbcs",
      "chars": ""
    },
    "macturkish": {
      "type": "_sbcs",
      "chars": ""
    },
    "macukraine": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8r": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8u": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8ru": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8t": {
      "type": "_sbcs",
      "chars": ""
    },
    "armscii8": {
      "type": "_sbcs",
      "chars": ")(.,-"
    },
    "rk1048": {
      "type": "_sbcs",
      "chars": ""
    },
    "tcvn": {
      "type": "_sbcs",
      "chars": "\u0000\u0003\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    },
    "georgianacademy": {
      "type": "_sbcs",
      "chars": ""
    },
    "georgianps": {
      "type": "_sbcs",
      "chars": ""
    },
    "pt154": {
      "type": "_sbcs",
      "chars": ""
    },
    "viscii": {
      "type": "_sbcs",
      "chars": "\u0000\u0001\u0003\u0004\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0015\u0016\u0017\u0018\u001a\u001b\u001c\u001d\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    },
    "iso646cn": {
      "type": "_sbcs",
      "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
    },
    "iso646jp": {
      "type": "_sbcs",
      "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
    },
    "hproman8": {
      "type": "_sbcs",
      "chars": ""
    },
    "macintosh": {
      "type": "_sbcs",
      "chars": ""
    },
    "ascii": {
      "type": "_sbcs",
      "chars": ""
    },
    "tis620": {
      "type": "_sbcs",
      "chars": ""
    }
  };
  return module.exports;
});
$__System.registerDynamic("146", ["2a", "13"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer, process) {
    "use strict";

    exports._dbcs = DBCSCodec;
    var UNASSIGNED = -1,
        GB18030_CODE = -2,
        SEQ_START = -10,
        NODE_START = -1000,
        UNASSIGNED_NODE = new Array(0x100),
        DEF_CHAR = -1;
    for (var i = 0; i < 0x100; i++) UNASSIGNED_NODE[i] = UNASSIGNED;
    function DBCSCodec(codecOptions, iconv) {
      this.encodingName = codecOptions.encodingName;
      if (!codecOptions) throw new Error("DBCS codec is called without the data.");
      if (!codecOptions.table) throw new Error("Encoding '" + this.encodingName + "' has no data.");
      var mappingTable = codecOptions.table();
      this.decodeTables = [];
      this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
      this.decodeTableSeq = [];
      for (var i = 0; i < mappingTable.length; i++) this._addDecodeChunk(mappingTable[i]);
      this.defaultCharUnicode = iconv.defaultCharUnicode;
      this.encodeTable = [];
      this.encodeTableSeq = [];
      var skipEncodeChars = {};
      if (codecOptions.encodeSkipVals) for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {
        var val = codecOptions.encodeSkipVals[i];
        if (typeof val === 'number') skipEncodeChars[val] = true;else for (var j = val.from; j <= val.to; j++) skipEncodeChars[j] = true;
      }
      this._fillEncodeTable(0, 0, skipEncodeChars);
      if (codecOptions.encodeAdd) {
        for (var uChar in codecOptions.encodeAdd) if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar)) this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
      }
      this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
      if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]['?'];
      if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);
      if (typeof codecOptions.gb18030 === 'function') {
        this.gb18030 = codecOptions.gb18030();
        var thirdByteNodeIdx = this.decodeTables.length;
        var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);
        var fourthByteNodeIdx = this.decodeTables.length;
        var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);
        for (var i = 0x81; i <= 0xFE; i++) {
          var secondByteNodeIdx = NODE_START - this.decodeTables[0][i];
          var secondByteNode = this.decodeTables[secondByteNodeIdx];
          for (var j = 0x30; j <= 0x39; j++) secondByteNode[j] = NODE_START - thirdByteNodeIdx;
        }
        for (var i = 0x81; i <= 0xFE; i++) thirdByteNode[i] = NODE_START - fourthByteNodeIdx;
        for (var i = 0x30; i <= 0x39; i++) fourthByteNode[i] = GB18030_CODE;
      }
    }
    DBCSCodec.prototype.encoder = DBCSEncoder;
    DBCSCodec.prototype.decoder = DBCSDecoder;
    DBCSCodec.prototype._getDecodeTrieNode = function (addr) {
      var bytes = [];
      for (; addr > 0; addr >>= 8) bytes.push(addr & 0xFF);
      if (bytes.length == 0) bytes.push(0);
      var node = this.decodeTables[0];
      for (var i = bytes.length - 1; i > 0; i--) {
        var val = node[bytes[i]];
        if (val == UNASSIGNED) {
          node[bytes[i]] = NODE_START - this.decodeTables.length;
          this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
        } else if (val <= NODE_START) {
          node = this.decodeTables[NODE_START - val];
        } else throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
      }
      return node;
    };
    DBCSCodec.prototype._addDecodeChunk = function (chunk) {
      var curAddr = parseInt(chunk[0], 16);
      var writeTable = this._getDecodeTrieNode(curAddr);
      curAddr = curAddr & 0xFF;
      for (var k = 1; k < chunk.length; k++) {
        var part = chunk[k];
        if (typeof part === "string") {
          for (var l = 0; l < part.length;) {
            var code = part.charCodeAt(l++);
            if (0xD800 <= code && code < 0xDC00) {
              var codeTrail = part.charCodeAt(l++);
              if (0xDC00 <= codeTrail && codeTrail < 0xE000) writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);else throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
            } else if (0x0FF0 < code && code <= 0x0FFF) {
              var len = 0xFFF - code + 2;
              var seq = [];
              for (var m = 0; m < len; m++) seq.push(part.charCodeAt(l++));
              writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
              this.decodeTableSeq.push(seq);
            } else writeTable[curAddr++] = code;
          }
        } else if (typeof part === "number") {
          var charCode = writeTable[curAddr - 1] + 1;
          for (var l = 0; l < part; l++) writeTable[curAddr++] = charCode++;
        } else throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
      }
      if (curAddr > 0xFF) throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
    };
    DBCSCodec.prototype._getEncodeBucket = function (uCode) {
      var high = uCode >> 8;
      if (this.encodeTable[high] === undefined) this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
      return this.encodeTable[high];
    };
    DBCSCodec.prototype._setEncodeChar = function (uCode, dbcsCode) {
      var bucket = this._getEncodeBucket(uCode);
      var low = uCode & 0xFF;
      if (bucket[low] <= SEQ_START) this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;else if (bucket[low] == UNASSIGNED) bucket[low] = dbcsCode;
    };
    DBCSCodec.prototype._setEncodeSequence = function (seq, dbcsCode) {
      var uCode = seq[0];
      var bucket = this._getEncodeBucket(uCode);
      var low = uCode & 0xFF;
      var node;
      if (bucket[low] <= SEQ_START) {
        node = this.encodeTableSeq[SEQ_START - bucket[low]];
      } else {
        node = {};
        if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low];
        bucket[low] = SEQ_START - this.encodeTableSeq.length;
        this.encodeTableSeq.push(node);
      }
      for (var j = 1; j < seq.length - 1; j++) {
        var oldVal = node[uCode];
        if (typeof oldVal === 'object') node = oldVal;else {
          node = node[uCode] = {};
          if (oldVal !== undefined) node[DEF_CHAR] = oldVal;
        }
      }
      uCode = seq[seq.length - 1];
      node[uCode] = dbcsCode;
    };
    DBCSCodec.prototype._fillEncodeTable = function (nodeIdx, prefix, skipEncodeChars) {
      var node = this.decodeTables[nodeIdx];
      for (var i = 0; i < 0x100; i++) {
        var uCode = node[i];
        var mbCode = prefix + i;
        if (skipEncodeChars[mbCode]) continue;
        if (uCode >= 0) this._setEncodeChar(uCode, mbCode);else if (uCode <= NODE_START) this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);else if (uCode <= SEQ_START) this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
      }
    };
    function DBCSEncoder(options, codec) {
      this.leadSurrogate = -1;
      this.seqObj = undefined;
      this.encodeTable = codec.encodeTable;
      this.encodeTableSeq = codec.encodeTableSeq;
      this.defaultCharSingleByte = codec.defCharSB;
      this.gb18030 = codec.gb18030;
    }
    DBCSEncoder.prototype.write = function (str) {
      var newBuf = new Buffer(str.length * (this.gb18030 ? 4 : 3)),
          leadSurrogate = this.leadSurrogate,
          seqObj = this.seqObj,
          nextChar = -1,
          i = 0,
          j = 0;
      while (true) {
        if (nextChar === -1) {
          if (i == str.length) break;
          var uCode = str.charCodeAt(i++);
        } else {
          var uCode = nextChar;
          nextChar = -1;
        }
        if (0xD800 <= uCode && uCode < 0xE000) {
          if (uCode < 0xDC00) {
            if (leadSurrogate === -1) {
              leadSurrogate = uCode;
              continue;
            } else {
              leadSurrogate = uCode;
              uCode = UNASSIGNED;
            }
          } else {
            if (leadSurrogate !== -1) {
              uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);
              leadSurrogate = -1;
            } else {
              uCode = UNASSIGNED;
            }
          }
        } else if (leadSurrogate !== -1) {
          nextChar = uCode;
          uCode = UNASSIGNED;
          leadSurrogate = -1;
        }
        var dbcsCode = UNASSIGNED;
        if (seqObj !== undefined && uCode != UNASSIGNED) {
          var resCode = seqObj[uCode];
          if (typeof resCode === 'object') {
            seqObj = resCode;
            continue;
          } else if (typeof resCode == 'number') {
            dbcsCode = resCode;
          } else if (resCode == undefined) {
            resCode = seqObj[DEF_CHAR];
            if (resCode !== undefined) {
              dbcsCode = resCode;
              nextChar = uCode;
            } else {}
          }
          seqObj = undefined;
        } else if (uCode >= 0) {
          var subtable = this.encodeTable[uCode >> 8];
          if (subtable !== undefined) dbcsCode = subtable[uCode & 0xFF];
          if (dbcsCode <= SEQ_START) {
            seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
            continue;
          }
          if (dbcsCode == UNASSIGNED && this.gb18030) {
            var idx = findIdx(this.gb18030.uChars, uCode);
            if (idx != -1) {
              var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
              newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600);
              dbcsCode = dbcsCode % 12600;
              newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260);
              dbcsCode = dbcsCode % 1260;
              newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10);
              dbcsCode = dbcsCode % 10;
              newBuf[j++] = 0x30 + dbcsCode;
              continue;
            }
          }
        }
        if (dbcsCode === UNASSIGNED) dbcsCode = this.defaultCharSingleByte;
        if (dbcsCode < 0x100) {
          newBuf[j++] = dbcsCode;
        } else if (dbcsCode < 0x10000) {
          newBuf[j++] = dbcsCode >> 8;
          newBuf[j++] = dbcsCode & 0xFF;
        } else {
          newBuf[j++] = dbcsCode >> 16;
          newBuf[j++] = dbcsCode >> 8 & 0xFF;
          newBuf[j++] = dbcsCode & 0xFF;
        }
      }
      this.seqObj = seqObj;
      this.leadSurrogate = leadSurrogate;
      return newBuf.slice(0, j);
    };
    DBCSEncoder.prototype.end = function () {
      if (this.leadSurrogate === -1 && this.seqObj === undefined) return;
      var newBuf = new Buffer(10),
          j = 0;
      if (this.seqObj) {
        var dbcsCode = this.seqObj[DEF_CHAR];
        if (dbcsCode !== undefined) {
          if (dbcsCode < 0x100) {
            newBuf[j++] = dbcsCode;
          } else {
            newBuf[j++] = dbcsCode >> 8;
            newBuf[j++] = dbcsCode & 0xFF;
          }
        } else {}
        this.seqObj = undefined;
      }
      if (this.leadSurrogate !== -1) {
        newBuf[j++] = this.defaultCharSingleByte;
        this.leadSurrogate = -1;
      }
      return newBuf.slice(0, j);
    };
    DBCSEncoder.prototype.findIdx = findIdx;
    function DBCSDecoder(options, codec) {
      this.nodeIdx = 0;
      this.prevBuf = new Buffer(0);
      this.decodeTables = codec.decodeTables;
      this.decodeTableSeq = codec.decodeTableSeq;
      this.defaultCharUnicode = codec.defaultCharUnicode;
      this.gb18030 = codec.gb18030;
    }
    DBCSDecoder.prototype.write = function (buf) {
      var newBuf = new Buffer(buf.length * 2),
          nodeIdx = this.nodeIdx,
          prevBuf = this.prevBuf,
          prevBufOffset = this.prevBuf.length,
          seqStart = -this.prevBuf.length,
          uCode;
      if (prevBufOffset > 0) prevBuf = Buffer.concat([prevBuf, buf.slice(0, 10)]);
      for (var i = 0, j = 0; i < buf.length; i++) {
        var curByte = i >= 0 ? buf[i] : prevBuf[i + prevBufOffset];
        var uCode = this.decodeTables[nodeIdx][curByte];
        if (uCode >= 0) {} else if (uCode === UNASSIGNED) {
          i = seqStart;
          uCode = this.defaultCharUnicode.charCodeAt(0);
        } else if (uCode === GB18030_CODE) {
          var curSeq = seqStart >= 0 ? buf.slice(seqStart, i + 1) : prevBuf.slice(seqStart + prevBufOffset, i + 1 + prevBufOffset);
          var ptr = (curSeq[0] - 0x81) * 12600 + (curSeq[1] - 0x30) * 1260 + (curSeq[2] - 0x81) * 10 + (curSeq[3] - 0x30);
          var idx = findIdx(this.gb18030.gbChars, ptr);
          uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
        } else if (uCode <= NODE_START) {
          nodeIdx = NODE_START - uCode;
          continue;
        } else if (uCode <= SEQ_START) {
          var seq = this.decodeTableSeq[SEQ_START - uCode];
          for (var k = 0; k < seq.length - 1; k++) {
            uCode = seq[k];
            newBuf[j++] = uCode & 0xFF;
            newBuf[j++] = uCode >> 8;
          }
          uCode = seq[seq.length - 1];
        } else throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
        if (uCode > 0xFFFF) {
          uCode -= 0x10000;
          var uCodeLead = 0xD800 + Math.floor(uCode / 0x400);
          newBuf[j++] = uCodeLead & 0xFF;
          newBuf[j++] = uCodeLead >> 8;
          uCode = 0xDC00 + uCode % 0x400;
        }
        newBuf[j++] = uCode & 0xFF;
        newBuf[j++] = uCode >> 8;
        nodeIdx = 0;
        seqStart = i + 1;
      }
      this.nodeIdx = nodeIdx;
      this.prevBuf = seqStart >= 0 ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);
      return newBuf.slice(0, j).toString('ucs2');
    };
    DBCSDecoder.prototype.end = function () {
      var ret = '';
      while (this.prevBuf.length > 0) {
        ret += this.defaultCharUnicode;
        var buf = this.prevBuf.slice(1);
        this.prevBuf = new Buffer(0);
        this.nodeIdx = 0;
        if (buf.length > 0) ret += this.write(buf);
      }
      this.nodeIdx = 0;
      return ret;
    };
    function findIdx(table, val) {
      if (table[0] > val) return -1;
      var l = 0,
          r = table.length;
      while (l < r - 1) {
        var mid = l + Math.floor((r - l + 1) / 2);
        if (table[mid] <= val) l = mid;else r = mid;
      }
      return l;
    }
  })($__require("2a").Buffer, $__require("13"));
  return module.exports;
});
$__System.registerDynamic("147", [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = [["0", "\u0000", 128], ["a1", "", 62], ["8140", "", 9, ""], ["8180", ""], ["81b8", ""], ["81c8", ""], ["81da", ""], ["81f0", ""], ["81fc", ""], ["824f", "", 9], ["8260", "", 25], ["8281", "", 25], ["829f", "", 82], ["8340", "", 62], ["8380", "", 22], ["839f", "", 16, "", 6], ["83bf", "", 16, "", 6], ["8440", "", 5, "", 25], ["8470", "", 5, "", 7], ["8480", "", 17], ["849f", ""], ["8740", "", 19, "", 9], ["875f", ""], ["877e", ""], ["8780", "", 4, ""], ["889f", ""], ["8940", ""], ["8980", ""], ["8a40", ""], ["8a80", ""], ["8b40", ""], ["8b80", ""], ["8c40", ""], ["8c80", ""], ["8d40", ""], ["8d80", ""], ["8e40", ""], ["8e80", ""], ["8f40", ""], ["8f80", ""], ["9040", ""], ["9080", ""], ["9140", ""], ["9180", ""], ["9240", ""], ["9280", ""], ["9340", ""], ["9380", ""], ["9440", ""], ["9480", ""], ["9540", ""], ["9580", ""], ["9640", ""], ["9680", ""], ["9740", ""], ["9780", ""], ["9840", ""], ["989f", ""], ["9940", ""], ["9980", ""], ["9a40", ""], ["9a80", ""], ["9b40", ""], ["9b80", ""], ["9c40", ""], ["9c80", ""], ["9d40", ""], ["9d80", ""], ["9e40", ""], ["9e80", ""], ["9f40", ""], ["9f80", ""], ["e040", ""], ["e080", ""], ["e140", ""], ["e180", ""], ["e240", ""], ["e280", ""], ["e340", ""], ["e380", ""], ["e440", ""], ["e480", ""], ["e540", ""], ["e580", ""], ["e640", ""], ["e680", ""], ["e740", ""], ["e780", ""], ["e840", ""], ["e880", ""], ["e940", ""], ["e980", ""], ["ea40", ""], ["ea80", ""], ["ed40", ""], ["ed80", ""], ["ee40", ""], ["ee80", ""], ["eeef", "", 9, ""], ["f040", "", 62], ["f080", "", 124], ["f140", "", 62], ["f180", "", 124], ["f240", "", 62], ["f280", "", 124], ["f340", "", 62], ["f380", "", 124], ["f440", "", 62], ["f480", "", 124], ["f540", "", 62], ["f580", "", 124], ["f640", "", 62], ["f680", "", 124], ["f740", "", 62], ["f780", "", 124], ["f840", "", 62], ["f880", "", 124], ["f940", ""], ["fa40", "", 9, "", 9, ""], ["fa80", ""], ["fb40", ""], ["fb80", ""], ["fc40", ""]];
  return module.exports;
});
$__System.registerDynamic("148", [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = [["0", "\u0000", 127], ["8ea1", "", 62], ["a1a1", "", 9, ""], ["a2a1", ""], ["a2ba", ""], ["a2ca", ""], ["a2dc", ""], ["a2f2", ""], ["a2fe", ""], ["a3b0", "", 9], ["a3c1", "", 25], ["a3e1", "", 25], ["a4a1", "", 82], ["a5a1", "", 85], ["a6a1", "", 16, "", 6], ["a6c1", "", 16, "", 6], ["a7a1", "", 5, "", 25], ["a7d1", "", 5, "", 25], ["a8a1", ""], ["ada1", "", 19, "", 9], ["adc0", ""], ["addf", "", 4, ""], ["b0a1", ""], ["b1a1", ""], ["b2a1", ""], ["b3a1", ""], ["b4a1", ""], ["b5a1", ""], ["b6a1", ""], ["b7a1", ""], ["b8a1", ""], ["b9a1", ""], ["baa1", ""], ["bba1", ""], ["bca1", ""], ["bda1", ""], ["bea1", ""], ["bfa1", ""], ["c0a1", ""], ["c1a1", ""], ["c2a1", ""], ["c3a1", ""], ["c4a1", ""], ["c5a1", ""], ["c6a1", ""], ["c7a1", ""], ["c8a1", ""], ["c9a1", ""], ["caa1", ""], ["cba1", ""], ["cca1", ""], ["cda1", ""], ["cea1", ""], ["cfa1", ""], ["d0a1", ""], ["d1a1", ""], ["d2a1", ""], ["d3a1", ""], ["d4a1", ""], ["d5a1", ""], ["d6a1", ""], ["d7a1", ""], ["d8a1", ""], ["d9a1", ""], ["daa1", ""], ["dba1", ""], ["dca1", ""], ["dda1", ""], ["dea1", ""], ["dfa1", ""], ["e0a1", ""], ["e1a1", ""], ["e2a1", ""], ["e3a1", ""], ["e4a1", ""], ["e5a1", ""], ["e6a1", ""], ["e7a1", ""], ["e8a1", ""], ["e9a1", ""], ["eaa1", ""], ["eba1", ""], ["eca1", ""], ["eda1", ""], ["eea1", ""], ["efa1", ""], ["f0a1", ""], ["f1a1", ""], ["f2a1", ""], ["f3a1", ""], ["f4a1", ""], ["f9a1", ""], ["faa1", ""], ["fba1", ""], ["fca1", ""], ["fcf1", "", 9, ""], ["8fa2af", ""], ["8fa2c2", ""], ["8fa2eb", ""], ["8fa6e1", ""], ["8fa6e7", ""], ["8fa6e9", ""], ["8fa6ec", ""], ["8fa6f1", ""], ["8fa7c2", "", 10, ""], ["8fa7f2", "", 10, ""], ["8fa9a1", ""], ["8fa9a4", ""], ["8fa9a6", ""], ["8fa9a8", ""], ["8fa9ab", ""], ["8fa9af", ""], ["8fa9c1", ""], ["8faaa1", ""], ["8faaba", ""], ["8faba1", ""], ["8fabbd", ""], ["8fabc5", ""], ["8fb0a1", ""], ["8fb1a1", ""], ["8fb2a1", "", 4, ""], ["8fb3a1", ""], ["8fb4a1", ""], ["8fb5a1", ""], ["8fb6a1", "", 5, "", 4, ""], ["8fb7a1", "", 4, ""], ["8fb8a1", ""], ["8fb9a1", ""], ["8fbaa1", "", 4, ""], ["8fbba1", ""], ["8fbca1", "", 4, ""], ["8fbda1", "", 4, ""], ["8fbea1", "", 4, ""], ["8fbfa1", ""], ["8fc0a1", ""], ["8fc1a1", ""], ["8fc2a1", ""], ["8fc3a1", "", 4, ""], ["8fc4a1", ""], ["8fc5a1", ""], ["8fc6a1", ""], ["8fc7a1", ""], ["8fc8a1", ""], ["8fc9a1", "", 4, "", 4, ""], ["8fcaa1", ""], ["8fcba1", ""], ["8fcca1", "", 9, ""], ["8fcda1", "", 5, ""], ["8fcea1", "", 6, ""], ["8fcfa1", ""], ["8fd0a1", ""], ["8fd1a1", ""], ["8fd2a1", "", 5], ["8fd3a1", ""], ["8fd4a1", "", 4, ""], ["8fd5a1", ""], ["8fd6a1", ""], ["8fd7a1", ""], ["8fd8a1", ""], ["8fd9a1", "", 4, "", 6, ""], ["8fdaa1", "", 4, ""], ["8fdba1", "", 6, ""], ["8fdca1", "", 4, ""], ["8fdda1", "", 4, ""], ["8fdea1", "", 4, ""], ["8fdfa1", ""], ["8fe0a1", ""], ["8fe1a1", "", 4, ""], ["8fe2a1", ""], ["8fe3a1", "", 5, "", 4, ""], ["8fe4a1", "", 4, ""], ["8fe5a1", "", 4, ""], ["8fe6a1", ""], ["8fe7a1", ""], ["8fe8a1", "", 4, ""], ["8fe9a1", "", 4], ["8feaa1", "", 4, ""], ["8feba1", "", 4, ""], ["8feca1", ""], ["8feda1", "", 4, "", 4, ""]];
  return module.exports;
});
$__System.registerDynamic("149", [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = [["0", "\u0000", 127, ""], ["8140", "", 5, "", 9, "", 6, ""], ["8180", "", 6, "", 4, "", 4, "", 5, ""], ["8240", "", 4, "", 8, "", 4, "", 11], ["8280", "", 10, "", 4, "", 7, "", 5, "", 8, "", 20, "", 4, "", 6, ""], ["8340", "", 17, "", 5, "", 10, "", 4, "", 9, ""], ["8380", "", 5, "", 13, "", 28, "", 4, "", 4, "", 5], ["8440", "", 5, "", 5, ""], ["8480", "", 9, "", 4, "", 6, "", 6, "", 9, "", 5, "", 10, "", 7, ""], ["8540", "", 9, ""], ["8580", "", 4, "", 6, "", 4, "", 4, "", 7, ""], ["8640", "", 4, "", 5, "", 4, "", 5, ""], ["8680", "", 4, "", 4, "", 5, "", 6, "", 8, "", 4, "", 4, "", 4, ""], ["8740", "", 7, "", 11, "", 4, "", 4], ["8780", "", 7, "", 6, "", 14, "", 10, "", 6, "", 12, "", 8, "", 5, "", 6], ["8840", "", 9, "", 4, "", 4, ""], ["8880", "", 4, "", 6, "", 8, "", 6, "", 7, "", 4, "", 4, "", 7], ["8940", "", 5, "", 6, "", 4, "", 5, "", 4, "", 16, ""], ["8980", "", 4, "", 4, "", 7, "", 17, "", 10, "", 13, "", 5, "", 7, "", 4, ""], ["8a40", "", 4, "", 12, ""], ["8a80", "", 5, "", 6, "", 4, "", 11, "", 6, "", 4, "", 4, "", 9, "", 5], ["8b40", "", 8, "", 17, "", 6, "", 13, ""], ["8b80", "", 4, "", 4, "", 5, "", 4, "", 4, "", 22, "", 11, "", 25, "", 7, "", 6], ["8c40", "", 7, ""], ["8c80", "", 8, "", 4, "", 6, "", 6, "", 6, "", 4, "", 4, "", 4], ["8d40", "", 5, "", 5, "", 5, "", 6, "", 9, "", 4], ["8d80", "", 5, "", 4, "", 4, "", 4, "", 7, "", 7, "", 10, "", 10, "", 12, "", 21, ""], ["8e40", "", 21, "", 12, "", 6, "", 12, ""], ["8e80", "", 4, "", 7, "", 4, "", 4, "", 5, "", 6, "", 4, "", 14, "", 4, "", 4, "", 6], ["8f40", "", 5, "", 11, "", 8, ""], ["8f80", "", 6, "", 14, "", 5, "", 5, "", 4, ""], ["9040", "", 4, "", 4, "", 6, ""], ["9080", "", 7, "", 4, "", 4, "", 4, "", 4, "", 18, "", 6], ["9140", "", 6, "", 6, "", 18, "", 4, ""], ["9180", "", 6, "", 8, "", 9, "", 5, "", 4, "", 4, "", 16, "", 13, "", 8, "", 5, "", 4, ""], ["9240", "", 6, "", 5, ""], ["9280", "", 5, "", 7, "", 6, ""], ["9340", "", 6, "", 4, "", 4, "", 5, ""], ["9380", "", 5, "", 4, "", 6, "", 4, "", 7, "", 9, "", 6, "", 8, "", 4, "", 6, ""], ["9440", "", 24, "", 7, "", 7, "", 4, "", 8], ["9480", "", 4, "", 4, "", 14, "", 7, "", 7, ""], ["9540", "", 4, "", 4, "", 6, ""], ["9580", "", 4, "", 4, "", 8, "", 4, "", 4, "", 25, "", 7, "", 5, ""], ["9640", "", 5, "", 4, ""], ["9680", "", 7, "", 9, "", 7, "", 4, "", 6, "", 6, "", 5], ["9740", "", 7, "", 8, "", 7, "", 9, ""], ["9780", "", 6, "", 5, "", 4, "", 9, "", 4, "", 11, "", 7, "", 16, ""], ["9840", "", 4, "", 5, "", 9, ""], ["9880", "", 7, "", 5, "", 11, "", 9, "", 9, "", 11, "", 5, "", 5, "", 6, "", 4, "", 7, "", 6, ""], ["9940", "", 4, "", 10, "", 6, "", 8, "", 4, "", 7, "", 5], ["9980", "", 114, "", 6], ["9a40", "", 11, "", 7, "", 13, ""], ["9a80", "", 4, "", 7, "", 7, "", 6, "", 4, "", 4, "", 7, "", 6, "", 4, "", 4, ""], ["9b40", "", 4, ""], ["9b80", "", 5, "", 4, "", 4, "", 5, ""], ["9c40", "", 7, ""], ["9c80", "", 7, "", 7, "", 10, "", 14, "", 4, "", 6, "", 5], ["9d40", "", 7, "", 4, "", 9, "", 6, ""], ["9d80", "", 9, "", 5, "", 6, "", 12, "", 4, "", 10, "", 5, "", 5, "", 6, "", 10, ""], ["9e40", "", 7, "", 32, "", 7, "", 6, "", 6], ["9e80", "", 9, "", 17, "", 13, "", 11, "", 12, "", 12, ""], ["9f40", "", 6, "", 10, "", 4, "", 10, "", 7, ""], ["9f80", "", 13, "", 12, "", 4, "", 4, "", 5, "", 4, "", 4, "", 6, "", 5, "", 8, "", 9, "", 4], ["a040", "", 9, "", 5, "", 9, "", 11, "", 19], ["a080", "", 9, "", 6, "", 4, "", 11, "", 11, "", 6, ""], ["a1a1", "", 7, ""], ["a2a1", "", 9], ["a2b1", "", 19, "", 19, "", 9], ["a2e5", "", 9], ["a2f1", "", 11], ["a3a1", "", 88, ""], ["a4a1", "", 82], ["a5a1", "", 85], ["a6a1", "", 16, "", 6], ["a6c1", "", 16, "", 6], ["a6e0", ""], ["a6ee", ""], ["a6f4", ""], ["a7a1", "", 5, "", 25], ["a7d1", "", 5, "", 25], ["a840", "", 35, "", 6], ["a880", "", 7, ""], ["a8a1", ""], ["a8bd", ""], ["a8c0", ""], ["a8c5", "", 36], ["a940", "", 8, ""], ["a959", ""], ["a95c", ""], ["a960", "", 9, "", 8], ["a980", "", 4, ""], ["a996", ""], ["a9a4", "", 75], ["aa40", "", 5, "", 5, "", 8], ["aa80", "", 7, "", 10, ""], ["ab40", "", 11, "", 4, "", 5, "", 4], ["ab80", "", 6, "", 4], ["ac40", "", 10, "", 8, "", 5, "", 4, "", 11], ["ac80", "", 6, "", 12, "", 4, ""], ["ad40", "", 10, "", 7, "", 15, "", 12], ["ad80", "", 9, "", 8, "", 6, ""], ["ae40", "", 6, "", 7, "", 4, ""], ["ae80", "", 7, "", 6, "", 4, ""], ["af40", "", 4, ""], ["af80", ""], ["b040", "", 6, "", 5, "", 4, "", 6, "", 7, ""], ["b080", "", 7, "", 8, "", 9, ""], ["b140", "", 4, "", 7, "", 10, ""], ["b180", "", 4, "", 7, "", 7, ""], ["b240", "", 11, "", 5, "", 11, "", 4], ["b280", "", 12, "", 8, "", 4, ""], ["b340", "", 5, ""], ["b380", "", 11, "", 7, "", 6, ""], ["b440", "", 7, "", 9], ["b480", "", 4, "", 5, "", 6, ""], ["b540", "", 5, "", 9, "", 4, "", 14, "", 4, "", 8, ""], ["b580", "", 6, "", 4, ""], ["b640", "", 6, "", 11, "", 10, "", 4, "", 5, ""], ["b680", "", 6, "", 4, ""], ["b740", "", 14, "", 5, "", 9, "", 4, "", 16], ["b780", "", 6, ""], ["b840", "", 4, "", 10, "", 10, "", 9, "", 5, ""], ["b880", "", 4, ""], ["b940", "", 5, "", 10, "", 6, ""], ["b980", "", 7, ""], ["ba40", "", 4, "", 4, "", 7, "", 5, ""], ["ba80", "", 4, "", 5, "", 12, "", 5, ""], ["bb40", "", 9, "", 36, "", 5, "", 9], ["bb80", "", 6, "", 4, ""], ["bc40", "", 6, "", 6, "", 5, "", 7, "", 13, "", 5], ["bc80", "", 14, "", 6, ""], ["bd40", "", 54, "", 7], ["bd80", "", 32, ""], ["be40", "", 12, "", 6, "", 42], ["be80", "", 32, ""], ["bf40", "", 62], ["bf80", "", 4, "", 4, "", 21, ""], ["c040", "", 35, "", 23, ""], ["c080", "", 6, "", 9, ""], ["c140", "", 4, "", 7, "", 4, "", 4, "", 6, ""], ["c180", "", 4, "", 4, "", 5, ""], ["c240", "", 6, "", 5, ""], ["c280", "", 13, "", 5, "", 11, ""], ["c340", "", 5, "", 4, "", 6, ""], ["c380", "", 12, "", 4, ""], ["c440", "", 5, "", 4, "", 4, "", 5, "", 4, ""], ["c480", "", 7, "", 5, "", 6, ""], ["c540", "", 14, "", 4, "", 5, "", 4, "", 5, ""], ["c580", "", 7, "", 7, ""], ["c640", ""], ["c680", "", 4, "", 9, ""], ["c740", "", 4, "", 4, "", 6, "", 6, "", 6, ""], ["c780", ""], ["c840", "", 4, "", 5, "", 5, "", 7, "", 5, "", 7, ""], ["c880", "", 6, "", 4, "", 4, ""], ["c940", "", 4, "", 7, "", 12, ""], ["c980", "", 4, "", 4, "", 10, ""], ["ca40", "", 8, "", 8, "", 9, "", 4, "", 10], ["ca80", "", 4, "", 8, ""], ["cb40", "", 6, "", 10, "", 6, "", 5, "", 6, "", 6, "", 4, ""], ["cb80", "", 5, "", 6, "", 14, ""], ["cc40", "", 4, "", 10, "", 15, "", 13, ""], ["cc80", "", 11, "", 4, "", 7, ""], ["cd40", "", 6, "", 6, "", 4, "", 5, "", 4, "", 4, ""], ["cd80", ""], ["ce40", "", 6, "", 5, "", 7, ""], ["ce80", "", 4, "", 6, "", 4, ""], ["cf40", "", 4, "", 4, "", 6, "", 9], ["cf80", "", 5, "", 7, "", 4, ""], ["d040", "", 13, "", 5, "", 5, "", 5, "", 6, ""], ["d080", "", 4, "", 4, "", 5, ""], ["d140", "", 4, "", 4, "", 6, "", 5], ["d180", "", 4, "", 4, "", 4, ""], ["d240", "", 8, "", 24, "", 5, "", 19, ""], ["d280", "", 26, ""], ["d340", "", 30, "", 6], ["d380", "", 4, "", 5, "", 21, ""], ["d440", "", 31, "", 8, "", 21], ["d480", "", 25, "", 6, ""], ["d540", "", 7, "", 7, "", 46], ["d580", "", 32, ""], ["d640", "", 34, "", 27], ["d680", "", 30, ""], ["d740", "", 31, "", 4, "", 25], ["d780", "", 24, ""], ["d840", "", 8, "", 7, "", 5, "", 6, "", 6, "", 6, ""], ["d880", "", 6, "", 20, ""], ["d940", "", 62], ["d980", "", 32, ""], ["da40", "", 14, "", 8, "", 4, "", 9, ""], ["da80", "", 12, ""], ["db40", "", 6, "", 7, "", 4, ""], ["db80", "", 4, "", 5, "", 11, ""], ["dc40", "", 4, "", 6, "", 6, "", 11, "", 6, "", 7], ["dc80", "", 10, "", 21, ""], ["dd40", "", 62], ["dd80", "", 32, ""], ["de40", "", 32, ""], ["de80", "", 4, ""], ["df40", "", 5, "", 4, "", 4, "", 5, "", 4, "", 6, ""], ["df80", "", 4, ""], ["e040", "", 19, ""], ["e080", "", 10, "", 6, "", 8, ""], ["e140", "", 4, "", 6, "", 5, "", 5, ""], ["e180", "", 10, "", 9, "", 8, ""], ["e240", "", 62], ["e280", "", 32, "", 5, ""], ["e340", "", 45, "", 16], ["e380", "", 7, "", 24, ""], ["e440", "", 5, "", 24, "", 31], ["e480", "", 32, ""], ["e540", "", 51, "", 10], ["e580", "", 31, ""], ["e640", "", 34, "", 27], ["e680", "", 29, ""], ["e740", "", 7, "", 54], ["e780", "", 32, "", 6, "", 4, ""], ["e840", "", 14, "", 43, ""], ["e880", "", 20, ""], ["e940", "", 7, "", 42], ["e980", "", 32, ""], ["ea40", "", 27, "", 6, ""], ["ea80", "", 4, "", 12, ""], ["eb40", "", 9, "", 7, "", 9, "", 6, ""], ["eb80", "", 4, ""], ["ec40", "", 8, "", 4, "", 18, "", 7], ["ec80", "", 4, "", 7, "", 4, "", 4, ""], ["ed40", "", 6, "", 46], ["ed80", "", 4, "", 23, ""], ["ee40", "", 62], ["ee80", "", 32, "", 4, "", 6, ""], ["ef40", "", 5, "", 37, "", 4], ["ef80", "", 30, "", 4, "", 8, ""], ["f040", "", 4, "", 28, "", 26], ["f080", "", 9, "", 12, "", 4, "", 6, ""], ["f140", "", 10, "", 47], ["f180", "", 32, ""], ["f240", "", 62], ["f280", "", 32, ""], ["f340", "", 17, "", 6, "", 4, ""], ["f380", "", 8, "", 6, ""], ["f440", "", 5, "", 10, "", 10, "", 7, "", 5], ["f480", "", 32, ""], ["f540", "", 62], ["f580", "", 32, ""], ["f640", "", 62], ["f680", "", 32, "", 5, "", 5, "", 4, "", 7, ""], ["f740", "", 62], ["f780", "", 4, "", 4, ""], ["f840", "", 62], ["f880", "", 32], ["f940", "", 62], ["f980", "", 32], ["fa40", "", 62], ["fa80", "", 32], ["fb40", "", 27, "", 9, ""], ["fb80", "", 5, "", 8, "", 5, ""], ["fc40", "", 8, "", 4, "", 8, "", 6], ["fc80", "", 4, "", 5, "", 8, ""], ["fd40", "", 4, "", 4, "", 10, "", 38], ["fd80", "", 5, "", 11, "", 4, ""], ["fe40", ""]];
  return module.exports;
});
$__System.registerDynamic("14a", [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = [["a140", "", 62], ["a180", "", 32], ["a240", "", 62], ["a280", "", 32], ["a2ab", "", 5], ["a2e3", ""], ["a2ef", ""], ["a2fd", ""], ["a340", "", 62], ["a380", "", 31, ""], ["a440", "", 62], ["a480", "", 32], ["a4f4", "", 10], ["a540", "", 62], ["a580", "", 32], ["a5f7", "", 7], ["a640", "", 62], ["a680", "", 32], ["a6b9", "", 7], ["a6d9", "", 6], ["a6ec", ""], ["a6f3", ""], ["a6f6", "", 8], ["a740", "", 62], ["a780", "", 32], ["a7c2", "", 14], ["a7f2", "", 12], ["a896", "", 10], ["a8bc", ""], ["a8bf", ""], ["a8c1", ""], ["a8ea", "", 20], ["a958", ""], ["a95b", ""], ["a95d", ""], ["a989", "", 11], ["a997", "", 12], ["a9f0", "", 14], ["aaa1", "", 93], ["aba1", "", 93], ["aca1", "", 93], ["ada1", "", 93], ["aea1", "", 93], ["afa1", "", 93], ["d7fa", "", 4], ["f8a1", "", 93], ["f9a1", "", 93], ["faa1", "", 93], ["fba1", "", 93], ["fca1", "", 93], ["fda1", "", 93], ["fe50", ""], ["fe80", "", 6, "", 93]];
  return module.exports;
});
$__System.registerDynamic("14b", [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = { "uChars": [128, 165, 169, 178, 184, 216, 226, 235, 238, 244, 248, 251, 253, 258, 276, 284, 300, 325, 329, 334, 364, 463, 465, 467, 469, 471, 473, 475, 477, 506, 594, 610, 712, 716, 730, 930, 938, 962, 970, 1026, 1104, 1106, 8209, 8215, 8218, 8222, 8231, 8241, 8244, 8246, 8252, 8365, 8452, 8454, 8458, 8471, 8482, 8556, 8570, 8596, 8602, 8713, 8720, 8722, 8726, 8731, 8737, 8740, 8742, 8748, 8751, 8760, 8766, 8777, 8781, 8787, 8802, 8808, 8816, 8854, 8858, 8870, 8896, 8979, 9322, 9372, 9548, 9588, 9616, 9622, 9634, 9652, 9662, 9672, 9676, 9680, 9702, 9735, 9738, 9793, 9795, 11906, 11909, 11913, 11917, 11928, 11944, 11947, 11951, 11956, 11960, 11964, 11979, 12284, 12292, 12312, 12319, 12330, 12351, 12436, 12447, 12535, 12543, 12586, 12842, 12850, 12964, 13200, 13215, 13218, 13253, 13263, 13267, 13270, 13384, 13428, 13727, 13839, 13851, 14617, 14703, 14801, 14816, 14964, 15183, 15471, 15585, 16471, 16736, 17208, 17325, 17330, 17374, 17623, 17997, 18018, 18212, 18218, 18301, 18318, 18760, 18811, 18814, 18820, 18823, 18844, 18848, 18872, 19576, 19620, 19738, 19887, 40870, 59244, 59336, 59367, 59413, 59417, 59423, 59431, 59437, 59443, 59452, 59460, 59478, 59493, 63789, 63866, 63894, 63976, 63986, 64016, 64018, 64021, 64025, 64034, 64037, 64042, 65074, 65093, 65107, 65112, 65127, 65132, 65375, 65510, 65536], "gbChars": [0, 36, 38, 45, 50, 81, 89, 95, 96, 100, 103, 104, 105, 109, 126, 133, 148, 172, 175, 179, 208, 306, 307, 308, 309, 310, 311, 312, 313, 341, 428, 443, 544, 545, 558, 741, 742, 749, 750, 805, 819, 820, 7922, 7924, 7925, 7927, 7934, 7943, 7944, 7945, 7950, 8062, 8148, 8149, 8152, 8164, 8174, 8236, 8240, 8262, 8264, 8374, 8380, 8381, 8384, 8388, 8390, 8392, 8393, 8394, 8396, 8401, 8406, 8416, 8419, 8424, 8437, 8439, 8445, 8482, 8485, 8496, 8521, 8603, 8936, 8946, 9046, 9050, 9063, 9066, 9076, 9092, 9100, 9108, 9111, 9113, 9131, 9162, 9164, 9218, 9219, 11329, 11331, 11334, 11336, 11346, 11361, 11363, 11366, 11370, 11372, 11375, 11389, 11682, 11686, 11687, 11692, 11694, 11714, 11716, 11723, 11725, 11730, 11736, 11982, 11989, 12102, 12336, 12348, 12350, 12384, 12393, 12395, 12397, 12510, 12553, 12851, 12962, 12973, 13738, 13823, 13919, 13933, 14080, 14298, 14585, 14698, 15583, 15847, 16318, 16434, 16438, 16481, 16729, 17102, 17122, 17315, 17320, 17402, 17418, 17859, 17909, 17911, 17915, 17916, 17936, 17939, 17961, 18664, 18703, 18814, 18962, 19043, 33469, 33470, 33471, 33484, 33485, 33490, 33497, 33501, 33505, 33513, 33520, 33536, 33550, 37845, 37921, 37948, 38029, 38038, 38064, 38065, 38066, 38069, 38075, 38076, 38078, 39108, 39109, 39113, 39114, 39115, 39116, 39265, 39394, 189000] };
  return module.exports;
});
$__System.registerDynamic("14c", [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = [["0", "\u0000", 127], ["8141", "", 4, "", 6, ""], ["8161", "", 9, "", 5, ""], ["8181", "", 18, "", 4, "", 6, "", 5, "", 6, "", 7, "", 7, "", 4, "", 4, ""], ["8241", "", 7, "", 5], ["8261", "", 6, "", 5, ""], ["8281", "", 7, "", 7, "", 4, "", 10, "", 5, "", 17, "", 7, "", 6, "", 7, "", 18], ["8341", "", 5, "", 5, "", 7], ["8361", "", 18, ""], ["8381", "", 4, "", 6, "", 5, "", 5, "", 46, "", 6, "", 5, "", 8], ["8441", "", 5, "", 8], ["8461", "", 18], ["8481", "", 7, "", 6, "", 5, "", 10, "", 5, "", 18, "", 5, "", 6, "", 5, "", 26, ""], ["8541", "", 5, "", 4, "", 6, "", 4], ["8561", "", 5, "", 5, "", 6, ""], ["8581", "", 6, "", 6, "", 9, "", 26, "", 29, "", 6, "", 5, ""], ["8641", "", 6, "", 5, ""], ["8661", "", 6, "", 10], ["8681", "", 22, "", 4, "", 6, "", 5, "", 6, "", 22, "", 4, ""], ["8741", "", 9, "", 15], ["8761", "", 18, ""], ["8781", "", 5, "", 7, "", 7, "", 5, "", 6, "", 5, "", 18, "", 6, "", 26, "", 6, "", 4], ["8841", "", 4, "", 5, "", 6, "", 4], ["8861", "", 4, ""], ["8881", "", 15, "", 4, "", 6, "", 5, "", 54, ""], ["8941", "", 6, "", 5, ""], ["8961", "", 10, "", 5, ""], ["8981", "", 21, "", 18, "", 18, "", 6, "", 6, "", 7, "", 15], ["8a41", "", 10, "", 6, ""], ["8a61", "", 4, "", 18, ""], ["8a81", "", 4, "", 19, "", 5, "", 7, "", 5, "", 6, "", 5, "", 4, "", 5, "", 26, ""], ["8b41", "", 5, "", 4, "", 6, ""], ["8b61", "", 6, "", 8], ["8b81", "", 52, "", 4, "", 6, "", 5, "", 18, "", 18], ["8c41", "", 15, "", 4], ["8c61", "", 6, "", 5, "", 6, "", 5], ["8c81", "", 12, "", 26, "", 50, "", 5, "", 16], ["8d41", "", 16, "", 8], ["8d61", "", 17, ""], ["8d81", "", 4, "", 33, "", 6, "", 7, "", 6, "", 9, "", 6, "", 5, "", 6, ""], ["8e41", "", 6, "", 5, "", 8], ["8e61", "", 4, "", 19], ["8e81", "", 13, "", 6, "", 4, "", 6, "", 5, "", 6, "", 5, "", 11, "", 7, "", 6, "", 5, "", 7], ["8f41", "", 7, "", 17], ["8f61", "", 7, "", 6, "", 4], ["8f81", "", 5, "", 7, "", 5, "", 6, "", 5, "", 18, "", 6, "", 26, "", 6, "", 5], ["9041", "", 6, "", 5, ""], ["9061", "", 5, "", 15], ["9081", "", 12, "", 6, "", 5, "", 4, "", 6, "", 4, "", 5, "", 11, "", 33, ""], ["9141", "", 6, "", 5], ["9161", "", 9, "", 5], ["9181", "", 20, "", 4, "", 5, "", 14, "", 33, "", 7, "", 5, "", 6], ["9241", "", 7, "", 4, ""], ["9261", "", 7, "", 7, "", 4], ["9281", "", 21, "", 18, "", 6, "", 7, "", 6, "", 35, ""], ["9341", "", 4, ""], ["9361", "", 6, "", 8], ["9381", "", 37, "", 4, "", 4, "", 6, "", 5, "", 7, "", 22, ""], ["9441", "", 5, "", 5, "", 8], ["9461", "", 5, "", 6, "", 12], ["9481", "", 5, "", 6, "", 6, "", 9, "", 22, "", 4, "", 6, "", 10, "", 6, "", 24], ["9541", "", 11, "", 5, ""], ["9561", "", 6, "", 5, ""], ["9581", "", 6, "", 35, "", 4, "", 4, "", 4, "", 6, "", 5, "", 13, "", 14], ["9641", "", 23, ""], ["9661", "", 6, "", 5, "", 8], ["9681", "", 10, "", 5, "", 13, "", 33, "", 6, "", 44], ["9741", "", 16, "", 8], ["9761", "", 17, "", 7], ["9781", "", 11, "", 5, "", 6, "", 89, ""], ["9841", "", 16, "", 5, ""], ["9861", "", 6, "", 15], ["9881", "", 21, "", 6, "", 5, "", 4, "", 6, "", 5, "", 6, "", 5, "", 6, "", 5, ""], ["9941", "", 6, "", 5, ""], ["9961", "", 6, "", 5, ""], ["9981", "", 8, "", 5, "", 4, "", 11, "", 5, "", 6, "", 6, "", 6, "", 7, "", 6, "", 5, ""], ["9a41", "", 16], ["9a61", "", 6, "", 6, ""], ["9a81", "", 4, "", 6, "", 5, "", 5, "", 6, "", 5, "", 5, "", 33, "", 5, "", 6, ""], ["9b41", "", 6, "", 8], ["9b61", "", 17, "", 7], ["9b81", "", 25, "", 4, "", 5, "", 50, "", 22, ""], ["9c41", "", 4, "", 5, "", 5], ["9c61", "", 8, "", 6, "", 9], ["9c81", "", 8, "", 6, "", 6, "", 9, "", 26, "", 6, "", 5, "", 18, "", 6, "", 12], ["9d41", "", 13, "", 8], ["9d61", "", 25], ["9d81", "", 8, "", 5, "", 9, "", 6, "", 10, "", 6, "", 5, "", 6, "", 5, ""], ["9e41", "", 7, "", 9, ""], ["9e61", "", 4, "", 6, ""], ["9e81", "", 6, "", 6, "", 6, "", 5, "", 10, "", 5, "", 6, "", 5, "", 6, ""], ["9f41", "", 5, "", 4, "", 5, ""], ["9f61", "", 6, "", 5, ""], ["9f81", "", 4, "", 5, "", 6, "", 5, "", 6, "", 4, "", 6, "", 7, "", 4, "", 4, ""], ["a041", "", 5, "", 6, ""], ["a061", "", 5, "", 13], ["a081", "", 4, "", 4, "", 4, "", 6, "", 5, "", 6, "", 5, "", 26, "", 4, "", 5, "", 7, ""], ["a141", "", 18, ""], ["a161", "", 6, "", 5, ""], ["a181", "", 14, "", 5, "", 4, "", 9, ""], ["a241", "", 5, "", 18], ["a261", "", 6, "", 18], ["a281", "", 7, "", 6, "", 7, ""], ["a341", "", 6, "", 10, ""], ["a361", "", 6, "", 16], ["a381", "", 16, "", 4, "", 58, "", 32, ""], ["a441", "", 5, ""], ["a461", "", 5, "", 12], ["a481", "", 28, "", 93], ["a541", "", 4, "", 6, "", 5, ""], ["a561", "", 17, "", 5, ""], ["a581", "", 16, "", 14, "", 9], ["a5b0", "", 9], ["a5c1", "", 16, "", 6], ["a5e1", "", 16, "", 6], ["a641", "", 19, ""], ["a661", "", 5, "", 5, "", 6], ["a681", "", 6, "", 18, "", 7], ["a741", "", 4, "", 6, "", 7], ["a761", "", 22, ""], ["a781", "", 6, "", 5, "", 7, "", 9, "", 9, "", 4, "", 5, "", 4, ""], ["a841", "", 10, "", 14], ["a861", "", 18, "", 6], ["a881", "", 19, "", 11, ""], ["a8a6", ""], ["a8a8", ""], ["a8b1", "", 27, "", 25, "", 14, ""], ["a941", "", 14, "", 10], ["a961", "", 18], ["a981", "", 14, "", 6, "", 27, "", 25, "", 14, ""], ["aa41", "", 6, "", 4, ""], ["aa61", "", 4, "", 5, "", 6, ""], ["aa81", "", 29, "", 82], ["ab41", "", 6, "", 5, ""], ["ab61", "", 6, "", 5, "", 5], ["ab81", "", 8, "", 6, "", 12, "", 85], ["ac41", "", 5, "", 6, ""], ["ac61", "", 11, "", 4], ["ac81", "", 28, "", 5, "", 25], ["acd1", "", 5, "", 25], ["ad41", "", 6, "", 5, "", 7], ["ad61", "", 6, "", 10, ""], ["ad81", "", 5, "", 18, ""], ["ae41", "", 5, "", 16], ["ae61", "", 5, "", 6, "", 4], ["ae81", "", 6, "", 5, ""], ["af41", "", 19], ["af61", "", 13, "", 5, ""], ["af81", "", 5, "", 6, "", 5, ""], ["b041", "", 5, "", 5, "", 12], ["b061", "", 5, "", 19], ["b081", "", 13, "", 6, "", 5, "", 7, "", 4, ""], ["b141", "", 6, "", 5, ""], ["b161", "", 6, "", 5, "", 11], ["b181", "", 14, "", 6, ""], ["b241", "", 6, "", 5, ""], ["b261", "", 18, "", 5, ""], ["b281", "", 5, "", 18, "", 6, ""], ["b341", "", 19, ""], ["b361", "", 5, "", 5, "", 5], ["b381", "", 5, "", 5, "", 19, "", 4, ""], ["b441", "", 5, "", 6, "", 5], ["b461", "", 6, "", 10, ""], ["b481", "", 6, "", 18, "", 4, "", 4, ""], ["b541", "", 14, "", 5], ["b561", "", 5, "", 5, "", 4], ["b581", "", 6, "", 5, "", 11, ""], ["b641", "", 7, "", 17], ["b661", "", 15, ""], ["b681", "", 5, "", 6, "", 5, ""], ["b741", "", 13, "", 6, ""], ["b761", "", 20, ""], ["b781", "", 6, "", 14, ""], ["b841", "", 7, "", 17], ["b861", "", 8, "", 13], ["b881", "", 5, "", 24, "", 4, ""], ["b941", "", 6, "", 5, ""], ["b961", "", 14, "", 6, ""], ["b981", "", 22, "", 4, "", 4, ""], ["ba41", "", 5, "", 6, ""], ["ba61", "", 5, "", 4, "", 5], ["ba81", "", 6, "", 9, ""], ["bb41", "", 4, "", 5, "", 4, ""], ["bb61", "", 6, "", 5, ""], ["bb81", "", 31, ""], ["bc41", "", 17, ""], ["bc61", "", 5, "", 6, ""], ["bc81", "", 4, "", 6, "", 5, "", 5, "", 4, ""], ["bd41", "", 7, "", 7, ""], ["bd61", "", 5, "", 13], ["bd81", "", 5, "", 25, ""], ["be41", "", 7, "", 14], ["be61", "", 7, "", 7, ""], ["be81", "", 4, "", 4, "", 5, "", 8, "", 6, ""], ["bf41", "", 10, "", 14], ["bf61", "", 18, ""], ["bf81", "", 5, "", 7, "", 6, "", 5, ""], ["c041", "", 5, "", 6, "", 5], ["c061", "", 25], ["c081", "", 6, "", 5, "", 7, ""], ["c141", "", 5, "", 6, ""], ["c161", "", 19, ""], ["c181", "", 31, ""], ["c241", "", 4, "", 5, ""], ["c261", "", 4, "", 5, "", 6, ""], ["c281", "", 5, "", 7, "", 9, ""], ["c341", "", 4], ["c361", "", 4, "", 5, "", 11], ["c381", "", 5, "", 7, "", 5, ""], ["c441", "", 7, "", 7, ""], ["c461", "", 5, "", 4], ["c481", "", 5, "", 11, ""], ["c541", "", 6, "", 5, ""], ["c561", "", 6, "", 5, "", 4], ["c581", "", 6, "", 5, ""], ["c641", "", 6, "", 5], ["c6a1", ""], ["c7a1", ""], ["c8a1", ""], ["caa1", ""], ["cba1", ""], ["cca1", ""], ["cda1", ""], ["cea1", ""], ["cfa1", ""], ["d0a1", ""], ["d1a1", "", 5, "", 4, ""], ["d2a1", "", 4, "", 5, "", 10, "", 7, "", 5, ""], ["d3a1", ""], ["d4a1", ""], ["d5a1", ""], ["d6a1", ""], ["d7a1", ""], ["d8a1", ""], ["d9a1", ""], ["daa1", ""], ["dba1", ""], ["dca1", ""], ["dda1", ""], ["dea1", ""], ["dfa1", ""], ["e0a1", ""], ["e1a1", ""], ["e2a1", ""], ["e3a1", ""], ["e4a1", ""], ["e5a1", ""], ["e6a1", ""], ["e7a1", ""], ["e8a1", ""], ["e9a1", ""], ["eaa1", ""], ["eba1", ""], ["eca1", ""], ["eda1", ""], ["eea1", ""], ["efa1", ""], ["f0a1", ""], ["f1a1", ""], ["f2a1", ""], ["f3a1", ""], ["f4a1", ""], ["f5a1", ""], ["f6a1", ""], ["f7a1", ""], ["f8a1", ""], ["f9a1", ""], ["faa1", ""], ["fba1", ""], ["fca1", ""], ["fda1", ""]];
  return module.exports;
});
$__System.registerDynamic("14d", [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = [["0", "\u0000", 127], ["a140", ""], ["a1a1", "", 4, ""], ["a240", "", 7, ""], ["a2a1", "", 9, "", 9, "", 8, "", 25, "", 21], ["a340", "", 16, "", 6, "", 16, "", 6, "", 10], ["a3a1", "", 25, ""], ["a3e1", ""], ["a440", ""], ["a4a1", ""], ["a540", ""], ["a5a1", ""], ["a640", ""], ["a6a1", ""], ["a740", ""], ["a7a1", ""], ["a840", ""], ["a8a1", ""], ["a940", ""], ["a9a1", ""], ["aa40", ""], ["aaa1", ""], ["ab40", ""], ["aba1", ""], ["ac40", ""], ["aca1", ""], ["ad40", ""], ["ada1", ""], ["ae40", ""], ["aea1", ""], ["af40", ""], ["afa1", ""], ["b040", ""], ["b0a1", ""], ["b140", ""], ["b1a1", ""], ["b240", ""], ["b2a1", ""], ["b340", ""], ["b3a1", ""], ["b440", ""], ["b4a1", ""], ["b540", ""], ["b5a1", ""], ["b640", ""], ["b6a1", ""], ["b740", ""], ["b7a1", ""], ["b840", ""], ["b8a1", ""], ["b940", ""], ["b9a1", ""], ["ba40", ""], ["baa1", ""], ["bb40", ""], ["bba1", ""], ["bc40", ""], ["bca1", ""], ["bd40", ""], ["bda1", ""], ["be40", ""], ["bea1", ""], ["bf40", ""], ["bfa1", ""], ["c040", ""], ["c0a1", ""], ["c140", ""], ["c1a1", ""], ["c240", ""], ["c2a1", ""], ["c340", ""], ["c3a1", ""], ["c440", ""], ["c4a1", ""], ["c540", ""], ["c5a1", ""], ["c640", ""], ["c940", ""], ["c9a1", ""], ["ca40", ""], ["caa1", ""], ["cb40", ""], ["cba1", ""], ["cc40", ""], ["cca1", ""], ["cd40", ""], ["cda1", ""], ["ce40", ""], ["cea1", ""], ["cf40", ""], ["cfa1", ""], ["d040", ""], ["d0a1", ""], ["d140", ""], ["d1a1", ""], ["d240", ""], ["d2a1", ""], ["d340", ""], ["d3a1", ""], ["d440", ""], ["d4a1", ""], ["d540", ""], ["d5a1", ""], ["d640", ""], ["d6a1", ""], ["d740", ""], ["d7a1", ""], ["d840", ""], ["d8a1", ""], ["d940", ""], ["d9a1", ""], ["da40", ""], ["daa1", ""], ["db40", ""], ["dba1", ""], ["dc40", ""], ["dca1", ""], ["dd40", ""], ["dda1", ""], ["de40", ""], ["dea1", ""], ["df40", ""], ["dfa1", ""], ["e040", ""], ["e0a1", ""], ["e140", ""], ["e1a1", ""], ["e240", ""], ["e2a1", ""], ["e340", ""], ["e3a1", ""], ["e440", ""], ["e4a1", ""], ["e540", ""], ["e5a1", ""], ["e640", ""], ["e6a1", ""], ["e740", ""], ["e7a1", ""], ["e840", ""], ["e8a1", ""], ["e940", ""], ["e9a1", ""], ["ea40", ""], ["eaa1", ""], ["eb40", ""], ["eba1", ""], ["ec40", ""], ["eca1", ""], ["ed40", ""], ["eda1", ""], ["ee40", ""], ["eea1", ""], ["ef40", ""], ["efa1", ""], ["f040", ""], ["f0a1", ""], ["f140", ""], ["f1a1", ""], ["f240", ""], ["f2a1", ""], ["f340", ""], ["f3a1", ""], ["f440", ""], ["f4a1", ""], ["f540", ""], ["f5a1", ""], ["f640", ""], ["f6a1", ""], ["f740", ""], ["f7a1", ""], ["f840", ""], ["f8a1", ""], ["f940", ""], ["f9a1", ""]];
  return module.exports;
});
$__System.registerDynamic("14e", [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = [["8740", ""], ["8767", ""], ["87a1", ""], ["8840", "", 4, ""], ["88a1", ""], ["8940", ""], ["8943", ""], ["8946", ""], ["894c", ""], ["89a1", ""], ["89ab", ""], ["89b0", ""], ["89b5", ""], ["89c1", ""], ["89c5", ""], ["8a40", ""], ["8a43", ""], ["8a64", ""], ["8a76", ""], ["8aa1", ""], ["8aac", ""], ["8ab2", ""], ["8abb", ""], ["8ac9", ""], ["8ace", ""], ["8adf", ""], ["8af6", ""], ["8b40", ""], ["8b55", ""], ["8ba1", ""], ["8bde", ""], ["8c40", ""], ["8ca1", ""], ["8ca7", ""], ["8cc9", ""], ["8cce", ""], ["8ce6", ""], ["8d40", ""], ["8d42", ""], ["8da1", ""], ["8e40", ""], ["8ea1", ""], ["8f40", ""], ["8fa1", ""], ["9040", ""], ["90a1", ""], ["9140", ""], ["91a1", ""], ["9240", ""], ["92a1", ""], ["9340", ""], ["93a1", ""], ["9440", ""], ["94a1", ""], ["9540", ""], ["95a1", ""], ["9640", ""], ["96a1", ""], ["9740", ""], ["97a1", ""], ["9840", ""], ["98a1", ""], ["9940", ""], ["99a1", ""], ["9a40", ""], ["9aa1", ""], ["9b40", ""], ["9b62", ""], ["9ba1", ""], ["9c40", ""], ["9ca1", ""], ["9d40", ""], ["9da1", ""], ["9e40", ""], ["9ea1", ""], ["9ead", ""], ["9ec5", ""], ["9ef5", ""], ["9f40", ""], ["9f4f", ""], ["9fa1", ""], ["9fae", ""], ["9fb2", ""], ["9fc1", ""], ["9fc9", ""], ["9fdb", ""], ["9fe7", ""], ["9feb", ""], ["9ff0", ""], ["a040", ""], ["a055", ""], ["a058", ""], ["a05b", ""], ["a063", ""], ["a073", ""], ["a0a1", ""], ["a0a6", ""], ["a0ae", ""], ["a0b0", ""], ["a0d4", ""], ["a0e2", ""], ["a3c0", "", 31, ""], ["c6a1", "", 9, "", 9, "", 9, "", 23], ["c740", "", 58, ""], ["c7a1", "", 81, "", 5, "", 4], ["c840", "", 26, "", 25, ""], ["c8a1", ""], ["c8cd", ""], ["c8f5", ""], ["f9fe", ""], ["fa40", ""], ["faa1", ""], ["fb40", ""], ["fba1", ""], ["fc40", ""], ["fca1", ""], ["fd40", ""], ["fda1", ""], ["fe40", ""], ["fea1", ""]];
  return module.exports;
});
$__System.registerDynamic('14f', ['147', '148', '149', '14a', '14b', '14c', '14d', '14e'], true, function ($__require, exports, module) {
  /* */
  "use strict";

  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = {
    'shiftjis': {
      type: '_dbcs',
      table: function () {
        return $__require('147');
      },
      encodeAdd: {
        '\u00a5': 0x5C,
        '\u203E': 0x7E
      },
      encodeSkipVals: [{
        from: 0xED40,
        to: 0xF940
      }]
    },
    'csshiftjis': 'shiftjis',
    'mskanji': 'shiftjis',
    'sjis': 'shiftjis',
    'windows31j': 'shiftjis',
    'xsjis': 'shiftjis',
    'windows932': 'shiftjis',
    '932': 'shiftjis',
    'cp932': 'shiftjis',
    'eucjp': {
      type: '_dbcs',
      table: function () {
        return $__require('148');
      },
      encodeAdd: {
        '\u00a5': 0x5C,
        '\u203E': 0x7E
      }
    },
    'gb2312': 'cp936',
    'gb231280': 'cp936',
    'gb23121980': 'cp936',
    'csgb2312': 'cp936',
    'csiso58gb231280': 'cp936',
    'euccn': 'cp936',
    'isoir58': 'gbk',
    'windows936': 'cp936',
    '936': 'cp936',
    'cp936': {
      type: '_dbcs',
      table: function () {
        return $__require('149');
      }
    },
    'gbk': {
      type: '_dbcs',
      table: function () {
        return $__require('149').concat($__require('14a'));
      }
    },
    'xgbk': 'gbk',
    'gb18030': {
      type: '_dbcs',
      table: function () {
        return $__require('149').concat($__require('14a'));
      },
      gb18030: function () {
        return $__require('14b');
      }
    },
    'chinese': 'gb18030',
    'windows949': 'cp949',
    '949': 'cp949',
    'cp949': {
      type: '_dbcs',
      table: function () {
        return $__require('14c');
      }
    },
    'cseuckr': 'cp949',
    'csksc56011987': 'cp949',
    'euckr': 'cp949',
    'isoir149': 'cp949',
    'korean': 'cp949',
    'ksc56011987': 'cp949',
    'ksc56011989': 'cp949',
    'ksc5601': 'cp949',
    'windows950': 'cp950',
    '950': 'cp950',
    'cp950': {
      type: '_dbcs',
      table: function () {
        return $__require('14d');
      }
    },
    'big5': 'big5hkscs',
    'big5hkscs': {
      type: '_dbcs',
      table: function () {
        return $__require('14d').concat($__require('14e'));
      },
      encodeSkipVals: [0xa2cc]
    },
    'cnbig5': 'big5hkscs',
    'csbig5': 'big5hkscs',
    'xxbig5': 'big5hkscs'
  };
  return module.exports;
});
$__System.registerDynamic('150', ['13f', '141', '142', '143', '144', '145', '146', '14f'], true, function ($__require, exports, module) {
  /* */
  "use strict";

  var define,
      global = this || self,
      GLOBAL = global;
  var modules = [$__require('13f'), $__require('141'), $__require('142'), $__require('143'), $__require('144'), $__require('145'), $__require('146'), $__require('14f')];
  for (var i = 0; i < modules.length; i++) {
    var module = modules[i];
    for (var enc in module) if (Object.prototype.hasOwnProperty.call(module, enc)) exports[enc] = module[enc];
  }
  return module.exports;
});
$__System.registerDynamic('151', ['13e', '150', '@empty', '2a', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer, process) {
    "use strict";

    var bomHandling = $__require('13e'),
        iconv = module.exports;
    iconv.encodings = null;
    iconv.defaultCharUnicode = '';
    iconv.defaultCharSingleByte = '?';
    iconv.encode = function encode(str, encoding, options) {
      str = "" + (str || "");
      var encoder = iconv.getEncoder(encoding, options);
      var res = encoder.write(str);
      var trail = encoder.end();
      return trail && trail.length > 0 ? Buffer.concat([res, trail]) : res;
    };
    iconv.decode = function decode(buf, encoding, options) {
      if (typeof buf === 'string') {
        if (!iconv.skipDecodeWarning) {
          console.error('Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding');
          iconv.skipDecodeWarning = true;
        }
        buf = new Buffer("" + (buf || ""), "binary");
      }
      var decoder = iconv.getDecoder(encoding, options);
      var res = decoder.write(buf);
      var trail = decoder.end();
      return trail ? res + trail : res;
    };
    iconv.encodingExists = function encodingExists(enc) {
      try {
        iconv.getCodec(enc);
        return true;
      } catch (e) {
        return false;
      }
    };
    iconv.toEncoding = iconv.encode;
    iconv.fromEncoding = iconv.decode;
    iconv._codecDataCache = {};
    iconv.getCodec = function getCodec(encoding) {
      if (!iconv.encodings) iconv.encodings = $__require('150');
      var enc = ('' + encoding).toLowerCase().replace(/[^0-9a-z]|:\d{4}$/g, "");
      var codecOptions = {};
      while (true) {
        var codec = iconv._codecDataCache[enc];
        if (codec) return codec;
        var codecDef = iconv.encodings[enc];
        switch (typeof codecDef) {
          case "string":
            enc = codecDef;
            break;
          case "object":
            for (var key in codecDef) codecOptions[key] = codecDef[key];
            if (!codecOptions.encodingName) codecOptions.encodingName = enc;
            enc = codecDef.type;
            break;
          case "function":
            if (!codecOptions.encodingName) codecOptions.encodingName = enc;
            codec = new codecDef(codecOptions, iconv);
            iconv._codecDataCache[codecOptions.encodingName] = codec;
            return codec;
          default:
            throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
        }
      }
    };
    iconv.getEncoder = function getEncoder(encoding, options) {
      var codec = iconv.getCodec(encoding),
          encoder = new codec.encoder(options, codec);
      if (codec.bomAware && options && options.addBOM) encoder = new bomHandling.PrependBOM(encoder, options);
      return encoder;
    };
    iconv.getDecoder = function getDecoder(encoding, options) {
      var codec = iconv.getCodec(encoding),
          decoder = new codec.decoder(options, codec);
      if (codec.bomAware && !(options && options.stripBOM === false)) decoder = new bomHandling.StripBOM(decoder, options);
      return decoder;
    };
    var nodeVer = typeof process !== 'undefined' && process.versions && process.versions.node;
    if (nodeVer) {
      var nodeVerArr = nodeVer.split(".").map(Number);
      if (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) {
        $__require('@empty')(iconv);
      }
      $__require('@empty')(iconv);
    }
  })($__require('2a').Buffer, $__require('13'));
  return module.exports;
});
$__System.registerDynamic("13c", ["151"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("151");
  return module.exports;
});
$__System.registerDynamic('152', ['153'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  module.exports = $__require('153');
  return module.exports;
});
$__System.registerDynamic('154', [], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  function ZStream() {
    /* next input byte */
    this.input = null; // JS specific, because we have no pointers
    this.next_in = 0;
    /* number of bytes available at input */
    this.avail_in = 0;
    /* total number of input bytes read so far */
    this.total_in = 0;
    /* next output byte should be put there */
    this.output = null; // JS specific, because we have no pointers
    this.next_out = 0;
    /* remaining free space at output */
    this.avail_out = 0;
    /* total number of bytes output so far */
    this.total_out = 0;
    /* last error message, NULL if no error */
    this.msg = '' /*Z_NULL*/;
    /* not visible by applications */
    this.state = null;
    /* best guess about the data type: binary or text */
    this.data_type = 2 /*Z_UNKNOWN*/;
    /* adler32 value of the uncompressed data */
    this.adler = 0;
  }

  module.exports = ZStream;
  return module.exports;
});
$__System.registerDynamic('155', ['156', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var utils = $__require('156');
    var Z_FIXED = 4;
    var Z_BINARY = 0;
    var Z_TEXT = 1;
    var Z_UNKNOWN = 2;
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var Buf_size = 16;
    var MAX_BL_BITS = 7;
    var END_BLOCK = 256;
    var REP_3_6 = 16;
    var REPZ_3_10 = 17;
    var REPZ_11_138 = 18;
    var extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
    var extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
    var extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
    var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var DIST_CODE_LEN = 512;
    var static_ltree = new Array((L_CODES + 2) * 2);
    zero(static_ltree);
    var static_dtree = new Array(D_CODES * 2);
    zero(static_dtree);
    var _dist_code = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero(_length_code);
    var base_length = new Array(LENGTH_CODES);
    zero(base_length);
    var base_dist = new Array(D_CODES);
    zero(base_dist);
    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    }
    function d_code(dist) {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    }
    function put_short(s, w) {
      s.pending_buf[s.pending++] = w & 0xff;
      s.pending_buf[s.pending++] = w >>> 8 & 0xff;
    }
    function send_bits(s, value, length) {
      if (s.bi_valid > Buf_size - length) {
        s.bi_buf |= value << s.bi_valid & 0xffff;
        put_short(s, s.bi_buf);
        s.bi_buf = value >> Buf_size - s.bi_valid;
        s.bi_valid += length - Buf_size;
      } else {
        s.bi_buf |= value << s.bi_valid & 0xffff;
        s.bi_valid += length;
      }
    }
    function send_code(s, c, tree) {
      send_bits(s, tree[c * 2], tree[c * 2 + 1]);
    }
    function bi_reverse(code, len) {
      var res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    }
    function bi_flush(s) {
      if (s.bi_valid === 16) {
        put_short(s, s.bi_buf);
        s.bi_buf = 0;
        s.bi_valid = 0;
      } else if (s.bi_valid >= 8) {
        s.pending_buf[s.pending++] = s.bi_buf & 0xff;
        s.bi_buf >>= 8;
        s.bi_valid -= 8;
      }
    }
    function gen_bitlen(s, desc) {
      var tree = desc.dyn_tree;
      var max_code = desc.max_code;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var extra = desc.stat_desc.extra_bits;
      var base = desc.stat_desc.extra_base;
      var max_length = desc.stat_desc.max_length;
      var h;
      var n, m;
      var bits;
      var xbits;
      var f;
      var overflow = 0;
      for (bits = 0; bits <= MAX_BITS; bits++) {
        s.bl_count[bits] = 0;
      }
      tree[s.heap[s.heap_max] * 2 + 1] = 0;
      for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
        n = s.heap[h];
        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n * 2 + 1] = bits;
        if (n > max_code) {
          continue;
        }
        s.bl_count[bits]++;
        xbits = 0;
        if (n >= base) {
          xbits = extra[n - base];
        }
        f = tree[n * 2];
        s.opt_len += f * (bits + xbits);
        if (has_stree) {
          s.static_len += f * (stree[n * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s.bl_count[bits] === 0) {
          bits--;
        }
        s.bl_count[bits]--;
        s.bl_count[bits + 1] += 2;
        s.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n = s.bl_count[bits];
        while (n !== 0) {
          m = s.heap[--h];
          if (m > max_code) {
            continue;
          }
          if (tree[m * 2 + 1] !== bits) {
            s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
            tree[m * 2 + 1] = bits;
          }
          n--;
        }
      }
    }
    function gen_codes(tree, max_code, bl_count) {
      var next_code = new Array(MAX_BITS + 1);
      var code = 0;
      var bits;
      var n;
      for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code = code + bl_count[bits - 1] << 1;
      }
      for (n = 0; n <= max_code; n++) {
        var len = tree[n * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n * 2] = bi_reverse(next_code[len]++, len);
      }
    }
    function tr_static_init() {
      var n;
      var bits;
      var length;
      var code;
      var dist;
      var bl_count = new Array(MAX_BITS + 1);
      length = 0;
      for (code = 0; code < LENGTH_CODES - 1; code++) {
        base_length[code] = length;
        for (n = 0; n < 1 << extra_lbits[code]; n++) {
          _length_code[length++] = code;
        }
      }
      _length_code[length - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < 1 << extra_dbits[code]; n++) {
          _dist_code[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
          _dist_code[256 + dist++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS; bits++) {
        bl_count[bits] = 0;
      }
      n = 0;
      while (n <= 143) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      while (n <= 255) {
        static_ltree[n * 2 + 1] = 9;
        n++;
        bl_count[9]++;
      }
      while (n <= 279) {
        static_ltree[n * 2 + 1] = 7;
        n++;
        bl_count[7]++;
      }
      while (n <= 287) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES + 1, bl_count);
      for (n = 0; n < D_CODES; n++) {
        static_dtree[n * 2 + 1] = 5;
        static_dtree[n * 2] = bi_reverse(n, 5);
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
    }
    function init_block(s) {
      var n;
      for (n = 0; n < L_CODES; n++) {
        s.dyn_ltree[n * 2] = 0;
      }
      for (n = 0; n < D_CODES; n++) {
        s.dyn_dtree[n * 2] = 0;
      }
      for (n = 0; n < BL_CODES; n++) {
        s.bl_tree[n * 2] = 0;
      }
      s.dyn_ltree[END_BLOCK * 2] = 1;
      s.opt_len = s.static_len = 0;
      s.last_lit = s.matches = 0;
    }
    function bi_windup(s) {
      if (s.bi_valid > 8) {
        put_short(s, s.bi_buf);
      } else if (s.bi_valid > 0) {
        s.pending_buf[s.pending++] = s.bi_buf;
      }
      s.bi_buf = 0;
      s.bi_valid = 0;
    }
    function copy_block(s, buf, len, header) {
      bi_windup(s);
      if (header) {
        put_short(s, len);
        put_short(s, ~len);
      }
      utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
      s.pending += len;
    }
    function smaller(tree, n, m, depth) {
      var _n2 = n * 2;
      var _m2 = m * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
    }
    function pqdownheap(s, tree, k) {
      var v = s.heap[k];
      var j = k << 1;
      while (j <= s.heap_len) {
        if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
          j++;
        }
        if (smaller(tree, v, s.heap[j], s.depth)) {
          break;
        }
        s.heap[k] = s.heap[j];
        k = j;
        j <<= 1;
      }
      s.heap[k] = v;
    }
    function compress_block(s, ltree, dtree) {
      var dist;
      var lc;
      var lx = 0;
      var code;
      var extra;
      if (s.last_lit !== 0) {
        do {
          dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
          lc = s.pending_buf[s.l_buf + lx];
          lx++;
          if (dist === 0) {
            send_code(s, lc, ltree);
          } else {
            code = _length_code[lc];
            send_code(s, code + LITERALS + 1, ltree);
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc -= base_length[code];
              send_bits(s, lc, extra);
            }
            dist--;
            code = d_code(dist);
            send_code(s, code, dtree);
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist -= base_dist[code];
              send_bits(s, dist, extra);
            }
          }
        } while (lx < s.last_lit);
      }
      send_code(s, END_BLOCK, ltree);
    }
    function build_tree(s, desc) {
      var tree = desc.dyn_tree;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var elems = desc.stat_desc.elems;
      var n, m;
      var max_code = -1;
      var node;
      s.heap_len = 0;
      s.heap_max = HEAP_SIZE;
      for (n = 0; n < elems; n++) {
        if (tree[n * 2] !== 0) {
          s.heap[++s.heap_len] = max_code = n;
          s.depth[n] = 0;
        } else {
          tree[n * 2 + 1] = 0;
        }
      }
      while (s.heap_len < 2) {
        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s.depth[node] = 0;
        s.opt_len--;
        if (has_stree) {
          s.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n = s.heap_len >> 1; n >= 1; n--) {
        pqdownheap(s, tree, n);
      }
      node = elems;
      do {
        n = s.heap[1];
        s.heap[1] = s.heap[s.heap_len--];
        pqdownheap(s, tree, 1);
        m = s.heap[1];
        s.heap[--s.heap_max] = n;
        s.heap[--s.heap_max] = m;
        tree[node * 2] = tree[n * 2] + tree[m * 2];
        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
        tree[n * 2 + 1] = tree[m * 2 + 1] = node;
        s.heap[1] = node++;
        pqdownheap(s, tree, 1);
      } while (s.heap_len >= 2);
      s.heap[--s.heap_max] = s.heap[1];
      gen_bitlen(s, desc);
      gen_codes(tree, max_code, s.bl_count);
    }
    function scan_tree(s, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 0xffff;
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s.bl_tree[curlen * 2]++;
          }
          s.bl_tree[REP_3_6 * 2]++;
        } else if (count <= 10) {
          s.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s.bl_tree[REPZ_11_138 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function send_tree(s, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code(s, curlen, s.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s, curlen, s.bl_tree);
            count--;
          }
          send_code(s, REP_3_6, s.bl_tree);
          send_bits(s, count - 3, 2);
        } else if (count <= 10) {
          send_code(s, REPZ_3_10, s.bl_tree);
          send_bits(s, count - 3, 3);
        } else {
          send_code(s, REPZ_11_138, s.bl_tree);
          send_bits(s, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function build_bl_tree(s) {
      var max_blindex;
      scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
      scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
      build_tree(s, s.bl_desc);
      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    }
    function send_all_trees(s, lcodes, dcodes, blcodes) {
      var rank;
      send_bits(s, lcodes - 257, 5);
      send_bits(s, dcodes - 1, 5);
      send_bits(s, blcodes - 4, 4);
      for (rank = 0; rank < blcodes; rank++) {
        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
      }
      send_tree(s, s.dyn_ltree, lcodes - 1);
      send_tree(s, s.dyn_dtree, dcodes - 1);
    }
    function detect_data_type(s) {
      var black_mask = 0xf3ffc07f;
      var n;
      for (n = 0; n <= 31; n++, black_mask >>>= 1) {
        if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
          return Z_BINARY;
        }
      }
      if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT;
      }
      for (n = 32; n < LITERALS; n++) {
        if (s.dyn_ltree[n * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    }
    var static_init_done = false;
    function _tr_init(s) {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
      s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
      s.bi_buf = 0;
      s.bi_valid = 0;
      init_block(s);
    }
    function _tr_stored_block(s, buf, stored_len, last) {
      send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
      copy_block(s, buf, stored_len, true);
    }
    function _tr_align(s) {
      send_bits(s, STATIC_TREES << 1, 3);
      send_code(s, END_BLOCK, static_ltree);
      bi_flush(s);
    }
    function _tr_flush_block(s, buf, stored_len, last) {
      var opt_lenb, static_lenb;
      var max_blindex = 0;
      if (s.level > 0) {
        if (s.strm.data_type === Z_UNKNOWN) {
          s.strm.data_type = detect_data_type(s);
        }
        build_tree(s, s.l_desc);
        build_tree(s, s.d_desc);
        max_blindex = build_bl_tree(s);
        opt_lenb = s.opt_len + 3 + 7 >>> 3;
        static_lenb = s.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block(s, buf, stored_len, last);
      } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
        compress_block(s, static_ltree, static_dtree);
      } else {
        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s, s.dyn_ltree, s.dyn_dtree);
      }
      init_block(s);
      if (last) {
        bi_windup(s);
      }
    }
    function _tr_tally(s, dist, lc) {
      s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 0xff;
      s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;
      s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
      s.last_lit++;
      if (dist === 0) {
        s.dyn_ltree[lc * 2]++;
      } else {
        s.matches++;
        dist--;
        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
        s.dyn_dtree[d_code(dist) * 2]++;
      }
      return s.last_lit === s.lit_bufsize - 1;
    }
    exports._tr_init = _tr_init;
    exports._tr_stored_block = _tr_stored_block;
    exports._tr_flush_block = _tr_flush_block;
    exports._tr_tally = _tr_tally;
    exports._tr_align = _tr_align;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('157', [], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = {
    2: 'need dictionary', /* Z_NEED_DICT       2  */
    1: 'stream end', /* Z_STREAM_END      1  */
    0: '', /* Z_OK              0  */
    '-1': 'file error', /* Z_ERRNO         (-1) */
    '-2': 'stream error', /* Z_STREAM_ERROR  (-2) */
    '-3': 'data error', /* Z_DATA_ERROR    (-3) */
    '-4': 'insufficient memory', /* Z_MEM_ERROR     (-4) */
    '-5': 'buffer error', /* Z_BUF_ERROR     (-5) */
    '-6': 'incompatible version' /* Z_VERSION_ERROR (-6) */
  };
  return module.exports;
});
$__System.registerDynamic('158', ['156', '155', '159', '15a', '157', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    'use strict';

    var utils = $__require('156');
    var trees = $__require('155');
    var adler32 = $__require('159');
    var crc32 = $__require('15a');
    var msg = $__require('157');
    var Z_NO_FLUSH = 0;
    var Z_PARTIAL_FLUSH = 1;
    var Z_FULL_FLUSH = 3;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_BUF_ERROR = -5;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_FILTERED = 1;
    var Z_HUFFMAN_ONLY = 2;
    var Z_RLE = 3;
    var Z_FIXED = 4;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_UNKNOWN = 2;
    var Z_DEFLATED = 8;
    var MAX_MEM_LEVEL = 9;
    var MAX_WBITS = 15;
    var DEF_MEM_LEVEL = 8;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    var PRESET_DICT = 0x20;
    var INIT_STATE = 42;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    var BS_NEED_MORE = 1;
    var BS_BLOCK_DONE = 2;
    var BS_FINISH_STARTED = 3;
    var BS_FINISH_DONE = 4;
    var OS_CODE = 0x03;
    function err(strm, errorCode) {
      strm.msg = msg[errorCode];
      return errorCode;
    }
    function rank(f) {
      return (f << 1) - (f > 4 ? 9 : 0);
    }
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    function flush_pending(strm) {
      var s = strm.state;
      var len = s.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
      strm.next_out += len;
      s.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s.pending -= len;
      if (s.pending === 0) {
        s.pending_out = 0;
      }
    }
    function flush_block_only(s, last) {
      trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
      s.block_start = s.strstart;
      flush_pending(s.strm);
    }
    function put_byte(s, b) {
      s.pending_buf[s.pending++] = b;
    }
    function putShortMSB(s, b) {
      s.pending_buf[s.pending++] = b >>> 8 & 0xff;
      s.pending_buf[s.pending++] = b & 0xff;
    }
    function read_buf(strm, buf, start, size) {
      var len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      utils.arraySet(buf, strm.input, strm.next_in, len, start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32(strm.adler, buf, len, start);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32(strm.adler, buf, len, start);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    }
    function longest_match(s, cur_match) {
      var chain_length = s.max_chain_length;
      var scan = s.strstart;
      var match;
      var len;
      var best_len = s.prev_length;
      var nice_match = s.nice_match;
      var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
      var _win = s.window;
      var wmask = s.w_mask;
      var prev = s.prev;
      var strend = s.strstart + MAX_MATCH;
      var scan_end1 = _win[scan + best_len - 1];
      var scan_end = _win[scan + best_len];
      if (s.prev_length >= s.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s.lookahead) {
        nice_match = s.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match++;
        do {} while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
          s.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s.lookahead) {
        return best_len;
      }
      return s.lookahead;
    }
    function fill_window(s) {
      var _w_size = s.w_size;
      var p, n, m, more, str;
      do {
        more = s.window_size - s.lookahead - s.strstart;
        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
          s.match_start -= _w_size;
          s.strstart -= _w_size;
          s.block_start -= _w_size;
          n = s.hash_size;
          p = n;
          do {
            m = s.head[--p];
            s.head[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          n = _w_size;
          p = n;
          do {
            m = s.prev[--p];
            s.prev[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          more += _w_size;
        }
        if (s.strm.avail_in === 0) {
          break;
        }
        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
        s.lookahead += n;
        if (s.lookahead + s.insert >= MIN_MATCH) {
          str = s.strstart - s.insert;
          s.ins_h = s.window[str];
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
          while (s.insert) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
            s.insert--;
            if (s.lookahead + s.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
    }
    function deflate_stored(s, flush) {
      var max_block_size = 0xffff;
      if (max_block_size > s.pending_buf_size - 5) {
        max_block_size = s.pending_buf_size - 5;
      }
      for (;;) {
        if (s.lookahead <= 1) {
          fill_window(s);
          if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.strstart += s.lookahead;
        s.lookahead = 0;
        var max_start = s.block_start + max_block_size;
        if (s.strstart === 0 || s.strstart >= max_start) {
          s.lookahead = s.strstart - max_start;
          s.strstart = max_start;
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.strstart > s.block_start) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_NEED_MORE;
    }
    function deflate_fast(s, flush) {
      var hash_head;
      var bflush;
      for (;;) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
            s.match_length--;
            do {
              s.strstart++;
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            } while (--s.match_length !== 0);
            s.strstart++;
          } else {
            s.strstart += s.match_length;
            s.match_length = 0;
            s.ins_h = s.window[s.strstart];
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
          }
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_slow(s, flush) {
      var hash_head;
      var bflush;
      var max_insert;
      for (;;) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        s.prev_length = s.match_length;
        s.prev_match = s.match_start;
        s.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
          if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
            s.match_length = MIN_MATCH - 1;
          }
        }
        if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
          max_insert = s.strstart + s.lookahead - MIN_MATCH;
          bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
          s.lookahead -= s.prev_length - 1;
          s.prev_length -= 2;
          do {
            if (++s.strstart <= max_insert) {
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            }
          } while (--s.prev_length !== 0);
          s.match_available = 0;
          s.match_length = MIN_MATCH - 1;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s.match_available) {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
          if (bflush) {
            flush_block_only(s, false);
          }
          s.strstart++;
          s.lookahead--;
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s.match_available = 1;
          s.strstart++;
          s.lookahead--;
        }
      }
      if (s.match_available) {
        bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
        s.match_available = 0;
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_rle(s, flush) {
      var bflush;
      var prev;
      var scan, strend;
      var _win = s.window;
      for (;;) {
        if (s.lookahead <= MAX_MATCH) {
          fill_window(s);
          if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.match_length = 0;
        if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
          scan = s.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s.strstart + MAX_MATCH;
            do {} while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s.match_length = MAX_MATCH - (strend - scan);
            if (s.match_length > s.lookahead) {
              s.match_length = s.lookahead;
            }
          }
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          s.strstart += s.match_length;
          s.match_length = 0;
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_huff(s, flush) {
      var bflush;
      for (;;) {
        if (s.lookahead === 0) {
          fill_window(s);
          if (s.lookahead === 0) {
            if (flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s.match_length = 0;
        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function Config(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    var configuration_table;
    configuration_table = [new Config(0, 0, 0, 0, deflate_stored), new Config(4, 4, 8, 4, deflate_fast), new Config(4, 5, 16, 8, deflate_fast), new Config(4, 6, 32, 32, deflate_fast), new Config(4, 4, 16, 16, deflate_slow), new Config(8, 16, 32, 32, deflate_slow), new Config(8, 16, 128, 128, deflate_slow), new Config(8, 32, 128, 256, deflate_slow), new Config(32, 128, 258, 1024, deflate_slow), new Config(32, 258, 258, 4096, deflate_slow)];
    function lm_init(s) {
      s.window_size = 2 * s.w_size;
      zero(s.head);
      s.max_lazy_match = configuration_table[s.level].max_lazy;
      s.good_match = configuration_table[s.level].good_length;
      s.nice_match = configuration_table[s.level].nice_length;
      s.max_chain_length = configuration_table[s.level].max_chain;
      s.strstart = 0;
      s.block_start = 0;
      s.lookahead = 0;
      s.insert = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      s.ins_h = 0;
    }
    function DeflateState() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
      this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
      this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
      zero(this.dyn_ltree);
      zero(this.dyn_dtree);
      zero(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new utils.Buf16(MAX_BITS + 1);
      this.heap = new utils.Buf16(2 * L_CODES + 1);
      zero(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new utils.Buf16(2 * L_CODES + 1);
      zero(this.depth);
      this.l_buf = 0;
      this.lit_bufsize = 0;
      this.last_lit = 0;
      this.d_buf = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    function deflateResetKeep(strm) {
      var s;
      if (!strm || !strm.state) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      s = strm.state;
      s.pending = 0;
      s.pending_out = 0;
      if (s.wrap < 0) {
        s.wrap = -s.wrap;
      }
      s.status = s.wrap ? INIT_STATE : BUSY_STATE;
      strm.adler = s.wrap === 2 ? 0 : 1;
      s.last_flush = Z_NO_FLUSH;
      trees._tr_init(s);
      return Z_OK;
    }
    function deflateReset(strm) {
      var ret = deflateResetKeep(strm);
      if (ret === Z_OK) {
        lm_init(strm.state);
      }
      return ret;
    }
    function deflateSetHeader(strm, head) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      if (strm.state.wrap !== 2) {
        return Z_STREAM_ERROR;
      }
      strm.state.gzhead = head;
      return Z_OK;
    }
    function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      var wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
        return err(strm, Z_STREAM_ERROR);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      var s = new DeflateState();
      strm.state = s;
      s.strm = strm;
      s.wrap = wrap;
      s.gzhead = null;
      s.w_bits = windowBits;
      s.w_size = 1 << s.w_bits;
      s.w_mask = s.w_size - 1;
      s.hash_bits = memLevel + 7;
      s.hash_size = 1 << s.hash_bits;
      s.hash_mask = s.hash_size - 1;
      s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s.window = new utils.Buf8(s.w_size * 2);
      s.head = new utils.Buf16(s.hash_size);
      s.prev = new utils.Buf16(s.w_size);
      s.lit_bufsize = 1 << memLevel + 6;
      s.pending_buf_size = s.lit_bufsize * 4;
      s.pending_buf = new utils.Buf8(s.pending_buf_size);
      s.d_buf = 1 * s.lit_bufsize;
      s.l_buf = (1 + 2) * s.lit_bufsize;
      s.level = level;
      s.strategy = strategy;
      s.method = method;
      return deflateReset(strm);
    }
    function deflateInit(strm, level) {
      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    }
    function deflate(strm, flush) {
      var old_flush, s;
      var beg, val;
      if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
      }
      s = strm.state;
      if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
      }
      s.strm = strm;
      old_flush = s.last_flush;
      s.last_flush = flush;
      if (s.status === INIT_STATE) {
        if (s.wrap === 2) {
          strm.adler = 0;
          put_byte(s, 31);
          put_byte(s, 139);
          put_byte(s, 8);
          if (!s.gzhead) {
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, OS_CODE);
            s.status = BUSY_STATE;
          } else {
            put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
            put_byte(s, s.gzhead.time & 0xff);
            put_byte(s, s.gzhead.time >> 8 & 0xff);
            put_byte(s, s.gzhead.time >> 16 & 0xff);
            put_byte(s, s.gzhead.time >> 24 & 0xff);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, s.gzhead.os & 0xff);
            if (s.gzhead.extra && s.gzhead.extra.length) {
              put_byte(s, s.gzhead.extra.length & 0xff);
              put_byte(s, s.gzhead.extra.length >> 8 & 0xff);
            }
            if (s.gzhead.hcrc) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
            }
            s.gzindex = 0;
            s.status = EXTRA_STATE;
          }
        } else {
          var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
          var level_flags = -1;
          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
            level_flags = 0;
          } else if (s.level < 6) {
            level_flags = 1;
          } else if (s.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= level_flags << 6;
          if (s.strstart !== 0) {
            header |= PRESET_DICT;
          }
          header += 31 - header % 31;
          s.status = BUSY_STATE;
          putShortMSB(s, header);
          if (s.strstart !== 0) {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 0xffff);
          }
          strm.adler = 1;
        }
      }
      if (s.status === EXTRA_STATE) {
        if (s.gzhead.extra) {
          beg = s.pending;
          while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                break;
              }
            }
            put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
            s.gzindex++;
          }
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (s.gzindex === s.gzhead.extra.length) {
            s.gzindex = 0;
            s.status = NAME_STATE;
          }
        } else {
          s.status = NAME_STATE;
        }
      }
      if (s.status === NAME_STATE) {
        if (s.gzhead.name) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.name.length) {
              val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.gzindex = 0;
            s.status = COMMENT_STATE;
          }
        } else {
          s.status = COMMENT_STATE;
        }
      }
      if (s.status === COMMENT_STATE) {
        if (s.gzhead.comment) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.comment.length) {
              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.status = HCRC_STATE;
          }
        } else {
          s.status = HCRC_STATE;
        }
      }
      if (s.status === HCRC_STATE) {
        if (s.gzhead.hcrc) {
          if (s.pending + 2 > s.pending_buf_size) {
            flush_pending(strm);
          }
          if (s.pending + 2 <= s.pending_buf_size) {
            put_byte(s, strm.adler & 0xff);
            put_byte(s, strm.adler >> 8 & 0xff);
            strm.adler = 0;
            s.status = BUSY_STATE;
          }
        } else {
          s.status = BUSY_STATE;
        }
      }
      if (s.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR);
      }
      if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
        var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s.last_flush = -1;
          }
          return Z_OK;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            trees._tr_align(s);
          } else if (flush !== Z_BLOCK) {
            trees._tr_stored_block(s, 0, 0, false);
            if (flush === Z_FULL_FLUSH) {
              zero(s.head);
              if (s.lookahead === 0) {
                s.strstart = 0;
                s.block_start = 0;
                s.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        }
      }
      if (flush !== Z_FINISH) {
        return Z_OK;
      }
      if (s.wrap <= 0) {
        return Z_STREAM_END;
      }
      if (s.wrap === 2) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, strm.adler >> 8 & 0xff);
        put_byte(s, strm.adler >> 16 & 0xff);
        put_byte(s, strm.adler >> 24 & 0xff);
        put_byte(s, strm.total_in & 0xff);
        put_byte(s, strm.total_in >> 8 & 0xff);
        put_byte(s, strm.total_in >> 16 & 0xff);
        put_byte(s, strm.total_in >> 24 & 0xff);
      } else {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }
      flush_pending(strm);
      if (s.wrap > 0) {
        s.wrap = -s.wrap;
      }
      return s.pending !== 0 ? Z_OK : Z_STREAM_END;
    }
    function deflateEnd(strm) {
      var status;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      status = strm.state.status;
      if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    }
    function deflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var s;
      var str, n;
      var wrap;
      var avail;
      var next;
      var input;
      var tmpDict;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      s = strm.state;
      wrap = s.wrap;
      if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
        return Z_STREAM_ERROR;
      }
      if (wrap === 1) {
        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
      }
      s.wrap = 0;
      if (dictLength >= s.w_size) {
        if (wrap === 0) {
          zero(s.head);
          s.strstart = 0;
          s.block_start = 0;
          s.insert = 0;
        }
        tmpDict = new utils.Buf8(s.w_size);
        utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
        dictionary = tmpDict;
        dictLength = s.w_size;
      }
      avail = strm.avail_in;
      next = strm.next_in;
      input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s);
      while (s.lookahead >= MIN_MATCH) {
        str = s.strstart;
        n = s.lookahead - (MIN_MATCH - 1);
        do {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
        } while (--n);
        s.strstart = str;
        s.lookahead = MIN_MATCH - 1;
        fill_window(s);
      }
      s.strstart += s.lookahead;
      s.block_start = s.strstart;
      s.insert = s.lookahead;
      s.lookahead = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s.wrap = wrap;
      return Z_OK;
    }
    exports.deflateInit = deflateInit;
    exports.deflateInit2 = deflateInit2;
    exports.deflateReset = deflateReset;
    exports.deflateResetKeep = deflateResetKeep;
    exports.deflateSetHeader = deflateSetHeader;
    exports.deflate = deflate;
    exports.deflateEnd = deflateEnd;
    exports.deflateSetDictionary = deflateSetDictionary;
    exports.deflateInfo = 'pako deflate (from Nodeca project)';
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic('159', [], true, function ($__require, exports, module) {
  /* */
  'use strict';

  // Note: adler32 takes 12% for level 0 and 2% for level 6.
  // It doesn't worth to make additional optimizationa as in original.
  // Small size is preferable.

  var define,
      global = this || self,
      GLOBAL = global;
  function adler32(adler, buf, len, pos) {
    var s1 = adler & 0xffff | 0,
        s2 = adler >>> 16 & 0xffff | 0,
        n = 0;

    while (len !== 0) {
      // Set limit ~ twice less than 5552, to keep
      // s2 in 31-bits, because we force signed ints.
      // in other case %= will fail.
      n = len > 2000 ? 2000 : len;
      len -= n;

      do {
        s1 = s1 + buf[pos++] | 0;
        s2 = s2 + s1 | 0;
      } while (--n);

      s1 %= 65521;
      s2 %= 65521;
    }

    return s1 | s2 << 16 | 0;
  }

  module.exports = adler32;
  return module.exports;
});
$__System.registerDynamic('15a', [], true, function ($__require, exports, module) {
  /* */
  'use strict';

  // Note: we can't get significant speed boost here.
  // So write code to minimize size - no pregenerated tables
  // and array tools dependencies.


  // Use ordinary array, since untyped makes no boost here

  var define,
      global = this || self,
      GLOBAL = global;
  function makeTable() {
    var c,
        table = [];

    for (var n = 0; n < 256; n++) {
      c = n;
      for (var k = 0; k < 8; k++) {
        c = c & 1 ? 0xEDB88320 ^ c >>> 1 : c >>> 1;
      }
      table[n] = c;
    }

    return table;
  }

  // Create table on load. Just 255 signed longs. Not a problem.
  var crcTable = makeTable();

  function crc32(crc, buf, len, pos) {
    var t = crcTable,
        end = pos + len;

    crc ^= -1;

    for (var i = pos; i < end; i++) {
      crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 0xFF];
    }

    return crc ^ -1; // >>> 0;
  }

  module.exports = crc32;
  return module.exports;
});
$__System.registerDynamic('15b', [], true, function ($__require, exports, module) {
  /* */
  'use strict';

  // See state defs from inflate.js

  var define,
      global = this || self,
      GLOBAL = global;
  var BAD = 30; /* got a data error -- remain here until reset */
  var TYPE = 12; /* i: waiting for type bits, including last-flag bit */

  /*
     Decode literal, length, and distance codes and write out the resulting
     literal and match bytes until either not enough input or output is
     available, an end-of-block is encountered, or a data error is encountered.
     When large enough input and output buffers are supplied to inflate(), for
     example, a 16K input buffer and a 64K output buffer, more than 95% of the
     inflate execution time is spent in this routine.
  
     Entry assumptions:
  
          state.mode === LEN
          strm.avail_in >= 6
          strm.avail_out >= 258
          start >= strm.avail_out
          state.bits < 8
  
     On return, state.mode is one of:
  
          LEN -- ran out of enough output space or enough available input
          TYPE -- reached end of block code, inflate() to interpret next block
          BAD -- error in block data
  
     Notes:
  
      - The maximum input bits used by a length/distance pair is 15 bits for the
        length code, 5 bits for the length extra, 15 bits for the distance code,
        and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
        Therefore if strm.avail_in >= 6, then there is enough input to avoid
        checking for available input while decoding.
  
      - The maximum bytes that a single length/distance pair can output is 258
        bytes, which is the maximum length that can be coded.  inflate_fast()
        requires strm.avail_out >= 258 for each loop to avoid checking for
        output space.
   */
  module.exports = function inflate_fast(strm, start) {
    var state;
    var _in; /* local strm.input */
    var last; /* have enough input while in < last */
    var _out; /* local strm.output */
    var beg; /* inflate()'s initial strm.output */
    var end; /* while out < end, enough space available */
    //#ifdef INFLATE_STRICT
    var dmax; /* maximum distance from zlib header */
    //#endif
    var wsize; /* window size or zero if not using window */
    var whave; /* valid bytes in the window */
    var wnext; /* window write index */
    // Use `s_window` instead `window`, avoid conflict with instrumentation tools
    var s_window; /* allocated sliding window, if wsize != 0 */
    var hold; /* local strm.hold */
    var bits; /* local strm.bits */
    var lcode; /* local strm.lencode */
    var dcode; /* local strm.distcode */
    var lmask; /* mask for first level of length codes */
    var dmask; /* mask for first level of distance codes */
    var here; /* retrieved table entry */
    var op; /* code bits, operation, extra bits, or */
    /*  window position, window bytes to copy */
    var len; /* match length, unused bytes */
    var dist; /* match distance */
    var from; /* where to copy match from */
    var from_source;

    var input, output; // JS specific, because we have no pointers

    /* copy state to local variables */
    state = strm.state;
    //here = state.here;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
    //#ifdef INFLATE_STRICT
    dmax = state.dmax;
    //#endif
    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;

    /* decode literals and length/distances until end-of-block or not enough
       input data or output space */

    top: do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }

      here = lcode[hold & lmask];

      dolen: for (;;) {
        // Goto emulation
        op = here >>> 24 /*here.bits*/;
        hold >>>= op;
        bits -= op;
        op = here >>> 16 & 0xff /*here.op*/;
        if (op === 0) {
          /* literal */
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          output[_out++] = here & 0xffff /*here.val*/;
        } else if (op & 16) {
          /* length base */
          len = here & 0xffff /*here.val*/;
          op &= 15; /* number of extra bits */
          if (op) {
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
            }
            len += hold & (1 << op) - 1;
            hold >>>= op;
            bits -= op;
          }
          //Tracevv((stderr, "inflate:         length %u\n", len));
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = dcode[hold & dmask];

          dodist: for (;;) {
            // goto emulation
            op = here >>> 24 /*here.bits*/;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 0xff /*here.op*/;

            if (op & 16) {
              /* distance base */
              dist = here & 0xffff /*here.val*/;
              op &= 15; /* number of extra bits */
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
              }
              dist += hold & (1 << op) - 1;
              //#ifdef INFLATE_STRICT
              if (dist > dmax) {
                strm.msg = 'invalid distance too far back';
                state.mode = BAD;
                break top;
              }
              //#endif
              hold >>>= op;
              bits -= op;
              //Tracevv((stderr, "inflate:         distance %u\n", dist));
              op = _out - beg; /* max distance in output */
              if (dist > op) {
                /* see if copy from window */
                op = dist - op; /* distance back in window */
                if (op > whave) {
                  if (state.sane) {
                    strm.msg = 'invalid distance too far back';
                    state.mode = BAD;
                    break top;
                  }

                  // (!) This block is disabled in zlib defailts,
                  // don't enable it for binary compatibility
                  //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
                  //                if (len <= op - whave) {
                  //                  do {
                  //                    output[_out++] = 0;
                  //                  } while (--len);
                  //                  continue top;
                  //                }
                  //                len -= op - whave;
                  //                do {
                  //                  output[_out++] = 0;
                  //                } while (--op > whave);
                  //                if (op === 0) {
                  //                  from = _out - dist;
                  //                  do {
                  //                    output[_out++] = output[from++];
                  //                  } while (--len);
                  //                  continue top;
                  //                }
                  //#endif
                }
                from = 0; // window index
                from_source = s_window;
                if (wnext === 0) {
                  /* very common case */
                  from += wsize - op;
                  if (op < len) {
                    /* some from window */
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist; /* rest from output */
                    from_source = output;
                  }
                } else if (wnext < op) {
                  /* wrap around window */
                  from += wsize + wnext - op;
                  op -= wnext;
                  if (op < len) {
                    /* some from end of window */
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = 0;
                    if (wnext < len) {
                      /* some from start of window */
                      op = wnext;
                      len -= op;
                      do {
                        output[_out++] = s_window[from++];
                      } while (--op);
                      from = _out - dist; /* rest from output */
                      from_source = output;
                    }
                  }
                } else {
                  /* contiguous in window */
                  from += wnext - op;
                  if (op < len) {
                    /* some from window */
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist; /* rest from output */
                    from_source = output;
                  }
                }
                while (len > 2) {
                  output[_out++] = from_source[from++];
                  output[_out++] = from_source[from++];
                  output[_out++] = from_source[from++];
                  len -= 3;
                }
                if (len) {
                  output[_out++] = from_source[from++];
                  if (len > 1) {
                    output[_out++] = from_source[from++];
                  }
                }
              } else {
                from = _out - dist; /* copy direct from output */
                do {
                  /* minimum length is three */
                  output[_out++] = output[from++];
                  output[_out++] = output[from++];
                  output[_out++] = output[from++];
                  len -= 3;
                } while (len > 2);
                if (len) {
                  output[_out++] = output[from++];
                  if (len > 1) {
                    output[_out++] = output[from++];
                  }
                }
              }
            } else if ((op & 64) === 0) {
              /* 2nd level distance code */
              here = dcode[(here & 0xffff) + ( /*here.val*/hold & (1 << op) - 1)];
              continue dodist;
            } else {
              strm.msg = 'invalid distance code';
              state.mode = BAD;
              break top;
            }

            break; // need to emulate goto via "continue"
          }
        } else if ((op & 64) === 0) {
          /* 2nd level length code */
          here = lcode[(here & 0xffff) + ( /*here.val*/hold & (1 << op) - 1)];
          continue dolen;
        } else if (op & 32) {
          /* end-of-block */
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.mode = TYPE;
          break top;
        } else {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD;
          break top;
        }

        break; // need to emulate goto via "continue"
      }
    } while (_in < last && _out < end);

    /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;

    /* update state and return */
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
    state.hold = hold;
    state.bits = bits;
    return;
  };
  return module.exports;
});
$__System.registerDynamic('156', [], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var TYPED_OK = typeof Uint8Array !== 'undefined' && typeof Uint16Array !== 'undefined' && typeof Int32Array !== 'undefined';

  exports.assign = function (obj /*from1, from2, from3, ...*/) {
    var sources = Array.prototype.slice.call(arguments, 1);
    while (sources.length) {
      var source = sources.shift();
      if (!source) {
        continue;
      }

      if (typeof source !== 'object') {
        throw new TypeError(source + 'must be non-object');
      }

      for (var p in source) {
        if (source.hasOwnProperty(p)) {
          obj[p] = source[p];
        }
      }
    }

    return obj;
  };

  // reduce buffer size, avoiding mem copy
  exports.shrinkBuf = function (buf, size) {
    if (buf.length === size) {
      return buf;
    }
    if (buf.subarray) {
      return buf.subarray(0, size);
    }
    buf.length = size;
    return buf;
  };

  var fnTyped = {
    arraySet: function (dest, src, src_offs, len, dest_offs) {
      if (src.subarray && dest.subarray) {
        dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
        return;
      }
      // Fallback to ordinary array
      for (var i = 0; i < len; i++) {
        dest[dest_offs + i] = src[src_offs + i];
      }
    },
    // Join array of chunks to single array.
    flattenChunks: function (chunks) {
      var i, l, len, pos, chunk, result;

      // calculate data length
      len = 0;
      for (i = 0, l = chunks.length; i < l; i++) {
        len += chunks[i].length;
      }

      // join chunks
      result = new Uint8Array(len);
      pos = 0;
      for (i = 0, l = chunks.length; i < l; i++) {
        chunk = chunks[i];
        result.set(chunk, pos);
        pos += chunk.length;
      }

      return result;
    }
  };

  var fnUntyped = {
    arraySet: function (dest, src, src_offs, len, dest_offs) {
      for (var i = 0; i < len; i++) {
        dest[dest_offs + i] = src[src_offs + i];
      }
    },
    // Join array of chunks to single array.
    flattenChunks: function (chunks) {
      return [].concat.apply([], chunks);
    }
  };

  // Enable/Disable typed arrays use, for testing
  //
  exports.setTyped = function (on) {
    if (on) {
      exports.Buf8 = Uint8Array;
      exports.Buf16 = Uint16Array;
      exports.Buf32 = Int32Array;
      exports.assign(exports, fnTyped);
    } else {
      exports.Buf8 = Array;
      exports.Buf16 = Array;
      exports.Buf32 = Array;
      exports.assign(exports, fnUntyped);
    }
  };

  exports.setTyped(TYPED_OK);
  return module.exports;
});
$__System.registerDynamic('15c', ['156', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var utils = $__require('156');
    var MAXBITS = 15;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var lbase = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];
    var lext = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78];
    var dbase = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0];
    var dext = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
    module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
      var bits = opts.bits;
      var len = 0;
      var sym = 0;
      var min = 0,
          max = 0;
      var root = 0;
      var curr = 0;
      var drop = 0;
      var left = 0;
      var used = 0;
      var huff = 0;
      var incr;
      var fill;
      var low;
      var mask;
      var next;
      var base = null;
      var base_index = 0;
      var end;
      var count = new utils.Buf16(MAXBITS + 1);
      var offs = new utils.Buf16(MAXBITS + 1);
      var extra = null;
      var extra_index = 0;
      var here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max = MAXBITS; max >= 1; max--) {
        if (count[max] !== 0) {
          break;
        }
      }
      if (root > max) {
        root = max;
      }
      if (max === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
      }
      for (min = 1; min < max; min++) {
        if (count[min] !== 0) {
          break;
        }
      }
      if (root < min) {
        root = min;
      }
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES || max !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES) {
        base = extra = work;
        end = 19;
      } else if (type === LENS) {
        base = lbase;
        base_index -= 257;
        extra = lext;
        extra_index -= 257;
        end = 256;
      } else {
        base = dbase;
        extra = dext;
        end = -1;
      }
      huff = 0;
      sym = 0;
      len = min;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      var i = 0;
      for (;;) {
        i++;
        here_bits = len - drop;
        if (work[sym] < end) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] > end) {
          here_op = extra[extra_index + work[sym]];
          here_val = base[base_index + work[sym]];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill = 1 << curr;
        min = fill;
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max) {
            left -= count[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
            return 1;
          }
          low = huff & mask;
          table[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts.bits = root;
      return 0;
    };
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('15d', ['156', '159', '15a', '15b', '15c', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var utils = $__require('156');
    var adler32 = $__require('159');
    var crc32 = $__require('15a');
    var inflate_fast = $__require('15b');
    var inflate_table = $__require('15c');
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_TREES = 6;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_NEED_DICT = 2;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_MEM_ERROR = -4;
    var Z_BUF_ERROR = -5;
    var Z_DEFLATED = 8;
    var HEAD = 1;
    var FLAGS = 2;
    var TIME = 3;
    var OS = 4;
    var EXLEN = 5;
    var EXTRA = 6;
    var NAME = 7;
    var COMMENT = 8;
    var HCRC = 9;
    var DICTID = 10;
    var DICT = 11;
    var TYPE = 12;
    var TYPEDO = 13;
    var STORED = 14;
    var COPY_ = 15;
    var COPY = 16;
    var TABLE = 17;
    var LENLENS = 18;
    var CODELENS = 19;
    var LEN_ = 20;
    var LEN = 21;
    var LENEXT = 22;
    var DIST = 23;
    var DISTEXT = 24;
    var MATCH = 25;
    var LIT = 26;
    var CHECK = 27;
    var LENGTH = 28;
    var DONE = 29;
    var BAD = 30;
    var MEM = 31;
    var SYNC = 32;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var MAX_WBITS = 15;
    var DEF_WBITS = MAX_WBITS;
    function zswap32(q) {
      return (q >>> 24 & 0xff) + (q >>> 8 & 0xff00) + ((q & 0xff00) << 8) + ((q & 0xff) << 24);
    }
    function InflateState() {
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new utils.Buf16(320);
      this.work = new utils.Buf16(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    function inflateResetKeep(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = '';
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
      state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK;
    }
    function inflateReset(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    }
    function inflateReset2(strm, windowBits) {
      var wrap;
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 1;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap;
      state.wbits = windowBits;
      return inflateReset(strm);
    }
    function inflateInit2(strm, windowBits) {
      var ret;
      var state;
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      state = new InflateState();
      strm.state = state;
      state.window = null;
      ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK) {
        strm.state = null;
      }
      return ret;
    }
    function inflateInit(strm) {
      return inflateInit2(strm, DEF_WBITS);
    }
    var virgin = true;
    var lenfix, distfix;
    function fixedtables(state) {
      if (virgin) {
        var sym;
        lenfix = new utils.Buf32(512);
        distfix = new utils.Buf32(32);
        sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    }
    function updatewindow(strm, src, end, copy) {
      var dist;
      var state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new utils.Buf8(state.wsize);
      }
      if (copy >= state.wsize) {
        utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
          dist = copy;
        }
        utils.arraySet(state.window, src, end - copy, dist, state.wnext);
        copy -= dist;
        if (copy) {
          utils.arraySet(state.window, src, end - copy, copy, 0);
          state.wnext = copy;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    }
    function inflate(strm, flush) {
      var state;
      var input, output;
      var next;
      var put;
      var have, left;
      var hold;
      var bits;
      var _in, _out;
      var copy;
      var from;
      var from_source;
      var here = 0;
      var here_bits, here_op, here_val;
      var last_bits, last_op, last_val;
      var len;
      var ret;
      var hbuf = new utils.Buf8(4);
      var opts;
      var n;
      var order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
      if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK;
      inf_leave: for (;;) {
        switch (state.mode) {
          case HEAD:
            if (state.wrap === 0) {
              state.mode = TYPEDO;
              break;
            }
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 2 && hold === 0x8b1f) {
              state.check = 0;
              hbuf[0] = hold & 0xff;
              hbuf[1] = hold >>> 8 & 0xff;
              state.check = crc32(state.check, hbuf, 2, 0);
              hold = 0;
              bits = 0;
              state.mode = FLAGS;
              break;
            }
            state.flags = 0;
            if (state.head) {
              state.head.done = false;
            }
            if (!(state.wrap & 1) || (((hold & 0xff) << 8) + (hold >> 8)) % 31) {
              strm.msg = 'incorrect header check';
              state.mode = BAD;
              break;
            }
            if ((hold & 0x0f) !== Z_DEFLATED) {
              strm.msg = 'unknown compression method';
              state.mode = BAD;
              break;
            }
            hold >>>= 4;
            bits -= 4;
            len = (hold & 0x0f) + 8;
            if (state.wbits === 0) {
              state.wbits = len;
            } else if (len > state.wbits) {
              strm.msg = 'invalid window size';
              state.mode = BAD;
              break;
            }
            state.dmax = 1 << len;
            strm.adler = state.check = 1;
            state.mode = hold & 0x200 ? DICTID : TYPE;
            hold = 0;
            bits = 0;
            break;
          case FLAGS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.flags = hold;
            if ((state.flags & 0xff) !== Z_DEFLATED) {
              strm.msg = 'unknown compression method';
              state.mode = BAD;
              break;
            }
            if (state.flags & 0xe000) {
              strm.msg = 'unknown header flags set';
              state.mode = BAD;
              break;
            }
            if (state.head) {
              state.head.text = hold >> 8 & 1;
            }
            if (state.flags & 0x0200) {
              hbuf[0] = hold & 0xff;
              hbuf[1] = hold >>> 8 & 0xff;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = TIME;
          case TIME:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.time = hold;
            }
            if (state.flags & 0x0200) {
              hbuf[0] = hold & 0xff;
              hbuf[1] = hold >>> 8 & 0xff;
              hbuf[2] = hold >>> 16 & 0xff;
              hbuf[3] = hold >>> 24 & 0xff;
              state.check = crc32(state.check, hbuf, 4, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = OS;
          case OS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.xflags = hold & 0xff;
              state.head.os = hold >> 8;
            }
            if (state.flags & 0x0200) {
              hbuf[0] = hold & 0xff;
              hbuf[1] = hold >>> 8 & 0xff;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = EXLEN;
          case EXLEN:
            if (state.flags & 0x0400) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length = hold;
              if (state.head) {
                state.head.extra_len = hold;
              }
              if (state.flags & 0x0200) {
                hbuf[0] = hold & 0xff;
                hbuf[1] = hold >>> 8 & 0xff;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
            } else if (state.head) {
              state.head.extra = null;
            }
            state.mode = EXTRA;
          case EXTRA:
            if (state.flags & 0x0400) {
              copy = state.length;
              if (copy > have) {
                copy = have;
              }
              if (copy) {
                if (state.head) {
                  len = state.head.extra_len - state.length;
                  if (!state.head.extra) {
                    state.head.extra = new Array(state.head.extra_len);
                  }
                  utils.arraySet(state.head.extra, input, next, copy, len);
                }
                if (state.flags & 0x0200) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                state.length -= copy;
              }
              if (state.length) {
                break inf_leave;
              }
            }
            state.length = 0;
            state.mode = NAME;
          case NAME:
            if (state.flags & 0x0800) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.name += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 0x0200) {
                state.check = crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.name = null;
            }
            state.length = 0;
            state.mode = COMMENT;
          case COMMENT:
            if (state.flags & 0x1000) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.comment += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 0x0200) {
                state.check = crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.comment = null;
            }
            state.mode = HCRC;
          case HCRC:
            if (state.flags & 0x0200) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.check & 0xffff)) {
                strm.msg = 'header crc mismatch';
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            if (state.head) {
              state.head.hcrc = state.flags >> 9 & 1;
              state.head.done = true;
            }
            strm.adler = state.check = 0;
            state.mode = TYPE;
            break;
          case DICTID:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            strm.adler = state.check = zswap32(hold);
            hold = 0;
            bits = 0;
            state.mode = DICT;
          case DICT:
            if (state.havedict === 0) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              return Z_NEED_DICT;
            }
            strm.adler = state.check = 1;
            state.mode = TYPE;
          case TYPE:
            if (flush === Z_BLOCK || flush === Z_TREES) {
              break inf_leave;
            }
          case TYPEDO:
            if (state.last) {
              hold >>>= bits & 7;
              bits -= bits & 7;
              state.mode = CHECK;
              break;
            }
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.last = hold & 0x01;
            hold >>>= 1;
            bits -= 1;
            switch (hold & 0x03) {
              case 0:
                state.mode = STORED;
                break;
              case 1:
                fixedtables(state);
                state.mode = LEN_;
                if (flush === Z_TREES) {
                  hold >>>= 2;
                  bits -= 2;
                  break inf_leave;
                }
                break;
              case 2:
                state.mode = TABLE;
                break;
              case 3:
                strm.msg = 'invalid block type';
                state.mode = BAD;
            }
            hold >>>= 2;
            bits -= 2;
            break;
          case STORED:
            hold >>>= bits & 7;
            bits -= bits & 7;
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((hold & 0xffff) !== (hold >>> 16 ^ 0xffff)) {
              strm.msg = 'invalid stored block lengths';
              state.mode = BAD;
              break;
            }
            state.length = hold & 0xffff;
            hold = 0;
            bits = 0;
            state.mode = COPY_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          case COPY_:
            state.mode = COPY;
          case COPY:
            copy = state.length;
            if (copy) {
              if (copy > have) {
                copy = have;
              }
              if (copy > left) {
                copy = left;
              }
              if (copy === 0) {
                break inf_leave;
              }
              utils.arraySet(output, input, next, copy, put);
              have -= copy;
              next += copy;
              left -= copy;
              put += copy;
              state.length -= copy;
              break;
            }
            state.mode = TYPE;
            break;
          case TABLE:
            while (bits < 14) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.nlen = (hold & 0x1f) + 257;
            hold >>>= 5;
            bits -= 5;
            state.ndist = (hold & 0x1f) + 1;
            hold >>>= 5;
            bits -= 5;
            state.ncode = (hold & 0x0f) + 4;
            hold >>>= 4;
            bits -= 4;
            if (state.nlen > 286 || state.ndist > 30) {
              strm.msg = 'too many length or distance symbols';
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = LENLENS;
          case LENLENS:
            while (state.have < state.ncode) {
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.lens[order[state.have++]] = hold & 0x07;
              hold >>>= 3;
              bits -= 3;
            }
            while (state.have < 19) {
              state.lens[order[state.have++]] = 0;
            }
            state.lencode = state.lendyn;
            state.lenbits = 7;
            opts = { bits: state.lenbits };
            ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = 'invalid code lengths set';
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = CODELENS;
          case CODELENS:
            while (state.have < state.nlen + state.ndist) {
              for (;;) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 0xff;
                here_val = here & 0xffff;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_val < 16) {
                hold >>>= here_bits;
                bits -= here_bits;
                state.lens[state.have++] = here_val;
              } else {
                if (here_val === 16) {
                  n = here_bits + 2;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  if (state.have === 0) {
                    strm.msg = 'invalid bit length repeat';
                    state.mode = BAD;
                    break;
                  }
                  len = state.lens[state.have - 1];
                  copy = 3 + (hold & 0x03);
                  hold >>>= 2;
                  bits -= 2;
                } else if (here_val === 17) {
                  n = here_bits + 3;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 3 + (hold & 0x07);
                  hold >>>= 3;
                  bits -= 3;
                } else {
                  n = here_bits + 7;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 11 + (hold & 0x7f);
                  hold >>>= 7;
                  bits -= 7;
                }
                if (state.have + copy > state.nlen + state.ndist) {
                  strm.msg = 'invalid bit length repeat';
                  state.mode = BAD;
                  break;
                }
                while (copy--) {
                  state.lens[state.have++] = len;
                }
              }
            }
            if (state.mode === BAD) {
              break;
            }
            if (state.lens[256] === 0) {
              strm.msg = 'invalid code -- missing end-of-block';
              state.mode = BAD;
              break;
            }
            state.lenbits = 9;
            opts = { bits: state.lenbits };
            ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = 'invalid literal/lengths set';
              state.mode = BAD;
              break;
            }
            state.distbits = 6;
            state.distcode = state.distdyn;
            opts = { bits: state.distbits };
            ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
            state.distbits = opts.bits;
            if (ret) {
              strm.msg = 'invalid distances set';
              state.mode = BAD;
              break;
            }
            state.mode = LEN_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          case LEN_:
            state.mode = LEN;
          case LEN:
            if (have >= 6 && left >= 258) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              inflate_fast(strm, _out);
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state.hold;
              bits = state.bits;
              if (state.mode === TYPE) {
                state.back = -1;
              }
              break;
            }
            state.back = 0;
            for (;;) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 0xff;
              here_val = here & 0xffff;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_op && (here_op & 0xf0) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (;;) {
                here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 0xff;
                here_val = here & 0xffff;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            state.length = here_val;
            if (here_op === 0) {
              state.mode = LIT;
              break;
            }
            if (here_op & 32) {
              state.back = -1;
              state.mode = TYPE;
              break;
            }
            if (here_op & 64) {
              strm.msg = 'invalid literal/length code';
              state.mode = BAD;
              break;
            }
            state.extra = here_op & 15;
            state.mode = LENEXT;
          case LENEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.was = state.length;
            state.mode = DIST;
          case DIST:
            for (;;) {
              here = state.distcode[hold & (1 << state.distbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 0xff;
              here_val = here & 0xffff;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((here_op & 0xf0) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (;;) {
                here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 0xff;
                here_val = here & 0xffff;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            if (here_op & 64) {
              strm.msg = 'invalid distance code';
              state.mode = BAD;
              break;
            }
            state.offset = here_val;
            state.extra = here_op & 15;
            state.mode = DISTEXT;
          case DISTEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.offset += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            if (state.offset > state.dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break;
            }
            state.mode = MATCH;
          case MATCH:
            if (left === 0) {
              break inf_leave;
            }
            copy = _out - left;
            if (state.offset > copy) {
              copy = state.offset - copy;
              if (copy > state.whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break;
                }
              }
              if (copy > state.wnext) {
                copy -= state.wnext;
                from = state.wsize - copy;
              } else {
                from = state.wnext - copy;
              }
              if (copy > state.length) {
                copy = state.length;
              }
              from_source = state.window;
            } else {
              from_source = output;
              from = put - state.offset;
              copy = state.length;
            }
            if (copy > left) {
              copy = left;
            }
            left -= copy;
            state.length -= copy;
            do {
              output[put++] = from_source[from++];
            } while (--copy);
            if (state.length === 0) {
              state.mode = LEN;
            }
            break;
          case LIT:
            if (left === 0) {
              break inf_leave;
            }
            output[put++] = state.length;
            left--;
            state.mode = LEN;
            break;
          case CHECK:
            if (state.wrap) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold |= input[next++] << bits;
                bits += 8;
              }
              _out -= left;
              strm.total_out += _out;
              state.total += _out;
              if (_out) {
                strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
              }
              _out = left;
              if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                strm.msg = 'incorrect data check';
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = LENGTH;
          case LENGTH:
            if (state.wrap && state.flags) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.total & 0xffffffff)) {
                strm.msg = 'incorrect length check';
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = DONE;
          case DONE:
            ret = Z_STREAM_END;
            break inf_leave;
          case BAD:
            ret = Z_DATA_ERROR;
            break inf_leave;
          case MEM:
            return Z_MEM_ERROR;
          case SYNC:
          default:
            return Z_STREAM_ERROR;
        }
      }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap && _out) {
        strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    }
    function inflateEnd(strm) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      var state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK;
    }
    function inflateGetHeader(strm, head) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR;
      }
      state.head = head;
      head.done = false;
      return Z_OK;
    }
    function inflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var state;
      var dictid;
      var ret;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR;
      }
      if (state.mode === DICT) {
        dictid = 1;
        dictid = adler32(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR;
        }
      }
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
      state.havedict = 1;
      return Z_OK;
    }
    exports.inflateReset = inflateReset;
    exports.inflateReset2 = inflateReset2;
    exports.inflateResetKeep = inflateResetKeep;
    exports.inflateInit = inflateInit;
    exports.inflateInit2 = inflateInit2;
    exports.inflate = inflate;
    exports.inflateEnd = inflateEnd;
    exports.inflateGetHeader = inflateGetHeader;
    exports.inflateSetDictionary = inflateSetDictionary;
    exports.inflateInfo = 'pako inflate (from Nodeca project)';
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('15e', [], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = {

    /* Allowed flush values; see deflate() and inflate() below for details */
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,

    /* Return codes for the compression/decompression functions. Negative values
    * are errors, positive values are used for special but normal events.
    */
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    //Z_MEM_ERROR:     -4,
    Z_BUF_ERROR: -5,
    //Z_VERSION_ERROR: -6,

    /* compression levels */
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,

    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,

    /* Possible values of the data_type field (though see inflate()) */
    Z_BINARY: 0,
    Z_TEXT: 1,
    //Z_ASCII:                1, // = Z_TEXT (deprecated)
    Z_UNKNOWN: 2,

    /* The deflate compression method */
    Z_DEFLATED: 8
    //Z_NULL:                 null // Use -1 or null inline, depending on var type
  };
  return module.exports;
});
$__System.registerDynamic('15f', ['157', '154', '158', '15d', '15e', '2a', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer, process) {
    var msg = $__require('157');
    var zstream = $__require('154');
    var zlib_deflate = $__require('158');
    var zlib_inflate = $__require('15d');
    var constants = $__require('15e');
    for (var key in constants) {
      exports[key] = constants[key];
    }
    exports.NONE = 0;
    exports.DEFLATE = 1;
    exports.INFLATE = 2;
    exports.GZIP = 3;
    exports.GUNZIP = 4;
    exports.DEFLATERAW = 5;
    exports.INFLATERAW = 6;
    exports.UNZIP = 7;
    function Zlib(mode) {
      if (mode < exports.DEFLATE || mode > exports.UNZIP) throw new TypeError("Bad argument");
      this.mode = mode;
      this.init_done = false;
      this.write_in_progress = false;
      this.pending_close = false;
      this.windowBits = 0;
      this.level = 0;
      this.memLevel = 0;
      this.strategy = 0;
      this.dictionary = null;
    }
    Zlib.prototype.init = function (windowBits, level, memLevel, strategy, dictionary) {
      this.windowBits = windowBits;
      this.level = level;
      this.memLevel = memLevel;
      this.strategy = strategy;
      if (this.mode === exports.GZIP || this.mode === exports.GUNZIP) this.windowBits += 16;
      if (this.mode === exports.UNZIP) this.windowBits += 32;
      if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW) this.windowBits = -this.windowBits;
      this.strm = new zstream();
      switch (this.mode) {
        case exports.DEFLATE:
        case exports.GZIP:
        case exports.DEFLATERAW:
          var status = zlib_deflate.deflateInit2(this.strm, this.level, exports.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
          break;
        case exports.INFLATE:
        case exports.GUNZIP:
        case exports.INFLATERAW:
        case exports.UNZIP:
          var status = zlib_inflate.inflateInit2(this.strm, this.windowBits);
          break;
        default:
          throw new Error("Unknown mode " + this.mode);
      }
      if (status !== exports.Z_OK) {
        this._error(status);
        return;
      }
      this.write_in_progress = false;
      this.init_done = true;
    };
    Zlib.prototype.params = function () {
      throw new Error("deflateParams Not supported");
    };
    Zlib.prototype._writeCheck = function () {
      if (!this.init_done) throw new Error("write before init");
      if (this.mode === exports.NONE) throw new Error("already finalized");
      if (this.write_in_progress) throw new Error("write already in progress");
      if (this.pending_close) throw new Error("close is pending");
    };
    Zlib.prototype.write = function (flush, input, in_off, in_len, out, out_off, out_len) {
      this._writeCheck();
      this.write_in_progress = true;
      var self = this;
      process.nextTick(function () {
        self.write_in_progress = false;
        var res = self._write(flush, input, in_off, in_len, out, out_off, out_len);
        self.callback(res[0], res[1]);
        if (self.pending_close) self.close();
      });
      return this;
    };
    function bufferSet(data, offset) {
      for (var i = 0; i < data.length; i++) {
        this[offset + i] = data[i];
      }
    }
    Zlib.prototype.writeSync = function (flush, input, in_off, in_len, out, out_off, out_len) {
      this._writeCheck();
      return this._write(flush, input, in_off, in_len, out, out_off, out_len);
    };
    Zlib.prototype._write = function (flush, input, in_off, in_len, out, out_off, out_len) {
      this.write_in_progress = true;
      if (flush !== exports.Z_NO_FLUSH && flush !== exports.Z_PARTIAL_FLUSH && flush !== exports.Z_SYNC_FLUSH && flush !== exports.Z_FULL_FLUSH && flush !== exports.Z_FINISH && flush !== exports.Z_BLOCK) {
        throw new Error("Invalid flush value");
      }
      if (input == null) {
        input = new Buffer(0);
        in_len = 0;
        in_off = 0;
      }
      if (out._set) out.set = out._set;else out.set = bufferSet;
      var strm = this.strm;
      strm.avail_in = in_len;
      strm.input = input;
      strm.next_in = in_off;
      strm.avail_out = out_len;
      strm.output = out;
      strm.next_out = out_off;
      switch (this.mode) {
        case exports.DEFLATE:
        case exports.GZIP:
        case exports.DEFLATERAW:
          var status = zlib_deflate.deflate(strm, flush);
          break;
        case exports.UNZIP:
        case exports.INFLATE:
        case exports.GUNZIP:
        case exports.INFLATERAW:
          var status = zlib_inflate.inflate(strm, flush);
          break;
        default:
          throw new Error("Unknown mode " + this.mode);
      }
      if (status !== exports.Z_STREAM_END && status !== exports.Z_OK) {
        this._error(status);
      }
      this.write_in_progress = false;
      return [strm.avail_in, strm.avail_out];
    };
    Zlib.prototype.close = function () {
      if (this.write_in_progress) {
        this.pending_close = true;
        return;
      }
      this.pending_close = false;
      if (this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW) {
        zlib_deflate.deflateEnd(this.strm);
      } else {
        zlib_inflate.inflateEnd(this.strm);
      }
      this.mode = exports.NONE;
    };
    Zlib.prototype.reset = function () {
      switch (this.mode) {
        case exports.DEFLATE:
        case exports.DEFLATERAW:
          var status = zlib_deflate.deflateReset(this.strm);
          break;
        case exports.INFLATE:
        case exports.INFLATERAW:
          var status = zlib_inflate.inflateReset(this.strm);
          break;
      }
      if (status !== exports.Z_OK) {
        this._error(status);
      }
    };
    Zlib.prototype._error = function (status) {
      this.onerror(msg[status] + ': ' + this.strm.msg, status);
      this.write_in_progress = false;
      if (this.pending_close) this.close();
    };
    exports.Zlib = Zlib;
  })($__require('2a').Buffer, $__require('13'));
  return module.exports;
});
$__System.registerDynamic('160', ['161', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    'use strict';

    function compare(a, b) {
      if (a === b) {
        return 0;
      }
      var x = a.length;
      var y = b.length;
      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y) {
        return -1;
      }
      if (y < x) {
        return 1;
      }
      return 0;
    }
    function isBuffer(b) {
      if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
        return global.Buffer.isBuffer(b);
      }
      return !!(b != null && b._isBuffer);
    }
    var util = $__require('161');
    var hasOwn = Object.prototype.hasOwnProperty;
    var pSlice = Array.prototype.slice;
    var functionsHaveNames = function () {
      return function foo() {}.name === 'foo';
    }();
    function pToString(obj) {
      return Object.prototype.toString.call(obj);
    }
    function isView(arrbuf) {
      if (isBuffer(arrbuf)) {
        return false;
      }
      if (typeof global.ArrayBuffer !== 'function') {
        return false;
      }
      if (typeof ArrayBuffer.isView === 'function') {
        return ArrayBuffer.isView(arrbuf);
      }
      if (!arrbuf) {
        return false;
      }
      if (arrbuf instanceof DataView) {
        return true;
      }
      if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
        return true;
      }
      return false;
    }
    var assert = module.exports = ok;
    var regex = /\s*function\s+([^\(\s]*)\s*/;
    function getName(func) {
      if (!util.isFunction(func)) {
        return;
      }
      if (functionsHaveNames) {
        return func.name;
      }
      var str = func.toString();
      var match = str.match(regex);
      return match && match[1];
    }
    assert.AssertionError = function AssertionError(options) {
      this.name = 'AssertionError';
      this.actual = options.actual;
      this.expected = options.expected;
      this.operator = options.operator;
      if (options.message) {
        this.message = options.message;
        this.generatedMessage = false;
      } else {
        this.message = getMessage(this);
        this.generatedMessage = true;
      }
      var stackStartFunction = options.stackStartFunction || fail;
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, stackStartFunction);
      } else {
        var err = new Error();
        if (err.stack) {
          var out = err.stack;
          var fn_name = getName(stackStartFunction);
          var idx = out.indexOf('\n' + fn_name);
          if (idx >= 0) {
            var next_line = out.indexOf('\n', idx + 1);
            out = out.substring(next_line + 1);
          }
          this.stack = out;
        }
      }
    };
    util.inherits(assert.AssertionError, Error);
    function truncate(s, n) {
      if (typeof s === 'string') {
        return s.length < n ? s : s.slice(0, n);
      } else {
        return s;
      }
    }
    function inspect(something) {
      if (functionsHaveNames || !util.isFunction(something)) {
        return util.inspect(something);
      }
      var rawname = getName(something);
      var name = rawname ? ': ' + rawname : '';
      return '[Function' + name + ']';
    }
    function getMessage(self) {
      return truncate(inspect(self.actual), 128) + ' ' + self.operator + ' ' + truncate(inspect(self.expected), 128);
    }
    function fail(actual, expected, message, operator, stackStartFunction) {
      throw new assert.AssertionError({
        message: message,
        actual: actual,
        expected: expected,
        operator: operator,
        stackStartFunction: stackStartFunction
      });
    }
    assert.fail = fail;
    function ok(value, message) {
      if (!value) fail(value, true, message, '==', assert.ok);
    }
    assert.ok = ok;
    assert.equal = function equal(actual, expected, message) {
      if (actual != expected) fail(actual, expected, message, '==', assert.equal);
    };
    assert.notEqual = function notEqual(actual, expected, message) {
      if (actual == expected) {
        fail(actual, expected, message, '!=', assert.notEqual);
      }
    };
    assert.deepEqual = function deepEqual(actual, expected, message) {
      if (!_deepEqual(actual, expected, false)) {
        fail(actual, expected, message, 'deepEqual', assert.deepEqual);
      }
    };
    assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
      if (!_deepEqual(actual, expected, true)) {
        fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
      }
    };
    function _deepEqual(actual, expected, strict, memos) {
      if (actual === expected) {
        return true;
      } else if (isBuffer(actual) && isBuffer(expected)) {
        return compare(actual, expected) === 0;
      } else if (util.isDate(actual) && util.isDate(expected)) {
        return actual.getTime() === expected.getTime();
      } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
        return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
      } else if ((actual === null || typeof actual !== 'object') && (expected === null || typeof expected !== 'object')) {
        return strict ? actual === expected : actual == expected;
      } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
        return compare(new Uint8Array(actual.buffer), new Uint8Array(expected.buffer)) === 0;
      } else if (isBuffer(actual) !== isBuffer(expected)) {
        return false;
      } else {
        memos = memos || {
          actual: [],
          expected: []
        };
        var actualIndex = memos.actual.indexOf(actual);
        if (actualIndex !== -1) {
          if (actualIndex === memos.expected.indexOf(expected)) {
            return true;
          }
        }
        memos.actual.push(actual);
        memos.expected.push(expected);
        return objEquiv(actual, expected, strict, memos);
      }
    }
    function isArguments(object) {
      return Object.prototype.toString.call(object) == '[object Arguments]';
    }
    function objEquiv(a, b, strict, actualVisitedObjects) {
      if (a === null || a === undefined || b === null || b === undefined) return false;
      if (util.isPrimitive(a) || util.isPrimitive(b)) return a === b;
      if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)) return false;
      var aIsArgs = isArguments(a);
      var bIsArgs = isArguments(b);
      if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs) return false;
      if (aIsArgs) {
        a = pSlice.call(a);
        b = pSlice.call(b);
        return _deepEqual(a, b, strict);
      }
      var ka = objectKeys(a);
      var kb = objectKeys(b);
      var key, i;
      if (ka.length !== kb.length) return false;
      ka.sort();
      kb.sort();
      for (i = ka.length - 1; i >= 0; i--) {
        if (ka[i] !== kb[i]) return false;
      }
      for (i = ka.length - 1; i >= 0; i--) {
        key = ka[i];
        if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects)) return false;
      }
      return true;
    }
    assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
      if (_deepEqual(actual, expected, false)) {
        fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
      }
    };
    assert.notDeepStrictEqual = notDeepStrictEqual;
    function notDeepStrictEqual(actual, expected, message) {
      if (_deepEqual(actual, expected, true)) {
        fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
      }
    }
    assert.strictEqual = function strictEqual(actual, expected, message) {
      if (actual !== expected) {
        fail(actual, expected, message, '===', assert.strictEqual);
      }
    };
    assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
      if (actual === expected) {
        fail(actual, expected, message, '!==', assert.notStrictEqual);
      }
    };
    function expectedException(actual, expected) {
      if (!actual || !expected) {
        return false;
      }
      if (Object.prototype.toString.call(expected) == '[object RegExp]') {
        return expected.test(actual);
      }
      try {
        if (actual instanceof expected) {
          return true;
        }
      } catch (e) {}
      if (Error.isPrototypeOf(expected)) {
        return false;
      }
      return expected.call({}, actual) === true;
    }
    function _tryBlock(block) {
      var error;
      try {
        block();
      } catch (e) {
        error = e;
      }
      return error;
    }
    function _throws(shouldThrow, block, expected, message) {
      var actual;
      if (typeof block !== 'function') {
        throw new TypeError('"block" argument must be a function');
      }
      if (typeof expected === 'string') {
        message = expected;
        expected = null;
      }
      actual = _tryBlock(block);
      message = (expected && expected.name ? ' (' + expected.name + ').' : '.') + (message ? ' ' + message : '.');
      if (shouldThrow && !actual) {
        fail(actual, expected, 'Missing expected exception' + message);
      }
      var userProvidedMessage = typeof message === 'string';
      var isUnwantedException = !shouldThrow && util.isError(actual);
      var isUnexpectedException = !shouldThrow && actual && !expected;
      if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
        fail(actual, expected, 'Got unwanted exception' + message);
      }
      if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
        throw actual;
      }
    }
    assert.throws = function (block, error, message) {
      _throws(true, block, error, message);
    };
    assert.doesNotThrow = function (block, error, message) {
      _throws(false, block, error, message);
    };
    assert.ifError = function (err) {
      if (err) throw err;
    };
    var objectKeys = Object.keys || function (obj) {
      var keys = [];
      for (var key in obj) {
        if (hasOwn.call(obj, key)) keys.push(key);
      }
      return keys;
    };
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic("162", ["160"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("160");
  return module.exports;
});
$__System.registerDynamic('163', ['162'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  module.exports = $__System._nodeRequire ? $__System._nodeRequire('assert') : $__require('162');
  return module.exports;
});
$__System.registerDynamic("164", ["163"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("163");
  return module.exports;
});
$__System.registerDynamic('165', ['152', '15f', '166', '164', '2a', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer, process) {
    var Transform = $__require('152');
    var binding = $__require('15f');
    var util = $__require('166');
    var assert = $__require('164').ok;
    binding.Z_MIN_WINDOWBITS = 8;
    binding.Z_MAX_WINDOWBITS = 15;
    binding.Z_DEFAULT_WINDOWBITS = 15;
    binding.Z_MIN_CHUNK = 64;
    binding.Z_MAX_CHUNK = Infinity;
    binding.Z_DEFAULT_CHUNK = 16 * 1024;
    binding.Z_MIN_MEMLEVEL = 1;
    binding.Z_MAX_MEMLEVEL = 9;
    binding.Z_DEFAULT_MEMLEVEL = 8;
    binding.Z_MIN_LEVEL = -1;
    binding.Z_MAX_LEVEL = 9;
    binding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;
    Object.keys(binding).forEach(function (k) {
      if (k.match(/^Z/)) exports[k] = binding[k];
    });
    exports.codes = {
      Z_OK: binding.Z_OK,
      Z_STREAM_END: binding.Z_STREAM_END,
      Z_NEED_DICT: binding.Z_NEED_DICT,
      Z_ERRNO: binding.Z_ERRNO,
      Z_STREAM_ERROR: binding.Z_STREAM_ERROR,
      Z_DATA_ERROR: binding.Z_DATA_ERROR,
      Z_MEM_ERROR: binding.Z_MEM_ERROR,
      Z_BUF_ERROR: binding.Z_BUF_ERROR,
      Z_VERSION_ERROR: binding.Z_VERSION_ERROR
    };
    Object.keys(exports.codes).forEach(function (k) {
      exports.codes[exports.codes[k]] = k;
    });
    exports.Deflate = Deflate;
    exports.Inflate = Inflate;
    exports.Gzip = Gzip;
    exports.Gunzip = Gunzip;
    exports.DeflateRaw = DeflateRaw;
    exports.InflateRaw = InflateRaw;
    exports.Unzip = Unzip;
    exports.createDeflate = function (o) {
      return new Deflate(o);
    };
    exports.createInflate = function (o) {
      return new Inflate(o);
    };
    exports.createDeflateRaw = function (o) {
      return new DeflateRaw(o);
    };
    exports.createInflateRaw = function (o) {
      return new InflateRaw(o);
    };
    exports.createGzip = function (o) {
      return new Gzip(o);
    };
    exports.createGunzip = function (o) {
      return new Gunzip(o);
    };
    exports.createUnzip = function (o) {
      return new Unzip(o);
    };
    exports.deflate = function (buffer, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Deflate(opts), buffer, callback);
    };
    exports.deflateSync = function (buffer, opts) {
      return zlibBufferSync(new Deflate(opts), buffer);
    };
    exports.gzip = function (buffer, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Gzip(opts), buffer, callback);
    };
    exports.gzipSync = function (buffer, opts) {
      return zlibBufferSync(new Gzip(opts), buffer);
    };
    exports.deflateRaw = function (buffer, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new DeflateRaw(opts), buffer, callback);
    };
    exports.deflateRawSync = function (buffer, opts) {
      return zlibBufferSync(new DeflateRaw(opts), buffer);
    };
    exports.unzip = function (buffer, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Unzip(opts), buffer, callback);
    };
    exports.unzipSync = function (buffer, opts) {
      return zlibBufferSync(new Unzip(opts), buffer);
    };
    exports.inflate = function (buffer, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Inflate(opts), buffer, callback);
    };
    exports.inflateSync = function (buffer, opts) {
      return zlibBufferSync(new Inflate(opts), buffer);
    };
    exports.gunzip = function (buffer, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Gunzip(opts), buffer, callback);
    };
    exports.gunzipSync = function (buffer, opts) {
      return zlibBufferSync(new Gunzip(opts), buffer);
    };
    exports.inflateRaw = function (buffer, opts, callback) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new InflateRaw(opts), buffer, callback);
    };
    exports.inflateRawSync = function (buffer, opts) {
      return zlibBufferSync(new InflateRaw(opts), buffer);
    };
    function zlibBuffer(engine, buffer, callback) {
      var buffers = [];
      var nread = 0;
      engine.on('error', onError);
      engine.on('end', onEnd);
      engine.end(buffer);
      flow();
      function flow() {
        var chunk;
        while (null !== (chunk = engine.read())) {
          buffers.push(chunk);
          nread += chunk.length;
        }
        engine.once('readable', flow);
      }
      function onError(err) {
        engine.removeListener('end', onEnd);
        engine.removeListener('readable', flow);
        callback(err);
      }
      function onEnd() {
        var buf = Buffer.concat(buffers, nread);
        buffers = [];
        callback(null, buf);
        engine.close();
      }
    }
    function zlibBufferSync(engine, buffer) {
      if (typeof buffer === 'string') buffer = new Buffer(buffer);
      if (!Buffer.isBuffer(buffer)) throw new TypeError('Not a string or buffer');
      var flushFlag = binding.Z_FINISH;
      return engine._processChunk(buffer, flushFlag);
    }
    function Deflate(opts) {
      if (!(this instanceof Deflate)) return new Deflate(opts);
      Zlib.call(this, opts, binding.DEFLATE);
    }
    function Inflate(opts) {
      if (!(this instanceof Inflate)) return new Inflate(opts);
      Zlib.call(this, opts, binding.INFLATE);
    }
    function Gzip(opts) {
      if (!(this instanceof Gzip)) return new Gzip(opts);
      Zlib.call(this, opts, binding.GZIP);
    }
    function Gunzip(opts) {
      if (!(this instanceof Gunzip)) return new Gunzip(opts);
      Zlib.call(this, opts, binding.GUNZIP);
    }
    function DeflateRaw(opts) {
      if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);
      Zlib.call(this, opts, binding.DEFLATERAW);
    }
    function InflateRaw(opts) {
      if (!(this instanceof InflateRaw)) return new InflateRaw(opts);
      Zlib.call(this, opts, binding.INFLATERAW);
    }
    function Unzip(opts) {
      if (!(this instanceof Unzip)) return new Unzip(opts);
      Zlib.call(this, opts, binding.UNZIP);
    }
    function Zlib(opts, mode) {
      this._opts = opts = opts || {};
      this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;
      Transform.call(this, opts);
      if (opts.flush) {
        if (opts.flush !== binding.Z_NO_FLUSH && opts.flush !== binding.Z_PARTIAL_FLUSH && opts.flush !== binding.Z_SYNC_FLUSH && opts.flush !== binding.Z_FULL_FLUSH && opts.flush !== binding.Z_FINISH && opts.flush !== binding.Z_BLOCK) {
          throw new Error('Invalid flush flag: ' + opts.flush);
        }
      }
      this._flushFlag = opts.flush || binding.Z_NO_FLUSH;
      if (opts.chunkSize) {
        if (opts.chunkSize < exports.Z_MIN_CHUNK || opts.chunkSize > exports.Z_MAX_CHUNK) {
          throw new Error('Invalid chunk size: ' + opts.chunkSize);
        }
      }
      if (opts.windowBits) {
        if (opts.windowBits < exports.Z_MIN_WINDOWBITS || opts.windowBits > exports.Z_MAX_WINDOWBITS) {
          throw new Error('Invalid windowBits: ' + opts.windowBits);
        }
      }
      if (opts.level) {
        if (opts.level < exports.Z_MIN_LEVEL || opts.level > exports.Z_MAX_LEVEL) {
          throw new Error('Invalid compression level: ' + opts.level);
        }
      }
      if (opts.memLevel) {
        if (opts.memLevel < exports.Z_MIN_MEMLEVEL || opts.memLevel > exports.Z_MAX_MEMLEVEL) {
          throw new Error('Invalid memLevel: ' + opts.memLevel);
        }
      }
      if (opts.strategy) {
        if (opts.strategy != exports.Z_FILTERED && opts.strategy != exports.Z_HUFFMAN_ONLY && opts.strategy != exports.Z_RLE && opts.strategy != exports.Z_FIXED && opts.strategy != exports.Z_DEFAULT_STRATEGY) {
          throw new Error('Invalid strategy: ' + opts.strategy);
        }
      }
      if (opts.dictionary) {
        if (!Buffer.isBuffer(opts.dictionary)) {
          throw new Error('Invalid dictionary: it should be a Buffer instance');
        }
      }
      this._binding = new binding.Zlib(mode);
      var self = this;
      this._hadError = false;
      this._binding.onerror = function (message, errno) {
        self._binding = null;
        self._hadError = true;
        var error = new Error(message);
        error.errno = errno;
        error.code = exports.codes[errno];
        self.emit('error', error);
      };
      var level = exports.Z_DEFAULT_COMPRESSION;
      if (typeof opts.level === 'number') level = opts.level;
      var strategy = exports.Z_DEFAULT_STRATEGY;
      if (typeof opts.strategy === 'number') strategy = opts.strategy;
      this._binding.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS, level, opts.memLevel || exports.Z_DEFAULT_MEMLEVEL, strategy, opts.dictionary);
      this._buffer = new Buffer(this._chunkSize);
      this._offset = 0;
      this._closed = false;
      this._level = level;
      this._strategy = strategy;
      this.once('end', this.close);
    }
    util.inherits(Zlib, Transform);
    Zlib.prototype.params = function (level, strategy, callback) {
      if (level < exports.Z_MIN_LEVEL || level > exports.Z_MAX_LEVEL) {
        throw new RangeError('Invalid compression level: ' + level);
      }
      if (strategy != exports.Z_FILTERED && strategy != exports.Z_HUFFMAN_ONLY && strategy != exports.Z_RLE && strategy != exports.Z_FIXED && strategy != exports.Z_DEFAULT_STRATEGY) {
        throw new TypeError('Invalid strategy: ' + strategy);
      }
      if (this._level !== level || this._strategy !== strategy) {
        var self = this;
        this.flush(binding.Z_SYNC_FLUSH, function () {
          self._binding.params(level, strategy);
          if (!self._hadError) {
            self._level = level;
            self._strategy = strategy;
            if (callback) callback();
          }
        });
      } else {
        process.nextTick(callback);
      }
    };
    Zlib.prototype.reset = function () {
      return this._binding.reset();
    };
    Zlib.prototype._flush = function (callback) {
      this._transform(new Buffer(0), '', callback);
    };
    Zlib.prototype.flush = function (kind, callback) {
      var ws = this._writableState;
      if (typeof kind === 'function' || kind === void 0 && !callback) {
        callback = kind;
        kind = binding.Z_FULL_FLUSH;
      }
      if (ws.ended) {
        if (callback) process.nextTick(callback);
      } else if (ws.ending) {
        if (callback) this.once('end', callback);
      } else if (ws.needDrain) {
        var self = this;
        this.once('drain', function () {
          self.flush(callback);
        });
      } else {
        this._flushFlag = kind;
        this.write(new Buffer(0), '', callback);
      }
    };
    Zlib.prototype.close = function (callback) {
      if (callback) process.nextTick(callback);
      if (this._closed) return;
      this._closed = true;
      this._binding.close();
      var self = this;
      process.nextTick(function () {
        self.emit('close');
      });
    };
    Zlib.prototype._transform = function (chunk, encoding, cb) {
      var flushFlag;
      var ws = this._writableState;
      var ending = ws.ending || ws.ended;
      var last = ending && (!chunk || ws.length === chunk.length);
      if (!chunk === null && !Buffer.isBuffer(chunk)) return cb(new Error('invalid input'));
      if (last) flushFlag = binding.Z_FINISH;else {
        flushFlag = this._flushFlag;
        if (chunk.length >= ws.length) {
          this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;
        }
      }
      var self = this;
      this._processChunk(chunk, flushFlag, cb);
    };
    Zlib.prototype._processChunk = function (chunk, flushFlag, cb) {
      var availInBefore = chunk && chunk.length;
      var availOutBefore = this._chunkSize - this._offset;
      var inOff = 0;
      var self = this;
      var async = typeof cb === 'function';
      if (!async) {
        var buffers = [];
        var nread = 0;
        var error;
        this.on('error', function (er) {
          error = er;
        });
        do {
          var res = this._binding.writeSync(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);
        } while (!this._hadError && callback(res[0], res[1]));
        if (this._hadError) {
          throw error;
        }
        var buf = Buffer.concat(buffers, nread);
        this.close();
        return buf;
      }
      var req = this._binding.write(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);
      req.buffer = chunk;
      req.callback = callback;
      function callback(availInAfter, availOutAfter) {
        if (self._hadError) return;
        var have = availOutBefore - availOutAfter;
        assert(have >= 0, 'have should not go down');
        if (have > 0) {
          var out = self._buffer.slice(self._offset, self._offset + have);
          self._offset += have;
          if (async) {
            self.push(out);
          } else {
            buffers.push(out);
            nread += out.length;
          }
        }
        if (availOutAfter === 0 || self._offset >= self._chunkSize) {
          availOutBefore = self._chunkSize;
          self._offset = 0;
          self._buffer = new Buffer(self._chunkSize);
        }
        if (availOutAfter === 0) {
          inOff += availInBefore - availInAfter;
          availInBefore = availInAfter;
          if (!async) return true;
          var newReq = self._binding.write(flushFlag, chunk, inOff, availInBefore, self._buffer, self._offset, self._chunkSize);
          newReq.callback = callback;
          newReq.buffer = chunk;
          return;
        }
        if (!async) return false;
        cb();
      }
    };
    util.inherits(Deflate, Zlib);
    util.inherits(Inflate, Zlib);
    util.inherits(Gzip, Zlib);
    util.inherits(Gunzip, Zlib);
    util.inherits(DeflateRaw, Zlib);
    util.inherits(InflateRaw, Zlib);
    util.inherits(Unzip, Zlib);
  })($__require('2a').Buffer, $__require('13'));
  return module.exports;
});
$__System.registerDynamic("167", ["165"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("165");
  return module.exports;
});
$__System.registerDynamic('168', ['167'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  module.exports = $__System._nodeRequire ? $__System._nodeRequire('zlib') : $__require('167');
  return module.exports;
});
$__System.registerDynamic("169", ["168"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("168");
  return module.exports;
});
$__System.registerDynamic('12a', ['12c', '13d', '13c', '3f', '169'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var createError = $__require('12c');
  var getBody = $__require('13d');
  var iconv = $__require('13c');
  var onFinished = $__require('3f');
  var zlib = $__require('169');
  module.exports = read;
  function read(req, res, next, parse, debug, options) {
    var length;
    var opts = options || {};
    var stream;
    req._body = true;
    var encoding = opts.encoding !== null ? opts.encoding || 'utf-8' : null;
    var verify = opts.verify;
    try {
      stream = contentstream(req, debug, opts.inflate);
      length = stream.length;
      stream.length = undefined;
    } catch (err) {
      return next(err);
    }
    opts.length = length;
    opts.encoding = verify ? null : encoding;
    if (opts.encoding === null && encoding !== null && !iconv.encodingExists(encoding)) {
      return next(createError(415, 'unsupported charset "' + encoding.toUpperCase() + '"', { charset: encoding.toLowerCase() }));
    }
    debug('read body');
    getBody(stream, opts, function (err, body) {
      if (err) {
        setErrorStatus(err, 400);
        if (err.type === 'encoding.unsupported') {
          err = createError(415, 'unsupported charset "' + encoding.toUpperCase() + '"', { charset: encoding.toLowerCase() });
        }
        stream.resume();
        onFinished(req, function onfinished() {
          next(err);
        });
        return;
      }
      if (verify) {
        try {
          debug('verify body');
          verify(req, res, body, encoding);
        } catch (err) {
          setErrorStatus(err, 403);
          next(err);
          return;
        }
      }
      var str;
      try {
        debug('parse body');
        str = typeof body !== 'string' && encoding !== null ? iconv.decode(body, encoding) : body;
        req.body = parse(str);
      } catch (err) {
        err.body = str === undefined ? body : str;
        setErrorStatus(err, 400);
        next(err);
        return;
      }
      next();
    });
  }
  function contentstream(req, debug, inflate) {
    var encoding = (req.headers['content-encoding'] || 'identity').toLowerCase();
    var length = req.headers['content-length'];
    var stream;
    debug('content-encoding "%s"', encoding);
    if (inflate === false && encoding !== 'identity') {
      throw createError(415, 'content encoding unsupported');
    }
    switch (encoding) {
      case 'deflate':
        stream = zlib.createInflate();
        debug('inflate body');
        req.pipe(stream);
        break;
      case 'gzip':
        stream = zlib.createGunzip();
        debug('gunzip body');
        req.pipe(stream);
        break;
      case 'identity':
        stream = req;
        stream.length = length;
        break;
      default:
        throw createError(415, 'unsupported content encoding "' + encoding + '"', { encoding: encoding });
    }
    return stream;
  }
  function setErrorStatus(error, status) {
    if (!error.status && !error.statusCode) {
      error.status = status;
      error.statusCode = status;
    }
  }
  return module.exports;
});
$__System.registerDynamic('16a', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /*!
   * media-typer
   * Copyright(c) 2014 Douglas Christopher Wilson
   * MIT Licensed
   */

  /**
   * RegExp to match *( ";" parameter ) in RFC 2616 sec 3.7
   *
   * parameter     = token "=" ( token | quoted-string )
   * token         = 1*<any CHAR except CTLs or separators>
   * separators    = "(" | ")" | "<" | ">" | "@"
   *               | "," | ";" | ":" | "\" | <">
   *               | "/" | "[" | "]" | "?" | "="
   *               | "{" | "}" | SP | HT
   * quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
   * qdtext        = <any TEXT except <">>
   * quoted-pair   = "\" CHAR
   * CHAR          = <any US-ASCII character (octets 0 - 127)>
   * TEXT          = <any OCTET except CTLs, but including LWS>
   * LWS           = [CRLF] 1*( SP | HT )
   * CRLF          = CR LF
   * CR            = <US-ASCII CR, carriage return (13)>
   * LF            = <US-ASCII LF, linefeed (10)>
   * SP            = <US-ASCII SP, space (32)>
   * SHT           = <US-ASCII HT, horizontal-tab (9)>
   * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
   * OCTET         = <any 8-bit sequence of data>
   */
  var paramRegExp = /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u0020-\u007e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g;
  var textRegExp = /^[\u0020-\u007e\u0080-\u00ff]+$/;
  var tokenRegExp = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/;

  /**
   * RegExp to match quoted-pair in RFC 2616
   *
   * quoted-pair = "\" CHAR
   * CHAR        = <any US-ASCII character (octets 0 - 127)>
   */
  var qescRegExp = /\\([\u0000-\u007f])/g;

  /**
   * RegExp to match chars that must be quoted-pair in RFC 2616
   */
  var quoteRegExp = /([\\"])/g;

  /**
   * RegExp to match type in RFC 6838
   *
   * type-name = restricted-name
   * subtype-name = restricted-name
   * restricted-name = restricted-name-first *126restricted-name-chars
   * restricted-name-first  = ALPHA / DIGIT
   * restricted-name-chars  = ALPHA / DIGIT / "!" / "#" /
   *                          "$" / "&" / "-" / "^" / "_"
   * restricted-name-chars =/ "." ; Characters before first dot always
   *                              ; specify a facet name
   * restricted-name-chars =/ "+" ; Characters after last plus always
   *                              ; specify a structured syntax suffix
   * ALPHA =  %x41-5A / %x61-7A   ; A-Z / a-z
   * DIGIT =  %x30-39             ; 0-9
   */
  var subtypeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/;
  var typeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/;
  var typeRegExp = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;

  /**
   * Module exports.
   */

  exports.format = format;
  exports.parse = parse;

  /**
   * Format object to media type.
   *
   * @param {object} obj
   * @return {string}
   * @api public
   */

  function format(obj) {
    if (!obj || typeof obj !== 'object') {
      throw new TypeError('argument obj is required');
    }

    var parameters = obj.parameters;
    var subtype = obj.subtype;
    var suffix = obj.suffix;
    var type = obj.type;

    if (!type || !typeNameRegExp.test(type)) {
      throw new TypeError('invalid type');
    }

    if (!subtype || !subtypeNameRegExp.test(subtype)) {
      throw new TypeError('invalid subtype');
    }

    // format as type/subtype
    var string = type + '/' + subtype;

    // append +suffix
    if (suffix) {
      if (!typeNameRegExp.test(suffix)) {
        throw new TypeError('invalid suffix');
      }

      string += '+' + suffix;
    }

    // append parameters
    if (parameters && typeof parameters === 'object') {
      var param;
      var params = Object.keys(parameters).sort();

      for (var i = 0; i < params.length; i++) {
        param = params[i];

        if (!tokenRegExp.test(param)) {
          throw new TypeError('invalid parameter name');
        }

        string += '; ' + param + '=' + qstring(parameters[param]);
      }
    }

    return string;
  }

  /**
   * Parse media type to object.
   *
   * @param {string|object} string
   * @return {Object}
   * @api public
   */

  function parse(string) {
    if (!string) {
      throw new TypeError('argument string is required');
    }

    // support req/res-like objects as argument
    if (typeof string === 'object') {
      string = getcontenttype(string);
    }

    if (typeof string !== 'string') {
      throw new TypeError('argument string is required to be a string');
    }

    var index = string.indexOf(';');
    var type = index !== -1 ? string.substr(0, index) : string;

    var key;
    var match;
    var obj = splitType(type);
    var params = {};
    var value;

    paramRegExp.lastIndex = index;

    while (match = paramRegExp.exec(string)) {
      if (match.index !== index) {
        throw new TypeError('invalid parameter format');
      }

      index += match[0].length;
      key = match[1].toLowerCase();
      value = match[2];

      if (value[0] === '"') {
        // remove quotes and escapes
        value = value.substr(1, value.length - 2).replace(qescRegExp, '$1');
      }

      params[key] = value;
    }

    if (index !== -1 && index !== string.length) {
      throw new TypeError('invalid parameter format');
    }

    obj.parameters = params;

    return obj;
  }

  /**
   * Get content-type from req/res objects.
   *
   * @param {object}
   * @return {Object}
   * @api private
   */

  function getcontenttype(obj) {
    if (typeof obj.getHeader === 'function') {
      // res-like
      return obj.getHeader('content-type');
    }

    if (typeof obj.headers === 'object') {
      // req-like
      return obj.headers && obj.headers['content-type'];
    }
  }

  /**
   * Quote a string if necessary.
   *
   * @param {string} val
   * @return {string}
   * @api private
   */

  function qstring(val) {
    var str = String(val);

    // no need to quote tokens
    if (tokenRegExp.test(str)) {
      return str;
    }

    if (str.length > 0 && !textRegExp.test(str)) {
      throw new TypeError('invalid parameter value');
    }

    return '"' + str.replace(quoteRegExp, '\\$1') + '"';
  }

  /**
   * Simply "type/subtype+siffx" into parts.
   *
   * @param {string} string
   * @return {Object}
   * @api private
   */

  function splitType(string) {
    var match = typeRegExp.exec(string.toLowerCase());

    if (!match) {
      throw new TypeError('invalid media type');
    }

    var type = match[1];
    var subtype = match[2];
    var suffix;

    // suffix after last +
    var index = subtype.lastIndexOf('+');
    if (index !== -1) {
      suffix = subtype.substr(index + 1);
      subtype = subtype.substr(0, index);
    }

    var obj = {
      type: type,
      subtype: subtype,
      suffix: suffix
    };

    return obj;
  }
  return module.exports;
});
$__System.registerDynamic("16b", ["16a"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("16a");
  return module.exports;
});
$__System.registerDynamic("16c", [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = { "application/1d-interleaved-parityfec": { "source": "iana" }, "application/3gpdash-qoe-report+xml": { "source": "iana" }, "application/3gpp-ims+xml": { "source": "iana" }, "application/a2l": { "source": "iana" }, "application/activemessage": { "source": "iana" }, "application/alto-costmap+json": { "source": "iana", "compressible": true }, "application/alto-costmapfilter+json": { "source": "iana", "compressible": true }, "application/alto-directory+json": { "source": "iana", "compressible": true }, "application/alto-endpointcost+json": { "source": "iana", "compressible": true }, "application/alto-endpointcostparams+json": { "source": "iana", "compressible": true }, "application/alto-endpointprop+json": { "source": "iana", "compressible": true }, "application/alto-endpointpropparams+json": { "source": "iana", "compressible": true }, "application/alto-error+json": { "source": "iana", "compressible": true }, "application/alto-networkmap+json": { "source": "iana", "compressible": true }, "application/alto-networkmapfilter+json": { "source": "iana", "compressible": true }, "application/aml": { "source": "iana" }, "application/andrew-inset": { "source": "iana", "extensions": ["ez"] }, "application/applefile": { "source": "iana" }, "application/applixware": { "source": "apache", "extensions": ["aw"] }, "application/atf": { "source": "iana" }, "application/atfx": { "source": "iana" }, "application/atom+xml": { "source": "iana", "compressible": true, "extensions": ["atom"] }, "application/atomcat+xml": { "source": "iana", "extensions": ["atomcat"] }, "application/atomdeleted+xml": { "source": "iana" }, "application/atomicmail": { "source": "iana" }, "application/atomsvc+xml": { "source": "iana", "extensions": ["atomsvc"] }, "application/atxml": { "source": "iana" }, "application/auth-policy+xml": { "source": "iana" }, "application/bacnet-xdd+zip": { "source": "iana" }, "application/batch-smtp": { "source": "iana" }, "application/bdoc": { "compressible": false, "extensions": ["bdoc"] }, "application/beep+xml": { "source": "iana" }, "application/calendar+json": { "source": "iana", "compressible": true }, "application/calendar+xml": { "source": "iana" }, "application/call-completion": { "source": "iana" }, "application/cals-1840": { "source": "iana" }, "application/cbor": { "source": "iana" }, "application/ccmp+xml": { "source": "iana" }, "application/ccxml+xml": { "source": "iana", "extensions": ["ccxml"] }, "application/cdfx+xml": { "source": "iana" }, "application/cdmi-capability": { "source": "iana", "extensions": ["cdmia"] }, "application/cdmi-container": { "source": "iana", "extensions": ["cdmic"] }, "application/cdmi-domain": { "source": "iana", "extensions": ["cdmid"] }, "application/cdmi-object": { "source": "iana", "extensions": ["cdmio"] }, "application/cdmi-queue": { "source": "iana", "extensions": ["cdmiq"] }, "application/cdni": { "source": "iana" }, "application/cea": { "source": "iana" }, "application/cea-2018+xml": { "source": "iana" }, "application/cellml+xml": { "source": "iana" }, "application/cfw": { "source": "iana" }, "application/clue_info+xml": { "source": "iana" }, "application/cms": { "source": "iana" }, "application/cnrp+xml": { "source": "iana" }, "application/coap-group+json": { "source": "iana", "compressible": true }, "application/commonground": { "source": "iana" }, "application/conference-info+xml": { "source": "iana" }, "application/cpl+xml": { "source": "iana" }, "application/csrattrs": { "source": "iana" }, "application/csta+xml": { "source": "iana" }, "application/cstadata+xml": { "source": "iana" }, "application/csvm+json": { "source": "iana", "compressible": true }, "application/cu-seeme": { "source": "apache", "extensions": ["cu"] }, "application/cybercash": { "source": "iana" }, "application/dart": { "compressible": true }, "application/dash+xml": { "source": "iana", "extensions": ["mpd"] }, "application/dashdelta": { "source": "iana" }, "application/davmount+xml": { "source": "iana", "extensions": ["davmount"] }, "application/dca-rft": { "source": "iana" }, "application/dcd": { "source": "iana" }, "application/dec-dx": { "source": "iana" }, "application/dialog-info+xml": { "source": "iana" }, "application/dicom": { "source": "iana" }, "application/dicom+json": { "source": "iana", "compressible": true }, "application/dicom+xml": { "source": "iana" }, "application/dii": { "source": "iana" }, "application/dit": { "source": "iana" }, "application/dns": { "source": "iana" }, "application/docbook+xml": { "source": "apache", "extensions": ["dbk"] }, "application/dskpp+xml": { "source": "iana" }, "application/dssc+der": { "source": "iana", "extensions": ["dssc"] }, "application/dssc+xml": { "source": "iana", "extensions": ["xdssc"] }, "application/dvcs": { "source": "iana" }, "application/ecmascript": { "source": "iana", "compressible": true, "extensions": ["ecma"] }, "application/edi-consent": { "source": "iana" }, "application/edi-x12": { "source": "iana", "compressible": false }, "application/edifact": { "source": "iana", "compressible": false }, "application/efi": { "source": "iana" }, "application/emergencycalldata.comment+xml": { "source": "iana" }, "application/emergencycalldata.deviceinfo+xml": { "source": "iana" }, "application/emergencycalldata.providerinfo+xml": { "source": "iana" }, "application/emergencycalldata.serviceinfo+xml": { "source": "iana" }, "application/emergencycalldata.subscriberinfo+xml": { "source": "iana" }, "application/emma+xml": { "source": "iana", "extensions": ["emma"] }, "application/emotionml+xml": { "source": "iana" }, "application/encaprtp": { "source": "iana" }, "application/epp+xml": { "source": "iana" }, "application/epub+zip": { "source": "iana", "extensions": ["epub"] }, "application/eshop": { "source": "iana" }, "application/exi": { "source": "iana", "extensions": ["exi"] }, "application/fastinfoset": { "source": "iana" }, "application/fastsoap": { "source": "iana" }, "application/fdt+xml": { "source": "iana" }, "application/fits": { "source": "iana" }, "application/font-sfnt": { "source": "iana" }, "application/font-tdpfr": { "source": "iana", "extensions": ["pfr"] }, "application/font-woff": { "source": "iana", "compressible": false, "extensions": ["woff"] }, "application/font-woff2": { "compressible": false, "extensions": ["woff2"] }, "application/framework-attributes+xml": { "source": "iana" }, "application/geo+json": { "source": "iana", "compressible": true }, "application/gml+xml": { "source": "apache", "extensions": ["gml"] }, "application/gpx+xml": { "source": "apache", "extensions": ["gpx"] }, "application/gxf": { "source": "apache", "extensions": ["gxf"] }, "application/gzip": { "source": "iana", "compressible": false }, "application/h224": { "source": "iana" }, "application/held+xml": { "source": "iana" }, "application/http": { "source": "iana" }, "application/hyperstudio": { "source": "iana", "extensions": ["stk"] }, "application/ibe-key-request+xml": { "source": "iana" }, "application/ibe-pkg-reply+xml": { "source": "iana" }, "application/ibe-pp-data": { "source": "iana" }, "application/iges": { "source": "iana" }, "application/im-iscomposing+xml": { "source": "iana" }, "application/index": { "source": "iana" }, "application/index.cmd": { "source": "iana" }, "application/index.obj": { "source": "iana" }, "application/index.response": { "source": "iana" }, "application/index.vnd": { "source": "iana" }, "application/inkml+xml": { "source": "iana", "extensions": ["ink", "inkml"] }, "application/iotp": { "source": "iana" }, "application/ipfix": { "source": "iana", "extensions": ["ipfix"] }, "application/ipp": { "source": "iana" }, "application/isup": { "source": "iana" }, "application/its+xml": { "source": "iana" }, "application/java-archive": { "source": "apache", "compressible": false, "extensions": ["jar", "war", "ear"] }, "application/java-serialized-object": { "source": "apache", "compressible": false, "extensions": ["ser"] }, "application/java-vm": { "source": "apache", "compressible": false, "extensions": ["class"] }, "application/javascript": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["js"] }, "application/jose": { "source": "iana" }, "application/jose+json": { "source": "iana", "compressible": true }, "application/jrd+json": { "source": "iana", "compressible": true }, "application/json": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["json", "map"] }, "application/json-patch+json": { "source": "iana", "compressible": true }, "application/json-seq": { "source": "iana" }, "application/json5": { "extensions": ["json5"] }, "application/jsonml+json": { "source": "apache", "compressible": true, "extensions": ["jsonml"] }, "application/jwk+json": { "source": "iana", "compressible": true }, "application/jwk-set+json": { "source": "iana", "compressible": true }, "application/jwt": { "source": "iana" }, "application/kpml-request+xml": { "source": "iana" }, "application/kpml-response+xml": { "source": "iana" }, "application/ld+json": { "source": "iana", "compressible": true, "extensions": ["jsonld"] }, "application/lgr+xml": { "source": "iana" }, "application/link-format": { "source": "iana" }, "application/load-control+xml": { "source": "iana" }, "application/lost+xml": { "source": "iana", "extensions": ["lostxml"] }, "application/lostsync+xml": { "source": "iana" }, "application/lxf": { "source": "iana" }, "application/mac-binhex40": { "source": "iana", "extensions": ["hqx"] }, "application/mac-compactpro": { "source": "apache", "extensions": ["cpt"] }, "application/macwriteii": { "source": "iana" }, "application/mads+xml": { "source": "iana", "extensions": ["mads"] }, "application/manifest+json": { "charset": "UTF-8", "compressible": true, "extensions": ["webmanifest"] }, "application/marc": { "source": "iana", "extensions": ["mrc"] }, "application/marcxml+xml": { "source": "iana", "extensions": ["mrcx"] }, "application/mathematica": { "source": "iana", "extensions": ["ma", "nb", "mb"] }, "application/mathml+xml": { "source": "iana", "extensions": ["mathml"] }, "application/mathml-content+xml": { "source": "iana" }, "application/mathml-presentation+xml": { "source": "iana" }, "application/mbms-associated-procedure-description+xml": { "source": "iana" }, "application/mbms-deregister+xml": { "source": "iana" }, "application/mbms-envelope+xml": { "source": "iana" }, "application/mbms-msk+xml": { "source": "iana" }, "application/mbms-msk-response+xml": { "source": "iana" }, "application/mbms-protection-description+xml": { "source": "iana" }, "application/mbms-reception-report+xml": { "source": "iana" }, "application/mbms-register+xml": { "source": "iana" }, "application/mbms-register-response+xml": { "source": "iana" }, "application/mbms-schedule+xml": { "source": "iana" }, "application/mbms-user-service-description+xml": { "source": "iana" }, "application/mbox": { "source": "iana", "extensions": ["mbox"] }, "application/media-policy-dataset+xml": { "source": "iana" }, "application/media_control+xml": { "source": "iana" }, "application/mediaservercontrol+xml": { "source": "iana", "extensions": ["mscml"] }, "application/merge-patch+json": { "source": "iana", "compressible": true }, "application/metalink+xml": { "source": "apache", "extensions": ["metalink"] }, "application/metalink4+xml": { "source": "iana", "extensions": ["meta4"] }, "application/mets+xml": { "source": "iana", "extensions": ["mets"] }, "application/mf4": { "source": "iana" }, "application/mikey": { "source": "iana" }, "application/mods+xml": { "source": "iana", "extensions": ["mods"] }, "application/moss-keys": { "source": "iana" }, "application/moss-signature": { "source": "iana" }, "application/mosskey-data": { "source": "iana" }, "application/mosskey-request": { "source": "iana" }, "application/mp21": { "source": "iana", "extensions": ["m21", "mp21"] }, "application/mp4": { "source": "iana", "extensions": ["mp4s", "m4p"] }, "application/mpeg4-generic": { "source": "iana" }, "application/mpeg4-iod": { "source": "iana" }, "application/mpeg4-iod-xmt": { "source": "iana" }, "application/mrb-consumer+xml": { "source": "iana" }, "application/mrb-publish+xml": { "source": "iana" }, "application/msc-ivr+xml": { "source": "iana" }, "application/msc-mixer+xml": { "source": "iana" }, "application/msword": { "source": "iana", "compressible": false, "extensions": ["doc", "dot"] }, "application/mxf": { "source": "iana", "extensions": ["mxf"] }, "application/nasdata": { "source": "iana" }, "application/news-checkgroups": { "source": "iana" }, "application/news-groupinfo": { "source": "iana" }, "application/news-transmission": { "source": "iana" }, "application/nlsml+xml": { "source": "iana" }, "application/nss": { "source": "iana" }, "application/ocsp-request": { "source": "iana" }, "application/ocsp-response": { "source": "iana" }, "application/octet-stream": { "source": "iana", "compressible": false, "extensions": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"] }, "application/oda": { "source": "iana", "extensions": ["oda"] }, "application/odx": { "source": "iana" }, "application/oebps-package+xml": { "source": "iana", "extensions": ["opf"] }, "application/ogg": { "source": "iana", "compressible": false, "extensions": ["ogx"] }, "application/omdoc+xml": { "source": "apache", "extensions": ["omdoc"] }, "application/onenote": { "source": "apache", "extensions": ["onetoc", "onetoc2", "onetmp", "onepkg"] }, "application/oxps": { "source": "iana", "extensions": ["oxps"] }, "application/p2p-overlay+xml": { "source": "iana" }, "application/parityfec": { "source": "iana" }, "application/patch-ops-error+xml": { "source": "iana", "extensions": ["xer"] }, "application/pdf": { "source": "iana", "compressible": false, "extensions": ["pdf"] }, "application/pdx": { "source": "iana" }, "application/pgp-encrypted": { "source": "iana", "compressible": false, "extensions": ["pgp"] }, "application/pgp-keys": { "source": "iana" }, "application/pgp-signature": { "source": "iana", "extensions": ["asc", "sig"] }, "application/pics-rules": { "source": "apache", "extensions": ["prf"] }, "application/pidf+xml": { "source": "iana" }, "application/pidf-diff+xml": { "source": "iana" }, "application/pkcs10": { "source": "iana", "extensions": ["p10"] }, "application/pkcs12": { "source": "iana" }, "application/pkcs7-mime": { "source": "iana", "extensions": ["p7m", "p7c"] }, "application/pkcs7-signature": { "source": "iana", "extensions": ["p7s"] }, "application/pkcs8": { "source": "iana", "extensions": ["p8"] }, "application/pkix-attr-cert": { "source": "iana", "extensions": ["ac"] }, "application/pkix-cert": { "source": "iana", "extensions": ["cer"] }, "application/pkix-crl": { "source": "iana", "extensions": ["crl"] }, "application/pkix-pkipath": { "source": "iana", "extensions": ["pkipath"] }, "application/pkixcmp": { "source": "iana", "extensions": ["pki"] }, "application/pls+xml": { "source": "iana", "extensions": ["pls"] }, "application/poc-settings+xml": { "source": "iana" }, "application/postscript": { "source": "iana", "compressible": true, "extensions": ["ai", "eps", "ps"] }, "application/ppsp-tracker+json": { "source": "iana", "compressible": true }, "application/problem+json": { "source": "iana", "compressible": true }, "application/problem+xml": { "source": "iana" }, "application/provenance+xml": { "source": "iana" }, "application/prs.alvestrand.titrax-sheet": { "source": "iana" }, "application/prs.cww": { "source": "iana", "extensions": ["cww"] }, "application/prs.hpub+zip": { "source": "iana" }, "application/prs.nprend": { "source": "iana" }, "application/prs.plucker": { "source": "iana" }, "application/prs.rdf-xml-crypt": { "source": "iana" }, "application/prs.xsf+xml": { "source": "iana" }, "application/pskc+xml": { "source": "iana", "extensions": ["pskcxml"] }, "application/qsig": { "source": "iana" }, "application/raptorfec": { "source": "iana" }, "application/rdap+json": { "source": "iana", "compressible": true }, "application/rdf+xml": { "source": "iana", "compressible": true, "extensions": ["rdf"] }, "application/reginfo+xml": { "source": "iana", "extensions": ["rif"] }, "application/relax-ng-compact-syntax": { "source": "iana", "extensions": ["rnc"] }, "application/remote-printing": { "source": "iana" }, "application/reputon+json": { "source": "iana", "compressible": true }, "application/resource-lists+xml": { "source": "iana", "extensions": ["rl"] }, "application/resource-lists-diff+xml": { "source": "iana", "extensions": ["rld"] }, "application/rfc+xml": { "source": "iana" }, "application/riscos": { "source": "iana" }, "application/rlmi+xml": { "source": "iana" }, "application/rls-services+xml": { "source": "iana", "extensions": ["rs"] }, "application/rpki-ghostbusters": { "source": "iana", "extensions": ["gbr"] }, "application/rpki-manifest": { "source": "iana", "extensions": ["mft"] }, "application/rpki-roa": { "source": "iana", "extensions": ["roa"] }, "application/rpki-updown": { "source": "iana" }, "application/rsd+xml": { "source": "apache", "extensions": ["rsd"] }, "application/rss+xml": { "source": "apache", "compressible": true, "extensions": ["rss"] }, "application/rtf": { "source": "iana", "compressible": true, "extensions": ["rtf"] }, "application/rtploopback": { "source": "iana" }, "application/rtx": { "source": "iana" }, "application/samlassertion+xml": { "source": "iana" }, "application/samlmetadata+xml": { "source": "iana" }, "application/sbml+xml": { "source": "iana", "extensions": ["sbml"] }, "application/scaip+xml": { "source": "iana" }, "application/scim+json": { "source": "iana", "compressible": true }, "application/scvp-cv-request": { "source": "iana", "extensions": ["scq"] }, "application/scvp-cv-response": { "source": "iana", "extensions": ["scs"] }, "application/scvp-vp-request": { "source": "iana", "extensions": ["spq"] }, "application/scvp-vp-response": { "source": "iana", "extensions": ["spp"] }, "application/sdp": { "source": "iana", "extensions": ["sdp"] }, "application/sep+xml": { "source": "iana" }, "application/sep-exi": { "source": "iana" }, "application/session-info": { "source": "iana" }, "application/set-payment": { "source": "iana" }, "application/set-payment-initiation": { "source": "iana", "extensions": ["setpay"] }, "application/set-registration": { "source": "iana" }, "application/set-registration-initiation": { "source": "iana", "extensions": ["setreg"] }, "application/sgml": { "source": "iana" }, "application/sgml-open-catalog": { "source": "iana" }, "application/shf+xml": { "source": "iana", "extensions": ["shf"] }, "application/sieve": { "source": "iana" }, "application/simple-filter+xml": { "source": "iana" }, "application/simple-message-summary": { "source": "iana" }, "application/simplesymbolcontainer": { "source": "iana" }, "application/slate": { "source": "iana" }, "application/smil": { "source": "iana" }, "application/smil+xml": { "source": "iana", "extensions": ["smi", "smil"] }, "application/smpte336m": { "source": "iana" }, "application/soap+fastinfoset": { "source": "iana" }, "application/soap+xml": { "source": "iana", "compressible": true }, "application/sparql-query": { "source": "iana", "extensions": ["rq"] }, "application/sparql-results+xml": { "source": "iana", "extensions": ["srx"] }, "application/spirits-event+xml": { "source": "iana" }, "application/sql": { "source": "iana" }, "application/srgs": { "source": "iana", "extensions": ["gram"] }, "application/srgs+xml": { "source": "iana", "extensions": ["grxml"] }, "application/sru+xml": { "source": "iana", "extensions": ["sru"] }, "application/ssdl+xml": { "source": "apache", "extensions": ["ssdl"] }, "application/ssml+xml": { "source": "iana", "extensions": ["ssml"] }, "application/tamp-apex-update": { "source": "iana" }, "application/tamp-apex-update-confirm": { "source": "iana" }, "application/tamp-community-update": { "source": "iana" }, "application/tamp-community-update-confirm": { "source": "iana" }, "application/tamp-error": { "source": "iana" }, "application/tamp-sequence-adjust": { "source": "iana" }, "application/tamp-sequence-adjust-confirm": { "source": "iana" }, "application/tamp-status-query": { "source": "iana" }, "application/tamp-status-response": { "source": "iana" }, "application/tamp-update": { "source": "iana" }, "application/tamp-update-confirm": { "source": "iana" }, "application/tar": { "compressible": true }, "application/tei+xml": { "source": "iana", "extensions": ["tei", "teicorpus"] }, "application/thraud+xml": { "source": "iana", "extensions": ["tfi"] }, "application/timestamp-query": { "source": "iana" }, "application/timestamp-reply": { "source": "iana" }, "application/timestamped-data": { "source": "iana", "extensions": ["tsd"] }, "application/ttml+xml": { "source": "iana" }, "application/tve-trigger": { "source": "iana" }, "application/ulpfec": { "source": "iana" }, "application/urc-grpsheet+xml": { "source": "iana" }, "application/urc-ressheet+xml": { "source": "iana" }, "application/urc-targetdesc+xml": { "source": "iana" }, "application/urc-uisocketdesc+xml": { "source": "iana" }, "application/vcard+json": { "source": "iana", "compressible": true }, "application/vcard+xml": { "source": "iana" }, "application/vemmi": { "source": "iana" }, "application/vividence.scriptfile": { "source": "apache" }, "application/vnd.3gpp-prose+xml": { "source": "iana" }, "application/vnd.3gpp-prose-pc3ch+xml": { "source": "iana" }, "application/vnd.3gpp.access-transfer-events+xml": { "source": "iana" }, "application/vnd.3gpp.bsf+xml": { "source": "iana" }, "application/vnd.3gpp.mid-call+xml": { "source": "iana" }, "application/vnd.3gpp.pic-bw-large": { "source": "iana", "extensions": ["plb"] }, "application/vnd.3gpp.pic-bw-small": { "source": "iana", "extensions": ["psb"] }, "application/vnd.3gpp.pic-bw-var": { "source": "iana", "extensions": ["pvb"] }, "application/vnd.3gpp.sms": { "source": "iana" }, "application/vnd.3gpp.sms+xml": { "source": "iana" }, "application/vnd.3gpp.srvcc-ext+xml": { "source": "iana" }, "application/vnd.3gpp.srvcc-info+xml": { "source": "iana" }, "application/vnd.3gpp.state-and-event-info+xml": { "source": "iana" }, "application/vnd.3gpp.ussd+xml": { "source": "iana" }, "application/vnd.3gpp2.bcmcsinfo+xml": { "source": "iana" }, "application/vnd.3gpp2.sms": { "source": "iana" }, "application/vnd.3gpp2.tcap": { "source": "iana", "extensions": ["tcap"] }, "application/vnd.3lightssoftware.imagescal": { "source": "iana" }, "application/vnd.3m.post-it-notes": { "source": "iana", "extensions": ["pwn"] }, "application/vnd.accpac.simply.aso": { "source": "iana", "extensions": ["aso"] }, "application/vnd.accpac.simply.imp": { "source": "iana", "extensions": ["imp"] }, "application/vnd.acucobol": { "source": "iana", "extensions": ["acu"] }, "application/vnd.acucorp": { "source": "iana", "extensions": ["atc", "acutc"] }, "application/vnd.adobe.air-application-installer-package+zip": { "source": "apache", "extensions": ["air"] }, "application/vnd.adobe.flash.movie": { "source": "iana" }, "application/vnd.adobe.formscentral.fcdt": { "source": "iana", "extensions": ["fcdt"] }, "application/vnd.adobe.fxp": { "source": "iana", "extensions": ["fxp", "fxpl"] }, "application/vnd.adobe.partial-upload": { "source": "iana" }, "application/vnd.adobe.xdp+xml": { "source": "iana", "extensions": ["xdp"] }, "application/vnd.adobe.xfdf": { "source": "iana", "extensions": ["xfdf"] }, "application/vnd.aether.imp": { "source": "iana" }, "application/vnd.ah-barcode": { "source": "iana" }, "application/vnd.ahead.space": { "source": "iana", "extensions": ["ahead"] }, "application/vnd.airzip.filesecure.azf": { "source": "iana", "extensions": ["azf"] }, "application/vnd.airzip.filesecure.azs": { "source": "iana", "extensions": ["azs"] }, "application/vnd.amazon.ebook": { "source": "apache", "extensions": ["azw"] }, "application/vnd.amazon.mobi8-ebook": { "source": "iana" }, "application/vnd.americandynamics.acc": { "source": "iana", "extensions": ["acc"] }, "application/vnd.amiga.ami": { "source": "iana", "extensions": ["ami"] }, "application/vnd.amundsen.maze+xml": { "source": "iana" }, "application/vnd.android.package-archive": { "source": "apache", "compressible": false, "extensions": ["apk"] }, "application/vnd.anki": { "source": "iana" }, "application/vnd.anser-web-certificate-issue-initiation": { "source": "iana", "extensions": ["cii"] }, "application/vnd.anser-web-funds-transfer-initiation": { "source": "apache", "extensions": ["fti"] }, "application/vnd.antix.game-component": { "source": "iana", "extensions": ["atx"] }, "application/vnd.apache.thrift.binary": { "source": "iana" }, "application/vnd.apache.thrift.compact": { "source": "iana" }, "application/vnd.apache.thrift.json": { "source": "iana" }, "application/vnd.api+json": { "source": "iana", "compressible": true }, "application/vnd.apple.installer+xml": { "source": "iana", "extensions": ["mpkg"] }, "application/vnd.apple.mpegurl": { "source": "iana", "extensions": ["m3u8"] }, "application/vnd.apple.pkpass": { "compressible": false, "extensions": ["pkpass"] }, "application/vnd.arastra.swi": { "source": "iana" }, "application/vnd.aristanetworks.swi": { "source": "iana", "extensions": ["swi"] }, "application/vnd.artsquare": { "source": "iana" }, "application/vnd.astraea-software.iota": { "source": "iana", "extensions": ["iota"] }, "application/vnd.audiograph": { "source": "iana", "extensions": ["aep"] }, "application/vnd.autopackage": { "source": "iana" }, "application/vnd.avistar+xml": { "source": "iana" }, "application/vnd.balsamiq.bmml+xml": { "source": "iana" }, "application/vnd.balsamiq.bmpr": { "source": "iana" }, "application/vnd.bekitzur-stech+json": { "source": "iana", "compressible": true }, "application/vnd.biopax.rdf+xml": { "source": "iana" }, "application/vnd.blueice.multipass": { "source": "iana", "extensions": ["mpm"] }, "application/vnd.bluetooth.ep.oob": { "source": "iana" }, "application/vnd.bluetooth.le.oob": { "source": "iana" }, "application/vnd.bmi": { "source": "iana", "extensions": ["bmi"] }, "application/vnd.businessobjects": { "source": "iana", "extensions": ["rep"] }, "application/vnd.cab-jscript": { "source": "iana" }, "application/vnd.canon-cpdl": { "source": "iana" }, "application/vnd.canon-lips": { "source": "iana" }, "application/vnd.cendio.thinlinc.clientconf": { "source": "iana" }, "application/vnd.century-systems.tcp_stream": { "source": "iana" }, "application/vnd.chemdraw+xml": { "source": "iana", "extensions": ["cdxml"] }, "application/vnd.chess-pgn": { "source": "iana" }, "application/vnd.chipnuts.karaoke-mmd": { "source": "iana", "extensions": ["mmd"] }, "application/vnd.cinderella": { "source": "iana", "extensions": ["cdy"] }, "application/vnd.cirpack.isdn-ext": { "source": "iana" }, "application/vnd.citationstyles.style+xml": { "source": "iana" }, "application/vnd.claymore": { "source": "iana", "extensions": ["cla"] }, "application/vnd.cloanto.rp9": { "source": "iana", "extensions": ["rp9"] }, "application/vnd.clonk.c4group": { "source": "iana", "extensions": ["c4g", "c4d", "c4f", "c4p", "c4u"] }, "application/vnd.cluetrust.cartomobile-config": { "source": "iana", "extensions": ["c11amc"] }, "application/vnd.cluetrust.cartomobile-config-pkg": { "source": "iana", "extensions": ["c11amz"] }, "application/vnd.coffeescript": { "source": "iana" }, "application/vnd.collection+json": { "source": "iana", "compressible": true }, "application/vnd.collection.doc+json": { "source": "iana", "compressible": true }, "application/vnd.collection.next+json": { "source": "iana", "compressible": true }, "application/vnd.comicbook+zip": { "source": "iana" }, "application/vnd.commerce-battelle": { "source": "iana" }, "application/vnd.commonspace": { "source": "iana", "extensions": ["csp"] }, "application/vnd.contact.cmsg": { "source": "iana", "extensions": ["cdbcmsg"] }, "application/vnd.coreos.ignition+json": { "source": "iana", "compressible": true }, "application/vnd.cosmocaller": { "source": "iana", "extensions": ["cmc"] }, "application/vnd.crick.clicker": { "source": "iana", "extensions": ["clkx"] }, "application/vnd.crick.clicker.keyboard": { "source": "iana", "extensions": ["clkk"] }, "application/vnd.crick.clicker.palette": { "source": "iana", "extensions": ["clkp"] }, "application/vnd.crick.clicker.template": { "source": "iana", "extensions": ["clkt"] }, "application/vnd.crick.clicker.wordbank": { "source": "iana", "extensions": ["clkw"] }, "application/vnd.criticaltools.wbs+xml": { "source": "iana", "extensions": ["wbs"] }, "application/vnd.ctc-posml": { "source": "iana", "extensions": ["pml"] }, "application/vnd.ctct.ws+xml": { "source": "iana" }, "application/vnd.cups-pdf": { "source": "iana" }, "application/vnd.cups-postscript": { "source": "iana" }, "application/vnd.cups-ppd": { "source": "iana", "extensions": ["ppd"] }, "application/vnd.cups-raster": { "source": "iana" }, "application/vnd.cups-raw": { "source": "iana" }, "application/vnd.curl": { "source": "iana" }, "application/vnd.curl.car": { "source": "apache", "extensions": ["car"] }, "application/vnd.curl.pcurl": { "source": "apache", "extensions": ["pcurl"] }, "application/vnd.cyan.dean.root+xml": { "source": "iana" }, "application/vnd.cybank": { "source": "iana" }, "application/vnd.d2l.coursepackage1p0+zip": { "source": "iana" }, "application/vnd.dart": { "source": "iana", "compressible": true, "extensions": ["dart"] }, "application/vnd.data-vision.rdz": { "source": "iana", "extensions": ["rdz"] }, "application/vnd.debian.binary-package": { "source": "iana" }, "application/vnd.dece.data": { "source": "iana", "extensions": ["uvf", "uvvf", "uvd", "uvvd"] }, "application/vnd.dece.ttml+xml": { "source": "iana", "extensions": ["uvt", "uvvt"] }, "application/vnd.dece.unspecified": { "source": "iana", "extensions": ["uvx", "uvvx"] }, "application/vnd.dece.zip": { "source": "iana", "extensions": ["uvz", "uvvz"] }, "application/vnd.denovo.fcselayout-link": { "source": "iana", "extensions": ["fe_launch"] }, "application/vnd.desmume-movie": { "source": "iana" }, "application/vnd.desmume.movie": { "source": "apache" }, "application/vnd.dir-bi.plate-dl-nosuffix": { "source": "iana" }, "application/vnd.dm.delegation+xml": { "source": "iana" }, "application/vnd.dna": { "source": "iana", "extensions": ["dna"] }, "application/vnd.document+json": { "source": "iana", "compressible": true }, "application/vnd.dolby.mlp": { "source": "apache", "extensions": ["mlp"] }, "application/vnd.dolby.mobile.1": { "source": "iana" }, "application/vnd.dolby.mobile.2": { "source": "iana" }, "application/vnd.doremir.scorecloud-binary-document": { "source": "iana" }, "application/vnd.dpgraph": { "source": "iana", "extensions": ["dpg"] }, "application/vnd.dreamfactory": { "source": "iana", "extensions": ["dfac"] }, "application/vnd.drive+json": { "source": "iana", "compressible": true }, "application/vnd.ds-keypoint": { "source": "apache", "extensions": ["kpxx"] }, "application/vnd.dtg.local": { "source": "iana" }, "application/vnd.dtg.local.flash": { "source": "iana" }, "application/vnd.dtg.local.html": { "source": "iana" }, "application/vnd.dvb.ait": { "source": "iana", "extensions": ["ait"] }, "application/vnd.dvb.dvbj": { "source": "iana" }, "application/vnd.dvb.esgcontainer": { "source": "iana" }, "application/vnd.dvb.ipdcdftnotifaccess": { "source": "iana" }, "application/vnd.dvb.ipdcesgaccess": { "source": "iana" }, "application/vnd.dvb.ipdcesgaccess2": { "source": "iana" }, "application/vnd.dvb.ipdcesgpdd": { "source": "iana" }, "application/vnd.dvb.ipdcroaming": { "source": "iana" }, "application/vnd.dvb.iptv.alfec-base": { "source": "iana" }, "application/vnd.dvb.iptv.alfec-enhancement": { "source": "iana" }, "application/vnd.dvb.notif-aggregate-root+xml": { "source": "iana" }, "application/vnd.dvb.notif-container+xml": { "source": "iana" }, "application/vnd.dvb.notif-generic+xml": { "source": "iana" }, "application/vnd.dvb.notif-ia-msglist+xml": { "source": "iana" }, "application/vnd.dvb.notif-ia-registration-request+xml": { "source": "iana" }, "application/vnd.dvb.notif-ia-registration-response+xml": { "source": "iana" }, "application/vnd.dvb.notif-init+xml": { "source": "iana" }, "application/vnd.dvb.pfr": { "source": "iana" }, "application/vnd.dvb.service": { "source": "iana", "extensions": ["svc"] }, "application/vnd.dxr": { "source": "iana" }, "application/vnd.dynageo": { "source": "iana", "extensions": ["geo"] }, "application/vnd.dzr": { "source": "iana" }, "application/vnd.easykaraoke.cdgdownload": { "source": "iana" }, "application/vnd.ecdis-update": { "source": "iana" }, "application/vnd.ecowin.chart": { "source": "iana", "extensions": ["mag"] }, "application/vnd.ecowin.filerequest": { "source": "iana" }, "application/vnd.ecowin.fileupdate": { "source": "iana" }, "application/vnd.ecowin.series": { "source": "iana" }, "application/vnd.ecowin.seriesrequest": { "source": "iana" }, "application/vnd.ecowin.seriesupdate": { "source": "iana" }, "application/vnd.emclient.accessrequest+xml": { "source": "iana" }, "application/vnd.enliven": { "source": "iana", "extensions": ["nml"] }, "application/vnd.enphase.envoy": { "source": "iana" }, "application/vnd.eprints.data+xml": { "source": "iana" }, "application/vnd.epson.esf": { "source": "iana", "extensions": ["esf"] }, "application/vnd.epson.msf": { "source": "iana", "extensions": ["msf"] }, "application/vnd.epson.quickanime": { "source": "iana", "extensions": ["qam"] }, "application/vnd.epson.salt": { "source": "iana", "extensions": ["slt"] }, "application/vnd.epson.ssf": { "source": "iana", "extensions": ["ssf"] }, "application/vnd.ericsson.quickcall": { "source": "iana" }, "application/vnd.espass-espass+zip": { "source": "iana" }, "application/vnd.eszigno3+xml": { "source": "iana", "extensions": ["es3", "et3"] }, "application/vnd.etsi.aoc+xml": { "source": "iana" }, "application/vnd.etsi.asic-e+zip": { "source": "iana" }, "application/vnd.etsi.asic-s+zip": { "source": "iana" }, "application/vnd.etsi.cug+xml": { "source": "iana" }, "application/vnd.etsi.iptvcommand+xml": { "source": "iana" }, "application/vnd.etsi.iptvdiscovery+xml": { "source": "iana" }, "application/vnd.etsi.iptvprofile+xml": { "source": "iana" }, "application/vnd.etsi.iptvsad-bc+xml": { "source": "iana" }, "application/vnd.etsi.iptvsad-cod+xml": { "source": "iana" }, "application/vnd.etsi.iptvsad-npvr+xml": { "source": "iana" }, "application/vnd.etsi.iptvservice+xml": { "source": "iana" }, "application/vnd.etsi.iptvsync+xml": { "source": "iana" }, "application/vnd.etsi.iptvueprofile+xml": { "source": "iana" }, "application/vnd.etsi.mcid+xml": { "source": "iana" }, "application/vnd.etsi.mheg5": { "source": "iana" }, "application/vnd.etsi.overload-control-policy-dataset+xml": { "source": "iana" }, "application/vnd.etsi.pstn+xml": { "source": "iana" }, "application/vnd.etsi.sci+xml": { "source": "iana" }, "application/vnd.etsi.simservs+xml": { "source": "iana" }, "application/vnd.etsi.timestamp-token": { "source": "iana" }, "application/vnd.etsi.tsl+xml": { "source": "iana" }, "application/vnd.etsi.tsl.der": { "source": "iana" }, "application/vnd.eudora.data": { "source": "iana" }, "application/vnd.ezpix-album": { "source": "iana", "extensions": ["ez2"] }, "application/vnd.ezpix-package": { "source": "iana", "extensions": ["ez3"] }, "application/vnd.f-secure.mobile": { "source": "iana" }, "application/vnd.fastcopy-disk-image": { "source": "iana" }, "application/vnd.fdf": { "source": "iana", "extensions": ["fdf"] }, "application/vnd.fdsn.mseed": { "source": "iana", "extensions": ["mseed"] }, "application/vnd.fdsn.seed": { "source": "iana", "extensions": ["seed", "dataless"] }, "application/vnd.ffsns": { "source": "iana" }, "application/vnd.filmit.zfc": { "source": "iana" }, "application/vnd.fints": { "source": "iana" }, "application/vnd.firemonkeys.cloudcell": { "source": "iana" }, "application/vnd.flographit": { "source": "iana", "extensions": ["gph"] }, "application/vnd.fluxtime.clip": { "source": "iana", "extensions": ["ftc"] }, "application/vnd.font-fontforge-sfd": { "source": "iana" }, "application/vnd.framemaker": { "source": "iana", "extensions": ["fm", "frame", "maker", "book"] }, "application/vnd.frogans.fnc": { "source": "iana", "extensions": ["fnc"] }, "application/vnd.frogans.ltf": { "source": "iana", "extensions": ["ltf"] }, "application/vnd.fsc.weblaunch": { "source": "iana", "extensions": ["fsc"] }, "application/vnd.fujitsu.oasys": { "source": "iana", "extensions": ["oas"] }, "application/vnd.fujitsu.oasys2": { "source": "iana", "extensions": ["oa2"] }, "application/vnd.fujitsu.oasys3": { "source": "iana", "extensions": ["oa3"] }, "application/vnd.fujitsu.oasysgp": { "source": "iana", "extensions": ["fg5"] }, "application/vnd.fujitsu.oasysprs": { "source": "iana", "extensions": ["bh2"] }, "application/vnd.fujixerox.art-ex": { "source": "iana" }, "application/vnd.fujixerox.art4": { "source": "iana" }, "application/vnd.fujixerox.ddd": { "source": "iana", "extensions": ["ddd"] }, "application/vnd.fujixerox.docuworks": { "source": "iana", "extensions": ["xdw"] }, "application/vnd.fujixerox.docuworks.binder": { "source": "iana", "extensions": ["xbd"] }, "application/vnd.fujixerox.docuworks.container": { "source": "iana" }, "application/vnd.fujixerox.hbpl": { "source": "iana" }, "application/vnd.fut-misnet": { "source": "iana" }, "application/vnd.fuzzysheet": { "source": "iana", "extensions": ["fzs"] }, "application/vnd.genomatix.tuxedo": { "source": "iana", "extensions": ["txd"] }, "application/vnd.geo+json": { "source": "iana", "compressible": true }, "application/vnd.geocube+xml": { "source": "iana" }, "application/vnd.geogebra.file": { "source": "iana", "extensions": ["ggb"] }, "application/vnd.geogebra.tool": { "source": "iana", "extensions": ["ggt"] }, "application/vnd.geometry-explorer": { "source": "iana", "extensions": ["gex", "gre"] }, "application/vnd.geonext": { "source": "iana", "extensions": ["gxt"] }, "application/vnd.geoplan": { "source": "iana", "extensions": ["g2w"] }, "application/vnd.geospace": { "source": "iana", "extensions": ["g3w"] }, "application/vnd.gerber": { "source": "iana" }, "application/vnd.globalplatform.card-content-mgt": { "source": "iana" }, "application/vnd.globalplatform.card-content-mgt-response": { "source": "iana" }, "application/vnd.gmx": { "source": "iana", "extensions": ["gmx"] }, "application/vnd.google-apps.document": { "compressible": false, "extensions": ["gdoc"] }, "application/vnd.google-apps.presentation": { "compressible": false, "extensions": ["gslides"] }, "application/vnd.google-apps.spreadsheet": { "compressible": false, "extensions": ["gsheet"] }, "application/vnd.google-earth.kml+xml": { "source": "iana", "compressible": true, "extensions": ["kml"] }, "application/vnd.google-earth.kmz": { "source": "iana", "compressible": false, "extensions": ["kmz"] }, "application/vnd.gov.sk.e-form+xml": { "source": "iana" }, "application/vnd.gov.sk.e-form+zip": { "source": "iana" }, "application/vnd.gov.sk.xmldatacontainer+xml": { "source": "iana" }, "application/vnd.grafeq": { "source": "iana", "extensions": ["gqf", "gqs"] }, "application/vnd.gridmp": { "source": "iana" }, "application/vnd.groove-account": { "source": "iana", "extensions": ["gac"] }, "application/vnd.groove-help": { "source": "iana", "extensions": ["ghf"] }, "application/vnd.groove-identity-message": { "source": "iana", "extensions": ["gim"] }, "application/vnd.groove-injector": { "source": "iana", "extensions": ["grv"] }, "application/vnd.groove-tool-message": { "source": "iana", "extensions": ["gtm"] }, "application/vnd.groove-tool-template": { "source": "iana", "extensions": ["tpl"] }, "application/vnd.groove-vcard": { "source": "iana", "extensions": ["vcg"] }, "application/vnd.hal+json": { "source": "iana", "compressible": true }, "application/vnd.hal+xml": { "source": "iana", "extensions": ["hal"] }, "application/vnd.handheld-entertainment+xml": { "source": "iana", "extensions": ["zmm"] }, "application/vnd.hbci": { "source": "iana", "extensions": ["hbci"] }, "application/vnd.hcl-bireports": { "source": "iana" }, "application/vnd.hdt": { "source": "iana" }, "application/vnd.heroku+json": { "source": "iana", "compressible": true }, "application/vnd.hhe.lesson-player": { "source": "iana", "extensions": ["les"] }, "application/vnd.hp-hpgl": { "source": "iana", "extensions": ["hpgl"] }, "application/vnd.hp-hpid": { "source": "iana", "extensions": ["hpid"] }, "application/vnd.hp-hps": { "source": "iana", "extensions": ["hps"] }, "application/vnd.hp-jlyt": { "source": "iana", "extensions": ["jlt"] }, "application/vnd.hp-pcl": { "source": "iana", "extensions": ["pcl"] }, "application/vnd.hp-pclxl": { "source": "iana", "extensions": ["pclxl"] }, "application/vnd.httphone": { "source": "iana" }, "application/vnd.hydrostatix.sof-data": { "source": "iana", "extensions": ["sfd-hdstx"] }, "application/vnd.hyperdrive+json": { "source": "iana", "compressible": true }, "application/vnd.hzn-3d-crossword": { "source": "iana" }, "application/vnd.ibm.afplinedata": { "source": "iana" }, "application/vnd.ibm.electronic-media": { "source": "iana" }, "application/vnd.ibm.minipay": { "source": "iana", "extensions": ["mpy"] }, "application/vnd.ibm.modcap": { "source": "iana", "extensions": ["afp", "listafp", "list3820"] }, "application/vnd.ibm.rights-management": { "source": "iana", "extensions": ["irm"] }, "application/vnd.ibm.secure-container": { "source": "iana", "extensions": ["sc"] }, "application/vnd.iccprofile": { "source": "iana", "extensions": ["icc", "icm"] }, "application/vnd.ieee.1905": { "source": "iana" }, "application/vnd.igloader": { "source": "iana", "extensions": ["igl"] }, "application/vnd.immervision-ivp": { "source": "iana", "extensions": ["ivp"] }, "application/vnd.immervision-ivu": { "source": "iana", "extensions": ["ivu"] }, "application/vnd.ims.imsccv1p1": { "source": "iana" }, "application/vnd.ims.imsccv1p2": { "source": "iana" }, "application/vnd.ims.imsccv1p3": { "source": "iana" }, "application/vnd.ims.lis.v2.result+json": { "source": "iana", "compressible": true }, "application/vnd.ims.lti.v2.toolconsumerprofile+json": { "source": "iana", "compressible": true }, "application/vnd.ims.lti.v2.toolproxy+json": { "source": "iana", "compressible": true }, "application/vnd.ims.lti.v2.toolproxy.id+json": { "source": "iana", "compressible": true }, "application/vnd.ims.lti.v2.toolsettings+json": { "source": "iana", "compressible": true }, "application/vnd.ims.lti.v2.toolsettings.simple+json": { "source": "iana", "compressible": true }, "application/vnd.informedcontrol.rms+xml": { "source": "iana" }, "application/vnd.informix-visionary": { "source": "iana" }, "application/vnd.infotech.project": { "source": "iana" }, "application/vnd.infotech.project+xml": { "source": "iana" }, "application/vnd.innopath.wamp.notification": { "source": "iana" }, "application/vnd.insors.igm": { "source": "iana", "extensions": ["igm"] }, "application/vnd.intercon.formnet": { "source": "iana", "extensions": ["xpw", "xpx"] }, "application/vnd.intergeo": { "source": "iana", "extensions": ["i2g"] }, "application/vnd.intertrust.digibox": { "source": "iana" }, "application/vnd.intertrust.nncp": { "source": "iana" }, "application/vnd.intu.qbo": { "source": "iana", "extensions": ["qbo"] }, "application/vnd.intu.qfx": { "source": "iana", "extensions": ["qfx"] }, "application/vnd.iptc.g2.catalogitem+xml": { "source": "iana" }, "application/vnd.iptc.g2.conceptitem+xml": { "source": "iana" }, "application/vnd.iptc.g2.knowledgeitem+xml": { "source": "iana" }, "application/vnd.iptc.g2.newsitem+xml": { "source": "iana" }, "application/vnd.iptc.g2.newsmessage+xml": { "source": "iana" }, "application/vnd.iptc.g2.packageitem+xml": { "source": "iana" }, "application/vnd.iptc.g2.planningitem+xml": { "source": "iana" }, "application/vnd.ipunplugged.rcprofile": { "source": "iana", "extensions": ["rcprofile"] }, "application/vnd.irepository.package+xml": { "source": "iana", "extensions": ["irp"] }, "application/vnd.is-xpr": { "source": "iana", "extensions": ["xpr"] }, "application/vnd.isac.fcs": { "source": "iana", "extensions": ["fcs"] }, "application/vnd.jam": { "source": "iana", "extensions": ["jam"] }, "application/vnd.japannet-directory-service": { "source": "iana" }, "application/vnd.japannet-jpnstore-wakeup": { "source": "iana" }, "application/vnd.japannet-payment-wakeup": { "source": "iana" }, "application/vnd.japannet-registration": { "source": "iana" }, "application/vnd.japannet-registration-wakeup": { "source": "iana" }, "application/vnd.japannet-setstore-wakeup": { "source": "iana" }, "application/vnd.japannet-verification": { "source": "iana" }, "application/vnd.japannet-verification-wakeup": { "source": "iana" }, "application/vnd.jcp.javame.midlet-rms": { "source": "iana", "extensions": ["rms"] }, "application/vnd.jisp": { "source": "iana", "extensions": ["jisp"] }, "application/vnd.joost.joda-archive": { "source": "iana", "extensions": ["joda"] }, "application/vnd.jsk.isdn-ngn": { "source": "iana" }, "application/vnd.kahootz": { "source": "iana", "extensions": ["ktz", "ktr"] }, "application/vnd.kde.karbon": { "source": "iana", "extensions": ["karbon"] }, "application/vnd.kde.kchart": { "source": "iana", "extensions": ["chrt"] }, "application/vnd.kde.kformula": { "source": "iana", "extensions": ["kfo"] }, "application/vnd.kde.kivio": { "source": "iana", "extensions": ["flw"] }, "application/vnd.kde.kontour": { "source": "iana", "extensions": ["kon"] }, "application/vnd.kde.kpresenter": { "source": "iana", "extensions": ["kpr", "kpt"] }, "application/vnd.kde.kspread": { "source": "iana", "extensions": ["ksp"] }, "application/vnd.kde.kword": { "source": "iana", "extensions": ["kwd", "kwt"] }, "application/vnd.kenameaapp": { "source": "iana", "extensions": ["htke"] }, "application/vnd.kidspiration": { "source": "iana", "extensions": ["kia"] }, "application/vnd.kinar": { "source": "iana", "extensions": ["kne", "knp"] }, "application/vnd.koan": { "source": "iana", "extensions": ["skp", "skd", "skt", "skm"] }, "application/vnd.kodak-descriptor": { "source": "iana", "extensions": ["sse"] }, "application/vnd.las.las+xml": { "source": "iana", "extensions": ["lasxml"] }, "application/vnd.liberty-request+xml": { "source": "iana" }, "application/vnd.llamagraphics.life-balance.desktop": { "source": "iana", "extensions": ["lbd"] }, "application/vnd.llamagraphics.life-balance.exchange+xml": { "source": "iana", "extensions": ["lbe"] }, "application/vnd.lotus-1-2-3": { "source": "iana", "extensions": ["123"] }, "application/vnd.lotus-approach": { "source": "iana", "extensions": ["apr"] }, "application/vnd.lotus-freelance": { "source": "iana", "extensions": ["pre"] }, "application/vnd.lotus-notes": { "source": "iana", "extensions": ["nsf"] }, "application/vnd.lotus-organizer": { "source": "iana", "extensions": ["org"] }, "application/vnd.lotus-screencam": { "source": "iana", "extensions": ["scm"] }, "application/vnd.lotus-wordpro": { "source": "iana", "extensions": ["lwp"] }, "application/vnd.macports.portpkg": { "source": "iana", "extensions": ["portpkg"] }, "application/vnd.mapbox-vector-tile": { "source": "iana" }, "application/vnd.marlin.drm.actiontoken+xml": { "source": "iana" }, "application/vnd.marlin.drm.conftoken+xml": { "source": "iana" }, "application/vnd.marlin.drm.license+xml": { "source": "iana" }, "application/vnd.marlin.drm.mdcf": { "source": "iana" }, "application/vnd.mason+json": { "source": "iana", "compressible": true }, "application/vnd.maxmind.maxmind-db": { "source": "iana" }, "application/vnd.mcd": { "source": "iana", "extensions": ["mcd"] }, "application/vnd.medcalcdata": { "source": "iana", "extensions": ["mc1"] }, "application/vnd.mediastation.cdkey": { "source": "iana", "extensions": ["cdkey"] }, "application/vnd.meridian-slingshot": { "source": "iana" }, "application/vnd.mfer": { "source": "iana", "extensions": ["mwf"] }, "application/vnd.mfmp": { "source": "iana", "extensions": ["mfm"] }, "application/vnd.micro+json": { "source": "iana", "compressible": true }, "application/vnd.micrografx.flo": { "source": "iana", "extensions": ["flo"] }, "application/vnd.micrografx.igx": { "source": "iana", "extensions": ["igx"] }, "application/vnd.microsoft.portable-executable": { "source": "iana" }, "application/vnd.miele+json": { "source": "iana", "compressible": true }, "application/vnd.mif": { "source": "iana", "extensions": ["mif"] }, "application/vnd.minisoft-hp3000-save": { "source": "iana" }, "application/vnd.mitsubishi.misty-guard.trustweb": { "source": "iana" }, "application/vnd.mobius.daf": { "source": "iana", "extensions": ["daf"] }, "application/vnd.mobius.dis": { "source": "iana", "extensions": ["dis"] }, "application/vnd.mobius.mbk": { "source": "iana", "extensions": ["mbk"] }, "application/vnd.mobius.mqy": { "source": "iana", "extensions": ["mqy"] }, "application/vnd.mobius.msl": { "source": "iana", "extensions": ["msl"] }, "application/vnd.mobius.plc": { "source": "iana", "extensions": ["plc"] }, "application/vnd.mobius.txf": { "source": "iana", "extensions": ["txf"] }, "application/vnd.mophun.application": { "source": "iana", "extensions": ["mpn"] }, "application/vnd.mophun.certificate": { "source": "iana", "extensions": ["mpc"] }, "application/vnd.motorola.flexsuite": { "source": "iana" }, "application/vnd.motorola.flexsuite.adsi": { "source": "iana" }, "application/vnd.motorola.flexsuite.fis": { "source": "iana" }, "application/vnd.motorola.flexsuite.gotap": { "source": "iana" }, "application/vnd.motorola.flexsuite.kmr": { "source": "iana" }, "application/vnd.motorola.flexsuite.ttc": { "source": "iana" }, "application/vnd.motorola.flexsuite.wem": { "source": "iana" }, "application/vnd.motorola.iprm": { "source": "iana" }, "application/vnd.mozilla.xul+xml": { "source": "iana", "compressible": true, "extensions": ["xul"] }, "application/vnd.ms-3mfdocument": { "source": "iana" }, "application/vnd.ms-artgalry": { "source": "iana", "extensions": ["cil"] }, "application/vnd.ms-asf": { "source": "iana" }, "application/vnd.ms-cab-compressed": { "source": "iana", "extensions": ["cab"] }, "application/vnd.ms-color.iccprofile": { "source": "apache" }, "application/vnd.ms-excel": { "source": "iana", "compressible": false, "extensions": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"] }, "application/vnd.ms-excel.addin.macroenabled.12": { "source": "iana", "extensions": ["xlam"] }, "application/vnd.ms-excel.sheet.binary.macroenabled.12": { "source": "iana", "extensions": ["xlsb"] }, "application/vnd.ms-excel.sheet.macroenabled.12": { "source": "iana", "extensions": ["xlsm"] }, "application/vnd.ms-excel.template.macroenabled.12": { "source": "iana", "extensions": ["xltm"] }, "application/vnd.ms-fontobject": { "source": "iana", "compressible": true, "extensions": ["eot"] }, "application/vnd.ms-htmlhelp": { "source": "iana", "extensions": ["chm"] }, "application/vnd.ms-ims": { "source": "iana", "extensions": ["ims"] }, "application/vnd.ms-lrm": { "source": "iana", "extensions": ["lrm"] }, "application/vnd.ms-office.activex+xml": { "source": "iana" }, "application/vnd.ms-officetheme": { "source": "iana", "extensions": ["thmx"] }, "application/vnd.ms-opentype": { "source": "apache", "compressible": true }, "application/vnd.ms-package.obfuscated-opentype": { "source": "apache" }, "application/vnd.ms-pki.seccat": { "source": "apache", "extensions": ["cat"] }, "application/vnd.ms-pki.stl": { "source": "apache", "extensions": ["stl"] }, "application/vnd.ms-playready.initiator+xml": { "source": "iana" }, "application/vnd.ms-powerpoint": { "source": "iana", "compressible": false, "extensions": ["ppt", "pps", "pot"] }, "application/vnd.ms-powerpoint.addin.macroenabled.12": { "source": "iana", "extensions": ["ppam"] }, "application/vnd.ms-powerpoint.presentation.macroenabled.12": { "source": "iana", "extensions": ["pptm"] }, "application/vnd.ms-powerpoint.slide.macroenabled.12": { "source": "iana", "extensions": ["sldm"] }, "application/vnd.ms-powerpoint.slideshow.macroenabled.12": { "source": "iana", "extensions": ["ppsm"] }, "application/vnd.ms-powerpoint.template.macroenabled.12": { "source": "iana", "extensions": ["potm"] }, "application/vnd.ms-printdevicecapabilities+xml": { "source": "iana" }, "application/vnd.ms-printing.printticket+xml": { "source": "apache" }, "application/vnd.ms-printschematicket+xml": { "source": "iana" }, "application/vnd.ms-project": { "source": "iana", "extensions": ["mpp", "mpt"] }, "application/vnd.ms-tnef": { "source": "iana" }, "application/vnd.ms-windows.devicepairing": { "source": "iana" }, "application/vnd.ms-windows.nwprinting.oob": { "source": "iana" }, "application/vnd.ms-windows.printerpairing": { "source": "iana" }, "application/vnd.ms-windows.wsd.oob": { "source": "iana" }, "application/vnd.ms-wmdrm.lic-chlg-req": { "source": "iana" }, "application/vnd.ms-wmdrm.lic-resp": { "source": "iana" }, "application/vnd.ms-wmdrm.meter-chlg-req": { "source": "iana" }, "application/vnd.ms-wmdrm.meter-resp": { "source": "iana" }, "application/vnd.ms-word.document.macroenabled.12": { "source": "iana", "extensions": ["docm"] }, "application/vnd.ms-word.template.macroenabled.12": { "source": "iana", "extensions": ["dotm"] }, "application/vnd.ms-works": { "source": "iana", "extensions": ["wps", "wks", "wcm", "wdb"] }, "application/vnd.ms-wpl": { "source": "iana", "extensions": ["wpl"] }, "application/vnd.ms-xpsdocument": { "source": "iana", "compressible": false, "extensions": ["xps"] }, "application/vnd.msa-disk-image": { "source": "iana" }, "application/vnd.mseq": { "source": "iana", "extensions": ["mseq"] }, "application/vnd.msign": { "source": "iana" }, "application/vnd.multiad.creator": { "source": "iana" }, "application/vnd.multiad.creator.cif": { "source": "iana" }, "application/vnd.music-niff": { "source": "iana" }, "application/vnd.musician": { "source": "iana", "extensions": ["mus"] }, "application/vnd.muvee.style": { "source": "iana", "extensions": ["msty"] }, "application/vnd.mynfc": { "source": "iana", "extensions": ["taglet"] }, "application/vnd.ncd.control": { "source": "iana" }, "application/vnd.ncd.reference": { "source": "iana" }, "application/vnd.nearst.inv+json": { "source": "iana", "compressible": true }, "application/vnd.nervana": { "source": "iana" }, "application/vnd.netfpx": { "source": "iana" }, "application/vnd.neurolanguage.nlu": { "source": "iana", "extensions": ["nlu"] }, "application/vnd.nintendo.nitro.rom": { "source": "iana" }, "application/vnd.nintendo.snes.rom": { "source": "iana" }, "application/vnd.nitf": { "source": "iana", "extensions": ["ntf", "nitf"] }, "application/vnd.noblenet-directory": { "source": "iana", "extensions": ["nnd"] }, "application/vnd.noblenet-sealer": { "source": "iana", "extensions": ["nns"] }, "application/vnd.noblenet-web": { "source": "iana", "extensions": ["nnw"] }, "application/vnd.nokia.catalogs": { "source": "iana" }, "application/vnd.nokia.conml+wbxml": { "source": "iana" }, "application/vnd.nokia.conml+xml": { "source": "iana" }, "application/vnd.nokia.iptv.config+xml": { "source": "iana" }, "application/vnd.nokia.isds-radio-presets": { "source": "iana" }, "application/vnd.nokia.landmark+wbxml": { "source": "iana" }, "application/vnd.nokia.landmark+xml": { "source": "iana" }, "application/vnd.nokia.landmarkcollection+xml": { "source": "iana" }, "application/vnd.nokia.n-gage.ac+xml": { "source": "iana" }, "application/vnd.nokia.n-gage.data": { "source": "iana", "extensions": ["ngdat"] }, "application/vnd.nokia.n-gage.symbian.install": { "source": "iana", "extensions": ["n-gage"] }, "application/vnd.nokia.ncd": { "source": "iana" }, "application/vnd.nokia.pcd+wbxml": { "source": "iana" }, "application/vnd.nokia.pcd+xml": { "source": "iana" }, "application/vnd.nokia.radio-preset": { "source": "iana", "extensions": ["rpst"] }, "application/vnd.nokia.radio-presets": { "source": "iana", "extensions": ["rpss"] }, "application/vnd.novadigm.edm": { "source": "iana", "extensions": ["edm"] }, "application/vnd.novadigm.edx": { "source": "iana", "extensions": ["edx"] }, "application/vnd.novadigm.ext": { "source": "iana", "extensions": ["ext"] }, "application/vnd.ntt-local.content-share": { "source": "iana" }, "application/vnd.ntt-local.file-transfer": { "source": "iana" }, "application/vnd.ntt-local.ogw_remote-access": { "source": "iana" }, "application/vnd.ntt-local.sip-ta_remote": { "source": "iana" }, "application/vnd.ntt-local.sip-ta_tcp_stream": { "source": "iana" }, "application/vnd.oasis.opendocument.chart": { "source": "iana", "extensions": ["odc"] }, "application/vnd.oasis.opendocument.chart-template": { "source": "iana", "extensions": ["otc"] }, "application/vnd.oasis.opendocument.database": { "source": "iana", "extensions": ["odb"] }, "application/vnd.oasis.opendocument.formula": { "source": "iana", "extensions": ["odf"] }, "application/vnd.oasis.opendocument.formula-template": { "source": "iana", "extensions": ["odft"] }, "application/vnd.oasis.opendocument.graphics": { "source": "iana", "compressible": false, "extensions": ["odg"] }, "application/vnd.oasis.opendocument.graphics-template": { "source": "iana", "extensions": ["otg"] }, "application/vnd.oasis.opendocument.image": { "source": "iana", "extensions": ["odi"] }, "application/vnd.oasis.opendocument.image-template": { "source": "iana", "extensions": ["oti"] }, "application/vnd.oasis.opendocument.presentation": { "source": "iana", "compressible": false, "extensions": ["odp"] }, "application/vnd.oasis.opendocument.presentation-template": { "source": "iana", "extensions": ["otp"] }, "application/vnd.oasis.opendocument.spreadsheet": { "source": "iana", "compressible": false, "extensions": ["ods"] }, "application/vnd.oasis.opendocument.spreadsheet-template": { "source": "iana", "extensions": ["ots"] }, "application/vnd.oasis.opendocument.text": { "source": "iana", "compressible": false, "extensions": ["odt"] }, "application/vnd.oasis.opendocument.text-master": { "source": "iana", "extensions": ["odm"] }, "application/vnd.oasis.opendocument.text-template": { "source": "iana", "extensions": ["ott"] }, "application/vnd.oasis.opendocument.text-web": { "source": "iana", "extensions": ["oth"] }, "application/vnd.obn": { "source": "iana" }, "application/vnd.oftn.l10n+json": { "source": "iana", "compressible": true }, "application/vnd.oipf.contentaccessdownload+xml": { "source": "iana" }, "application/vnd.oipf.contentaccessstreaming+xml": { "source": "iana" }, "application/vnd.oipf.cspg-hexbinary": { "source": "iana" }, "application/vnd.oipf.dae.svg+xml": { "source": "iana" }, "application/vnd.oipf.dae.xhtml+xml": { "source": "iana" }, "application/vnd.oipf.mippvcontrolmessage+xml": { "source": "iana" }, "application/vnd.oipf.pae.gem": { "source": "iana" }, "application/vnd.oipf.spdiscovery+xml": { "source": "iana" }, "application/vnd.oipf.spdlist+xml": { "source": "iana" }, "application/vnd.oipf.ueprofile+xml": { "source": "iana" }, "application/vnd.oipf.userprofile+xml": { "source": "iana" }, "application/vnd.olpc-sugar": { "source": "iana", "extensions": ["xo"] }, "application/vnd.oma-scws-config": { "source": "iana" }, "application/vnd.oma-scws-http-request": { "source": "iana" }, "application/vnd.oma-scws-http-response": { "source": "iana" }, "application/vnd.oma.bcast.associated-procedure-parameter+xml": { "source": "iana" }, "application/vnd.oma.bcast.drm-trigger+xml": { "source": "iana" }, "application/vnd.oma.bcast.imd+xml": { "source": "iana" }, "application/vnd.oma.bcast.ltkm": { "source": "iana" }, "application/vnd.oma.bcast.notification+xml": { "source": "iana" }, "application/vnd.oma.bcast.provisioningtrigger": { "source": "iana" }, "application/vnd.oma.bcast.sgboot": { "source": "iana" }, "application/vnd.oma.bcast.sgdd+xml": { "source": "iana" }, "application/vnd.oma.bcast.sgdu": { "source": "iana" }, "application/vnd.oma.bcast.simple-symbol-container": { "source": "iana" }, "application/vnd.oma.bcast.smartcard-trigger+xml": { "source": "iana" }, "application/vnd.oma.bcast.sprov+xml": { "source": "iana" }, "application/vnd.oma.bcast.stkm": { "source": "iana" }, "application/vnd.oma.cab-address-book+xml": { "source": "iana" }, "application/vnd.oma.cab-feature-handler+xml": { "source": "iana" }, "application/vnd.oma.cab-pcc+xml": { "source": "iana" }, "application/vnd.oma.cab-subs-invite+xml": { "source": "iana" }, "application/vnd.oma.cab-user-prefs+xml": { "source": "iana" }, "application/vnd.oma.dcd": { "source": "iana" }, "application/vnd.oma.dcdc": { "source": "iana" }, "application/vnd.oma.dd2+xml": { "source": "iana", "extensions": ["dd2"] }, "application/vnd.oma.drm.risd+xml": { "source": "iana" }, "application/vnd.oma.group-usage-list+xml": { "source": "iana" }, "application/vnd.oma.lwm2m+json": { "source": "iana", "compressible": true }, "application/vnd.oma.lwm2m+tlv": { "source": "iana" }, "application/vnd.oma.pal+xml": { "source": "iana" }, "application/vnd.oma.poc.detailed-progress-report+xml": { "source": "iana" }, "application/vnd.oma.poc.final-report+xml": { "source": "iana" }, "application/vnd.oma.poc.groups+xml": { "source": "iana" }, "application/vnd.oma.poc.invocation-descriptor+xml": { "source": "iana" }, "application/vnd.oma.poc.optimized-progress-report+xml": { "source": "iana" }, "application/vnd.oma.push": { "source": "iana" }, "application/vnd.oma.scidm.messages+xml": { "source": "iana" }, "application/vnd.oma.xcap-directory+xml": { "source": "iana" }, "application/vnd.omads-email+xml": { "source": "iana" }, "application/vnd.omads-file+xml": { "source": "iana" }, "application/vnd.omads-folder+xml": { "source": "iana" }, "application/vnd.omaloc-supl-init": { "source": "iana" }, "application/vnd.onepager": { "source": "iana" }, "application/vnd.openblox.game+xml": { "source": "iana" }, "application/vnd.openblox.game-binary": { "source": "iana" }, "application/vnd.openeye.oeb": { "source": "iana" }, "application/vnd.openofficeorg.extension": { "source": "apache", "extensions": ["oxt"] }, "application/vnd.openstreetmap.data+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.custom-properties+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.drawing+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.extended-properties+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.presentationml-template": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.presentationml.presentation": { "source": "iana", "compressible": false, "extensions": ["pptx"] }, "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.presentationml.slide": { "source": "iana", "extensions": ["sldx"] }, "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.presentationml.slideshow": { "source": "iana", "extensions": ["ppsx"] }, "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.presentationml.template": { "source": "apache", "extensions": ["potx"] }, "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.spreadsheetml-template": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": { "source": "iana", "compressible": false, "extensions": ["xlsx"] }, "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.spreadsheetml.template": { "source": "apache", "extensions": ["xltx"] }, "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.theme+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.themeoverride+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.vmldrawing": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.wordprocessingml-template": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.wordprocessingml.document": { "source": "iana", "compressible": false, "extensions": ["docx"] }, "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.wordprocessingml.template": { "source": "apache", "extensions": ["dotx"] }, "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": { "source": "iana" }, "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": { "source": "iana" }, "application/vnd.openxmlformats-package.core-properties+xml": { "source": "iana" }, "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": { "source": "iana" }, "application/vnd.openxmlformats-package.relationships+xml": { "source": "iana" }, "application/vnd.oracle.resource+json": { "source": "iana", "compressible": true }, "application/vnd.orange.indata": { "source": "iana" }, "application/vnd.osa.netdeploy": { "source": "iana" }, "application/vnd.osgeo.mapguide.package": { "source": "iana", "extensions": ["mgp"] }, "application/vnd.osgi.bundle": { "source": "iana" }, "application/vnd.osgi.dp": { "source": "iana", "extensions": ["dp"] }, "application/vnd.osgi.subsystem": { "source": "iana", "extensions": ["esa"] }, "application/vnd.otps.ct-kip+xml": { "source": "iana" }, "application/vnd.oxli.countgraph": { "source": "iana" }, "application/vnd.pagerduty+json": { "source": "iana", "compressible": true }, "application/vnd.palm": { "source": "iana", "extensions": ["pdb", "pqa", "oprc"] }, "application/vnd.panoply": { "source": "iana" }, "application/vnd.paos+xml": { "source": "iana" }, "application/vnd.paos.xml": { "source": "apache" }, "application/vnd.pawaafile": { "source": "iana", "extensions": ["paw"] }, "application/vnd.pcos": { "source": "iana" }, "application/vnd.pg.format": { "source": "iana", "extensions": ["str"] }, "application/vnd.pg.osasli": { "source": "iana", "extensions": ["ei6"] }, "application/vnd.piaccess.application-licence": { "source": "iana" }, "application/vnd.picsel": { "source": "iana", "extensions": ["efif"] }, "application/vnd.pmi.widget": { "source": "iana", "extensions": ["wg"] }, "application/vnd.poc.group-advertisement+xml": { "source": "iana" }, "application/vnd.pocketlearn": { "source": "iana", "extensions": ["plf"] }, "application/vnd.powerbuilder6": { "source": "iana", "extensions": ["pbd"] }, "application/vnd.powerbuilder6-s": { "source": "iana" }, "application/vnd.powerbuilder7": { "source": "iana" }, "application/vnd.powerbuilder7-s": { "source": "iana" }, "application/vnd.powerbuilder75": { "source": "iana" }, "application/vnd.powerbuilder75-s": { "source": "iana" }, "application/vnd.preminet": { "source": "iana" }, "application/vnd.previewsystems.box": { "source": "iana", "extensions": ["box"] }, "application/vnd.proteus.magazine": { "source": "iana", "extensions": ["mgz"] }, "application/vnd.publishare-delta-tree": { "source": "iana", "extensions": ["qps"] }, "application/vnd.pvi.ptid1": { "source": "iana", "extensions": ["ptid"] }, "application/vnd.pwg-multiplexed": { "source": "iana" }, "application/vnd.pwg-xhtml-print+xml": { "source": "iana" }, "application/vnd.qualcomm.brew-app-res": { "source": "iana" }, "application/vnd.quarantainenet": { "source": "iana" }, "application/vnd.quark.quarkxpress": { "source": "iana", "extensions": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"] }, "application/vnd.quobject-quoxdocument": { "source": "iana" }, "application/vnd.radisys.moml+xml": { "source": "iana" }, "application/vnd.radisys.msml+xml": { "source": "iana" }, "application/vnd.radisys.msml-audit+xml": { "source": "iana" }, "application/vnd.radisys.msml-audit-conf+xml": { "source": "iana" }, "application/vnd.radisys.msml-audit-conn+xml": { "source": "iana" }, "application/vnd.radisys.msml-audit-dialog+xml": { "source": "iana" }, "application/vnd.radisys.msml-audit-stream+xml": { "source": "iana" }, "application/vnd.radisys.msml-conf+xml": { "source": "iana" }, "application/vnd.radisys.msml-dialog+xml": { "source": "iana" }, "application/vnd.radisys.msml-dialog-base+xml": { "source": "iana" }, "application/vnd.radisys.msml-dialog-fax-detect+xml": { "source": "iana" }, "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": { "source": "iana" }, "application/vnd.radisys.msml-dialog-group+xml": { "source": "iana" }, "application/vnd.radisys.msml-dialog-speech+xml": { "source": "iana" }, "application/vnd.radisys.msml-dialog-transform+xml": { "source": "iana" }, "application/vnd.rainstor.data": { "source": "iana" }, "application/vnd.rapid": { "source": "iana" }, "application/vnd.rar": { "source": "iana" }, "application/vnd.realvnc.bed": { "source": "iana", "extensions": ["bed"] }, "application/vnd.recordare.musicxml": { "source": "iana", "extensions": ["mxl"] }, "application/vnd.recordare.musicxml+xml": { "source": "iana", "extensions": ["musicxml"] }, "application/vnd.renlearn.rlprint": { "source": "iana" }, "application/vnd.rig.cryptonote": { "source": "iana", "extensions": ["cryptonote"] }, "application/vnd.rim.cod": { "source": "apache", "extensions": ["cod"] }, "application/vnd.rn-realmedia": { "source": "apache", "extensions": ["rm"] }, "application/vnd.rn-realmedia-vbr": { "source": "apache", "extensions": ["rmvb"] }, "application/vnd.route66.link66+xml": { "source": "iana", "extensions": ["link66"] }, "application/vnd.rs-274x": { "source": "iana" }, "application/vnd.ruckus.download": { "source": "iana" }, "application/vnd.s3sms": { "source": "iana" }, "application/vnd.sailingtracker.track": { "source": "iana", "extensions": ["st"] }, "application/vnd.sbm.cid": { "source": "iana" }, "application/vnd.sbm.mid2": { "source": "iana" }, "application/vnd.scribus": { "source": "iana" }, "application/vnd.sealed.3df": { "source": "iana" }, "application/vnd.sealed.csf": { "source": "iana" }, "application/vnd.sealed.doc": { "source": "iana" }, "application/vnd.sealed.eml": { "source": "iana" }, "application/vnd.sealed.mht": { "source": "iana" }, "application/vnd.sealed.net": { "source": "iana" }, "application/vnd.sealed.ppt": { "source": "iana" }, "application/vnd.sealed.tiff": { "source": "iana" }, "application/vnd.sealed.xls": { "source": "iana" }, "application/vnd.sealedmedia.softseal.html": { "source": "iana" }, "application/vnd.sealedmedia.softseal.pdf": { "source": "iana" }, "application/vnd.seemail": { "source": "iana", "extensions": ["see"] }, "application/vnd.sema": { "source": "iana", "extensions": ["sema"] }, "application/vnd.semd": { "source": "iana", "extensions": ["semd"] }, "application/vnd.semf": { "source": "iana", "extensions": ["semf"] }, "application/vnd.shana.informed.formdata": { "source": "iana", "extensions": ["ifm"] }, "application/vnd.shana.informed.formtemplate": { "source": "iana", "extensions": ["itp"] }, "application/vnd.shana.informed.interchange": { "source": "iana", "extensions": ["iif"] }, "application/vnd.shana.informed.package": { "source": "iana", "extensions": ["ipk"] }, "application/vnd.simtech-mindmapper": { "source": "iana", "extensions": ["twd", "twds"] }, "application/vnd.siren+json": { "source": "iana", "compressible": true }, "application/vnd.smaf": { "source": "iana", "extensions": ["mmf"] }, "application/vnd.smart.notebook": { "source": "iana" }, "application/vnd.smart.teacher": { "source": "iana", "extensions": ["teacher"] }, "application/vnd.software602.filler.form+xml": { "source": "iana" }, "application/vnd.software602.filler.form-xml-zip": { "source": "iana" }, "application/vnd.solent.sdkm+xml": { "source": "iana", "extensions": ["sdkm", "sdkd"] }, "application/vnd.spotfire.dxp": { "source": "iana", "extensions": ["dxp"] }, "application/vnd.spotfire.sfs": { "source": "iana", "extensions": ["sfs"] }, "application/vnd.sss-cod": { "source": "iana" }, "application/vnd.sss-dtf": { "source": "iana" }, "application/vnd.sss-ntf": { "source": "iana" }, "application/vnd.stardivision.calc": { "source": "apache", "extensions": ["sdc"] }, "application/vnd.stardivision.draw": { "source": "apache", "extensions": ["sda"] }, "application/vnd.stardivision.impress": { "source": "apache", "extensions": ["sdd"] }, "application/vnd.stardivision.math": { "source": "apache", "extensions": ["smf"] }, "application/vnd.stardivision.writer": { "source": "apache", "extensions": ["sdw", "vor"] }, "application/vnd.stardivision.writer-global": { "source": "apache", "extensions": ["sgl"] }, "application/vnd.stepmania.package": { "source": "iana", "extensions": ["smzip"] }, "application/vnd.stepmania.stepchart": { "source": "iana", "extensions": ["sm"] }, "application/vnd.street-stream": { "source": "iana" }, "application/vnd.sun.wadl+xml": { "source": "iana" }, "application/vnd.sun.xml.calc": { "source": "apache", "extensions": ["sxc"] }, "application/vnd.sun.xml.calc.template": { "source": "apache", "extensions": ["stc"] }, "application/vnd.sun.xml.draw": { "source": "apache", "extensions": ["sxd"] }, "application/vnd.sun.xml.draw.template": { "source": "apache", "extensions": ["std"] }, "application/vnd.sun.xml.impress": { "source": "apache", "extensions": ["sxi"] }, "application/vnd.sun.xml.impress.template": { "source": "apache", "extensions": ["sti"] }, "application/vnd.sun.xml.math": { "source": "apache", "extensions": ["sxm"] }, "application/vnd.sun.xml.writer": { "source": "apache", "extensions": ["sxw"] }, "application/vnd.sun.xml.writer.global": { "source": "apache", "extensions": ["sxg"] }, "application/vnd.sun.xml.writer.template": { "source": "apache", "extensions": ["stw"] }, "application/vnd.sus-calendar": { "source": "iana", "extensions": ["sus", "susp"] }, "application/vnd.svd": { "source": "iana", "extensions": ["svd"] }, "application/vnd.swiftview-ics": { "source": "iana" }, "application/vnd.symbian.install": { "source": "apache", "extensions": ["sis", "sisx"] }, "application/vnd.syncml+xml": { "source": "iana", "extensions": ["xsm"] }, "application/vnd.syncml.dm+wbxml": { "source": "iana", "extensions": ["bdm"] }, "application/vnd.syncml.dm+xml": { "source": "iana", "extensions": ["xdm"] }, "application/vnd.syncml.dm.notification": { "source": "iana" }, "application/vnd.syncml.dmddf+wbxml": { "source": "iana" }, "application/vnd.syncml.dmddf+xml": { "source": "iana" }, "application/vnd.syncml.dmtnds+wbxml": { "source": "iana" }, "application/vnd.syncml.dmtnds+xml": { "source": "iana" }, "application/vnd.syncml.ds.notification": { "source": "iana" }, "application/vnd.tao.intent-module-archive": { "source": "iana", "extensions": ["tao"] }, "application/vnd.tcpdump.pcap": { "source": "iana", "extensions": ["pcap", "cap", "dmp"] }, "application/vnd.tmd.mediaflex.api+xml": { "source": "iana" }, "application/vnd.tml": { "source": "iana" }, "application/vnd.tmobile-livetv": { "source": "iana", "extensions": ["tmo"] }, "application/vnd.tri.onesource": { "source": "iana" }, "application/vnd.trid.tpt": { "source": "iana", "extensions": ["tpt"] }, "application/vnd.triscape.mxs": { "source": "iana", "extensions": ["mxs"] }, "application/vnd.trueapp": { "source": "iana", "extensions": ["tra"] }, "application/vnd.truedoc": { "source": "iana" }, "application/vnd.ubisoft.webplayer": { "source": "iana" }, "application/vnd.ufdl": { "source": "iana", "extensions": ["ufd", "ufdl"] }, "application/vnd.uiq.theme": { "source": "iana", "extensions": ["utz"] }, "application/vnd.umajin": { "source": "iana", "extensions": ["umj"] }, "application/vnd.unity": { "source": "iana", "extensions": ["unityweb"] }, "application/vnd.uoml+xml": { "source": "iana", "extensions": ["uoml"] }, "application/vnd.uplanet.alert": { "source": "iana" }, "application/vnd.uplanet.alert-wbxml": { "source": "iana" }, "application/vnd.uplanet.bearer-choice": { "source": "iana" }, "application/vnd.uplanet.bearer-choice-wbxml": { "source": "iana" }, "application/vnd.uplanet.cacheop": { "source": "iana" }, "application/vnd.uplanet.cacheop-wbxml": { "source": "iana" }, "application/vnd.uplanet.channel": { "source": "iana" }, "application/vnd.uplanet.channel-wbxml": { "source": "iana" }, "application/vnd.uplanet.list": { "source": "iana" }, "application/vnd.uplanet.list-wbxml": { "source": "iana" }, "application/vnd.uplanet.listcmd": { "source": "iana" }, "application/vnd.uplanet.listcmd-wbxml": { "source": "iana" }, "application/vnd.uplanet.signal": { "source": "iana" }, "application/vnd.uri-map": { "source": "iana" }, "application/vnd.valve.source.material": { "source": "iana" }, "application/vnd.vcx": { "source": "iana", "extensions": ["vcx"] }, "application/vnd.vd-study": { "source": "iana" }, "application/vnd.vectorworks": { "source": "iana" }, "application/vnd.vel+json": { "source": "iana", "compressible": true }, "application/vnd.verimatrix.vcas": { "source": "iana" }, "application/vnd.vidsoft.vidconference": { "source": "iana" }, "application/vnd.visio": { "source": "iana", "extensions": ["vsd", "vst", "vss", "vsw"] }, "application/vnd.visionary": { "source": "iana", "extensions": ["vis"] }, "application/vnd.vividence.scriptfile": { "source": "iana" }, "application/vnd.vsf": { "source": "iana", "extensions": ["vsf"] }, "application/vnd.wap.sic": { "source": "iana" }, "application/vnd.wap.slc": { "source": "iana" }, "application/vnd.wap.wbxml": { "source": "iana", "extensions": ["wbxml"] }, "application/vnd.wap.wmlc": { "source": "iana", "extensions": ["wmlc"] }, "application/vnd.wap.wmlscriptc": { "source": "iana", "extensions": ["wmlsc"] }, "application/vnd.webturbo": { "source": "iana", "extensions": ["wtb"] }, "application/vnd.wfa.p2p": { "source": "iana" }, "application/vnd.wfa.wsc": { "source": "iana" }, "application/vnd.windows.devicepairing": { "source": "iana" }, "application/vnd.wmc": { "source": "iana" }, "application/vnd.wmf.bootstrap": { "source": "iana" }, "application/vnd.wolfram.mathematica": { "source": "iana" }, "application/vnd.wolfram.mathematica.package": { "source": "iana" }, "application/vnd.wolfram.player": { "source": "iana", "extensions": ["nbp"] }, "application/vnd.wordperfect": { "source": "iana", "extensions": ["wpd"] }, "application/vnd.wqd": { "source": "iana", "extensions": ["wqd"] }, "application/vnd.wrq-hp3000-labelled": { "source": "iana" }, "application/vnd.wt.stf": { "source": "iana", "extensions": ["stf"] }, "application/vnd.wv.csp+wbxml": { "source": "iana" }, "application/vnd.wv.csp+xml": { "source": "iana" }, "application/vnd.wv.ssp+xml": { "source": "iana" }, "application/vnd.xacml+json": { "source": "iana", "compressible": true }, "application/vnd.xara": { "source": "iana", "extensions": ["xar"] }, "application/vnd.xfdl": { "source": "iana", "extensions": ["xfdl"] }, "application/vnd.xfdl.webform": { "source": "iana" }, "application/vnd.xmi+xml": { "source": "iana" }, "application/vnd.xmpie.cpkg": { "source": "iana" }, "application/vnd.xmpie.dpkg": { "source": "iana" }, "application/vnd.xmpie.plan": { "source": "iana" }, "application/vnd.xmpie.ppkg": { "source": "iana" }, "application/vnd.xmpie.xlim": { "source": "iana" }, "application/vnd.yamaha.hv-dic": { "source": "iana", "extensions": ["hvd"] }, "application/vnd.yamaha.hv-script": { "source": "iana", "extensions": ["hvs"] }, "application/vnd.yamaha.hv-voice": { "source": "iana", "extensions": ["hvp"] }, "application/vnd.yamaha.openscoreformat": { "source": "iana", "extensions": ["osf"] }, "application/vnd.yamaha.openscoreformat.osfpvg+xml": { "source": "iana", "extensions": ["osfpvg"] }, "application/vnd.yamaha.remote-setup": { "source": "iana" }, "application/vnd.yamaha.smaf-audio": { "source": "iana", "extensions": ["saf"] }, "application/vnd.yamaha.smaf-phrase": { "source": "iana", "extensions": ["spf"] }, "application/vnd.yamaha.through-ngn": { "source": "iana" }, "application/vnd.yamaha.tunnel-udpencap": { "source": "iana" }, "application/vnd.yaoweme": { "source": "iana" }, "application/vnd.yellowriver-custom-menu": { "source": "iana", "extensions": ["cmp"] }, "application/vnd.zul": { "source": "iana", "extensions": ["zir", "zirz"] }, "application/vnd.zzazz.deck+xml": { "source": "iana", "extensions": ["zaz"] }, "application/voicexml+xml": { "source": "iana", "extensions": ["vxml"] }, "application/vq-rtcpxr": { "source": "iana" }, "application/watcherinfo+xml": { "source": "iana" }, "application/whoispp-query": { "source": "iana" }, "application/whoispp-response": { "source": "iana" }, "application/widget": { "source": "iana", "extensions": ["wgt"] }, "application/winhlp": { "source": "apache", "extensions": ["hlp"] }, "application/wita": { "source": "iana" }, "application/wordperfect5.1": { "source": "iana" }, "application/wsdl+xml": { "source": "iana", "extensions": ["wsdl"] }, "application/wspolicy+xml": { "source": "iana", "extensions": ["wspolicy"] }, "application/x-7z-compressed": { "source": "apache", "compressible": false, "extensions": ["7z"] }, "application/x-abiword": { "source": "apache", "extensions": ["abw"] }, "application/x-ace-compressed": { "source": "apache", "extensions": ["ace"] }, "application/x-amf": { "source": "apache" }, "application/x-apple-diskimage": { "source": "apache", "extensions": ["dmg"] }, "application/x-authorware-bin": { "source": "apache", "extensions": ["aab", "x32", "u32", "vox"] }, "application/x-authorware-map": { "source": "apache", "extensions": ["aam"] }, "application/x-authorware-seg": { "source": "apache", "extensions": ["aas"] }, "application/x-bcpio": { "source": "apache", "extensions": ["bcpio"] }, "application/x-bdoc": { "compressible": false, "extensions": ["bdoc"] }, "application/x-bittorrent": { "source": "apache", "extensions": ["torrent"] }, "application/x-blorb": { "source": "apache", "extensions": ["blb", "blorb"] }, "application/x-bzip": { "source": "apache", "compressible": false, "extensions": ["bz"] }, "application/x-bzip2": { "source": "apache", "compressible": false, "extensions": ["bz2", "boz"] }, "application/x-cbr": { "source": "apache", "extensions": ["cbr", "cba", "cbt", "cbz", "cb7"] }, "application/x-cdlink": { "source": "apache", "extensions": ["vcd"] }, "application/x-cfs-compressed": { "source": "apache", "extensions": ["cfs"] }, "application/x-chat": { "source": "apache", "extensions": ["chat"] }, "application/x-chess-pgn": { "source": "apache", "extensions": ["pgn"] }, "application/x-chrome-extension": { "extensions": ["crx"] }, "application/x-cocoa": { "source": "nginx", "extensions": ["cco"] }, "application/x-compress": { "source": "apache" }, "application/x-conference": { "source": "apache", "extensions": ["nsc"] }, "application/x-cpio": { "source": "apache", "extensions": ["cpio"] }, "application/x-csh": { "source": "apache", "extensions": ["csh"] }, "application/x-deb": { "compressible": false }, "application/x-debian-package": { "source": "apache", "extensions": ["deb", "udeb"] }, "application/x-dgc-compressed": { "source": "apache", "extensions": ["dgc"] }, "application/x-director": { "source": "apache", "extensions": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"] }, "application/x-doom": { "source": "apache", "extensions": ["wad"] }, "application/x-dtbncx+xml": { "source": "apache", "extensions": ["ncx"] }, "application/x-dtbook+xml": { "source": "apache", "extensions": ["dtb"] }, "application/x-dtbresource+xml": { "source": "apache", "extensions": ["res"] }, "application/x-dvi": { "source": "apache", "compressible": false, "extensions": ["dvi"] }, "application/x-envoy": { "source": "apache", "extensions": ["evy"] }, "application/x-eva": { "source": "apache", "extensions": ["eva"] }, "application/x-font-bdf": { "source": "apache", "extensions": ["bdf"] }, "application/x-font-dos": { "source": "apache" }, "application/x-font-framemaker": { "source": "apache" }, "application/x-font-ghostscript": { "source": "apache", "extensions": ["gsf"] }, "application/x-font-libgrx": { "source": "apache" }, "application/x-font-linux-psf": { "source": "apache", "extensions": ["psf"] }, "application/x-font-otf": { "source": "apache", "compressible": true, "extensions": ["otf"] }, "application/x-font-pcf": { "source": "apache", "extensions": ["pcf"] }, "application/x-font-snf": { "source": "apache", "extensions": ["snf"] }, "application/x-font-speedo": { "source": "apache" }, "application/x-font-sunos-news": { "source": "apache" }, "application/x-font-ttf": { "source": "apache", "compressible": true, "extensions": ["ttf", "ttc"] }, "application/x-font-type1": { "source": "apache", "extensions": ["pfa", "pfb", "pfm", "afm"] }, "application/x-font-vfont": { "source": "apache" }, "application/x-freearc": { "source": "apache", "extensions": ["arc"] }, "application/x-futuresplash": { "source": "apache", "extensions": ["spl"] }, "application/x-gca-compressed": { "source": "apache", "extensions": ["gca"] }, "application/x-glulx": { "source": "apache", "extensions": ["ulx"] }, "application/x-gnumeric": { "source": "apache", "extensions": ["gnumeric"] }, "application/x-gramps-xml": { "source": "apache", "extensions": ["gramps"] }, "application/x-gtar": { "source": "apache", "extensions": ["gtar"] }, "application/x-gzip": { "source": "apache" }, "application/x-hdf": { "source": "apache", "extensions": ["hdf"] }, "application/x-httpd-php": { "compressible": true, "extensions": ["php"] }, "application/x-install-instructions": { "source": "apache", "extensions": ["install"] }, "application/x-iso9660-image": { "source": "apache", "extensions": ["iso"] }, "application/x-java-archive-diff": { "source": "nginx", "extensions": ["jardiff"] }, "application/x-java-jnlp-file": { "source": "apache", "compressible": false, "extensions": ["jnlp"] }, "application/x-javascript": { "compressible": true }, "application/x-latex": { "source": "apache", "compressible": false, "extensions": ["latex"] }, "application/x-lua-bytecode": { "extensions": ["luac"] }, "application/x-lzh-compressed": { "source": "apache", "extensions": ["lzh", "lha"] }, "application/x-makeself": { "source": "nginx", "extensions": ["run"] }, "application/x-mie": { "source": "apache", "extensions": ["mie"] }, "application/x-mobipocket-ebook": { "source": "apache", "extensions": ["prc", "mobi"] }, "application/x-mpegurl": { "compressible": false }, "application/x-ms-application": { "source": "apache", "extensions": ["application"] }, "application/x-ms-shortcut": { "source": "apache", "extensions": ["lnk"] }, "application/x-ms-wmd": { "source": "apache", "extensions": ["wmd"] }, "application/x-ms-wmz": { "source": "apache", "extensions": ["wmz"] }, "application/x-ms-xbap": { "source": "apache", "extensions": ["xbap"] }, "application/x-msaccess": { "source": "apache", "extensions": ["mdb"] }, "application/x-msbinder": { "source": "apache", "extensions": ["obd"] }, "application/x-mscardfile": { "source": "apache", "extensions": ["crd"] }, "application/x-msclip": { "source": "apache", "extensions": ["clp"] }, "application/x-msdos-program": { "extensions": ["exe"] }, "application/x-msdownload": { "source": "apache", "extensions": ["exe", "dll", "com", "bat", "msi"] }, "application/x-msmediaview": { "source": "apache", "extensions": ["mvb", "m13", "m14"] }, "application/x-msmetafile": { "source": "apache", "extensions": ["wmf", "wmz", "emf", "emz"] }, "application/x-msmoney": { "source": "apache", "extensions": ["mny"] }, "application/x-mspublisher": { "source": "apache", "extensions": ["pub"] }, "application/x-msschedule": { "source": "apache", "extensions": ["scd"] }, "application/x-msterminal": { "source": "apache", "extensions": ["trm"] }, "application/x-mswrite": { "source": "apache", "extensions": ["wri"] }, "application/x-netcdf": { "source": "apache", "extensions": ["nc", "cdf"] }, "application/x-ns-proxy-autoconfig": { "compressible": true, "extensions": ["pac"] }, "application/x-nzb": { "source": "apache", "extensions": ["nzb"] }, "application/x-perl": { "source": "nginx", "extensions": ["pl", "pm"] }, "application/x-pilot": { "source": "nginx", "extensions": ["prc", "pdb"] }, "application/x-pkcs12": { "source": "apache", "compressible": false, "extensions": ["p12", "pfx"] }, "application/x-pkcs7-certificates": { "source": "apache", "extensions": ["p7b", "spc"] }, "application/x-pkcs7-certreqresp": { "source": "apache", "extensions": ["p7r"] }, "application/x-rar-compressed": { "source": "apache", "compressible": false, "extensions": ["rar"] }, "application/x-redhat-package-manager": { "source": "nginx", "extensions": ["rpm"] }, "application/x-research-info-systems": { "source": "apache", "extensions": ["ris"] }, "application/x-sea": { "source": "nginx", "extensions": ["sea"] }, "application/x-sh": { "source": "apache", "compressible": true, "extensions": ["sh"] }, "application/x-shar": { "source": "apache", "extensions": ["shar"] }, "application/x-shockwave-flash": { "source": "apache", "compressible": false, "extensions": ["swf"] }, "application/x-silverlight-app": { "source": "apache", "extensions": ["xap"] }, "application/x-sql": { "source": "apache", "extensions": ["sql"] }, "application/x-stuffit": { "source": "apache", "compressible": false, "extensions": ["sit"] }, "application/x-stuffitx": { "source": "apache", "extensions": ["sitx"] }, "application/x-subrip": { "source": "apache", "extensions": ["srt"] }, "application/x-sv4cpio": { "source": "apache", "extensions": ["sv4cpio"] }, "application/x-sv4crc": { "source": "apache", "extensions": ["sv4crc"] }, "application/x-t3vm-image": { "source": "apache", "extensions": ["t3"] }, "application/x-tads": { "source": "apache", "extensions": ["gam"] }, "application/x-tar": { "source": "apache", "compressible": true, "extensions": ["tar"] }, "application/x-tcl": { "source": "apache", "extensions": ["tcl", "tk"] }, "application/x-tex": { "source": "apache", "extensions": ["tex"] }, "application/x-tex-tfm": { "source": "apache", "extensions": ["tfm"] }, "application/x-texinfo": { "source": "apache", "extensions": ["texinfo", "texi"] }, "application/x-tgif": { "source": "apache", "extensions": ["obj"] }, "application/x-ustar": { "source": "apache", "extensions": ["ustar"] }, "application/x-wais-source": { "source": "apache", "extensions": ["src"] }, "application/x-web-app-manifest+json": { "compressible": true, "extensions": ["webapp"] }, "application/x-www-form-urlencoded": { "source": "iana", "compressible": true }, "application/x-x509-ca-cert": { "source": "apache", "extensions": ["der", "crt", "pem"] }, "application/x-xfig": { "source": "apache", "extensions": ["fig"] }, "application/x-xliff+xml": { "source": "apache", "extensions": ["xlf"] }, "application/x-xpinstall": { "source": "apache", "compressible": false, "extensions": ["xpi"] }, "application/x-xz": { "source": "apache", "extensions": ["xz"] }, "application/x-zmachine": { "source": "apache", "extensions": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"] }, "application/x400-bp": { "source": "iana" }, "application/xacml+xml": { "source": "iana" }, "application/xaml+xml": { "source": "apache", "extensions": ["xaml"] }, "application/xcap-att+xml": { "source": "iana" }, "application/xcap-caps+xml": { "source": "iana" }, "application/xcap-diff+xml": { "source": "iana", "extensions": ["xdf"] }, "application/xcap-el+xml": { "source": "iana" }, "application/xcap-error+xml": { "source": "iana" }, "application/xcap-ns+xml": { "source": "iana" }, "application/xcon-conference-info+xml": { "source": "iana" }, "application/xcon-conference-info-diff+xml": { "source": "iana" }, "application/xenc+xml": { "source": "iana", "extensions": ["xenc"] }, "application/xhtml+xml": { "source": "iana", "compressible": true, "extensions": ["xhtml", "xht"] }, "application/xhtml-voice+xml": { "source": "apache" }, "application/xml": { "source": "iana", "compressible": true, "extensions": ["xml", "xsl", "xsd", "rng"] }, "application/xml-dtd": { "source": "iana", "compressible": true, "extensions": ["dtd"] }, "application/xml-external-parsed-entity": { "source": "iana" }, "application/xml-patch+xml": { "source": "iana" }, "application/xmpp+xml": { "source": "iana" }, "application/xop+xml": { "source": "iana", "compressible": true, "extensions": ["xop"] }, "application/xproc+xml": { "source": "apache", "extensions": ["xpl"] }, "application/xslt+xml": { "source": "iana", "extensions": ["xslt"] }, "application/xspf+xml": { "source": "apache", "extensions": ["xspf"] }, "application/xv+xml": { "source": "iana", "extensions": ["mxml", "xhvml", "xvml", "xvm"] }, "application/yang": { "source": "iana", "extensions": ["yang"] }, "application/yang-data+json": { "source": "iana", "compressible": true }, "application/yang-data+xml": { "source": "iana" }, "application/yin+xml": { "source": "iana", "extensions": ["yin"] }, "application/zip": { "source": "iana", "compressible": false, "extensions": ["zip"] }, "application/zlib": { "source": "iana" }, "audio/1d-interleaved-parityfec": { "source": "iana" }, "audio/32kadpcm": { "source": "iana" }, "audio/3gpp": { "source": "iana", "compressible": false, "extensions": ["3gpp"] }, "audio/3gpp2": { "source": "iana" }, "audio/ac3": { "source": "iana" }, "audio/adpcm": { "source": "apache", "extensions": ["adp"] }, "audio/amr": { "source": "iana" }, "audio/amr-wb": { "source": "iana" }, "audio/amr-wb+": { "source": "iana" }, "audio/aptx": { "source": "iana" }, "audio/asc": { "source": "iana" }, "audio/atrac-advanced-lossless": { "source": "iana" }, "audio/atrac-x": { "source": "iana" }, "audio/atrac3": { "source": "iana" }, "audio/basic": { "source": "iana", "compressible": false, "extensions": ["au", "snd"] }, "audio/bv16": { "source": "iana" }, "audio/bv32": { "source": "iana" }, "audio/clearmode": { "source": "iana" }, "audio/cn": { "source": "iana" }, "audio/dat12": { "source": "iana" }, "audio/dls": { "source": "iana" }, "audio/dsr-es201108": { "source": "iana" }, "audio/dsr-es202050": { "source": "iana" }, "audio/dsr-es202211": { "source": "iana" }, "audio/dsr-es202212": { "source": "iana" }, "audio/dv": { "source": "iana" }, "audio/dvi4": { "source": "iana" }, "audio/eac3": { "source": "iana" }, "audio/encaprtp": { "source": "iana" }, "audio/evrc": { "source": "iana" }, "audio/evrc-qcp": { "source": "iana" }, "audio/evrc0": { "source": "iana" }, "audio/evrc1": { "source": "iana" }, "audio/evrcb": { "source": "iana" }, "audio/evrcb0": { "source": "iana" }, "audio/evrcb1": { "source": "iana" }, "audio/evrcnw": { "source": "iana" }, "audio/evrcnw0": { "source": "iana" }, "audio/evrcnw1": { "source": "iana" }, "audio/evrcwb": { "source": "iana" }, "audio/evrcwb0": { "source": "iana" }, "audio/evrcwb1": { "source": "iana" }, "audio/evs": { "source": "iana" }, "audio/fwdred": { "source": "iana" }, "audio/g711-0": { "source": "iana" }, "audio/g719": { "source": "iana" }, "audio/g722": { "source": "iana" }, "audio/g7221": { "source": "iana" }, "audio/g723": { "source": "iana" }, "audio/g726-16": { "source": "iana" }, "audio/g726-24": { "source": "iana" }, "audio/g726-32": { "source": "iana" }, "audio/g726-40": { "source": "iana" }, "audio/g728": { "source": "iana" }, "audio/g729": { "source": "iana" }, "audio/g7291": { "source": "iana" }, "audio/g729d": { "source": "iana" }, "audio/g729e": { "source": "iana" }, "audio/gsm": { "source": "iana" }, "audio/gsm-efr": { "source": "iana" }, "audio/gsm-hr-08": { "source": "iana" }, "audio/ilbc": { "source": "iana" }, "audio/ip-mr_v2.5": { "source": "iana" }, "audio/isac": { "source": "apache" }, "audio/l16": { "source": "iana" }, "audio/l20": { "source": "iana" }, "audio/l24": { "source": "iana", "compressible": false }, "audio/l8": { "source": "iana" }, "audio/lpc": { "source": "iana" }, "audio/midi": { "source": "apache", "extensions": ["mid", "midi", "kar", "rmi"] }, "audio/mobile-xmf": { "source": "iana" }, "audio/mp3": { "compressible": false, "extensions": ["mp3"] }, "audio/mp4": { "source": "iana", "compressible": false, "extensions": ["m4a", "mp4a"] }, "audio/mp4a-latm": { "source": "iana" }, "audio/mpa": { "source": "iana" }, "audio/mpa-robust": { "source": "iana" }, "audio/mpeg": { "source": "iana", "compressible": false, "extensions": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"] }, "audio/mpeg4-generic": { "source": "iana" }, "audio/musepack": { "source": "apache" }, "audio/ogg": { "source": "iana", "compressible": false, "extensions": ["oga", "ogg", "spx"] }, "audio/opus": { "source": "iana" }, "audio/parityfec": { "source": "iana" }, "audio/pcma": { "source": "iana" }, "audio/pcma-wb": { "source": "iana" }, "audio/pcmu": { "source": "iana" }, "audio/pcmu-wb": { "source": "iana" }, "audio/prs.sid": { "source": "iana" }, "audio/qcelp": { "source": "iana" }, "audio/raptorfec": { "source": "iana" }, "audio/red": { "source": "iana" }, "audio/rtp-enc-aescm128": { "source": "iana" }, "audio/rtp-midi": { "source": "iana" }, "audio/rtploopback": { "source": "iana" }, "audio/rtx": { "source": "iana" }, "audio/s3m": { "source": "apache", "extensions": ["s3m"] }, "audio/silk": { "source": "apache", "extensions": ["sil"] }, "audio/smv": { "source": "iana" }, "audio/smv-qcp": { "source": "iana" }, "audio/smv0": { "source": "iana" }, "audio/sp-midi": { "source": "iana" }, "audio/speex": { "source": "iana" }, "audio/t140c": { "source": "iana" }, "audio/t38": { "source": "iana" }, "audio/telephone-event": { "source": "iana" }, "audio/tone": { "source": "iana" }, "audio/uemclip": { "source": "iana" }, "audio/ulpfec": { "source": "iana" }, "audio/vdvi": { "source": "iana" }, "audio/vmr-wb": { "source": "iana" }, "audio/vnd.3gpp.iufp": { "source": "iana" }, "audio/vnd.4sb": { "source": "iana" }, "audio/vnd.audiokoz": { "source": "iana" }, "audio/vnd.celp": { "source": "iana" }, "audio/vnd.cisco.nse": { "source": "iana" }, "audio/vnd.cmles.radio-events": { "source": "iana" }, "audio/vnd.cns.anp1": { "source": "iana" }, "audio/vnd.cns.inf1": { "source": "iana" }, "audio/vnd.dece.audio": { "source": "iana", "extensions": ["uva", "uvva"] }, "audio/vnd.digital-winds": { "source": "iana", "extensions": ["eol"] }, "audio/vnd.dlna.adts": { "source": "iana" }, "audio/vnd.dolby.heaac.1": { "source": "iana" }, "audio/vnd.dolby.heaac.2": { "source": "iana" }, "audio/vnd.dolby.mlp": { "source": "iana" }, "audio/vnd.dolby.mps": { "source": "iana" }, "audio/vnd.dolby.pl2": { "source": "iana" }, "audio/vnd.dolby.pl2x": { "source": "iana" }, "audio/vnd.dolby.pl2z": { "source": "iana" }, "audio/vnd.dolby.pulse.1": { "source": "iana" }, "audio/vnd.dra": { "source": "iana", "extensions": ["dra"] }, "audio/vnd.dts": { "source": "iana", "extensions": ["dts"] }, "audio/vnd.dts.hd": { "source": "iana", "extensions": ["dtshd"] }, "audio/vnd.dvb.file": { "source": "iana" }, "audio/vnd.everad.plj": { "source": "iana" }, "audio/vnd.hns.audio": { "source": "iana" }, "audio/vnd.lucent.voice": { "source": "iana", "extensions": ["lvp"] }, "audio/vnd.ms-playready.media.pya": { "source": "iana", "extensions": ["pya"] }, "audio/vnd.nokia.mobile-xmf": { "source": "iana" }, "audio/vnd.nortel.vbk": { "source": "iana" }, "audio/vnd.nuera.ecelp4800": { "source": "iana", "extensions": ["ecelp4800"] }, "audio/vnd.nuera.ecelp7470": { "source": "iana", "extensions": ["ecelp7470"] }, "audio/vnd.nuera.ecelp9600": { "source": "iana", "extensions": ["ecelp9600"] }, "audio/vnd.octel.sbc": { "source": "iana" }, "audio/vnd.qcelp": { "source": "iana" }, "audio/vnd.rhetorex.32kadpcm": { "source": "iana" }, "audio/vnd.rip": { "source": "iana", "extensions": ["rip"] }, "audio/vnd.rn-realaudio": { "compressible": false }, "audio/vnd.sealedmedia.softseal.mpeg": { "source": "iana" }, "audio/vnd.vmx.cvsd": { "source": "iana" }, "audio/vnd.wave": { "compressible": false }, "audio/vorbis": { "source": "iana", "compressible": false }, "audio/vorbis-config": { "source": "iana" }, "audio/wav": { "compressible": false, "extensions": ["wav"] }, "audio/wave": { "compressible": false, "extensions": ["wav"] }, "audio/webm": { "source": "apache", "compressible": false, "extensions": ["weba"] }, "audio/x-aac": { "source": "apache", "compressible": false, "extensions": ["aac"] }, "audio/x-aiff": { "source": "apache", "extensions": ["aif", "aiff", "aifc"] }, "audio/x-caf": { "source": "apache", "compressible": false, "extensions": ["caf"] }, "audio/x-flac": { "source": "apache", "extensions": ["flac"] }, "audio/x-m4a": { "source": "nginx", "extensions": ["m4a"] }, "audio/x-matroska": { "source": "apache", "extensions": ["mka"] }, "audio/x-mpegurl": { "source": "apache", "extensions": ["m3u"] }, "audio/x-ms-wax": { "source": "apache", "extensions": ["wax"] }, "audio/x-ms-wma": { "source": "apache", "extensions": ["wma"] }, "audio/x-pn-realaudio": { "source": "apache", "extensions": ["ram", "ra"] }, "audio/x-pn-realaudio-plugin": { "source": "apache", "extensions": ["rmp"] }, "audio/x-realaudio": { "source": "nginx", "extensions": ["ra"] }, "audio/x-tta": { "source": "apache" }, "audio/x-wav": { "source": "apache", "extensions": ["wav"] }, "audio/xm": { "source": "apache", "extensions": ["xm"] }, "chemical/x-cdx": { "source": "apache", "extensions": ["cdx"] }, "chemical/x-cif": { "source": "apache", "extensions": ["cif"] }, "chemical/x-cmdf": { "source": "apache", "extensions": ["cmdf"] }, "chemical/x-cml": { "source": "apache", "extensions": ["cml"] }, "chemical/x-csml": { "source": "apache", "extensions": ["csml"] }, "chemical/x-pdb": { "source": "apache" }, "chemical/x-xyz": { "source": "apache", "extensions": ["xyz"] }, "font/opentype": { "compressible": true, "extensions": ["otf"] }, "image/bmp": { "source": "iana", "compressible": true, "extensions": ["bmp"] }, "image/cgm": { "source": "iana", "extensions": ["cgm"] }, "image/dicom-rle": { "source": "iana" }, "image/emf": { "source": "iana" }, "image/fits": { "source": "iana" }, "image/g3fax": { "source": "iana", "extensions": ["g3"] }, "image/gif": { "source": "iana", "compressible": false, "extensions": ["gif"] }, "image/ief": { "source": "iana", "extensions": ["ief"] }, "image/jls": { "source": "iana" }, "image/jp2": { "source": "iana" }, "image/jpeg": { "source": "iana", "compressible": false, "extensions": ["jpeg", "jpg", "jpe"] }, "image/jpm": { "source": "iana" }, "image/jpx": { "source": "iana" }, "image/ktx": { "source": "iana", "extensions": ["ktx"] }, "image/naplps": { "source": "iana" }, "image/pjpeg": { "compressible": false }, "image/png": { "source": "iana", "compressible": false, "extensions": ["png"] }, "image/prs.btif": { "source": "iana", "extensions": ["btif"] }, "image/prs.pti": { "source": "iana" }, "image/pwg-raster": { "source": "iana" }, "image/sgi": { "source": "apache", "extensions": ["sgi"] }, "image/svg+xml": { "source": "iana", "compressible": true, "extensions": ["svg", "svgz"] }, "image/t38": { "source": "iana" }, "image/tiff": { "source": "iana", "compressible": false, "extensions": ["tiff", "tif"] }, "image/tiff-fx": { "source": "iana" }, "image/vnd.adobe.photoshop": { "source": "iana", "compressible": true, "extensions": ["psd"] }, "image/vnd.airzip.accelerator.azv": { "source": "iana" }, "image/vnd.cns.inf2": { "source": "iana" }, "image/vnd.dece.graphic": { "source": "iana", "extensions": ["uvi", "uvvi", "uvg", "uvvg"] }, "image/vnd.djvu": { "source": "iana", "extensions": ["djvu", "djv"] }, "image/vnd.dvb.subtitle": { "source": "iana", "extensions": ["sub"] }, "image/vnd.dwg": { "source": "iana", "extensions": ["dwg"] }, "image/vnd.dxf": { "source": "iana", "extensions": ["dxf"] }, "image/vnd.fastbidsheet": { "source": "iana", "extensions": ["fbs"] }, "image/vnd.fpx": { "source": "iana", "extensions": ["fpx"] }, "image/vnd.fst": { "source": "iana", "extensions": ["fst"] }, "image/vnd.fujixerox.edmics-mmr": { "source": "iana", "extensions": ["mmr"] }, "image/vnd.fujixerox.edmics-rlc": { "source": "iana", "extensions": ["rlc"] }, "image/vnd.globalgraphics.pgb": { "source": "iana" }, "image/vnd.microsoft.icon": { "source": "iana" }, "image/vnd.mix": { "source": "iana" }, "image/vnd.mozilla.apng": { "source": "iana" }, "image/vnd.ms-modi": { "source": "iana", "extensions": ["mdi"] }, "image/vnd.ms-photo": { "source": "apache", "extensions": ["wdp"] }, "image/vnd.net-fpx": { "source": "iana", "extensions": ["npx"] }, "image/vnd.radiance": { "source": "iana" }, "image/vnd.sealed.png": { "source": "iana" }, "image/vnd.sealedmedia.softseal.gif": { "source": "iana" }, "image/vnd.sealedmedia.softseal.jpg": { "source": "iana" }, "image/vnd.svf": { "source": "iana" }, "image/vnd.tencent.tap": { "source": "iana" }, "image/vnd.valve.source.texture": { "source": "iana" }, "image/vnd.wap.wbmp": { "source": "iana", "extensions": ["wbmp"] }, "image/vnd.xiff": { "source": "iana", "extensions": ["xif"] }, "image/vnd.zbrush.pcx": { "source": "iana" }, "image/webp": { "source": "apache", "extensions": ["webp"] }, "image/wmf": { "source": "iana" }, "image/x-3ds": { "source": "apache", "extensions": ["3ds"] }, "image/x-cmu-raster": { "source": "apache", "extensions": ["ras"] }, "image/x-cmx": { "source": "apache", "extensions": ["cmx"] }, "image/x-freehand": { "source": "apache", "extensions": ["fh", "fhc", "fh4", "fh5", "fh7"] }, "image/x-icon": { "source": "apache", "compressible": true, "extensions": ["ico"] }, "image/x-jng": { "source": "nginx", "extensions": ["jng"] }, "image/x-mrsid-image": { "source": "apache", "extensions": ["sid"] }, "image/x-ms-bmp": { "source": "nginx", "compressible": true, "extensions": ["bmp"] }, "image/x-pcx": { "source": "apache", "extensions": ["pcx"] }, "image/x-pict": { "source": "apache", "extensions": ["pic", "pct"] }, "image/x-portable-anymap": { "source": "apache", "extensions": ["pnm"] }, "image/x-portable-bitmap": { "source": "apache", "extensions": ["pbm"] }, "image/x-portable-graymap": { "source": "apache", "extensions": ["pgm"] }, "image/x-portable-pixmap": { "source": "apache", "extensions": ["ppm"] }, "image/x-rgb": { "source": "apache", "extensions": ["rgb"] }, "image/x-tga": { "source": "apache", "extensions": ["tga"] }, "image/x-xbitmap": { "source": "apache", "extensions": ["xbm"] }, "image/x-xcf": { "compressible": false }, "image/x-xpixmap": { "source": "apache", "extensions": ["xpm"] }, "image/x-xwindowdump": { "source": "apache", "extensions": ["xwd"] }, "message/cpim": { "source": "iana" }, "message/delivery-status": { "source": "iana" }, "message/disposition-notification": { "source": "iana" }, "message/external-body": { "source": "iana" }, "message/feedback-report": { "source": "iana" }, "message/global": { "source": "iana" }, "message/global-delivery-status": { "source": "iana" }, "message/global-disposition-notification": { "source": "iana" }, "message/global-headers": { "source": "iana" }, "message/http": { "source": "iana", "compressible": false }, "message/imdn+xml": { "source": "iana", "compressible": true }, "message/news": { "source": "iana" }, "message/partial": { "source": "iana", "compressible": false }, "message/rfc822": { "source": "iana", "compressible": true, "extensions": ["eml", "mime"] }, "message/s-http": { "source": "iana" }, "message/sip": { "source": "iana" }, "message/sipfrag": { "source": "iana" }, "message/tracking-status": { "source": "iana" }, "message/vnd.si.simp": { "source": "iana" }, "message/vnd.wfa.wsc": { "source": "iana" }, "model/gltf+json": { "source": "iana", "compressible": true }, "model/iges": { "source": "iana", "compressible": false, "extensions": ["igs", "iges"] }, "model/mesh": { "source": "iana", "compressible": false, "extensions": ["msh", "mesh", "silo"] }, "model/vnd.collada+xml": { "source": "iana", "extensions": ["dae"] }, "model/vnd.dwf": { "source": "iana", "extensions": ["dwf"] }, "model/vnd.flatland.3dml": { "source": "iana" }, "model/vnd.gdl": { "source": "iana", "extensions": ["gdl"] }, "model/vnd.gs-gdl": { "source": "apache" }, "model/vnd.gs.gdl": { "source": "iana" }, "model/vnd.gtw": { "source": "iana", "extensions": ["gtw"] }, "model/vnd.moml+xml": { "source": "iana" }, "model/vnd.mts": { "source": "iana", "extensions": ["mts"] }, "model/vnd.opengex": { "source": "iana" }, "model/vnd.parasolid.transmit.binary": { "source": "iana" }, "model/vnd.parasolid.transmit.text": { "source": "iana" }, "model/vnd.rosette.annotated-data-model": { "source": "iana" }, "model/vnd.valve.source.compiled-map": { "source": "iana" }, "model/vnd.vtu": { "source": "iana", "extensions": ["vtu"] }, "model/vrml": { "source": "iana", "compressible": false, "extensions": ["wrl", "vrml"] }, "model/x3d+binary": { "source": "apache", "compressible": false, "extensions": ["x3db", "x3dbz"] }, "model/x3d+fastinfoset": { "source": "iana" }, "model/x3d+vrml": { "source": "apache", "compressible": false, "extensions": ["x3dv", "x3dvz"] }, "model/x3d+xml": { "source": "iana", "compressible": true, "extensions": ["x3d", "x3dz"] }, "model/x3d-vrml": { "source": "iana" }, "multipart/alternative": { "source": "iana", "compressible": false }, "multipart/appledouble": { "source": "iana" }, "multipart/byteranges": { "source": "iana" }, "multipart/digest": { "source": "iana" }, "multipart/encrypted": { "source": "iana", "compressible": false }, "multipart/form-data": { "source": "iana", "compressible": false }, "multipart/header-set": { "source": "iana" }, "multipart/mixed": { "source": "iana", "compressible": false }, "multipart/parallel": { "source": "iana" }, "multipart/related": { "source": "iana", "compressible": false }, "multipart/report": { "source": "iana" }, "multipart/signed": { "source": "iana", "compressible": false }, "multipart/voice-message": { "source": "iana" }, "multipart/x-mixed-replace": { "source": "iana" }, "text/1d-interleaved-parityfec": { "source": "iana" }, "text/cache-manifest": { "source": "iana", "compressible": true, "extensions": ["appcache", "manifest"] }, "text/calendar": { "source": "iana", "extensions": ["ics", "ifb"] }, "text/calender": { "compressible": true }, "text/cmd": { "compressible": true }, "text/coffeescript": { "extensions": ["coffee", "litcoffee"] }, "text/css": { "source": "iana", "compressible": true, "extensions": ["css"] }, "text/csv": { "source": "iana", "compressible": true, "extensions": ["csv"] }, "text/csv-schema": { "source": "iana" }, "text/directory": { "source": "iana" }, "text/dns": { "source": "iana" }, "text/ecmascript": { "source": "iana" }, "text/encaprtp": { "source": "iana" }, "text/enriched": { "source": "iana" }, "text/fwdred": { "source": "iana" }, "text/grammar-ref-list": { "source": "iana" }, "text/hjson": { "extensions": ["hjson"] }, "text/html": { "source": "iana", "compressible": true, "extensions": ["html", "htm", "shtml"] }, "text/jade": { "extensions": ["jade"] }, "text/javascript": { "source": "iana", "compressible": true }, "text/jcr-cnd": { "source": "iana" }, "text/jsx": { "compressible": true, "extensions": ["jsx"] }, "text/less": { "extensions": ["less"] }, "text/markdown": { "source": "iana" }, "text/mathml": { "source": "nginx", "extensions": ["mml"] }, "text/mizar": { "source": "iana" }, "text/n3": { "source": "iana", "compressible": true, "extensions": ["n3"] }, "text/parameters": { "source": "iana" }, "text/parityfec": { "source": "iana" }, "text/plain": { "source": "iana", "compressible": true, "extensions": ["txt", "text", "conf", "def", "list", "log", "in", "ini"] }, "text/provenance-notation": { "source": "iana" }, "text/prs.fallenstein.rst": { "source": "iana" }, "text/prs.lines.tag": { "source": "iana", "extensions": ["dsc"] }, "text/prs.prop.logic": { "source": "iana" }, "text/raptorfec": { "source": "iana" }, "text/red": { "source": "iana" }, "text/rfc822-headers": { "source": "iana" }, "text/richtext": { "source": "iana", "compressible": true, "extensions": ["rtx"] }, "text/rtf": { "source": "iana", "compressible": true, "extensions": ["rtf"] }, "text/rtp-enc-aescm128": { "source": "iana" }, "text/rtploopback": { "source": "iana" }, "text/rtx": { "source": "iana" }, "text/sgml": { "source": "iana", "extensions": ["sgml", "sgm"] }, "text/slim": { "extensions": ["slim", "slm"] }, "text/stylus": { "extensions": ["stylus", "styl"] }, "text/t140": { "source": "iana" }, "text/tab-separated-values": { "source": "iana", "compressible": true, "extensions": ["tsv"] }, "text/troff": { "source": "iana", "extensions": ["t", "tr", "roff", "man", "me", "ms"] }, "text/turtle": { "source": "iana", "extensions": ["ttl"] }, "text/ulpfec": { "source": "iana" }, "text/uri-list": { "source": "iana", "compressible": true, "extensions": ["uri", "uris", "urls"] }, "text/vcard": { "source": "iana", "compressible": true, "extensions": ["vcard"] }, "text/vnd.a": { "source": "iana" }, "text/vnd.abc": { "source": "iana" }, "text/vnd.ascii-art": { "source": "iana" }, "text/vnd.curl": { "source": "iana", "extensions": ["curl"] }, "text/vnd.curl.dcurl": { "source": "apache", "extensions": ["dcurl"] }, "text/vnd.curl.mcurl": { "source": "apache", "extensions": ["mcurl"] }, "text/vnd.curl.scurl": { "source": "apache", "extensions": ["scurl"] }, "text/vnd.debian.copyright": { "source": "iana" }, "text/vnd.dmclientscript": { "source": "iana" }, "text/vnd.dvb.subtitle": { "source": "iana", "extensions": ["sub"] }, "text/vnd.esmertec.theme-descriptor": { "source": "iana" }, "text/vnd.fly": { "source": "iana", "extensions": ["fly"] }, "text/vnd.fmi.flexstor": { "source": "iana", "extensions": ["flx"] }, "text/vnd.graphviz": { "source": "iana", "extensions": ["gv"] }, "text/vnd.in3d.3dml": { "source": "iana", "extensions": ["3dml"] }, "text/vnd.in3d.spot": { "source": "iana", "extensions": ["spot"] }, "text/vnd.iptc.newsml": { "source": "iana" }, "text/vnd.iptc.nitf": { "source": "iana" }, "text/vnd.latex-z": { "source": "iana" }, "text/vnd.motorola.reflex": { "source": "iana" }, "text/vnd.ms-mediapackage": { "source": "iana" }, "text/vnd.net2phone.commcenter.command": { "source": "iana" }, "text/vnd.radisys.msml-basic-layout": { "source": "iana" }, "text/vnd.si.uricatalogue": { "source": "iana" }, "text/vnd.sun.j2me.app-descriptor": { "source": "iana", "extensions": ["jad"] }, "text/vnd.trolltech.linguist": { "source": "iana" }, "text/vnd.wap.si": { "source": "iana" }, "text/vnd.wap.sl": { "source": "iana" }, "text/vnd.wap.wml": { "source": "iana", "extensions": ["wml"] }, "text/vnd.wap.wmlscript": { "source": "iana", "extensions": ["wmls"] }, "text/vtt": { "charset": "UTF-8", "compressible": true, "extensions": ["vtt"] }, "text/x-asm": { "source": "apache", "extensions": ["s", "asm"] }, "text/x-c": { "source": "apache", "extensions": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"] }, "text/x-component": { "source": "nginx", "extensions": ["htc"] }, "text/x-fortran": { "source": "apache", "extensions": ["f", "for", "f77", "f90"] }, "text/x-gwt-rpc": { "compressible": true }, "text/x-handlebars-template": { "extensions": ["hbs"] }, "text/x-java-source": { "source": "apache", "extensions": ["java"] }, "text/x-jquery-tmpl": { "compressible": true }, "text/x-lua": { "extensions": ["lua"] }, "text/x-markdown": { "compressible": true, "extensions": ["markdown", "md", "mkd"] }, "text/x-nfo": { "source": "apache", "extensions": ["nfo"] }, "text/x-opml": { "source": "apache", "extensions": ["opml"] }, "text/x-pascal": { "source": "apache", "extensions": ["p", "pas"] }, "text/x-processing": { "compressible": true, "extensions": ["pde"] }, "text/x-sass": { "extensions": ["sass"] }, "text/x-scss": { "extensions": ["scss"] }, "text/x-setext": { "source": "apache", "extensions": ["etx"] }, "text/x-sfv": { "source": "apache", "extensions": ["sfv"] }, "text/x-suse-ymp": { "compressible": true, "extensions": ["ymp"] }, "text/x-uuencode": { "source": "apache", "extensions": ["uu"] }, "text/x-vcalendar": { "source": "apache", "extensions": ["vcs"] }, "text/x-vcard": { "source": "apache", "extensions": ["vcf"] }, "text/xml": { "source": "iana", "compressible": true, "extensions": ["xml"] }, "text/xml-external-parsed-entity": { "source": "iana" }, "text/yaml": { "extensions": ["yaml", "yml"] }, "video/1d-interleaved-parityfec": { "source": "apache" }, "video/3gpp": { "source": "apache", "extensions": ["3gp", "3gpp"] }, "video/3gpp-tt": { "source": "apache" }, "video/3gpp2": { "source": "apache", "extensions": ["3g2"] }, "video/bmpeg": { "source": "apache" }, "video/bt656": { "source": "apache" }, "video/celb": { "source": "apache" }, "video/dv": { "source": "apache" }, "video/encaprtp": { "source": "apache" }, "video/h261": { "source": "apache", "extensions": ["h261"] }, "video/h263": { "source": "apache", "extensions": ["h263"] }, "video/h263-1998": { "source": "apache" }, "video/h263-2000": { "source": "apache" }, "video/h264": { "source": "apache", "extensions": ["h264"] }, "video/h264-rcdo": { "source": "apache" }, "video/h264-svc": { "source": "apache" }, "video/h265": { "source": "apache" }, "video/iso.segment": { "source": "apache" }, "video/jpeg": { "source": "apache", "extensions": ["jpgv"] }, "video/jpeg2000": { "source": "apache" }, "video/jpm": { "source": "apache", "extensions": ["jpm", "jpgm"] }, "video/mj2": { "source": "apache", "extensions": ["mj2", "mjp2"] }, "video/mp1s": { "source": "apache" }, "video/mp2p": { "source": "apache" }, "video/mp2t": { "source": "apache", "extensions": ["ts"] }, "video/mp4": { "source": "apache", "compressible": false, "extensions": ["mp4", "mp4v", "mpg4"] }, "video/mp4v-es": { "source": "apache" }, "video/mpeg": { "source": "apache", "compressible": false, "extensions": ["mpeg", "mpg", "mpe", "m1v", "m2v"] }, "video/mpeg4-generic": { "source": "apache" }, "video/mpv": { "source": "apache" }, "video/nv": { "source": "apache" }, "video/ogg": { "source": "apache", "compressible": false, "extensions": ["ogv"] }, "video/parityfec": { "source": "apache" }, "video/pointer": { "source": "apache" }, "video/quicktime": { "source": "apache", "compressible": false, "extensions": ["qt", "mov"] }, "video/raptorfec": { "source": "apache" }, "video/raw": { "source": "apache" }, "video/rtp-enc-aescm128": { "source": "apache" }, "video/rtploopback": { "source": "apache" }, "video/rtx": { "source": "apache" }, "video/smpte292m": { "source": "apache" }, "video/ulpfec": { "source": "apache" }, "video/vc1": { "source": "apache" }, "video/vnd.cctv": { "source": "apache" }, "video/vnd.dece.hd": { "source": "apache", "extensions": ["uvh", "uvvh"] }, "video/vnd.dece.mobile": { "source": "apache", "extensions": ["uvm", "uvvm"] }, "video/vnd.dece.mp4": { "source": "apache" }, "video/vnd.dece.pd": { "source": "apache", "extensions": ["uvp", "uvvp"] }, "video/vnd.dece.sd": { "source": "apache", "extensions": ["uvs", "uvvs"] }, "video/vnd.dece.video": { "source": "apache", "extensions": ["uvv", "uvvv"] }, "video/vnd.directv.mpeg": { "source": "apache" }, "video/vnd.directv.mpeg-tts": { "source": "apache" }, "video/vnd.dlna.mpeg-tts": { "source": "apache" }, "video/vnd.dvb.file": { "source": "apache", "extensions": ["dvb"] }, "video/vnd.fvt": { "source": "apache", "extensions": ["fvt"] }, "video/vnd.hns.video": { "source": "apache" }, "video/vnd.iptvforum.1dparityfec-1010": { "source": "apache" }, "video/vnd.iptvforum.1dparityfec-2005": { "source": "apache" }, "video/vnd.iptvforum.2dparityfec-1010": { "source": "apache" }, "video/vnd.iptvforum.2dparityfec-2005": { "source": "apache" }, "video/vnd.iptvforum.ttsavc": { "source": "apache" }, "video/vnd.iptvforum.ttsmpeg2": { "source": "apache" }, "video/vnd.motorola.video": { "source": "apache" }, "video/vnd.motorola.videop": { "source": "apache" }, "video/vnd.mpegurl": { "source": "apache", "extensions": ["mxu", "m4u"] }, "video/vnd.ms-playready.media.pyv": { "source": "apache", "extensions": ["pyv"] }, "video/vnd.nokia.interleaved-multimedia": { "source": "apache" }, "video/vnd.nokia.videovoip": { "source": "apache" }, "video/vnd.objectvideo": { "source": "apache" }, "video/vnd.radgamettools.bink": { "source": "apache" }, "video/vnd.radgamettools.smacker": { "source": "apache" }, "video/vnd.sealed.mpeg1": { "source": "apache" }, "video/vnd.sealed.mpeg4": { "source": "apache" }, "video/vnd.sealed.swf": { "source": "apache" }, "video/vnd.sealedmedia.softseal.mov": { "source": "apache" }, "video/vnd.uvvu.mp4": { "source": "apache", "extensions": ["uvu", "uvvu"] }, "video/vnd.vivo": { "source": "apache", "extensions": ["viv"] }, "video/vp8": { "source": "apache" }, "video/webm": { "source": "apache", "compressible": false, "extensions": ["webm"] }, "video/x-f4v": { "source": "apache", "extensions": ["f4v"] }, "video/x-fli": { "source": "apache", "extensions": ["fli"] }, "video/x-flv": { "source": "apache", "compressible": false, "extensions": ["flv"] }, "video/x-m4v": { "source": "apache", "extensions": ["m4v"] }, "video/x-matroska": { "source": "apache", "compressible": false, "extensions": ["mkv", "mk3d", "mks"] }, "video/x-mng": { "source": "apache", "extensions": ["mng"] }, "video/x-ms-asf": { "source": "apache", "extensions": ["asf", "asx"] }, "video/x-ms-vob": { "source": "apache", "extensions": ["vob"] }, "video/x-ms-wm": { "source": "apache", "extensions": ["wm"] }, "video/x-ms-wmv": { "source": "apache", "compressible": false, "extensions": ["wmv"] }, "video/x-ms-wmx": { "source": "apache", "extensions": ["wmx"] }, "video/x-ms-wvx": { "source": "apache", "extensions": ["wvx"] }, "video/x-msvideo": { "source": "apache", "extensions": ["avi"] }, "video/x-sgi-movie": { "source": "apache", "extensions": ["movie"] }, "video/x-smv": { "source": "apache", "extensions": ["smv"] }, "x-conference/x-cooltalk": { "source": "apache", "extensions": ["ice"] }, "x-shader/x-fragment": { "compressible": true }, "x-shader/x-vertex": { "compressible": true } };
  return module.exports;
});
$__System.registerDynamic('16d', ['16c'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  module.exports = $__require('16c');
  return module.exports;
});
$__System.registerDynamic("16e", ["16d"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("16d");
  return module.exports;
});
$__System.registerDynamic('16f', ['16e', '9'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var db = $__require('16e');
  var extname = $__require('9').extname;
  var extractTypeRegExp = /^\s*([^;\s]*)(?:;|\s|$)/;
  var textTypeRegExp = /^text\//i;
  exports.charset = charset;
  exports.charsets = { lookup: charset };
  exports.contentType = contentType;
  exports.extension = extension;
  exports.extensions = Object.create(null);
  exports.lookup = lookup;
  exports.types = Object.create(null);
  populateMaps(exports.extensions, exports.types);
  function charset(type) {
    if (!type || typeof type !== 'string') {
      return false;
    }
    var match = extractTypeRegExp.exec(type);
    var mime = match && db[match[1].toLowerCase()];
    if (mime && mime.charset) {
      return mime.charset;
    }
    if (match && textTypeRegExp.test(match[1])) {
      return 'UTF-8';
    }
    return false;
  }
  function contentType(str) {
    if (!str || typeof str !== 'string') {
      return false;
    }
    var mime = str.indexOf('/') === -1 ? exports.lookup(str) : str;
    if (!mime) {
      return false;
    }
    if (mime.indexOf('charset') === -1) {
      var charset = exports.charset(mime);
      if (charset) mime += '; charset=' + charset.toLowerCase();
    }
    return mime;
  }
  function extension(type) {
    if (!type || typeof type !== 'string') {
      return false;
    }
    var match = extractTypeRegExp.exec(type);
    var exts = match && exports.extensions[match[1].toLowerCase()];
    if (!exts || !exts.length) {
      return false;
    }
    return exts[0];
  }
  function lookup(path) {
    if (!path || typeof path !== 'string') {
      return false;
    }
    var extension = extname('x.' + path).toLowerCase().substr(1);
    if (!extension) {
      return false;
    }
    return exports.types[extension] || false;
  }
  function populateMaps(extensions, types) {
    var preference = ['nginx', 'apache', undefined, 'iana'];
    Object.keys(db).forEach(function forEachMimeType(type) {
      var mime = db[type];
      var exts = mime.extensions;
      if (!exts || !exts.length) {
        return;
      }
      extensions[type] = exts;
      for (var i = 0; i < exts.length; i++) {
        var extension = exts[i];
        if (types[extension]) {
          var from = preference.indexOf(db[types[extension]].source);
          var to = preference.indexOf(mime.source);
          if (types[extension] !== 'application/octet-stream' && from > to || from === to && types[extension].substr(0, 12) === 'application/') {
            continue;
          }
        }
        types[extension] = type;
      }
    });
  }
  return module.exports;
});
$__System.registerDynamic("21", ["16f"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("16f");
  return module.exports;
});
$__System.registerDynamic('170', ['16b', '21'], true, function ($__require, exports, module) {
  /*!
   * type-is
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */

  'use strict';

  /**
   * Module dependencies.
   * @private
   */

  var define,
      global = this || self,
      GLOBAL = global;
  var typer = $__require('16b');
  var mime = $__require('21');

  /**
   * Module exports.
   * @public
   */

  module.exports = typeofrequest;
  module.exports.is = typeis;
  module.exports.hasBody = hasbody;
  module.exports.normalize = normalize;
  module.exports.match = mimeMatch;

  /**
   * Compare a `value` content-type with `types`.
   * Each `type` can be an extension like `html`,
   * a special shortcut like `multipart` or `urlencoded`,
   * or a mime type.
   *
   * If no types match, `false` is returned.
   * Otherwise, the first `type` that matches is returned.
   *
   * @param {String} value
   * @param {Array} types
   * @public
   */

  function typeis(value, types_) {
    var i;
    var types = types_;

    // remove parameters and normalize
    var val = tryNormalizeType(value);

    // no type or invalid
    if (!val) {
      return false;
    }

    // support flattened arguments
    if (types && !Array.isArray(types)) {
      types = new Array(arguments.length - 1);
      for (i = 0; i < types.length; i++) {
        types[i] = arguments[i + 1];
      }
    }

    // no types, return the content type
    if (!types || !types.length) {
      return val;
    }

    var type;
    for (i = 0; i < types.length; i++) {
      if (mimeMatch(normalize(type = types[i]), val)) {
        return type[0] === '+' || type.indexOf('*') !== -1 ? val : type;
      }
    }

    // no matches
    return false;
  }

  /**
   * Check if a request has a request body.
   * A request with a body __must__ either have `transfer-encoding`
   * or `content-length` headers set.
   * http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3
   *
   * @param {Object} request
   * @return {Boolean}
   * @public
   */

  function hasbody(req) {
    return req.headers['transfer-encoding'] !== undefined || !isNaN(req.headers['content-length']);
  }

  /**
   * Check if the incoming request contains the "Content-Type"
   * header field, and it contains any of the give mime `type`s.
   * If there is no request body, `null` is returned.
   * If there is no content type, `false` is returned.
   * Otherwise, it returns the first `type` that matches.
   *
   * Examples:
   *
   *     // With Content-Type: text/html; charset=utf-8
   *     this.is('html'); // => 'html'
   *     this.is('text/html'); // => 'text/html'
   *     this.is('text/*', 'application/json'); // => 'text/html'
   *
   *     // When Content-Type is application/json
   *     this.is('json', 'urlencoded'); // => 'json'
   *     this.is('application/json'); // => 'application/json'
   *     this.is('html', 'application/*'); // => 'application/json'
   *
   *     this.is('html'); // => false
   *
   * @param {String|Array} types...
   * @return {String|false|null}
   * @public
   */

  function typeofrequest(req, types_) {
    var types = types_;

    // no body
    if (!hasbody(req)) {
      return null;
    }

    // support flattened arguments
    if (arguments.length > 2) {
      types = new Array(arguments.length - 1);
      for (var i = 0; i < types.length; i++) {
        types[i] = arguments[i + 1];
      }
    }

    // request content type
    var value = req.headers['content-type'];

    return typeis(value, types);
  }

  /**
   * Normalize a mime type.
   * If it's a shorthand, expand it to a valid mime type.
   *
   * In general, you probably want:
   *
   *   var type = is(req, ['urlencoded', 'json', 'multipart']);
   *
   * Then use the appropriate body parsers.
   * These three are the most common request body types
   * and are thus ensured to work.
   *
   * @param {String} type
   * @private
   */

  function normalize(type) {
    if (typeof type !== 'string') {
      // invalid type
      return false;
    }

    switch (type) {
      case 'urlencoded':
        return 'application/x-www-form-urlencoded';
      case 'multipart':
        return 'multipart/*';
    }

    if (type[0] === '+') {
      // "+json" -> "*/*+json" expando
      return '*/*' + type;
    }

    return type.indexOf('/') === -1 ? mime.lookup(type) : type;
  }

  /**
   * Check if `expected` mime type
   * matches `actual` mime type with
   * wildcard and +suffix support.
   *
   * @param {String} expected
   * @param {String} actual
   * @return {Boolean}
   * @private
   */

  function mimeMatch(expected, actual) {
    // invalid type
    if (expected === false) {
      return false;
    }

    // split types
    var actualParts = actual.split('/');
    var expectedParts = expected.split('/');

    // invalid format
    if (actualParts.length !== 2 || expectedParts.length !== 2) {
      return false;
    }

    // validate type
    if (expectedParts[0] !== '*' && expectedParts[0] !== actualParts[0]) {
      return false;
    }

    // validate suffix wildcard
    if (expectedParts[1].substr(0, 2) === '*+') {
      return expectedParts[1].length <= actualParts[1].length + 1 && expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length);
    }

    // validate subtype
    if (expectedParts[1] !== '*' && expectedParts[1] !== actualParts[1]) {
      return false;
    }

    return true;
  }

  /**
   * Normalize a type and remove parameters.
   *
   * @param {string} value
   * @return {string}
   * @private
   */

  function normalizeType(value) {
    // parse the type
    var type = typer.parse(value);

    // remove the parameters
    type.parameters = undefined;

    // reformat it
    return typer.format(type);
  }

  /**
   * Try to normalize a type and remove parameters.
   *
   * @param {string} value
   * @return {string}
   * @private
   */

  function tryNormalizeType(value) {
    try {
      return normalizeType(value);
    } catch (err) {
      return null;
    }
  }
  return module.exports;
});
$__System.registerDynamic("27", ["170"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("170");
  return module.exports;
});
$__System.registerDynamic('171', ['172'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var Utils = $__require('172');
  var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
      return prefix + '[]';
    },
    indices: function indices(prefix, key) {
      return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) {
      return prefix;
    }
  };
  var defaults = {
    delimiter: '&',
    strictNullHandling: false,
    skipNulls: false,
    encode: true,
    encoder: Utils.encode
  };
  var stringify = function stringify(object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots) {
    var obj = object;
    if (typeof filter === 'function') {
      obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
      obj = obj.toISOString();
    } else if (obj === null) {
      if (strictNullHandling) {
        return encoder ? encoder(prefix) : prefix;
      }
      obj = '';
    }
    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean' || Utils.isBuffer(obj)) {
      if (encoder) {
        return [encoder(prefix) + '=' + encoder(obj)];
      }
      return [prefix + '=' + String(obj)];
    }
    var values = [];
    if (typeof obj === 'undefined') {
      return values;
    }
    var objKeys;
    if (Array.isArray(filter)) {
      objKeys = filter;
    } else {
      var keys = Object.keys(obj);
      objKeys = sort ? keys.sort(sort) : keys;
    }
    for (var i = 0; i < objKeys.length; ++i) {
      var key = objKeys[i];
      if (skipNulls && obj[key] === null) {
        continue;
      }
      if (Array.isArray(obj)) {
        values = values.concat(stringify(obj[key], generateArrayPrefix(prefix, key), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots));
      } else {
        values = values.concat(stringify(obj[key], prefix + (allowDots ? '.' + key : '[' + key + ']'), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots));
      }
    }
    return values;
  };
  module.exports = function (object, opts) {
    var obj = object;
    var options = opts || {};
    var delimiter = typeof options.delimiter === 'undefined' ? defaults.delimiter : options.delimiter;
    var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;
    var skipNulls = typeof options.skipNulls === 'boolean' ? options.skipNulls : defaults.skipNulls;
    var encode = typeof options.encode === 'boolean' ? options.encode : defaults.encode;
    var encoder = encode ? typeof options.encoder === 'function' ? options.encoder : defaults.encoder : null;
    var sort = typeof options.sort === 'function' ? options.sort : null;
    var allowDots = typeof options.allowDots === 'undefined' ? false : options.allowDots;
    var objKeys;
    var filter;
    if (options.encoder !== null && options.encoder !== undefined && typeof options.encoder !== 'function') {
      throw new TypeError('Encoder has to be a function.');
    }
    if (typeof options.filter === 'function') {
      filter = options.filter;
      obj = filter('', obj);
    } else if (Array.isArray(options.filter)) {
      objKeys = filter = options.filter;
    }
    var keys = [];
    if (typeof obj !== 'object' || obj === null) {
      return '';
    }
    var arrayFormat;
    if (options.arrayFormat in arrayPrefixGenerators) {
      arrayFormat = options.arrayFormat;
    } else if ('indices' in options) {
      arrayFormat = options.indices ? 'indices' : 'repeat';
    } else {
      arrayFormat = 'indices';
    }
    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
    if (!objKeys) {
      objKeys = Object.keys(obj);
    }
    if (sort) {
      objKeys.sort(sort);
    }
    for (var i = 0; i < objKeys.length; ++i) {
      var key = objKeys[i];
      if (skipNulls && obj[key] === null) {
        continue;
      }
      keys = keys.concat(stringify(obj[key], key, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots));
    }
    return keys.join(delimiter);
  };
  return module.exports;
});
$__System.registerDynamic('172', [], true, function ($__require, exports, module) {
    /* */
    'use strict';

    var define,
        global = this || self,
        GLOBAL = global;
    var hexTable = function () {
        var array = new Array(256);
        for (var i = 0; i < 256; ++i) {
            array[i] = '%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase();
        }

        return array;
    }();

    exports.arrayToObject = function (source, options) {
        var obj = options.plainObjects ? Object.create(null) : {};
        for (var i = 0; i < source.length; ++i) {
            if (typeof source[i] !== 'undefined') {
                obj[i] = source[i];
            }
        }

        return obj;
    };

    exports.merge = function (target, source, options) {
        if (!source) {
            return target;
        }

        if (typeof source !== 'object') {
            if (Array.isArray(target)) {
                target.push(source);
            } else if (typeof target === 'object') {
                target[source] = true;
            } else {
                return [target, source];
            }

            return target;
        }

        if (typeof target !== 'object') {
            return [target].concat(source);
        }

        var mergeTarget = target;
        if (Array.isArray(target) && !Array.isArray(source)) {
            mergeTarget = exports.arrayToObject(target, options);
        }

        return Object.keys(source).reduce(function (acc, key) {
            var value = source[key];

            if (Object.prototype.hasOwnProperty.call(acc, key)) {
                acc[key] = exports.merge(acc[key], value, options);
            } else {
                acc[key] = value;
            }
            return acc;
        }, mergeTarget);
    };

    exports.decode = function (str) {
        try {
            return decodeURIComponent(str.replace(/\+/g, ' '));
        } catch (e) {
            return str;
        }
    };

    exports.encode = function (str) {
        // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
        // It has been adapted here for stricter adherence to RFC 3986
        if (str.length === 0) {
            return str;
        }

        var string = typeof str === 'string' ? str : String(str);

        var out = '';
        for (var i = 0; i < string.length; ++i) {
            var c = string.charCodeAt(i);

            if (c === 0x2D || // -
            c === 0x2E || // .
            c === 0x5F || // _
            c === 0x7E || // ~
            c >= 0x30 && c <= 0x39 || // 0-9
            c >= 0x41 && c <= 0x5A || // a-z
            c >= 0x61 && c <= 0x7A // A-Z
            ) {
                    out += string.charAt(i);
                    continue;
                }

            if (c < 0x80) {
                out = out + hexTable[c];
                continue;
            }

            if (c < 0x800) {
                out = out + (hexTable[0xC0 | c >> 6] + hexTable[0x80 | c & 0x3F]);
                continue;
            }

            if (c < 0xD800 || c >= 0xE000) {
                out = out + (hexTable[0xE0 | c >> 12] + hexTable[0x80 | c >> 6 & 0x3F] + hexTable[0x80 | c & 0x3F]);
                continue;
            }

            i += 1;
            c = 0x10000 + ((c & 0x3FF) << 10 | string.charCodeAt(i) & 0x3FF);
            out += hexTable[0xF0 | c >> 18] + hexTable[0x80 | c >> 12 & 0x3F] + hexTable[0x80 | c >> 6 & 0x3F] + hexTable[0x80 | c & 0x3F];
        }

        return out;
    };

    exports.compact = function (obj, references) {
        if (typeof obj !== 'object' || obj === null) {
            return obj;
        }

        var refs = references || [];
        var lookup = refs.indexOf(obj);
        if (lookup !== -1) {
            return refs[lookup];
        }

        refs.push(obj);

        if (Array.isArray(obj)) {
            var compacted = [];

            for (var i = 0; i < obj.length; ++i) {
                if (obj[i] && typeof obj[i] === 'object') {
                    compacted.push(exports.compact(obj[i], refs));
                } else if (typeof obj[i] !== 'undefined') {
                    compacted.push(obj[i]);
                }
            }

            return compacted;
        }

        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            obj[key] = exports.compact(obj[key], refs);
        }

        return obj;
    };

    exports.isRegExp = function (obj) {
        return Object.prototype.toString.call(obj) === '[object RegExp]';
    };

    exports.isBuffer = function (obj) {
        if (obj === null || typeof obj === 'undefined') {
            return false;
        }

        return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    };
    return module.exports;
});
$__System.registerDynamic('173', ['172'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var Utils = $__require('172');
  var defaults = {
    delimiter: '&',
    depth: 5,
    arrayLimit: 20,
    parameterLimit: 1000,
    strictNullHandling: false,
    plainObjects: false,
    allowPrototypes: false,
    allowDots: false,
    decoder: Utils.decode
  };
  var parseValues = function parseValues(str, options) {
    var obj = {};
    var parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit);
    for (var i = 0; i < parts.length; ++i) {
      var part = parts[i];
      var pos = part.indexOf(']=') === -1 ? part.indexOf('=') : part.indexOf(']=') + 1;
      if (pos === -1) {
        obj[options.decoder(part)] = '';
        if (options.strictNullHandling) {
          obj[options.decoder(part)] = null;
        }
      } else {
        var key = options.decoder(part.slice(0, pos));
        var val = options.decoder(part.slice(pos + 1));
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          obj[key] = [].concat(obj[key]).concat(val);
        } else {
          obj[key] = val;
        }
      }
    }
    return obj;
  };
  var parseObject = function parseObject(chain, val, options) {
    if (!chain.length) {
      return val;
    }
    var root = chain.shift();
    var obj;
    if (root === '[]') {
      obj = [];
      obj = obj.concat(parseObject(chain, val, options));
    } else {
      obj = options.plainObjects ? Object.create(null) : {};
      var cleanRoot = root[0] === '[' && root[root.length - 1] === ']' ? root.slice(1, root.length - 1) : root;
      var index = parseInt(cleanRoot, 10);
      if (!isNaN(index) && root !== cleanRoot && String(index) === cleanRoot && index >= 0 && options.parseArrays && index <= options.arrayLimit) {
        obj = [];
        obj[index] = parseObject(chain, val, options);
      } else {
        obj[cleanRoot] = parseObject(chain, val, options);
      }
    }
    return obj;
  };
  var parseKeys = function parseKeys(givenKey, val, options) {
    if (!givenKey) {
      return;
    }
    var key = options.allowDots ? givenKey.replace(/\.([^\.\[]+)/g, '[$1]') : givenKey;
    var parent = /^([^\[\]]*)/;
    var child = /(\[[^\[\]]*\])/g;
    var segment = parent.exec(key);
    var keys = [];
    if (segment[1]) {
      if (!options.plainObjects && Object.prototype.hasOwnProperty(segment[1])) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      keys.push(segment[1]);
    }
    var i = 0;
    while ((segment = child.exec(key)) !== null && i < options.depth) {
      i += 1;
      if (!options.plainObjects && Object.prototype.hasOwnProperty(segment[1].replace(/\[|\]/g, ''))) {
        if (!options.allowPrototypes) {
          continue;
        }
      }
      keys.push(segment[1]);
    }
    if (segment) {
      keys.push('[' + key.slice(segment.index) + ']');
    }
    return parseObject(keys, val, options);
  };
  module.exports = function (str, opts) {
    var options = opts || {};
    if (options.decoder !== null && options.decoder !== undefined && typeof options.decoder !== 'function') {
      throw new TypeError('Decoder has to be a function.');
    }
    options.delimiter = typeof options.delimiter === 'string' || Utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;
    options.depth = typeof options.depth === 'number' ? options.depth : defaults.depth;
    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : defaults.arrayLimit;
    options.parseArrays = options.parseArrays !== false;
    options.decoder = typeof options.decoder === 'function' ? options.decoder : defaults.decoder;
    options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : defaults.allowDots;
    options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : defaults.plainObjects;
    options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : defaults.allowPrototypes;
    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : defaults.parameterLimit;
    options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;
    if (str === '' || str === null || typeof str === 'undefined') {
      return options.plainObjects ? Object.create(null) : {};
    }
    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};
    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];
      var newObj = parseKeys(key, tempObj[key], options);
      obj = Utils.merge(obj, newObj, options);
    }
    return Utils.compact(obj);
  };
  return module.exports;
});
$__System.registerDynamic('174', ['171', '173'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var Stringify = $__require('171');
  var Parse = $__require('173');
  module.exports = {
    stringify: Stringify,
    parse: Parse
  };
  return module.exports;
});
$__System.registerDynamic("175", ["174"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("174");
  return module.exports;
});
$__System.registerDynamic('176', ['177'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  module.exports = $__System._nodeRequire ? $__System._nodeRequire('querystring') : $__require('177');
  return module.exports;
});
$__System.registerDynamic("36", ["176"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("176");
  return module.exports;
});
$__System.registerDynamic('178', ['12b', '32', '12c', '8', '12', '12a', '27', '175', '36'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var bytes = $__require('12b');
  var contentType = $__require('32');
  var createError = $__require('12c');
  var debug = $__require('8')('body-parser:urlencoded');
  var deprecate = $__require('12')('body-parser');
  var read = $__require('12a');
  var typeis = $__require('27');
  module.exports = urlencoded;
  var parsers = Object.create(null);
  function urlencoded(options) {
    var opts = options || {};
    if (opts.extended === undefined) {
      deprecate('undefined extended: provide extended option');
    }
    var extended = opts.extended !== false;
    var inflate = opts.inflate !== false;
    var limit = typeof opts.limit !== 'number' ? bytes.parse(opts.limit || '100kb') : opts.limit;
    var type = opts.type || 'application/x-www-form-urlencoded';
    var verify = opts.verify || false;
    if (verify !== false && typeof verify !== 'function') {
      throw new TypeError('option verify must be function');
    }
    var queryparse = extended ? extendedparser(opts) : simpleparser(opts);
    var shouldParse = typeof type !== 'function' ? typeChecker(type) : type;
    function parse(body) {
      return body.length ? queryparse(body) : {};
    }
    return function urlencodedParser(req, res, next) {
      if (req._body) {
        debug('body already parsed');
        next();
        return;
      }
      req.body = req.body || {};
      if (!typeis.hasBody(req)) {
        debug('skip empty body');
        next();
        return;
      }
      debug('content-type %j', req.headers['content-type']);
      if (!shouldParse(req)) {
        debug('skip parsing');
        next();
        return;
      }
      var charset = getCharset(req) || 'utf-8';
      if (charset !== 'utf-8') {
        debug('invalid charset');
        next(createError(415, 'unsupported charset "' + charset.toUpperCase() + '"', { charset: charset }));
        return;
      }
      read(req, res, next, parse, debug, {
        debug: debug,
        encoding: charset,
        inflate: inflate,
        limit: limit,
        verify: verify
      });
    };
  }
  function extendedparser(options) {
    var parameterLimit = options.parameterLimit !== undefined ? options.parameterLimit : 1000;
    var parse = parser('qs');
    if (isNaN(parameterLimit) || parameterLimit < 1) {
      throw new TypeError('option parameterLimit must be a positive number');
    }
    if (isFinite(parameterLimit)) {
      parameterLimit = parameterLimit | 0;
    }
    return function queryparse(body) {
      var paramCount = parameterCount(body, parameterLimit);
      if (paramCount === undefined) {
        debug('too many parameters');
        throw createError(413, 'too many parameters');
      }
      var arrayLimit = Math.max(100, paramCount);
      debug('parse extended urlencoding');
      return parse(body, {
        allowPrototypes: true,
        arrayLimit: arrayLimit,
        depth: Infinity,
        parameterLimit: parameterLimit
      });
    };
  }
  function getCharset(req) {
    try {
      return contentType.parse(req).parameters.charset.toLowerCase();
    } catch (e) {
      return undefined;
    }
  }
  function parameterCount(body, limit) {
    var count = 0;
    var index = 0;
    while ((index = body.indexOf('&', index)) !== -1) {
      count++;
      index++;
      if (count === limit) {
        return undefined;
      }
    }
    return count;
  }
  function parser(name) {
    var mod = parsers[name];
    if (mod !== undefined) {
      return mod.parse;
    }
    switch (name) {
      case 'qs':
        mod = $__require('175');
        break;
      case 'querystring':
        mod = $__require('36');
        break;
    }
    parsers[name] = mod;
    return mod.parse;
  }
  function simpleparser(options) {
    var parameterLimit = options.parameterLimit !== undefined ? options.parameterLimit : 1000;
    var parse = parser('querystring');
    if (isNaN(parameterLimit) || parameterLimit < 1) {
      throw new TypeError('option parameterLimit must be a positive number');
    }
    if (isFinite(parameterLimit)) {
      parameterLimit = parameterLimit | 0;
    }
    return function queryparse(body) {
      var paramCount = parameterCount(body, parameterLimit);
      if (paramCount === undefined) {
        debug('too many parameters');
        throw createError(413, 'too many parameters');
      }
      debug('parse urlencoding');
      return parse(body, undefined, undefined, { maxKeys: parameterLimit });
    };
  }
  function typeChecker(type) {
    return function checkType(req) {
      return Boolean(typeis(req, type));
    };
  }
  return module.exports;
});
$__System.registerDynamic('179', ['12', '129', '12d', '12e', '178'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var deprecate = $__require('12')('body-parser');
  var parsers = Object.create(null);
  exports = module.exports = deprecate.function(bodyParser, 'bodyParser: use individual json/urlencoded middlewares');
  Object.defineProperty(exports, 'json', {
    configurable: true,
    enumerable: true,
    get: createParserGetter('json')
  });
  Object.defineProperty(exports, 'raw', {
    configurable: true,
    enumerable: true,
    get: createParserGetter('raw')
  });
  Object.defineProperty(exports, 'text', {
    configurable: true,
    enumerable: true,
    get: createParserGetter('text')
  });
  Object.defineProperty(exports, 'urlencoded', {
    configurable: true,
    enumerable: true,
    get: createParserGetter('urlencoded')
  });
  function bodyParser(options) {
    var opts = {};
    if (options) {
      for (var prop in options) {
        if (prop !== 'type') {
          opts[prop] = options[prop];
        }
      }
    }
    var _urlencoded = exports.urlencoded(opts);
    var _json = exports.json(opts);
    return function bodyParser(req, res, next) {
      _json(req, res, function (err) {
        if (err) return next(err);
        _urlencoded(req, res, next);
      });
    };
  }
  function createParserGetter(name) {
    return function get() {
      return loadParser(name);
    };
  }
  function loadParser(parserName) {
    var parser = parsers[parserName];
    if (parser !== undefined) {
      return parser;
    }
    switch (parserName) {
      case 'json':
        parser = $__require('129');
        break;
      case 'raw':
        parser = $__require('12d');
        break;
      case 'text':
        parser = $__require('12e');
        break;
      case 'urlencoded':
        parser = $__require('178');
        break;
    }
    return parsers[parserName] = parser;
  }
  return module.exports;
});
$__System.registerDynamic("17a", ["179"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("179");
  return module.exports;
});
$__System.registerDynamic('17b', [], true, function ($__require, exports, module) {
  /*!
   * vary
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */

  'use strict';

  /**
   * Module exports.
   */

  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = vary;
  module.exports.append = append;

  /**
   * Variables.
   */

  var separators = /[\(\)<>@,;:\\"\/\[\]\?=\{\}\u0020\u0009]/;

  /**
   * Append a field to a vary header.
   *
   * @param {String} header
   * @param {String|Array} field
   * @return {String}
   * @api public
   */

  function append(header, field) {
    if (typeof header !== 'string') {
      throw new TypeError('header argument is required');
    }

    if (!field) {
      throw new TypeError('field argument is required');
    }

    // get fields array
    var fields = !Array.isArray(field) ? parse(String(field)) : field;

    // assert on invalid fields
    for (var i = 0; i < fields.length; i++) {
      if (separators.test(fields[i])) {
        throw new TypeError('field argument contains an invalid header');
      }
    }

    // existing, unspecified vary
    if (header === '*') {
      return header;
    }

    // enumerate current values
    var val = header;
    var vals = parse(header.toLowerCase());

    // unspecified vary
    if (fields.indexOf('*') !== -1 || vals.indexOf('*') !== -1) {
      return '*';
    }

    for (var i = 0; i < fields.length; i++) {
      var fld = fields[i].toLowerCase();

      // append value (case-preserving)
      if (vals.indexOf(fld) === -1) {
        vals.push(fld);
        val = val ? val + ', ' + fields[i] : fields[i];
      }
    }

    return val;
  }

  /**
   * Parse a vary header into an array.
   *
   * @param {String} header
   * @return {Array}
   * @api private
   */

  function parse(header) {
    return header.trim().split(/ *, */);
  }

  /**
   * Mark that a request is varied on a header field.
   *
   * @param {Object} res
   * @param {String|Array} field
   * @api public
   */

  function vary(res, field) {
    if (!res || !res.getHeader || !res.setHeader) {
      // quack quack
      throw new TypeError('res argument is required');
    }

    // get existing header
    var val = res.getHeader('Vary') || '';
    var header = Array.isArray(val) ? val.join(', ') : String(val);

    // set new header
    if (val = append(header, field)) {
      res.setHeader('Vary', val);
    }
  }
  return module.exports;
});
$__System.registerDynamic("3e", ["17b"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("17b");
  return module.exports;
});
$__System.registerDynamic('17c', ['3e'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function () {

    'use strict';

    var vary = $__require('3e');

    var defaults = {
      origin: '*',
      methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
      preflightContinue: false,
      optionsSuccessStatus: 204
    };

    function isString(s) {
      return typeof s === 'string' || s instanceof String;
    }

    function isOriginAllowed(origin, allowedOrigin) {
      if (Array.isArray(allowedOrigin)) {
        for (var i = 0; i < allowedOrigin.length; ++i) {
          if (isOriginAllowed(origin, allowedOrigin[i])) {
            return true;
          }
        }
        return false;
      } else if (isString(allowedOrigin)) {
        return origin === allowedOrigin;
      } else if (allowedOrigin instanceof RegExp) {
        return allowedOrigin.test(origin);
      } else {
        return !!allowedOrigin;
      }
    }

    function configureOrigin(options, req) {
      var requestOrigin = req.headers.origin,
          headers = [],
          isAllowed;

      if (!options.origin || options.origin === '*') {
        // allow any origin
        headers.push([{
          key: 'Access-Control-Allow-Origin',
          value: '*'
        }]);
      } else if (isString(options.origin)) {
        // fixed origin
        headers.push([{
          key: 'Access-Control-Allow-Origin',
          value: options.origin
        }]);
        headers.push([{
          key: 'Vary',
          value: 'Origin'
        }]);
      } else {
        isAllowed = isOriginAllowed(requestOrigin, options.origin);
        // reflect origin
        headers.push([{
          key: 'Access-Control-Allow-Origin',
          value: isAllowed ? requestOrigin : false
        }]);
        if (isAllowed) {
          headers.push([{
            key: 'Vary',
            value: 'Origin'
          }]);
        }
      }

      return headers;
    }

    function configureMethods(options) {
      var methods = options.methods || defaults.methods;
      if (methods.join) {
        methods = options.methods.join(','); // .methods is an array, so turn it into a string
      }
      return {
        key: 'Access-Control-Allow-Methods',
        value: methods
      };
    }

    function configureCredentials(options) {
      if (options.credentials === true) {
        return {
          key: 'Access-Control-Allow-Credentials',
          value: 'true'
        };
      }
      return null;
    }

    function configureAllowedHeaders(options, req) {
      var headers = options.allowedHeaders || options.headers;
      if (!headers) {
        headers = req.headers['access-control-request-headers']; // .headers wasn't specified, so reflect the request headers
      } else if (headers.join) {
        headers = headers.join(','); // .headers is an array, so turn it into a string
      }
      if (headers && headers.length) {
        return {
          key: 'Access-Control-Allow-Headers',
          value: headers
        };
      }
      return null;
    }

    function configureExposedHeaders(options) {
      var headers = options.exposedHeaders;
      if (!headers) {
        return null;
      } else if (headers.join) {
        headers = headers.join(','); // .headers is an array, so turn it into a string
      }
      if (headers && headers.length) {
        return {
          key: 'Access-Control-Expose-Headers',
          value: headers
        };
      }
      return null;
    }

    function configureMaxAge(options) {
      var maxAge = options.maxAge && options.maxAge.toString();
      if (maxAge && maxAge.length) {
        return {
          key: 'Access-Control-Max-Age',
          value: maxAge
        };
      }
      return null;
    }

    function applyHeaders(headers, res) {
      for (var i = 0, n = headers.length; i < n; i++) {
        var header = headers[i];
        if (header) {
          if (Array.isArray(header)) {
            applyHeaders(header, res);
          } else if (header.key === 'Vary' && header.value) {
            vary(res, header.value);
          } else if (header.value) {
            res.setHeader(header.key, header.value);
          }
        }
      }
    }

    function cors(options, req, res, next) {
      var headers = [],
          method = req.method && req.method.toUpperCase && req.method.toUpperCase();

      if (method === 'OPTIONS') {
        // preflight
        headers.push(configureOrigin(options, req));
        headers.push(configureCredentials(options, req));
        headers.push(configureMethods(options, req));
        headers.push(configureAllowedHeaders(options, req));
        headers.push(configureMaxAge(options, req));
        headers.push(configureExposedHeaders(options, req));
        applyHeaders(headers, res);

        if (options.preflightContinue) {
          next();
        } else {
          res.statusCode = options.optionsSuccessStatus || defaults.optionsSuccessStatus;
          res.end();
        }
      } else {
        // actual response
        headers.push(configureOrigin(options, req));
        headers.push(configureCredentials(options, req));
        headers.push(configureExposedHeaders(options, req));
        applyHeaders(headers, res);
        next();
      }
    }

    function middlewareWrapper(o) {
      // if no options were passed in, use the defaults
      if (!o || o === true) {
        o = {};
      }
      if (o.origin === undefined) {
        o.origin = defaults.origin;
      }
      if (o.methods === undefined) {
        o.methods = defaults.methods;
      }
      if (o.preflightContinue === undefined) {
        o.preflightContinue = defaults.preflightContinue;
      }

      // if options are static (either via defaults or custom options passed in), wrap in a function
      var optionsCallback = null;
      if (typeof o === 'function') {
        optionsCallback = o;
      } else {
        optionsCallback = function (req, cb) {
          cb(null, o);
        };
      }

      return function corsMiddleware(req, res, next) {
        optionsCallback(req, function (err, options) {
          if (err) {
            next(err);
          } else {
            var originCallback = null;
            if (options.origin && typeof options.origin === 'function') {
              originCallback = options.origin;
            } else if (options.origin) {
              originCallback = function (origin, cb) {
                cb(null, options.origin);
              };
            }

            if (originCallback) {
              originCallback(req.headers.origin, function (err2, origin) {
                if (err2 || !origin) {
                  next(err2);
                } else {
                  var corsOptions = Object.create(options);
                  corsOptions.origin = origin;
                  cors(corsOptions, req, res, next);
                }
              });
            } else {
              next();
            }
          }
        });
      };
    }

    // can pass either an options hash, an options delegate, or nothing
    module.exports = middlewareWrapper;
  })();
  return module.exports;
});
$__System.registerDynamic("17d", ["17c"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("17c");
  return module.exports;
});
$__System.registerDynamic('17e', ['55', '166', '17f', '180', '181', '182', '183', '184', '185', '186'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var EventEmitter = $__require('55').EventEmitter,
      inherits = $__require('166').inherits;
  var AggregationCursor = $__require('17f'),
      CommandCursor = $__require('180'),
      OrderedBulkOperation = $__require('181').OrderedBulkOperation,
      UnorderedBulkOperation = $__require('182').UnorderedBulkOperation,
      GridStore = $__require('183'),
      Cursor = $__require('184'),
      Collection = $__require('185'),
      Db = $__require('186');
  var basicOperationIdGenerator = {
    operationId: 1,
    next: function () {
      return this.operationId++;
    }
  };
  var basicTimestampGenerator = {
    current: function () {
      return new Date().getTime();
    },
    duration: function (start, end) {
      return end - start;
    }
  };
  var senstiveCommands = ['authenticate', 'saslStart', 'saslContinue', 'getnonce', 'createUser', 'updateUser', 'copydbgetnonce', 'copydbsaslstart', 'copydb'];
  var Instrumentation = function (core, options, callback) {
    options = options || {};
    var operationIdGenerator = options.operationIdGenerator || basicOperationIdGenerator;
    var timestampGenerator = options.timestampGenerator || basicTimestampGenerator;
    EventEmitter.call(this);
    this.overloads = [];
    var instrumentPrototype = function (callback) {
      var instrumentations = [];
      var classes = [GridStore, OrderedBulkOperation, UnorderedBulkOperation, CommandCursor, AggregationCursor, Cursor, Collection, Db];
      for (var i = 0; i < classes.length; i++) {
        if (classes[i].define) {
          instrumentations.push(classes[i].define.generate());
        }
      }
      callback(null, instrumentations);
    };
    if (typeof callback == 'function') {
      instrumentPrototype(callback);
    }
    var self = this;
    var methods = ['command', 'insert', 'update', 'remove'];
    var proto = core.Server.prototype;
    methods.forEach(function (x) {
      var func = proto[x];
      self.overloads.push({
        proto: proto,
        name: x,
        func: func
      });
      proto[x] = function () {
        var requestId = core.Query.nextRequestId();
        var args = Array.prototype.slice.call(arguments, 0);
        var ns = args[0];
        var commandObj = args[1];
        var options = args[2] || {};
        var keys = Object.keys(commandObj);
        var commandName = keys[0];
        var db = ns.split('.')[0];
        var col = ns.split('.');
        col.shift();
        col = col.join('.');
        if (x == 'insert') {
          commandName = 'insert';
          commandObj = {
            insert: col,
            documents: commandObj
          };
          if (options.writeConcern && Object.keys(options.writeConcern).length > 0) {
            commandObj.writeConcern = options.writeConcern;
          }
          commandObj.ordered = options.ordered != undefined ? options.ordered : true;
        } else if (x == 'update') {
          commandName = 'update';
          commandObj = {
            update: col,
            updates: commandObj
          };
          if (options.writeConcern && Object.keys(options.writeConcern).length > 0) {
            commandObj.writeConcern = options.writeConcern;
          }
          commandObj.ordered = options.ordered != undefined ? options.ordered : true;
        } else if (x == 'remove') {
          commandName = 'delete';
          commandObj = {
            delete: col,
            deletes: commandObj
          };
          if (options.writeConcern && Object.keys(options.writeConcern).length > 0) {
            commandObj.writeConcern = options.writeConcern;
          }
          commandObj.ordered = options.ordered != undefined ? options.ordered : true;
        }
        var callback = args.pop();
        var ourOpId = callback.operationId || operationIdGenerator.next();
        var connection = this.s.pool.get();
        var command = {
          command: commandObj,
          databaseName: db,
          commandName: commandName,
          requestId: requestId,
          operationId: ourOpId,
          connectionId: connection
        };
        if (senstiveCommands.indexOf(commandName.toLowerCase())) {
          command.commandObj = {};
          command.commandObj[commandName] = true;
        }
        self.emit('started', command);
        var startTime = timestampGenerator.current();
        args.push(function (err, r) {
          var endTime = timestampGenerator.current();
          var command = {
            duration: timestampGenerator.duration(startTime, endTime),
            commandName: commandName,
            requestId: requestId,
            operationId: ourOpId,
            connectionId: connection
          };
          if (err || r && r.result && r.result.ok == 0) {
            command.failure = err || r.result.writeErrors || r.result;
            if (senstiveCommands.indexOf(commandName.toLowerCase())) {
              command.failure = {};
            }
            self.emit('failed', command);
          } else if (commandObj && commandObj.writeConcern && commandObj.writeConcern.w == 0) {
            command.reply = { ok: 1 };
            self.emit('succeeded', command);
          } else {
            command.reply = r && r.result ? r.result : r;
            if (senstiveCommands.indexOf(commandName.toLowerCase()) != -1) {
              command.reply = {};
            }
            self.emit('succeeded', command);
          }
          callback(err, r);
        });
        func.apply(this, args);
      };
    });
    methods = ['execute'];
    var prototypes = [$__require('181').Bulk.prototype, $__require('182').Bulk.prototype];
    prototypes.forEach(function (proto) {
      methods.forEach(function (x) {
        var func = proto[x];
        self.overloads.push({
          proto: proto,
          name: x,
          func: func
        });
        proto[x] = function () {
          var args = Array.prototype.slice.call(arguments, 0);
          this.operationId = operationIdGenerator.next();
          var callback = args.pop();
          if (typeof callback == 'function') {
            args.push(function (err, r) {
              callback(err, r);
            });
            func.apply(this, args);
          } else {
            return func.apply(this, args);
          }
        };
      });
    });
    methods = ['_find', '_getmore', '_killcursor'];
    prototypes = [$__require('184').prototype, $__require('180').prototype, $__require('17f').prototype];
    var commandTranslation = {
      '_find': 'find',
      '_getmore': 'getMore',
      '_killcursor': 'killCursors',
      '_explain': 'explain'
    };
    prototypes.forEach(function (proto) {
      methods.forEach(function (x) {
        var func = proto[x];
        self.overloads.push({
          proto: proto,
          name: x,
          func: func
        });
        proto[x] = function () {
          var cursor = this;
          var requestId = core.Query.nextRequestId();
          var ourOpId = operationIdGenerator.next();
          var parts = this.ns.split('.');
          var db = parts[0];
          parts.shift();
          var collection = parts.join('.');
          var command = this.query;
          var cmd = this.s.cmd;
          if (x == '_find') {
            cursor.operationId = ourOpId;
          }
          if (x == '_getmore') {
            command = {
              getMore: this.cursorState.cursorId,
              collection: collection,
              batchSize: cmd.batchSize
            };
            if (cmd.maxTimeMS) command.maxTimeMS = cmd.maxTimeMS;
          } else if (x == '_killcursors') {
            command = {
              killCursors: collection,
              cursors: [this.cursorState.cursorId]
            };
          } else if (cmd.find) {
            command = {
              find: collection,
              filter: cmd.query
            };
            if (cmd.sort) command.sort = cmd.sort;
            if (cmd.fields) command.projection = cmd.fields;
            if (cmd.limit && cmd.limit < 0) {
              command.limit = Math.abs(cmd.limit);
              command.singleBatch = true;
            } else if (cmd.limit) {
              command.limit = Math.abs(cmd.limit);
            }
            if (cmd.skip) command.skip = cmd.skip;
            if (cmd.hint) command.hint = cmd.hint;
            if (cmd.batchSize) command.batchSize = cmd.batchSize;
            if (typeof cmd.returnKey == 'boolean') command.returnKey = cmd.returnKey;
            if (cmd.comment) command.comment = cmd.comment;
            if (cmd.min) command.min = cmd.min;
            if (cmd.max) command.max = cmd.max;
            if (cmd.maxScan) command.maxScan = cmd.maxScan;
            if (cmd.maxTimeMS) command.maxTimeMS = cmd.maxTimeMS;
            if (typeof cmd.awaitData == 'boolean') command.awaitData = cmd.awaitData;
            if (typeof cmd.snapshot == 'boolean') command.snapshot = cmd.snapshot;
            if (typeof cmd.tailable == 'boolean') command.tailable = cmd.tailable;
            if (typeof cmd.oplogReplay == 'boolean') command.oplogReplay = cmd.oplogReplay;
            if (typeof cmd.noCursorTimeout == 'boolean') command.noCursorTimeout = cmd.noCursorTimeout;
            if (typeof cmd.partial == 'boolean') command.partial = cmd.partial;
            if (typeof cmd.showDiskLoc == 'boolean') command.showRecordId = cmd.showDiskLoc;
            if (cmd.readConcern) command.readConcern = cmd.readConcern;
            if (cmd.explain) command.explain = cmd.explain;
            if (cmd.exhaust) command.exhaust = cmd.exhaust;
            if (cmd.explain) {
              command = {
                explain: command,
                verbosity: 'allPlansExecution'
              };
              if (cmd.readConcern) command.readConcern = cmd.readConcern;
              x = '_explain';
            }
          } else {
            command = cmd;
          }
          var connectionId = null;
          if (this.connection) connectionId = this.connection;
          if (!connectionId && this.server && this.server.getConnection) connectionId = this.server.getConnection();
          var commandName = x == '_find' ? Object.keys(command)[0] : commandTranslation[x];
          command = {
            command: command,
            databaseName: db,
            commandName: commandName,
            requestId: requestId,
            operationId: this.operationId,
            connectionId: connectionId
          };
          var args = Array.prototype.slice.call(arguments, 0);
          var callback = args.pop();
          if (typeof callback == 'function' || command.commandName == 'killCursors') {
            var startTime = timestampGenerator.current();
            self.emit('started', command);
            if (command.commandName == 'killCursors' && this.server.lastIsMaster() && this.server.lastIsMaster().maxWireVersion < 4) {
              command = {
                duration: timestampGenerator.duration(startTime, timestampGenerator.current()),
                commandName: commandName,
                requestId: requestId,
                operationId: cursor.operationId,
                connectionId: cursor.server.getConnection(),
                reply: [{ ok: 1 }]
              };
              return self.emit('succeeded', command);
            }
            args.push(function (err, r) {
              if (err) {
                var command = {
                  duration: timestampGenerator.duration(startTime, timestampGenerator.current()),
                  commandName: commandName,
                  requestId: requestId,
                  operationId: ourOpId,
                  connectionId: cursor.server.getConnection(),
                  failure: err
                };
                self.emit('failed', command);
              } else {
                if (commandName.toLowerCase() == 'getmore' && r == null) {
                  r = {
                    cursor: {
                      id: cursor.cursorState.cursorId,
                      ns: cursor.ns,
                      nextBatch: cursor.cursorState.documents
                    },
                    ok: 1
                  };
                } else if (commandName.toLowerCase() == 'find' && r == null) {
                  r = {
                    cursor: {
                      id: cursor.cursorState.cursorId,
                      ns: cursor.ns,
                      firstBatch: cursor.cursorState.documents
                    },
                    ok: 1
                  };
                } else if (commandName.toLowerCase() == 'killcursors' && r == null) {
                  r = {
                    cursorsUnknown: [cursor.cursorState.lastCursorId],
                    ok: 1
                  };
                }
                command = {
                  duration: timestampGenerator.duration(startTime, timestampGenerator.current()),
                  commandName: commandName,
                  requestId: requestId,
                  operationId: cursor.operationId,
                  connectionId: cursor.server.getConnection(),
                  reply: r && r.result ? r.result : r
                };
                self.emit('succeeded', command);
              }
              if (!callback) return;
              callback(err, r);
            });
            func.apply(this, args);
          } else {
            args.push(callback);
            var promise = func.apply(this, args);
            return new cursor.s.promiseLibrary(function (resolve, reject) {
              var startTime = timestampGenerator.current();
              self.emit('started', command);
              promise.then(function () {
                var command = {
                  duration: timestampGenerator.duration(startTime, timestampGenerator.current()),
                  commandName: commandName,
                  requestId: requestId,
                  operationId: cursor.operationId,
                  connectionId: cursor.server.getConnection(),
                  reply: cursor.cursorState.documents
                };
                self.emit('succeeded', command);
              }).catch(function (err) {
                var command = {
                  duration: timestampGenerator.duration(startTime, timestampGenerator.current()),
                  commandName: commandName,
                  requestId: requestId,
                  operationId: ourOpId,
                  connectionId: cursor.server.getConnection(),
                  failure: err
                };
                self.emit('failed', command);
                reject(err);
              });
            });
          }
        };
      });
    });
  };
  inherits(Instrumentation, EventEmitter);
  Instrumentation.prototype.uninstrument = function () {
    for (var i = 0; i < this.overloads.length; i++) {
      var obj = this.overloads[i];
      obj.proto[obj.name] = obj.func;
    }
    this.removeAllListeners('started');
    this.removeAllListeners('succeeded');
    this.removeAllListeners('failed');
  };
  module.exports = Instrumentation;
  return module.exports;
});
$__System.registerDynamic('187', ['188', '57', '166'], true, function ($__require, exports, module) {
  /* */
  "use strict";

  var define,
      global = this || self,
      GLOBAL = global;
  var ReadPreference = $__require('188'),
      parser = $__require('57'),
      f = $__require('166').format;
  module.exports = function (url) {
    var connection_part = '';
    var auth_part = '';
    var query_string_part = '';
    var dbName = 'admin';
    var result = parser.parse(url, true);
    if (result.protocol != 'mongodb:') {
      throw new Error('invalid schema, expected mongodb');
    }
    if ((result.hostname == null || result.hostname == '') && url.indexOf('.sock') == -1) {
      throw new Error('no hostname or hostnames provided in connection string');
    }
    if (result.port == '0') {
      throw new Error('invalid port (zero) with hostname');
    }
    if (!isNaN(parseInt(result.port, 10)) && parseInt(result.port, 10) > 65535) {
      throw new Error('invalid port (larger than 65535) with hostname');
    }
    if (result.path && result.path.length > 0 && result.path[0] != '/' && url.indexOf('.sock') == -1) {
      throw new Error('missing delimiting slash between hosts and options');
    }
    if (result.query) {
      for (var name in result.query) {
        if (name.indexOf('::') != -1) {
          throw new Error('double colon in host identifier');
        }
        if (result.query[name] == '') {
          throw new Error('query parameter ' + name + ' is an incomplete value pair');
        }
      }
    }
    if (result.auth) {
      var parts = result.auth.split(':');
      if (url.indexOf(result.auth) != -1 && parts.length > 2) {
        throw new Error('Username with password containing an unescaped colon');
      }
      if (url.indexOf(result.auth) != -1 && result.auth.indexOf('@') != -1) {
        throw new Error('Username containing an unescaped at-sign');
      }
    }
    var clean = url.split('?').shift();
    var strings = clean.split(',');
    var hosts = [];
    for (var i = 0; i < strings.length; i++) {
      var hostString = strings[i];
      if (hostString.indexOf('mongodb') != -1) {
        if (hostString.indexOf('@') != -1) {
          hosts.push(hostString.split('@').pop());
        } else {
          hosts.push(hostString.substr('mongodb://'.length));
        }
      } else if (hostString.indexOf('/') != -1) {
        hosts.push(hostString.split('/').shift());
      } else if (hostString.indexOf('/') == -1) {
        hosts.push(hostString.trim());
      }
    }
    for (i = 0; i < hosts.length; i++) {
      var r = parser.parse(f('mongodb://%s', hosts[i].trim()));
      if (r.path && r.path.indexOf(':') != -1) {
        throw new Error('double colon in host identifier');
      }
    }
    if (url.indexOf("?") != -1) {
      query_string_part = url.substr(url.indexOf("?") + 1);
      connection_part = url.substring("mongodb://".length, url.indexOf("?"));
    } else {
      connection_part = url.substring("mongodb://".length);
    }
    if (connection_part.indexOf("@") != -1) {
      auth_part = connection_part.split("@")[0];
      connection_part = connection_part.split("@")[1];
    }
    if (connection_part.indexOf(".sock") != -1) {
      if (connection_part.indexOf(".sock/") != -1) {
        dbName = connection_part.split(".sock/")[1];
        if (dbName.indexOf("/") != -1) {
          if (dbName.split("/").length == 2 && dbName.split("/")[1].length == 0) {
            throw new Error('Illegal trailing backslash after database name');
          }
          throw new Error('More than 1 database name in URL');
        }
        connection_part = connection_part.split("/", connection_part.indexOf(".sock") + ".sock".length);
      }
    } else if (connection_part.indexOf("/") != -1) {
      if (connection_part.split("/").length > 2) {
        if (connection_part.split("/")[2].length == 0) {
          throw new Error('Illegal trailing backslash after database name');
        }
        throw new Error('More than 1 database name in URL');
      }
      dbName = connection_part.split("/")[1];
      connection_part = connection_part.split("/")[0];
    }
    var object = {};
    var authPart = auth_part || '';
    var auth = authPart.split(':', 2);
    auth[0] = decodeURIComponent(auth[0]);
    if (auth[1]) {
      auth[1] = decodeURIComponent(auth[1]);
    }
    if (auth.length == 2) object.auth = {
      user: auth[0],
      password: auth[1]
    };
    var hostPart;
    var urlOptions;
    var servers;
    var serverOptions = { socketOptions: {} };
    var dbOptions = { read_preference_tags: [] };
    var replSetServersOptions = { socketOptions: {} };
    var mongosOptions = { socketOptions: {} };
    object.server_options = serverOptions;
    object.db_options = dbOptions;
    object.rs_options = replSetServersOptions;
    object.mongos_options = mongosOptions;
    if (url.match(/\.sock/)) {
      var domainSocket = url.substring(url.indexOf("mongodb://") + "mongodb://".length, url.lastIndexOf(".sock") + ".sock".length);
      if (domainSocket.indexOf("@") != -1) domainSocket = domainSocket.split("@")[1];
      servers = [{ domain_socket: domainSocket }];
    } else {
      hostPart = connection_part;
      var deduplicatedServers = {};
      servers = hostPart.split(',').map(function (h) {
        var _host, _port, ipv6match;
        if (ipv6match = /\[([^\]]+)\](?:\:(.+))?/.exec(h)) {
          _host = ipv6match[1];
          _port = parseInt(ipv6match[2], 10) || 27017;
        } else {
          var hostPort = h.split(':', 2);
          _host = hostPort[0] || 'localhost';
          _port = hostPort[1] != null ? parseInt(hostPort[1], 10) : 27017;
          if (_host.indexOf("?") != -1) _host = _host.split(/\?/)[0];
        }
        if (deduplicatedServers[_host + "_" + _port]) return null;
        deduplicatedServers[_host + "_" + _port] = 1;
        return {
          host: _host,
          port: _port
        };
      }).filter(function (x) {
        return x != null;
      });
    }
    object.dbName = dbName || 'admin';
    urlOptions = (query_string_part || '').split(/[&;]/);
    urlOptions.forEach(function (opt) {
      if (!opt) return;
      var splitOpt = opt.split('='),
          name = splitOpt[0],
          value = splitOpt[1];
      switch (name) {
        case 'slaveOk':
        case 'slave_ok':
          serverOptions.slave_ok = value == 'true';
          dbOptions.slaveOk = value == 'true';
          break;
        case 'maxPoolSize':
        case 'poolSize':
          serverOptions.poolSize = parseInt(value, 10);
          replSetServersOptions.poolSize = parseInt(value, 10);
          break;
        case 'appname':
          object.appname = decodeURIComponent(value);
          break;
        case 'autoReconnect':
        case 'auto_reconnect':
          serverOptions.auto_reconnect = value == 'true';
          break;
        case 'minPoolSize':
          throw new Error("minPoolSize not supported");
        case 'maxIdleTimeMS':
          throw new Error("maxIdleTimeMS not supported");
        case 'waitQueueMultiple':
          throw new Error("waitQueueMultiple not supported");
        case 'waitQueueTimeoutMS':
          throw new Error("waitQueueTimeoutMS not supported");
        case 'uuidRepresentation':
          throw new Error("uuidRepresentation not supported");
        case 'ssl':
          if (value == 'prefer') {
            serverOptions.ssl = value;
            replSetServersOptions.ssl = value;
            mongosOptions.ssl = value;
            break;
          }
          serverOptions.ssl = value == 'true';
          replSetServersOptions.ssl = value == 'true';
          mongosOptions.ssl = value == 'true';
          break;
        case 'sslValidate':
          serverOptions.sslValidate = value == 'true';
          replSetServersOptions.sslValidate = value == 'true';
          mongosOptions.sslValidate = value == 'true';
          break;
        case 'replicaSet':
        case 'rs_name':
          replSetServersOptions.rs_name = value;
          break;
        case 'reconnectWait':
          replSetServersOptions.reconnectWait = parseInt(value, 10);
          break;
        case 'retries':
          replSetServersOptions.retries = parseInt(value, 10);
          break;
        case 'readSecondary':
        case 'read_secondary':
          replSetServersOptions.read_secondary = value == 'true';
          break;
        case 'fsync':
          dbOptions.fsync = value == 'true';
          break;
        case 'journal':
          dbOptions.j = value == 'true';
          break;
        case 'safe':
          dbOptions.safe = value == 'true';
          break;
        case 'nativeParser':
        case 'native_parser':
          dbOptions.native_parser = value == 'true';
          break;
        case 'readConcernLevel':
          dbOptions.readConcern = { level: value };
          break;
        case 'connectTimeoutMS':
          serverOptions.socketOptions.connectTimeoutMS = parseInt(value, 10);
          replSetServersOptions.socketOptions.connectTimeoutMS = parseInt(value, 10);
          mongosOptions.socketOptions.connectTimeoutMS = parseInt(value, 10);
          break;
        case 'socketTimeoutMS':
          serverOptions.socketOptions.socketTimeoutMS = parseInt(value, 10);
          replSetServersOptions.socketOptions.socketTimeoutMS = parseInt(value, 10);
          mongosOptions.socketOptions.socketTimeoutMS = parseInt(value, 10);
          break;
        case 'w':
          dbOptions.w = parseInt(value, 10);
          if (isNaN(dbOptions.w)) dbOptions.w = value;
          break;
        case 'authSource':
          dbOptions.authSource = value;
          break;
        case 'gssapiServiceName':
          dbOptions.gssapiServiceName = value;
          break;
        case 'authMechanism':
          if (value == 'GSSAPI') {
            if (object.auth == null) {
              var urlDecodeAuthPart = decodeURIComponent(authPart);
              if (urlDecodeAuthPart.indexOf("@") == -1) throw new Error("GSSAPI requires a provided principal");
              object.auth = {
                user: urlDecodeAuthPart,
                password: null
              };
            } else {
              object.auth.user = decodeURIComponent(object.auth.user);
            }
          } else if (value == 'MONGODB-X509') {
            object.auth = { user: decodeURIComponent(authPart) };
          }
          if (value != 'GSSAPI' && value != 'MONGODB-X509' && value != 'MONGODB-CR' && value != 'DEFAULT' && value != 'SCRAM-SHA-1' && value != 'PLAIN') throw new Error("only DEFAULT, GSSAPI, PLAIN, MONGODB-X509, SCRAM-SHA-1 or MONGODB-CR is supported by authMechanism");
          dbOptions.authMechanism = value;
          break;
        case 'authMechanismProperties':
          var values = value.split(',');
          var o = {};
          values.forEach(function (x) {
            var v = x.split(':');
            o[v[0]] = v[1];
          });
          dbOptions.authMechanismProperties = o;
          if (typeof o.SERVICE_NAME == 'string') dbOptions.gssapiServiceName = o.SERVICE_NAME;
          if (typeof o.SERVICE_REALM == 'string') dbOptions.gssapiServiceRealm = o.SERVICE_REALM;
          if (typeof o.CANONICALIZE_HOST_NAME == 'string') dbOptions.gssapiCanonicalizeHostName = o.CANONICALIZE_HOST_NAME == 'true' ? true : false;
          break;
        case 'wtimeoutMS':
          dbOptions.wtimeout = parseInt(value, 10);
          break;
        case 'readPreference':
          if (!ReadPreference.isValid(value)) throw new Error("readPreference must be either primary/primaryPreferred/secondary/secondaryPreferred/nearest");
          dbOptions.readPreference = value;
          break;
        case 'maxStalenessSeconds':
          dbOptions.maxStalenessSeconds = parseInt(value, 10);
          break;
        case 'readPreferenceTags':
          value = decodeURIComponent(value);
          var tagObject = {};
          if (value == null || value == '') {
            dbOptions.read_preference_tags.push(tagObject);
            break;
          }
          var tags = value.split(/\,/);
          for (var i = 0; i < tags.length; i++) {
            var parts = tags[i].trim().split(/\:/);
            tagObject[parts[0]] = parts[1];
          }
          dbOptions.read_preference_tags.push(tagObject);
          break;
        default:
          break;
      }
    });
    if (dbOptions.read_preference_tags.length === 0) {
      dbOptions.read_preference_tags = null;
    }
    if ((dbOptions.w == -1 || dbOptions.w == 0) && (dbOptions.journal == true || dbOptions.fsync == true || dbOptions.safe == true)) throw new Error("w set to -1 or 0 cannot be combined with safe/w/journal/fsync");
    if (!dbOptions.readPreference) {
      dbOptions.readPreference = 'primary';
    }
    object.servers = servers;
    return object;
  };
  return module.exports;
});
$__System.registerDynamic('189', ['187', '18a', '18b', '18c', '18d', '188', '18f', '186', '166', '18e', '190', '2a', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer, process) {
    "use strict";

    var parse = $__require('187'),
        Server = $__require('18a'),
        Mongos = $__require('18b'),
        ReplSet = $__require('18c'),
        Define = $__require('18d'),
        ReadPreference = $__require('188'),
        Logger = $__require('18f').Logger,
        MongoError = $__require('18f').MongoError,
        Db = $__require('186'),
        f = $__require('166').format,
        shallowClone = $__require('18e').shallowClone;
    function MongoClient() {
      this.connect = MongoClient.connect;
    }
    var define = MongoClient.define = new Define('MongoClient', MongoClient, false);
    MongoClient.connect = function (url, options, callback) {
      var args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] == 'function' ? args.pop() : null;
      options = args.length ? args.shift() : null;
      options = options || {};
      var promiseLibrary = options.promiseLibrary;
      if (!promiseLibrary) {
        promiseLibrary = typeof global.Promise == 'function' ? global.Promise : $__require('190').Promise;
      }
      if (typeof callback != 'function') {
        return new promiseLibrary(function (resolve, reject) {
          connect(url, options, function (err, db) {
            if (err) return reject(err);
            resolve(db);
          });
        });
      }
      connect(url, options, callback);
    };
    define.staticMethod('connect', {
      callback: true,
      promise: true
    });
    var mergeOptions = function (target, source, flatten) {
      for (var name in source) {
        if (source[name] && typeof source[name] == 'object' && flatten) {
          target = mergeOptions(target, source[name], flatten);
        } else {
          target[name] = source[name];
        }
      }
      return target;
    };
    var createUnifiedOptions = function (finalOptions, options) {
      var childOptions = ['mongos', 'server', 'db', 'replset', 'db_options', 'server_options', 'rs_options', 'mongos_options'];
      var noMerge = [];
      for (var name in options) {
        if (noMerge.indexOf(name.toLowerCase()) != -1) {
          finalOptions[name] = options[name];
        } else if (childOptions.indexOf(name.toLowerCase()) != -1) {
          finalOptions = mergeOptions(finalOptions, options[name], false);
        } else {
          if (options[name] && typeof options[name] == 'object' && !Buffer.isBuffer(options[name]) && !Array.isArray(options[name])) {
            finalOptions = mergeOptions(finalOptions, options[name], true);
          } else {
            finalOptions[name] = options[name];
          }
        }
      }
      return finalOptions;
    };
    function translateOptions(options) {
      if (typeof options.readPreference == 'string' || typeof options.read_preference == 'string') {
        options.readPreference = new ReadPreference(options.readPreference || options.read_preference);
      }
      if (options.readPreference && (options.readPreferenceTags || options.read_preference_tags)) {
        options.readPreference.tags = options.readPreferenceTags || options.read_preference_tags;
      }
      if (options.maxStalenessSeconds) {
        options.readPreference.maxStalenessSeconds = options.maxStalenessSeconds;
      }
      if (options.socketTimeoutMS == null) options.socketTimeoutMS = 30000;
      if (options.connectTimeoutMS == null) options.connectTimeoutMS = 30000;
      return options.servers.map(function (serverObj) {
        return serverObj.domain_socket ? new Server(serverObj.domain_socket, 27017, options) : new Server(serverObj.host, serverObj.port, options);
      });
    }
    function createReplicaset(options, callback) {
      var servers = translateOptions(options);
      new Db(options.dbName, new ReplSet(servers, options), options).open(callback);
    }
    function createMongos(options, callback) {
      var servers = translateOptions(options);
      new Db(options.dbName, new Mongos(servers, options), options).open(callback);
    }
    function createServer(options, callback) {
      var servers = translateOptions(options);
      new Db(options.dbName, servers[0], options).open(function (err, db) {
        if (err) return callback(err);
        var ismaster = db.serverConfig.lastIsMaster();
        if (ismaster && ismaster.msg == 'isdbgrid') {
          db.close();
          return createMongos(options, callback);
        }
        callback(err, db);
      });
    }
    function connectHandler(options, callback) {
      return function (err, db) {
        if (err) {
          return process.nextTick(function () {
            try {
              callback(err, null);
            } catch (err) {
              if (db) db.close();
              throw err;
            }
          });
        }
        if (!options.auth) {
          return process.nextTick(function () {
            try {
              callback(err, db);
            } catch (err) {
              if (db) db.close();
              throw err;
            }
          });
        }
        var authentication_db = db;
        if (options.authSource) {
          authentication_db = db.db(options.authSource);
        }
        authentication_db.authenticate(options.user, options.password, options, function (err, success) {
          if (success) {
            process.nextTick(function () {
              try {
                callback(null, db);
              } catch (err) {
                if (db) db.close();
                throw err;
              }
            });
          } else {
            if (db) db.close();
            process.nextTick(function () {
              try {
                callback(err ? err : new Error('Could not authenticate user ' + options.auth[0]), null);
              } catch (err) {
                if (db) db.close();
                throw err;
              }
            });
          }
        });
      };
    }
    var connect = function (url, options, callback) {
      options = options || {};
      options = shallowClone(options);
      if (callback == null) {
        throw new Error("no callback function provided");
      }
      var logger = Logger('MongoClient', options);
      var object = parse(url, options);
      var _finalOptions = createUnifiedOptions({}, object);
      _finalOptions = mergeOptions(_finalOptions, object, false);
      _finalOptions = createUnifiedOptions(_finalOptions, options);
      if (_finalOptions.socketTimeoutMS == null) _finalOptions.socketTimeoutMS = 30000;
      if (_finalOptions.connectTimeoutMS == null) _finalOptions.connectTimeoutMS = 30000;
      if (object.servers.length == 0) {
        throw new Error("connection string must contain at least one seed host");
      }
      function connectCallback(err, db) {
        if (err && err.message == 'no mongos proxies found in seed list') {
          if (logger.isWarn()) {
            logger.warn(f('seed list contains no mongos proxies, replicaset connections requires the parameter replicaSet to be supplied in the URI or options object, mongodb://server:port/db?replicaSet=name'));
          }
          return callback(new MongoError('seed list contains no mongos proxies, replicaset connections requires the parameter replicaSet to be supplied in the URI or options object, mongodb://server:port/db?replicaSet=name'));
        }
        callback(err, db);
      }
      if (_finalOptions.replicaSet || _finalOptions.rs_name) {
        return createReplicaset(_finalOptions, connectHandler(_finalOptions, connectCallback));
      } else if (object.servers.length > 1) {
        return createMongos(_finalOptions, connectHandler(_finalOptions, connectCallback));
      } else {
        return createServer(_finalOptions, connectHandler(_finalOptions, connectCallback));
      }
    };
    module.exports = MongoClient;
  })($__require('2a').Buffer, $__require('13'));
  return module.exports;
});
$__System.registerDynamic('191', ['18e', '18d'], true, function ($__require, exports, module) {
  /* */
  "use strict";

  var define,
      global = this || self,
      GLOBAL = global;
  var toError = $__require('18e').toError,
      Define = $__require('18d'),
      shallowClone = $__require('18e').shallowClone;
  var Admin = function (db, topology, promiseLibrary) {
    if (!(this instanceof Admin)) return new Admin(db, topology);
    this.s = {
      db: db,
      topology: topology,
      promiseLibrary: promiseLibrary
    };
  };
  var define = Admin.define = new Define('Admin', Admin, false);
  Admin.prototype.command = function (command, options, callback) {
    var self = this;
    var args = Array.prototype.slice.call(arguments, 1);
    callback = args.pop();
    if (typeof callback != 'function') args.push(callback);
    options = args.length ? args.shift() : {};
    if (typeof callback == 'function') return this.s.db.executeDbAdminCommand(command, options, function (err, doc) {
      return callback != null ? callback(err, doc) : null;
    });
    return new this.s.promiseLibrary(function (resolve, reject) {
      self.s.db.executeDbAdminCommand(command, options, function (err, doc) {
        if (err) return reject(err);
        resolve(doc);
      });
    });
  };
  define.classMethod('command', {
    callback: true,
    promise: true
  });
  Admin.prototype.buildInfo = function (callback) {
    var self = this;
    if (typeof callback == 'function') return this.serverInfo(callback);
    return new this.s.promiseLibrary(function (resolve, reject) {
      self.serverInfo(function (err, r) {
        if (err) return reject(err);
        resolve(r);
      });
    });
  };
  define.classMethod('buildInfo', {
    callback: true,
    promise: true
  });
  Admin.prototype.serverInfo = function (callback) {
    var self = this;
    if (typeof callback == 'function') return this.s.db.executeDbAdminCommand({ buildinfo: 1 }, function (err, doc) {
      if (err != null) return callback(err, null);
      callback(null, doc);
    });
    return new this.s.promiseLibrary(function (resolve, reject) {
      self.s.db.executeDbAdminCommand({ buildinfo: 1 }, function (err, doc) {
        if (err) return reject(err);
        resolve(doc);
      });
    });
  };
  define.classMethod('serverInfo', {
    callback: true,
    promise: true
  });
  Admin.prototype.serverStatus = function (callback) {
    var self = this;
    if (typeof callback == 'function') return serverStatus(self, callback);
    return new this.s.promiseLibrary(function (resolve, reject) {
      serverStatus(self, function (err, r) {
        if (err) return reject(err);
        resolve(r);
      });
    });
  };
  var serverStatus = function (self, callback) {
    self.s.db.executeDbAdminCommand({ serverStatus: 1 }, function (err, doc) {
      if (err == null && doc.ok === 1) {
        callback(null, doc);
      } else {
        if (err) return callback(err, false);
        return callback(toError(doc), false);
      }
    });
  };
  define.classMethod('serverStatus', {
    callback: true,
    promise: true
  });
  Admin.prototype.profilingLevel = function (callback) {
    var self = this;
    if (typeof callback == 'function') return profilingLevel(self, callback);
    return new this.s.promiseLibrary(function (resolve, reject) {
      profilingLevel(self, function (err, r) {
        if (err) return reject(err);
        resolve(r);
      });
    });
  };
  var profilingLevel = function (self, callback) {
    self.s.db.executeDbAdminCommand({ profile: -1 }, function (err, doc) {
      if (err == null && doc.ok === 1) {
        var was = doc.was;
        if (was == 0) return callback(null, "off");
        if (was == 1) return callback(null, "slow_only");
        if (was == 2) return callback(null, "all");
        return callback(new Error("Error: illegal profiling level value " + was), null);
      } else {
        err != null ? callback(err, null) : callback(new Error("Error with profile command"), null);
      }
    });
  };
  define.classMethod('profilingLevel', {
    callback: true,
    promise: true
  });
  Admin.prototype.ping = function (options, callback) {
    var self = this;
    var args = Array.prototype.slice.call(arguments, 0);
    callback = args.pop();
    if (typeof callback != 'function') args.push(callback);
    if (typeof callback == 'function') return this.s.db.executeDbAdminCommand({ ping: 1 }, callback);
    return new this.s.promiseLibrary(function (resolve, reject) {
      self.s.db.executeDbAdminCommand({ ping: 1 }, function (err, r) {
        if (err) return reject(err);
        resolve(r);
      });
    });
  };
  define.classMethod('ping', {
    callback: true,
    promise: true
  });
  Admin.prototype.authenticate = function (username, password, options, callback) {
    var self = this;
    if (typeof options == 'function') callback = options, options = {};
    options = shallowClone(options);
    options.authdb = 'admin';
    if (typeof callback == 'function') return this.s.db.authenticate(username, password, options, callback);
    return new this.s.promiseLibrary(function (resolve, reject) {
      self.s.db.authenticate(username, password, options, function (err, r) {
        if (err) return reject(err);
        resolve(r);
      });
    });
  };
  define.classMethod('authenticate', {
    callback: true,
    promise: true
  });
  Admin.prototype.logout = function (callback) {
    var self = this;
    if (typeof callback == 'function') return this.s.db.logout({ dbName: 'admin' }, callback);
    return new this.s.promiseLibrary(function (resolve, reject) {
      self.s.db.logout({ dbName: 'admin' }, function (err) {
        if (err) return reject(err);
        resolve(true);
      });
    });
  };
  define.classMethod('logout', {
    callback: true,
    promise: true
  });
  var writeConcern = function (options, db) {
    options = shallowClone(options);
    if (options.w || options.wtimeout || options.j || options.fsync) {
      return options;
    }
    if (db.writeConcern) {
      if (options.w) options.w = db.writeConcern.w;
      if (options.wtimeout) options.wtimeout = db.writeConcern.wtimeout;
      if (options.j) options.j = db.writeConcern.j;
      if (options.fsync) options.fsync = db.writeConcern.fsync;
    }
    return options;
  };
  Admin.prototype.addUser = function (username, password, options, callback) {
    var self = this;
    var args = Array.prototype.slice.call(arguments, 2);
    callback = args.pop();
    if (typeof callback != 'function') args.push(callback);
    options = args.length ? args.shift() : {};
    options = options || {};
    options = writeConcern(options, self.s.db);
    options.dbName = 'admin';
    if (typeof callback == 'function') return self.s.db.addUser(username, password, options, callback);
    return new this.s.promiseLibrary(function (resolve, reject) {
      self.s.db.addUser(username, password, options, function (err, r) {
        if (err) return reject(err);
        resolve(r);
      });
    });
  };
  define.classMethod('addUser', {
    callback: true,
    promise: true
  });
  Admin.prototype.removeUser = function (username, options, callback) {
    var self = this;
    var args = Array.prototype.slice.call(arguments, 1);
    callback = args.pop();
    if (typeof callback != 'function') args.push(callback);
    options = args.length ? args.shift() : {};
    options = options || {};
    options = writeConcern(options, self.s.db);
    options.dbName = 'admin';
    if (typeof callback == 'function') return self.s.db.removeUser(username, options, callback);
    return new this.s.promiseLibrary(function (resolve, reject) {
      self.s.db.removeUser(username, options, function (err, r) {
        if (err) return reject(err);
        resolve(r);
      });
    });
  };
  define.classMethod('removeUser', {
    callback: true,
    promise: true
  });
  Admin.prototype.setProfilingLevel = function (level, callback) {
    var self = this;
    if (typeof callback == 'function') return setProfilingLevel(self, level, callback);
    return new this.s.promiseLibrary(function (resolve, reject) {
      setProfilingLevel(self, level, function (err, r) {
        if (err) return reject(err);
        resolve(r);
      });
    });
  };
  var setProfilingLevel = function (self, level, callback) {
    var command = {};
    var profile = 0;
    if (level == "off") {
      profile = 0;
    } else if (level == "slow_only") {
      profile = 1;
    } else if (level == "all") {
      profile = 2;
    } else {
      return callback(new Error("Error: illegal profiling level value " + level));
    }
    command['profile'] = profile;
    self.s.db.executeDbAdminCommand(command, function (err, doc) {
      if (err == null && doc.ok === 1) return callback(null, level);
      return err != null ? callback(err, null) : callback(new Error("Error with profile command"), null);
    });
  };
  define.classMethod('setProfilingLevel', {
    callback: true,
    promise: true
  });
  Admin.prototype.profilingInfo = function (callback) {
    var self = this;
    if (typeof callback == 'function') return profilingInfo(self, callback);
    return new this.s.promiseLibrary(function (resolve, reject) {
      profilingInfo(self, function (err, r) {
        if (err) return reject(err);
        resolve(r);
      });
    });
  };
  var profilingInfo = function (self, callback) {
    try {
      self.s.topology.cursor("admin.system.profile", {
        find: 'system.profile',
        query: {}
      }, {}).toArray(callback);
    } catch (err) {
      return callback(err, null);
    }
  };
  define.classMethod('profilingLevel', {
    callback: true,
    promise: true
  });
  Admin.prototype.validateCollection = function (collectionName, options, callback) {
    var self = this;
    var args = Array.prototype.slice.call(arguments, 1);
    callback = args.pop();
    if (typeof callback != 'function') args.push(callback);
    options = args.length ? args.shift() : {};
    options = options || {};
    if (typeof callback == 'function') return validateCollection(self, collectionName, options, callback);
    return new this.s.promiseLibrary(function (resolve, reject) {
      validateCollection(self, collectionName, options, function (err, r) {
        if (err) return reject(err);
        resolve(r);
      });
    });
  };
  var validateCollection = function (self, collectionName, options, callback) {
    var command = { validate: collectionName };
    var keys = Object.keys(options);
    for (var i = 0; i < keys.length; i++) {
      if (options.hasOwnProperty(keys[i])) {
        command[keys[i]] = options[keys[i]];
      }
    }
    self.s.db.command(command, function (err, doc) {
      if (err != null) return callback(err, null);
      if (doc.ok === 0) return callback(new Error("Error with validate command"), null);
      if (doc.result != null && doc.result.constructor != String) return callback(new Error("Error with validation data"), null);
      if (doc.result != null && doc.result.match(/exception|corrupt/) != null) return callback(new Error("Error: invalid collection " + collectionName), null);
      if (doc.valid != null && !doc.valid) return callback(new Error("Error: invalid collection " + collectionName), null);
      return callback(null, doc);
    });
  };
  define.classMethod('validateCollection', {
    callback: true,
    promise: true
  });
  Admin.prototype.listDatabases = function (callback) {
    var self = this;
    if (typeof callback == 'function') return self.s.db.executeDbAdminCommand({ listDatabases: 1 }, {}, callback);
    return new this.s.promiseLibrary(function (resolve, reject) {
      self.s.db.executeDbAdminCommand({ listDatabases: 1 }, {}, function (err, r) {
        if (err) return reject(err);
        resolve(r);
      });
    });
  };
  define.classMethod('listDatabases', {
    callback: true,
    promise: true
  });
  Admin.prototype.replSetGetStatus = function (callback) {
    var self = this;
    if (typeof callback == 'function') return replSetGetStatus(self, callback);
    return new this.s.promiseLibrary(function (resolve, reject) {
      replSetGetStatus(self, function (err, r) {
        if (err) return reject(err);
        resolve(r);
      });
    });
  };
  var replSetGetStatus = function (self, callback) {
    self.s.db.executeDbAdminCommand({ replSetGetStatus: 1 }, function (err, doc) {
      if (err == null && doc.ok === 1) return callback(null, doc);
      if (err) return callback(err, false);
      callback(toError(doc), false);
    });
  };
  define.classMethod('replSetGetStatus', {
    callback: true,
    promise: true
  });
  module.exports = Admin;
  return module.exports;
});
$__System.registerDynamic('186', ['55', '166', '18e', '180', '188', '191', '18f', '18d', '185', '38', '190', '2a', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer, process) {
    "use strict";

    var EventEmitter = $__require('55').EventEmitter,
        inherits = $__require('166').inherits,
        getSingleProperty = $__require('18e').getSingleProperty,
        shallowClone = $__require('18e').shallowClone,
        parseIndexOptions = $__require('18e').parseIndexOptions,
        debugOptions = $__require('18e').debugOptions,
        CommandCursor = $__require('180'),
        handleCallback = $__require('18e').handleCallback,
        filterOptions = $__require('18e').filterOptions,
        toError = $__require('18e').toError,
        ReadPreference = $__require('188'),
        f = $__require('166').format,
        Admin = $__require('191'),
        Code = $__require('18f').BSON.Code,
        CoreReadPreference = $__require('18f').ReadPreference,
        MongoError = $__require('18f').MongoError,
        ObjectID = $__require('18f').ObjectID,
        Define = $__require('18d'),
        Logger = $__require('18f').Logger,
        Collection = $__require('185'),
        crypto = $__require('38'),
        assign = $__require('18e').assign;
    var debugFields = ['authSource', 'w', 'wtimeout', 'j', 'native_parser', 'forceServerObjectId', 'serializeFunctions', 'raw', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'bufferMaxEntries', 'numberOfRetries', 'retryMiliSeconds', 'readPreference', 'pkFactory', 'parentDb', 'promiseLibrary', 'noListener'];
    var illegalCommandFields = ['w', 'wtimeout', 'j', 'fsync', 'autoIndexId', 'strict', 'serializeFunctions', 'pkFactory', 'raw', 'readPreference'];
    var legalOptionNames = ['w', 'wtimeout', 'fsync', 'j', 'readPreference', 'readPreferenceTags', 'native_parser', 'forceServerObjectId', 'pkFactory', 'serializeFunctions', 'raw', 'bufferMaxEntries', 'authSource', 'ignoreUndefined', 'promoteLongs', 'promiseLibrary', 'readConcern', 'retryMiliSeconds', 'numberOfRetries', 'parentDb', 'noListener', 'loggerLevel', 'logger', 'promoteBuffers', 'promoteLongs', 'promoteValues'];
    var Db = function (databaseName, topology, options) {
      options = options || {};
      if (!(this instanceof Db)) return new Db(databaseName, topology, options);
      EventEmitter.call(this);
      var self = this;
      var promiseLibrary = options.promiseLibrary;
      if (!promiseLibrary) {
        promiseLibrary = typeof global.Promise == 'function' ? global.Promise : $__require('190').Promise;
      }
      options = filterOptions(options, legalOptionNames);
      options.promiseLibrary = promiseLibrary;
      this.s = {
        databaseName: databaseName,
        dbCache: {},
        children: [],
        topology: topology,
        options: options,
        logger: Logger('Db', options),
        bson: topology ? topology.bson : null,
        authSource: options.authSource,
        readPreference: options.readPreference,
        bufferMaxEntries: typeof options.bufferMaxEntries == 'number' ? options.bufferMaxEntries : -1,
        parentDb: options.parentDb || null,
        pkFactory: options.pkFactory || ObjectID,
        nativeParser: options.nativeParser || options.native_parser,
        promiseLibrary: promiseLibrary,
        noListener: typeof options.noListener == 'boolean' ? options.noListener : false,
        readConcern: options.readConcern
      };
      validateDatabaseName(self.s.databaseName);
      getSingleProperty(this, 'serverConfig', self.s.topology);
      getSingleProperty(this, 'bufferMaxEntries', self.s.bufferMaxEntries);
      getSingleProperty(this, 'databaseName', self.s.databaseName);
      if (options.parentDb) return;
      if (this.s.noListener) return;
      topology.on('error', createListener(self, 'error', self));
      topology.on('timeout', createListener(self, 'timeout', self));
      topology.on('close', createListener(self, 'close', self));
      topology.on('parseError', createListener(self, 'parseError', self));
      topology.once('open', createListener(self, 'open', self));
      topology.once('fullsetup', createListener(self, 'fullsetup', self));
      topology.once('all', createListener(self, 'all', self));
      topology.on('reconnect', createListener(self, 'reconnect', self));
    };
    inherits(Db, EventEmitter);
    var define = Db.define = new Define('Db', Db, false);
    Object.defineProperty(Db.prototype, 'topology', {
      enumerable: true,
      get: function () {
        return this.s.topology;
      }
    });
    Object.defineProperty(Db.prototype, 'options', {
      enumerable: true,
      get: function () {
        return this.s.options;
      }
    });
    Object.defineProperty(Db.prototype, 'slaveOk', {
      enumerable: true,
      get: function () {
        if (this.s.options.readPreference != null && (this.s.options.readPreference != 'primary' || this.s.options.readPreference.mode != 'primary')) {
          return true;
        }
        return false;
      }
    });
    Object.defineProperty(Db.prototype, 'writeConcern', {
      enumerable: true,
      get: function () {
        var ops = {};
        if (this.s.options.w != null) ops.w = this.s.options.w;
        if (this.s.options.j != null) ops.j = this.s.options.j;
        if (this.s.options.fsync != null) ops.fsync = this.s.options.fsync;
        if (this.s.options.wtimeout != null) ops.wtimeout = this.s.options.wtimeout;
        return ops;
      }
    });
    var open = function (self, callback) {
      self.s.topology.connect(self, self.s.options, function (err) {
        if (callback == null) return;
        var internalCallback = callback;
        callback == null;
        if (err) {
          self.close();
          return internalCallback(err);
        }
        internalCallback(null, self);
      });
    };
    Db.prototype.open = function (callback) {
      var self = this;
      if (typeof callback == 'function') return open(self, callback);
      return new self.s.promiseLibrary(function (resolve, reject) {
        open(self, function (err, db) {
          if (err) return reject(err);
          resolve(db);
        });
      });
    };
    define.classMethod('open', {
      callback: true,
      promise: true
    });
    var convertReadPreference = function (readPreference) {
      if (readPreference && typeof readPreference == 'string') {
        return new CoreReadPreference(readPreference);
      } else if (readPreference instanceof ReadPreference) {
        return new CoreReadPreference(readPreference.mode, readPreference.tags, { maxStalenessSeconds: readPreference.maxStalenessSeconds });
      } else if (readPreference && typeof readPreference == 'object') {
        var mode = readPreference.mode || readPreference.preference;
        if (mode && typeof mode == 'string') {
          readPreference = new CoreReadPreference(mode, readPreference.tags, { maxStalenessSeconds: readPreference.maxStalenessSeconds });
        }
      }
      return readPreference;
    };
    var executeCommand = function (self, command, options, callback) {
      if (self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));
      var dbName = options.dbName || options.authdb || self.s.databaseName;
      if (options.readPreference == null && self.s.readPreference) {
        options.readPreference = self.s.readPreference;
      }
      if (options.readPreference) {
        options.readPreference = convertReadPreference(options.readPreference);
      } else {
        options.readPreference = CoreReadPreference.primary;
      }
      if (self.s.logger.isDebug()) self.s.logger.debug(f('executing command %s against %s with options [%s]', JSON.stringify(command), f('%s.$cmd', dbName), JSON.stringify(debugOptions(debugFields, options))));
      self.s.topology.command(f('%s.$cmd', dbName), command, options, function (err, result) {
        if (err) return handleCallback(callback, err);
        if (options.full) return handleCallback(callback, null, result);
        handleCallback(callback, null, result.result);
      });
    };
    Db.prototype.command = function (command, options, callback) {
      var self = this;
      if (typeof options == 'function') callback = options, options = {};
      options = shallowClone(options);
      if (typeof callback == 'function') return executeCommand(self, command, options, callback);
      return new this.s.promiseLibrary(function (resolve, reject) {
        executeCommand(self, command, options, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    define.classMethod('command', {
      callback: true,
      promise: true
    });
    Db.prototype.close = function (force, callback) {
      if (typeof force == 'function') callback = force, force = false;
      this.s.topology.close(force);
      var self = this;
      if (this.listeners('close').length > 0) {
        this.emit('close');
        if (this.parentDb == null) {
          for (var i = 0; i < this.s.children.length; i++) {
            this.s.children[i].emit('close');
          }
        }
        self.removeAllListeners('close');
      }
      if (this.s.parentDb) this.s.parentDb.close();
      if (typeof callback == 'function') return process.nextTick(function () {
        handleCallback(callback, null);
      });
      return new this.s.promiseLibrary(function (resolve) {
        resolve();
      });
    };
    define.classMethod('close', {
      callback: true,
      promise: true
    });
    Db.prototype.admin = function () {
      return new Admin(this, this.s.topology, this.s.promiseLibrary);
    };
    define.classMethod('admin', {
      callback: false,
      promise: false,
      returns: [Admin]
    });
    Db.prototype.collection = function (name, options, callback) {
      var self = this;
      if (typeof options == 'function') callback = options, options = {};
      options = options || {};
      options = shallowClone(options);
      options.promiseLibrary = this.s.promiseLibrary;
      options.readConcern = options.readConcern || this.s.readConcern;
      if (this.s.options.ignoreUndefined) {
        options.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      if (options == null || !options.strict) {
        try {
          var collection = new Collection(this, this.s.topology, this.s.databaseName, name, this.s.pkFactory, options);
          if (callback) callback(null, collection);
          return collection;
        } catch (err) {
          if (callback) return callback(err);
          throw err;
        }
      }
      if (typeof callback != 'function') {
        throw toError(f("A callback is required in strict mode. While getting collection %s.", name));
      }
      if (self.serverConfig && self.serverConfig.isDestroyed()) {
        return callback(new MongoError('topology was destroyed'));
      }
      this.listCollections({ name: name }).toArray(function (err, collections) {
        if (err != null) return handleCallback(callback, err, null);
        if (collections.length == 0) return handleCallback(callback, toError(f("Collection %s does not exist. Currently in strict mode.", name)), null);
        try {
          return handleCallback(callback, null, new Collection(self, self.s.topology, self.s.databaseName, name, self.s.pkFactory, options));
        } catch (err) {
          return handleCallback(callback, err, null);
        }
      });
    };
    define.classMethod('collection', {
      callback: true,
      promise: false,
      returns: [Collection]
    });
    function decorateWithWriteConcern(command, self, options) {
      if (self.s.topology.capabilities().commandsTakeWriteConcern) {
        var finalOptions = writeConcern(shallowClone(options), self, options);
        if (finalOptions.writeConcern) {
          command.writeConcern = finalOptions.writeConcern;
        }
      }
    }
    var createCollection = function (self, name, options, callback) {
      var finalOptions = writeConcern(shallowClone(options), self, options);
      if (self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));
      self.listCollections({ name: name }).setReadPreference(ReadPreference.PRIMARY).toArray(function (err, collections) {
        if (err != null) return handleCallback(callback, err, null);
        if (collections.length > 0 && finalOptions.strict) {
          return handleCallback(callback, MongoError.create({
            message: f("Collection %s already exists. Currently in strict mode.", name),
            driver: true
          }), null);
        } else if (collections.length > 0) {
          try {
            return handleCallback(callback, null, new Collection(self, self.s.topology, self.s.databaseName, name, self.s.pkFactory, options));
          } catch (err) {
            return handleCallback(callback, err);
          }
        }
        var cmd = { 'create': name };
        decorateWithWriteConcern(cmd, self, options);
        for (var n in options) {
          if (options[n] != null && typeof options[n] != 'function' && illegalCommandFields.indexOf(n) == -1) {
            cmd[n] = options[n];
          }
        }
        finalOptions.readPreference = ReadPreference.PRIMARY;
        self.command(cmd, finalOptions, function (err) {
          if (err) return handleCallback(callback, err);
          handleCallback(callback, null, new Collection(self, self.s.topology, self.s.databaseName, name, self.s.pkFactory, options));
        });
      });
    };
    Db.prototype.createCollection = function (name, options, callback) {
      var self = this;
      var args = Array.prototype.slice.call(arguments, 0);
      callback = args.pop();
      if (typeof callback != 'function') args.push(callback);
      name = args.length ? args.shift() : null;
      options = args.length ? args.shift() || {} : {};
      options.promiseLibrary = options.promiseLibrary || this.s.promiseLibrary;
      if (typeof callback == 'string') name = callback;
      if (typeof callback == 'function') return createCollection(self, name, options, callback);
      return new this.s.promiseLibrary(function (resolve, reject) {
        createCollection(self, name, options, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    define.classMethod('createCollection', {
      callback: true,
      promise: true
    });
    Db.prototype.stats = function (options, callback) {
      if (typeof options == 'function') callback = options, options = {};
      options = options || {};
      var commandObject = { dbStats: true };
      if (options['scale'] != null) commandObject['scale'] = options['scale'];
      if (options.readPreference == null && this.s.readPreference) {
        options.readPreference = this.s.readPreference;
      }
      return this.command(commandObject, options, callback);
    };
    define.classMethod('stats', {
      callback: true,
      promise: true
    });
    var listCollectionsTranforms = function (databaseName) {
      var matching = f('%s.', databaseName);
      return { doc: function (doc) {
          var index = doc.name.indexOf(matching);
          if (doc.name && index == 0) {
            doc.name = doc.name.substr(index + matching.length);
          }
          return doc;
        } };
    };
    Db.prototype.listCollections = function (filter, options) {
      filter = filter || {};
      options = options || {};
      options = shallowClone(options);
      options.promiseLibrary = this.s.promiseLibrary;
      if (options.readPreference) {
        options.readPreference = convertReadPreference(options.readPreference);
      }
      if (this.serverConfig.capabilities().hasListCollectionsCommand) {
        var cursor = options.batchSize ? { batchSize: options.batchSize } : {};
        var command = {
          listCollections: true,
          filter: filter,
          cursor: cursor
        };
        options.cursorFactory = CommandCursor;
        cursor = this.s.topology.cursor(f('%s.$cmd', this.s.databaseName), command, options);
        if (options.readPreference) {
          cursor.setReadPreference(options.readPreference);
        }
        return cursor;
      }
      if (!this.serverConfig.capabilities().hasListCollectionsCommand) {
        if (typeof filter.name == 'string' && !new RegExp('^' + this.databaseName + '\\.').test(filter.name)) {
          filter = shallowClone(filter);
          filter.name = f('%s.%s', this.s.databaseName, filter.name);
        }
      }
      if (filter == null) {
        filter.name = f('/%s/', this.s.databaseName);
      }
      if (filter.name) {
        filter = { $and: [{ name: filter.name }, { name: /^((?!\$).)*$/ }] };
      } else {
        filter = { name: /^((?!\$).)*$/ };
      }
      var _options = { transforms: listCollectionsTranforms(this.s.databaseName) };
      cursor = this.collection(Db.SYSTEM_NAMESPACE_COLLECTION).find(filter, _options);
      if (options.readPreference) cursor.setReadPreference(options.readPreference);
      if (options.batchSize) cursor = cursor.batchSize(options.batchSize);
      return cursor;
    };
    define.classMethod('listCollections', {
      callback: false,
      promise: false,
      returns: [CommandCursor]
    });
    var evaluate = function (self, code, parameters, options, callback) {
      var finalCode = code;
      var finalParameters = [];
      if (self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));
      if (!(finalCode instanceof Code)) finalCode = new Code(finalCode);
      if (parameters != null && !Array.isArray(parameters) && typeof parameters !== 'function') {
        finalParameters = [parameters];
      } else if (parameters != null && Array.isArray(parameters) && typeof parameters !== 'function') {
        finalParameters = parameters;
      }
      var cmd = {
        '$eval': finalCode,
        'args': finalParameters
      };
      if (options['nolock']) {
        cmd['nolock'] = options['nolock'];
      }
      options.readPreference = new CoreReadPreference(ReadPreference.PRIMARY);
      self.command(cmd, options, function (err, result) {
        if (err) return handleCallback(callback, err, null);
        if (result && result.ok == 1) return handleCallback(callback, null, result.retval);
        if (result) return handleCallback(callback, MongoError.create({
          message: f("eval failed: %s", result.errmsg),
          driver: true
        }), null);
        handleCallback(callback, err, result);
      });
    };
    Db.prototype.eval = function (code, parameters, options, callback) {
      var self = this;
      var args = Array.prototype.slice.call(arguments, 1);
      callback = args.pop();
      if (typeof callback != 'function') args.push(callback);
      parameters = args.length ? args.shift() : parameters;
      options = args.length ? args.shift() || {} : {};
      if (typeof callback == 'function') return evaluate(self, code, parameters, options, callback);
      return new this.s.promiseLibrary(function (resolve, reject) {
        evaluate(self, code, parameters, options, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    define.classMethod('eval', {
      callback: true,
      promise: true
    });
    Db.prototype.renameCollection = function (fromCollection, toCollection, options, callback) {
      var self = this;
      if (typeof options == 'function') callback = options, options = {};
      options = options || {};
      options.new_collection = true;
      if (typeof callback == 'function') {
        return this.collection(fromCollection).rename(toCollection, options, callback);
      }
      return new this.s.promiseLibrary(function (resolve, reject) {
        self.collection(fromCollection).rename(toCollection, options, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    define.classMethod('renameCollection', {
      callback: true,
      promise: true
    });
    Db.prototype.dropCollection = function (name, options, callback) {
      var self = this;
      if (typeof options == 'function') callback = options, options = {};
      options = options || {};
      var cmd = { 'drop': name };
      decorateWithWriteConcern(cmd, self, options);
      options = assign({}, this.s.options, { readPreference: ReadPreference.PRIMARY });
      if (typeof callback == 'function') return this.command(cmd, options, function (err, result) {
        if (self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));
        if (err) return handleCallback(callback, err);
        if (result.ok) return handleCallback(callback, null, true);
        handleCallback(callback, null, false);
      });
      options = shallowClone(self.s.options);
      options.readPreference = ReadPreference.PRIMARY;
      return new this.s.promiseLibrary(function (resolve, reject) {
        self.command(cmd, options, function (err, result) {
          if (self.serverConfig && self.serverConfig.isDestroyed()) return reject(new MongoError('topology was destroyed'));
          if (err) return reject(err);
          if (result.ok) return resolve(true);
          resolve(false);
        });
      });
    };
    define.classMethod('dropCollection', {
      callback: true,
      promise: true
    });
    Db.prototype.dropDatabase = function (options, callback) {
      var self = this;
      if (typeof options == 'function') callback = options, options = {};
      options = options || {};
      var cmd = { 'dropDatabase': 1 };
      decorateWithWriteConcern(cmd, self, options);
      options = assign({}, this.s.options, { readPreference: ReadPreference.PRIMARY });
      if (typeof callback == 'function') return this.command(cmd, options, function (err, result) {
        if (self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));
        if (callback == null) return;
        if (err) return handleCallback(callback, err, null);
        handleCallback(callback, null, result.ok ? true : false);
      });
      return new this.s.promiseLibrary(function (resolve, reject) {
        self.command(cmd, options, function (err, result) {
          if (self.serverConfig && self.serverConfig.isDestroyed()) return reject(new MongoError('topology was destroyed'));
          if (err) return reject(err);
          if (result.ok) return resolve(true);
          resolve(false);
        });
      });
    };
    define.classMethod('dropDatabase', {
      callback: true,
      promise: true
    });
    var collections = function (self, callback) {
      self.listCollections().toArray(function (err, documents) {
        if (err != null) return handleCallback(callback, err, null);
        documents = documents.filter(function (doc) {
          return doc.name.indexOf('$') == -1;
        });
        handleCallback(callback, null, documents.map(function (d) {
          return new Collection(self, self.s.topology, self.s.databaseName, d.name.replace(self.s.databaseName + ".", ''), self.s.pkFactory, self.s.options);
        }));
      });
    };
    Db.prototype.collections = function (callback) {
      var self = this;
      if (typeof callback == 'function') return collections(self, callback);
      return new self.s.promiseLibrary(function (resolve, reject) {
        collections(self, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    define.classMethod('collections', {
      callback: true,
      promise: true
    });
    Db.prototype.executeDbAdminCommand = function (selector, options, callback) {
      var self = this;
      if (typeof options == 'function') callback = options, options = {};
      options = options || {};
      if (typeof callback == 'function') {
        if (options.readPreference) {
          options.readPreference = convertReadPreference(options.readPreference);
        }
        return self.s.topology.command('admin.$cmd', selector, options, function (err, result) {
          if (self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));
          if (err) return handleCallback(callback, err);
          handleCallback(callback, null, result.result);
        });
      }
      return new self.s.promiseLibrary(function (resolve, reject) {
        self.s.topology.command('admin.$cmd', selector, options, function (err, result) {
          if (self.serverConfig && self.serverConfig.isDestroyed()) return reject(new MongoError('topology was destroyed'));
          if (err) return reject(err);
          resolve(result.result);
        });
      });
    };
    define.classMethod('executeDbAdminCommand', {
      callback: true,
      promise: true
    });
    Db.prototype.createIndex = function (name, fieldOrSpec, options, callback) {
      var self = this;
      var args = Array.prototype.slice.call(arguments, 2);
      callback = args.pop();
      if (typeof callback != 'function') args.push(callback);
      options = args.length ? args.shift() || {} : {};
      options = typeof callback === 'function' ? options : callback;
      options = options == null ? {} : options;
      options = shallowClone(options);
      options.readPreference = ReadPreference.PRIMARY;
      if (typeof callback == 'function') return createIndex(self, name, fieldOrSpec, options, callback);
      return new this.s.promiseLibrary(function (resolve, reject) {
        createIndex(self, name, fieldOrSpec, options, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var createIndex = function (self, name, fieldOrSpec, options, callback) {
      var finalOptions = writeConcern({}, self, options);
      if (finalOptions.writeConcern && typeof callback != 'function') {
        throw MongoError.create({
          message: "Cannot use a writeConcern without a provided callback",
          driver: true
        });
      }
      if (self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));
      createIndexUsingCreateIndexes(self, name, fieldOrSpec, options, function (err, result) {
        if (err == null) return handleCallback(callback, err, result);
        if (err.code === 67 || err.code == 11000 || err.code === 85) {
          return handleCallback(callback, err, result);
        }
        var doc = createCreateIndexCommand(self, name, fieldOrSpec, options);
        finalOptions.checkKeys = false;
        self.s.topology.insert(f("%s.%s", self.s.databaseName, Db.SYSTEM_INDEX_COLLECTION), doc, finalOptions, function (err, result) {
          if (callback == null) return;
          if (err) return handleCallback(callback, err);
          if (result == null) return handleCallback(callback, null, null);
          if (result.result.writeErrors) return handleCallback(callback, MongoError.create(result.result.writeErrors[0]), null);
          handleCallback(callback, null, doc.name);
        });
      });
    };
    define.classMethod('createIndex', {
      callback: true,
      promise: true
    });
    Db.prototype.ensureIndex = function (name, fieldOrSpec, options, callback) {
      var self = this;
      if (typeof options == 'function') callback = options, options = {};
      options = options || {};
      if (typeof callback == 'function') return ensureIndex(self, name, fieldOrSpec, options, callback);
      return new this.s.promiseLibrary(function (resolve, reject) {
        ensureIndex(self, name, fieldOrSpec, options, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var ensureIndex = function (self, name, fieldOrSpec, options, callback) {
      var finalOptions = writeConcern({}, self, options);
      var selector = createCreateIndexCommand(self, name, fieldOrSpec, options);
      var index_name = selector.name;
      if (self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));
      self.indexInformation(name, finalOptions, function (err, indexInformation) {
        if (err != null && err.code != 26) return handleCallback(callback, err, null);
        if (indexInformation == null || !indexInformation[index_name]) {
          self.createIndex(name, fieldOrSpec, options, callback);
        } else {
          if (typeof callback === 'function') return handleCallback(callback, null, index_name);
        }
      });
    };
    define.classMethod('ensureIndex', {
      callback: true,
      promise: true
    });
    Db.prototype.addChild = function (db) {
      if (this.s.parentDb) return this.s.parentDb.addChild(db);
      this.s.children.push(db);
    };
    Db.prototype.db = function (dbName, options) {
      options = options || {};
      var finalOptions = assign({}, this.options, options);
      if (this.s.dbCache[dbName] && finalOptions.returnNonCachedInstance !== true) {
        return this.s.dbCache[dbName];
      }
      if (finalOptions.noListener == null || finalOptions.noListener == false) {
        finalOptions.parentDb = this;
      }
      finalOptions.promiseLibrary = this.s.promiseLibrary;
      var db = new Db(dbName, this.s.topology, finalOptions);
      if (finalOptions.noListener == null || finalOptions.noListener == false) {
        this.addChild(db);
      }
      this.s.dbCache[dbName] = db;
      return db;
    };
    define.classMethod('db', {
      callback: false,
      promise: false,
      returns: [Db]
    });
    var _executeAuthCreateUserCommand = function (self, username, password, options, callback) {
      if (typeof username == 'string' && password != null && typeof password == 'object') {
        options = password;
        password = null;
      }
      if (typeof options == 'function') {
        callback = options;
        options = {};
      }
      if (options.digestPassword != null) {
        throw toError("The digestPassword option is not supported via add_user. Please use db.command('createUser', ...) instead for this option.");
      }
      var customData = options.customData != null ? options.customData : {};
      var roles = Array.isArray(options.roles) ? options.roles : [];
      var maxTimeMS = typeof options.maxTimeMS == 'number' ? options.maxTimeMS : null;
      if (roles.length == 0) {
        console.log("Creating a user without roles is deprecated in MongoDB >= 2.6");
      }
      var commandOptions = { writeCommand: true };
      if (options['dbName']) commandOptions.dbName = options['dbName'];
      if (maxTimeMS != null) commandOptions.maxTimeMS = maxTimeMS;
      if ((self.databaseName.toLowerCase() == 'admin' || options.dbName == 'admin') && !Array.isArray(options.roles)) {
        roles = ['root'];
      } else if (!Array.isArray(options.roles)) {
        roles = ['dbOwner'];
      }
      var command = {
        createUser: username,
        customData: customData,
        roles: roles,
        digestPassword: false
      };
      command = writeConcern(command, self, options);
      var md5 = crypto.createHash('md5');
      md5.update(username + ":mongo:" + password);
      var userPassword = md5.digest('hex');
      if (typeof password == 'string') {
        command.pwd = userPassword;
      }
      commandOptions.readPreference = ReadPreference.primary;
      self.command(command, commandOptions, function (err, result) {
        if (err && err.ok == 0 && err.code == undefined) return handleCallback(callback, { code: -5000 }, null);
        if (err) return handleCallback(callback, err, null);
        handleCallback(callback, !result.ok ? toError(result) : null, result.ok ? [{
          user: username,
          pwd: ''
        }] : null);
      });
    };
    var addUser = function (self, username, password, options, callback) {
      if (self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));
      _executeAuthCreateUserCommand(self, username, password, options, function (err, r) {
        if (err && err.code == -5000) {
          var finalOptions = writeConcern(shallowClone(options), self, options);
          var md5 = crypto.createHash('md5');
          md5.update(username + ":mongo:" + password);
          var userPassword = md5.digest('hex');
          var db = options.dbName ? self.db(options.dbName) : self;
          var collection = db.collection(Db.SYSTEM_USER_COLLECTION);
          collection.count({}, function (err, count) {
            if (err != null) return handleCallback(callback, err, null);
            collection.find({ user: username }, { dbName: options['dbName'] }).toArray(function (err) {
              if (err != null) return handleCallback(callback, err, null);
              finalOptions.upsert = true;
              collection.update({ user: username }, { $set: {
                  user: username,
                  pwd: userPassword
                } }, finalOptions, function (err) {
                if (count == 0 && err) return handleCallback(callback, null, [{
                  user: username,
                  pwd: userPassword
                }]);
                if (err) return handleCallback(callback, err, null);
                handleCallback(callback, null, [{
                  user: username,
                  pwd: userPassword
                }]);
              });
            });
          });
          return;
        }
        if (err) return handleCallback(callback, err);
        handleCallback(callback, err, r);
      });
    };
    Db.prototype.addUser = function (username, password, options, callback) {
      var self = this;
      var args = Array.prototype.slice.call(arguments, 2);
      callback = args.pop();
      if (typeof callback != 'function') args.push(callback);
      options = args.length ? args.shift() || {} : {};
      if (typeof callback == 'function') return addUser(self, username, password, options, callback);
      return new this.s.promiseLibrary(function (resolve, reject) {
        addUser(self, username, password, options, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    define.classMethod('addUser', {
      callback: true,
      promise: true
    });
    var _executeAuthRemoveUserCommand = function (self, username, options, callback) {
      if (typeof options == 'function') callback = options, options = {};
      if (self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));
      var commandOptions = { writeCommand: true };
      if (options['dbName']) commandOptions.dbName = options['dbName'];
      var maxTimeMS = typeof options.maxTimeMS == 'number' ? options.maxTimeMS : null;
      if (maxTimeMS != null) commandOptions.maxTimeMS = maxTimeMS;
      var command = { dropUser: username };
      command = writeConcern(command, self, options);
      commandOptions.readPreference = ReadPreference.primary;
      self.command(command, commandOptions, function (err, result) {
        if (err && !err.ok && err.code == undefined) return handleCallback(callback, { code: -5000 });
        if (err) return handleCallback(callback, err, null);
        handleCallback(callback, null, result.ok ? true : false);
      });
    };
    var removeUser = function (self, username, options, callback) {
      _executeAuthRemoveUserCommand(self, username, options, function (err, result) {
        if (err && err.code == -5000) {
          var finalOptions = writeConcern(shallowClone(options), self, options);
          var db = options.dbName ? self.db(options.dbName) : self;
          var collection = db.collection(Db.SYSTEM_USER_COLLECTION);
          collection.findOne({ user: username }, {}, function (err, user) {
            if (user == null) return handleCallback(callback, err, false);
            collection.remove({ user: username }, finalOptions, function (err) {
              handleCallback(callback, err, true);
            });
          });
          return;
        }
        if (err) return handleCallback(callback, err);
        handleCallback(callback, err, result);
      });
    };
    define.classMethod('removeUser', {
      callback: true,
      promise: true
    });
    Db.prototype.removeUser = function (username, options, callback) {
      var self = this;
      var args = Array.prototype.slice.call(arguments, 1);
      callback = args.pop();
      if (typeof callback != 'function') args.push(callback);
      options = args.length ? args.shift() || {} : {};
      if (typeof callback == 'function') return removeUser(self, username, options, callback);
      return new this.s.promiseLibrary(function (resolve, reject) {
        removeUser(self, username, options, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var authenticate = function (self, username, password, options, callback) {
      if (self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));
      var authdb = options.dbName ? options.dbName : self.databaseName;
      authdb = self.authSource ? self.authSource : authdb;
      authdb = options.authdb ? options.authdb : authdb;
      authdb = options.authSource ? options.authSource : authdb;
      var _callback = function (err, result) {
        if (self.listeners('authenticated').length > 0) {
          self.emit('authenticated', err, result);
        }
        handleCallback(callback, err, result);
      };
      var authMechanism = options.authMechanism || '';
      authMechanism = authMechanism.toUpperCase();
      if (authMechanism == 'MONGODB-CR') {
        self.s.topology.auth('mongocr', authdb, username, password, function (err) {
          if (err) return handleCallback(callback, err, false);
          _callback(null, true);
        });
      } else if (authMechanism == 'PLAIN') {
        self.s.topology.auth('plain', authdb, username, password, function (err) {
          if (err) return handleCallback(callback, err, false);
          _callback(null, true);
        });
      } else if (authMechanism == 'MONGODB-X509') {
        self.s.topology.auth('x509', authdb, username, password, function (err) {
          if (err) return handleCallback(callback, err, false);
          _callback(null, true);
        });
      } else if (authMechanism == 'SCRAM-SHA-1') {
        self.s.topology.auth('scram-sha-1', authdb, username, password, function (err) {
          if (err) return handleCallback(callback, err, false);
          _callback(null, true);
        });
      } else if (authMechanism == 'GSSAPI') {
        if (process.platform == 'win32') {
          self.s.topology.auth('sspi', authdb, username, password, options, function (err) {
            if (err) return handleCallback(callback, err, false);
            _callback(null, true);
          });
        } else {
          self.s.topology.auth('gssapi', authdb, username, password, options, function (err) {
            if (err) return handleCallback(callback, err, false);
            _callback(null, true);
          });
        }
      } else if (authMechanism == 'DEFAULT') {
        self.s.topology.auth('default', authdb, username, password, function (err) {
          if (err) return handleCallback(callback, err, false);
          _callback(null, true);
        });
      } else {
        handleCallback(callback, MongoError.create({
          message: f("authentication mechanism %s not supported", options.authMechanism),
          driver: true
        }));
      }
    };
    Db.prototype.authenticate = function (username, password, options, callback) {
      if (typeof options == 'function') callback = options, options = {};
      var self = this;
      options = shallowClone(options);
      if (!options.authMechanism) {
        options.authMechanism = 'DEFAULT';
      } else if (options.authMechanism != 'GSSAPI' && options.authMechanism != 'DEFAULT' && options.authMechanism != 'MONGODB-CR' && options.authMechanism != 'MONGODB-X509' && options.authMechanism != 'SCRAM-SHA-1' && options.authMechanism != 'PLAIN') {
        return handleCallback(callback, MongoError.create({
          message: "only DEFAULT, GSSAPI, PLAIN, MONGODB-X509, SCRAM-SHA-1 or MONGODB-CR is supported by authMechanism",
          driver: true
        }));
      }
      if (typeof callback == 'function') return authenticate(self, username, password, options, function (err, r) {
        if (err && err.message && err.message.indexOf('saslStart') != -1) err.code = 59;
        if (err) return callback(err, r);
        callback(null, r);
      });
      return new this.s.promiseLibrary(function (resolve, reject) {
        authenticate(self, username, password, options, function (err, r) {
          if (err && err.message && err.message.indexOf('saslStart') != -1) err.code = 59;
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    define.classMethod('authenticate', {
      callback: true,
      promise: true
    });
    Db.prototype.logout = function (options, callback) {
      var self = this;
      if (typeof options == 'function') callback = options, options = {};
      options = options || {};
      var dbName = this.s.authSource ? this.s.authSource : this.s.databaseName;
      dbName = options.dbName ? options.dbName : dbName;
      if (typeof callback == 'function') {
        return self.s.topology.logout(dbName, function (err) {
          if (err) return callback(err);
          callback(null, true);
        });
      }
      return new this.s.promiseLibrary(function (resolve, reject) {
        self.s.topology.logout(dbName, function (err) {
          if (err) return reject(err);
          resolve(true);
        });
      });
    };
    define.classMethod('logout', {
      callback: true,
      promise: true
    });
    Db.prototype.indexInformation = function (name, options, callback) {
      var self = this;
      if (typeof options == 'function') callback = options, options = {};
      options = options || {};
      if (typeof callback == 'function') return indexInformation(self, name, options, callback);
      return new this.s.promiseLibrary(function (resolve, reject) {
        indexInformation(self, name, options, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var indexInformation = function (self, name, options, callback) {
      var full = options['full'] == null ? false : options['full'];
      if (self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));
      var processResults = function (indexes) {
        var info = {};
        for (var i = 0; i < indexes.length; i++) {
          var index = indexes[i];
          info[index.name] = [];
          for (var name in index.key) {
            info[index.name].push([name, index.key[name]]);
          }
        }
        return info;
      };
      self.collection(name).listIndexes().toArray(function (err, indexes) {
        if (err) return callback(toError(err));
        if (!Array.isArray(indexes)) return handleCallback(callback, null, []);
        if (full) return handleCallback(callback, null, indexes);
        handleCallback(callback, null, processResults(indexes));
      });
    };
    define.classMethod('indexInformation', {
      callback: true,
      promise: true
    });
    var createCreateIndexCommand = function (db, name, fieldOrSpec, options) {
      var indexParameters = parseIndexOptions(fieldOrSpec);
      var fieldHash = indexParameters.fieldHash;
      var indexName = typeof options.name == 'string' ? options.name : indexParameters.name;
      var selector = {
        'ns': db.databaseName + "." + name,
        'key': fieldHash,
        'name': indexName
      };
      var finalUnique = options == null || 'object' === typeof options ? false : options;
      options = options == null || typeof options == 'boolean' ? {} : options;
      var keysToOmit = Object.keys(selector);
      for (var optionName in options) {
        if (keysToOmit.indexOf(optionName) == -1) {
          selector[optionName] = options[optionName];
        }
      }
      if (selector['unique'] == null) selector['unique'] = finalUnique;
      var removeKeys = ['w', 'wtimeout', 'j', 'fsync', 'readPreference'];
      for (var i = 0; i < removeKeys.length; i++) {
        delete selector[removeKeys[i]];
      }
      return selector;
    };
    var createIndexUsingCreateIndexes = function (self, name, fieldOrSpec, options, callback) {
      var indexParameters = parseIndexOptions(fieldOrSpec);
      var indexName = typeof options.name == 'string' ? options.name : indexParameters.name;
      var indexes = [{
        name: indexName,
        key: indexParameters.fieldHash
      }];
      var keysToOmit = Object.keys(indexes[0]);
      for (var optionName in options) {
        if (keysToOmit.indexOf(optionName) == -1) {
          indexes[0][optionName] = options[optionName];
        }
        var removeKeys = ['w', 'wtimeout', 'j', 'fsync', 'readPreference'];
        for (var i = 0; i < removeKeys.length; i++) {
          delete indexes[0][removeKeys[i]];
        }
      }
      var capabilities = self.s.topology.capabilities();
      if (indexes[0].collation && capabilities && !capabilities.commandsTakeCollation) {
        var error = new MongoError(f('server/primary/mongos does not support collation'));
        error.code = 67;
        return callback(error);
      }
      var cmd = writeConcern({
        createIndexes: name,
        indexes: indexes
      }, self, options);
      decorateWithWriteConcern(cmd, self, options);
      options.readPreference = ReadPreference.PRIMARY;
      self.command(cmd, options, function (err, result) {
        if (err) return handleCallback(callback, err, null);
        if (result.ok == 0) return handleCallback(callback, toError(result), null);
        handleCallback(callback, null, indexName);
      });
    };
    var validateDatabaseName = function (databaseName) {
      if (typeof databaseName !== 'string') throw MongoError.create({
        message: "database name must be a string",
        driver: true
      });
      if (databaseName.length === 0) throw MongoError.create({
        message: "database name cannot be the empty string",
        driver: true
      });
      if (databaseName == '$external') return;
      var invalidChars = [" ", ".", "$", "/", "\\"];
      for (var i = 0; i < invalidChars.length; i++) {
        if (databaseName.indexOf(invalidChars[i]) != -1) throw MongoError.create({
          message: "database names cannot contain the character '" + invalidChars[i] + "'",
          driver: true
        });
      }
    };
    var writeConcern = function (target, db, options) {
      if (options.w != null || options.j != null || options.fsync != null) {
        var opts = {};
        if (options.w) opts.w = options.w;
        if (options.wtimeout) opts.wtimeout = options.wtimeout;
        if (options.j) opts.j = options.j;
        if (options.fsync) opts.fsync = options.fsync;
        target.writeConcern = opts;
      } else if (db.writeConcern.w != null || db.writeConcern.j != null || db.writeConcern.fsync != null) {
        target.writeConcern = db.writeConcern;
      }
      return target;
    };
    var createListener = function (self, e, object) {
      var listener = function (err) {
        if (object.listeners(e).length > 0) {
          object.emit(e, err, self);
          for (var i = 0; i < self.s.children.length; i++) {
            self.s.children[i].emit(e, err, self.s.children[i]);
          }
        }
      };
      return listener;
    };
    Db.prototype.unref = function () {
      this.s.topology.unref();
    };
    Db.SYSTEM_NAMESPACE_COLLECTION = "system.namespaces";
    Db.SYSTEM_INDEX_COLLECTION = "system.indexes";
    Db.SYSTEM_PROFILE_COLLECTION = "system.profile";
    Db.SYSTEM_USER_COLLECTION = "system.users";
    Db.SYSTEM_COMMAND_COLLECTION = "$cmd";
    Db.SYSTEM_JS_COLLECTION = "system.js";
    module.exports = Db;
  })($__require('2a').Buffer, $__require('13'));
  return module.exports;
});
$__System.registerDynamic('18c', ['55', '166', '18a', '184', '17f', '180', '188', '18f', '192', '18d', '18e', '193', '2a', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  var __filename = 'jspm_packages/npm/mongodb@2.2.12/lib/replset.js',
      __dirname = 'jspm_packages/npm/mongodb@2.2.12/lib';
  /* */
  (function (Buffer, process) {
    "use strict";

    var EventEmitter = $__require('55').EventEmitter,
        inherits = $__require('166').inherits,
        f = $__require('166').format,
        Server = $__require('18a'),
        Cursor = $__require('184'),
        AggregationCursor = $__require('17f'),
        CommandCursor = $__require('180'),
        ReadPreference = $__require('188'),
        MongoError = $__require('18f').MongoError,
        ServerCapabilities = $__require('192').ServerCapabilities,
        Store = $__require('192').Store,
        Define = $__require('18d'),
        CReplSet = $__require('18f').ReplSet,
        CoreReadPreference = $__require('18f').ReadPreference,
        MAX_JS_INT = $__require('18e').MAX_JS_INT,
        translateOptions = $__require('18e').translateOptions,
        filterOptions = $__require('18e').filterOptions,
        mergeOptions = $__require('18e').mergeOptions,
        os = $__require('193');
    var legalOptionNames = ['ha', 'haInterval', 'replicaSet', 'rs_name', 'secondaryAcceptableLatencyMS', 'connectWithNoPrimary', 'poolSize', 'ssl', 'checkServerIdentity', 'sslValidate', 'sslCA', 'sslCert', 'sslKey', 'sslPass', 'socketOptions', 'bufferMaxEntries', 'store', 'auto_reconnect', 'autoReconnect', 'emitError', 'keepAlive', 'noDelay', 'connectTimeoutMS', 'socketTimeoutMS', 'strategy', 'debug', 'loggerLevel', 'logger', 'reconnectTries', 'appname', 'domainsEnabled', 'servername', 'promoteLongs', 'promoteValues', 'promoteBuffers'];
    var driverVersion = $__require(__dirname + '/../package.json').version;
    var nodejsversion = f('Node.js %s, %s', process.version, os.endianness());
    var type = os.type();
    var name = process.platform;
    var architecture = process.arch;
    var release = os.release();
    var ReplSet = function (servers, options) {
      if (!(this instanceof ReplSet)) return new ReplSet(servers, options);
      options = options || {};
      var self = this;
      EventEmitter.call(this);
      options = filterOptions(options, legalOptionNames);
      for (var i = 0; i < servers.length; i++) {
        if (!(servers[i] instanceof Server)) {
          throw MongoError.create({
            message: "all seed list instances must be of the Server type",
            driver: true
          });
        }
      }
      var storeOptions = {
        force: false,
        bufferMaxEntries: typeof options.bufferMaxEntries == 'number' ? options.bufferMaxEntries : MAX_JS_INT
      };
      var store = options.store || new Store(self, storeOptions);
      var seedlist = servers.map(function (x) {
        return {
          host: x.host,
          port: x.port
        };
      });
      var clonedOptions = mergeOptions({}, {
        disconnectHandler: store,
        cursorFactory: Cursor,
        reconnect: false,
        emitError: typeof options.emitError == 'boolean' ? options.emitError : true,
        size: typeof options.poolSize == 'number' ? options.poolSize : 5
      });
      clonedOptions = translateOptions(clonedOptions, options);
      var socketOptions = options.socketOptions && Object.keys(options.socketOptions).length > 0 ? options.socketOptions : options;
      clonedOptions = translateOptions(clonedOptions, socketOptions);
      if (typeof clonedOptions.keepAlive == 'number') {
        clonedOptions.keepAliveInitialDelay = clonedOptions.keepAlive;
        clonedOptions.keepAlive = clonedOptions.keepAlive > 0;
      }
      this.clientInfo = {
        driver: {
          name: "nodejs",
          version: driverVersion
        },
        os: {
          type: type,
          name: name,
          architecture: architecture,
          version: release
        },
        platform: nodejsversion
      };
      clonedOptions.clientInfo = this.clientInfo;
      if (options.appname) {
        clonedOptions.clientInfo.application = { name: options.appname };
      }
      var replset = new CReplSet(seedlist, clonedOptions);
      replset.on('reconnect', function () {
        self.emit('reconnect');
        store.execute();
      });
      this.s = {
        replset: replset,
        sCapabilities: null,
        tag: options.tag,
        storeOptions: storeOptions,
        clonedOptions: clonedOptions,
        store: store,
        options: options
      };
      if (clonedOptions.debug) {
        Object.defineProperty(this, 'replset', {
          enumerable: true,
          get: function () {
            return replset;
          }
        });
      }
    };
    inherits(ReplSet, EventEmitter);
    Object.defineProperty(ReplSet.prototype, 'isMasterDoc', {
      enumerable: true,
      get: function () {
        return this.s.replset.lastIsMaster();
      }
    });
    Object.defineProperty(ReplSet.prototype, 'bson', {
      enumerable: true,
      get: function () {
        return this.s.replset.s.bson;
      }
    });
    Object.defineProperty(ReplSet.prototype, 'haInterval', {
      enumerable: true,
      get: function () {
        return this.s.replset.s.haInterval;
      }
    });
    var define = ReplSet.define = new Define('ReplSet', ReplSet, false);
    var translateReadPreference = function (options) {
      if (typeof options.readPreference == 'string') {
        options.readPreference = new CoreReadPreference(options.readPreference);
      } else if (options.readPreference instanceof ReadPreference) {
        options.readPreference = new CoreReadPreference(options.readPreference.mode, options.readPreference.tags, { maxStalenessSeconds: options.readPreference.maxStalenessSeconds });
      }
      return options;
    };
    ReplSet.prototype.connect = function (db, _options, callback) {
      var self = this;
      if ('function' === typeof _options) callback = _options, _options = {};
      if (_options == null) _options = {};
      if (!('function' === typeof callback)) callback = null;
      self.s.options = _options;
      self.s.storeOptions.bufferMaxEntries = db.bufferMaxEntries;
      var errorHandler = function (event) {
        return function (err) {
          if (event != 'error') {
            self.emit(event, err);
          }
        };
      };
      var connectHandler = function () {
        ["timeout", "error", "close", 'serverOpening', 'serverDescriptionChanged', 'serverHeartbeatStarted', 'serverHeartbeatSucceeded', 'serverHeartbeatFailed', 'serverClosed', 'topologyOpening', 'topologyClosed', 'topologyDescriptionChanged'].forEach(function (e) {
          self.s.replset.removeAllListeners(e);
        });
        self.s.replset.once('timeout', errorHandler('timeout'));
        self.s.replset.once('error', errorHandler('error'));
        self.s.replset.once('close', errorHandler('close'));
        var relay = function (event) {
          return function (t, server) {
            self.emit(event, t, server);
          };
        };
        var replsetRelay = function (event) {
          return function (t, server) {
            self.emit(event, t, server.lastIsMaster(), server);
          };
        };
        var relayHa = function (t, state) {
          self.emit('ha', t, state);
          if (t == 'start') {
            self.emit('ha_connect', t, state);
          } else if (t == 'end') {
            self.emit('ha_ismaster', t, state);
          }
        };
        self.s.replset.on('joined', replsetRelay('joined'));
        self.s.replset.on('left', relay('left'));
        self.s.replset.on('ping', relay('ping'));
        self.s.replset.on('ha', relayHa);
        self.s.replset.on('serverDescriptionChanged', relay('serverDescriptionChanged'));
        self.s.replset.on('serverHeartbeatStarted', relay('serverHeartbeatStarted'));
        self.s.replset.on('serverHeartbeatSucceeded', relay('serverHeartbeatSucceeded'));
        self.s.replset.on('serverHeartbeatFailed', relay('serverHeartbeatFailed'));
        self.s.replset.on('serverOpening', relay('serverOpening'));
        self.s.replset.on('serverClosed', relay('serverClosed'));
        self.s.replset.on('topologyOpening', relay('topologyOpening'));
        self.s.replset.on('topologyClosed', relay('topologyClosed'));
        self.s.replset.on('topologyDescriptionChanged', relay('topologyDescriptionChanged'));
        self.s.replset.on('fullsetup', function () {
          self.emit('fullsetup', null, self);
        });
        self.s.replset.on('all', function () {
          self.emit('all', null, self);
        });
        self.emit('open', null, self);
        try {
          callback(null, self);
        } catch (err) {
          process.nextTick(function () {
            throw err;
          });
        }
      };
      var connectErrorHandler = function () {
        return function (err) {
          ['timeout', 'error', 'close'].forEach(function (e) {
            self.s.replset.removeListener(e, connectErrorHandler);
          });
          self.s.replset.removeListener('connect', connectErrorHandler);
          self.s.replset.destroy();
          try {
            callback(err);
          } catch (err) {
            if (!self.s.replset.isConnected()) process.nextTick(function () {
              throw err;
            });
          }
        };
      };
      self.s.replset.once('timeout', connectErrorHandler('timeout'));
      self.s.replset.once('error', connectErrorHandler('error'));
      self.s.replset.once('close', connectErrorHandler('close'));
      self.s.replset.once('connect', connectHandler);
      self.s.replset.connect(_options);
    };
    ReplSet.prototype.capabilities = function () {
      if (this.s.sCapabilities) return this.s.sCapabilities;
      if (this.s.replset.lastIsMaster() == null) return null;
      this.s.sCapabilities = new ServerCapabilities(this.s.replset.lastIsMaster());
      return this.s.sCapabilities;
    };
    define.classMethod('capabilities', {
      callback: false,
      promise: false,
      returns: [ServerCapabilities]
    });
    ReplSet.prototype.command = function (ns, cmd, options, callback) {
      options = translateReadPreference(options);
      this.s.replset.command(ns, cmd, options, callback);
    };
    define.classMethod('command', {
      callback: true,
      promise: false
    });
    ReplSet.prototype.insert = function (ns, ops, options, callback) {
      this.s.replset.insert(ns, ops, options, callback);
    };
    define.classMethod('insert', {
      callback: true,
      promise: false
    });
    ReplSet.prototype.update = function (ns, ops, options, callback) {
      this.s.replset.update(ns, ops, options, callback);
    };
    define.classMethod('update', {
      callback: true,
      promise: false
    });
    ReplSet.prototype.remove = function (ns, ops, options, callback) {
      this.s.replset.remove(ns, ops, options, callback);
    };
    define.classMethod('remove', {
      callback: true,
      promise: false
    });
    ReplSet.prototype.isDestroyed = function () {
      return this.s.replset.isDestroyed();
    };
    ReplSet.prototype.isConnected = function () {
      return this.s.replset.isConnected();
    };
    define.classMethod('isConnected', {
      callback: false,
      promise: false,
      returns: [Boolean]
    });
    ReplSet.prototype.cursor = function (ns, cmd, options) {
      options = translateReadPreference(options);
      options.disconnectHandler = this.s.store;
      return this.s.replset.cursor(ns, cmd, options);
    };
    define.classMethod('cursor', {
      callback: false,
      promise: false,
      returns: [Cursor, AggregationCursor, CommandCursor]
    });
    ReplSet.prototype.lastIsMaster = function () {
      return this.s.replset.lastIsMaster();
    };
    ReplSet.prototype.close = function (forceClosed) {
      var self = this;
      this.s.replset.destroy();
      if (forceClosed == true) {
        this.s.storeOptions.force = forceClosed;
        this.s.store.flush();
      }
      var events = ['timeout', 'error', 'close', 'joined', 'left'];
      events.forEach(function (e) {
        self.removeAllListeners(e);
      });
    };
    define.classMethod('close', {
      callback: false,
      promise: false
    });
    ReplSet.prototype.auth = function () {
      var args = Array.prototype.slice.call(arguments, 0);
      this.s.replset.auth.apply(this.s.replset, args);
    };
    define.classMethod('auth', {
      callback: true,
      promise: false
    });
    ReplSet.prototype.logout = function () {
      var args = Array.prototype.slice.call(arguments, 0);
      this.s.replset.logout.apply(this.s.replset, args);
    };
    define.classMethod('logout', {
      callback: true,
      promise: false
    });
    ReplSet.prototype.connections = function () {
      return this.s.replset.connections();
    };
    define.classMethod('connections', {
      callback: false,
      promise: false,
      returns: [Array]
    });
    module.exports = ReplSet;
  })($__require('2a').Buffer, $__require('13'));
  return module.exports;
});
$__System.registerDynamic('192', ['18f', '166'], true, function ($__require, exports, module) {
  /* */
  "use strict";

  var define,
      global = this || self,
      GLOBAL = global;
  var MongoError = $__require('18f').MongoError,
      f = $__require('166').format;

  // The store of ops
  var Store = function (topology, storeOptions) {
    var self = this;
    var storedOps = [];
    storeOptions = storeOptions || { force: false, bufferMaxEntries: -1 };

    // Internal state
    this.s = {
      storedOps: storedOps,
      storeOptions: storeOptions,
      topology: topology
    };

    Object.defineProperty(this, 'length', {
      enumerable: true, get: function () {
        return self.s.storedOps.length;
      }
    });
  };

  Store.prototype.add = function (opType, ns, ops, options, callback) {
    if (this.s.storeOptions.force) {
      return callback(MongoError.create({ message: "db closed by application", driver: true }));
    }

    if (this.s.storeOptions.bufferMaxEntries == 0) {
      return callback(MongoError.create({ message: f("no connection available for operation and number of stored operation > %s", this.s.storeOptions.bufferMaxEntries), driver: true }));
    }

    if (this.s.storeOptions.bufferMaxEntries > 0 && this.s.storedOps.length > this.s.storeOptions.bufferMaxEntries) {
      while (this.s.storedOps.length > 0) {
        var op = this.s.storedOps.shift();
        op.c(MongoError.create({ message: f("no connection available for operation and number of stored operation > %s", this.s.storeOptions.bufferMaxEntries), driver: true }));
      }

      return;
    }

    this.s.storedOps.push({ t: opType, n: ns, o: ops, op: options, c: callback });
  };

  Store.prototype.addObjectAndMethod = function (opType, object, method, params, callback) {
    if (this.s.storeOptions.force) {
      return callback(MongoError.create({ message: "db closed by application", driver: true }));
    }

    if (this.s.storeOptions.bufferMaxEntries == 0) {
      return callback(MongoError.create({ message: f("no connection available for operation and number of stored operation > %s", this.s.storeOptions.bufferMaxEntries), driver: true }));
    }

    if (this.s.storeOptions.bufferMaxEntries > 0 && this.s.storedOps.length > this.s.storeOptions.bufferMaxEntries) {
      while (this.s.storedOps.length > 0) {
        var op = this.s.storedOps.shift();
        op.c(MongoError.create({ message: f("no connection available for operation and number of stored operation > %s", this.s.storeOptions.bufferMaxEntries), driver: true }));
      }

      return;
    }

    this.s.storedOps.push({ t: opType, m: method, o: object, p: params, c: callback });
  };

  Store.prototype.flush = function (err) {
    while (this.s.storedOps.length > 0) {
      this.s.storedOps.shift().c(err || MongoError.create({ message: f("no connection available for operation"), driver: true }));
    }
  };

  var primaryOptions = ['primary', 'primaryPreferred', 'nearest', 'secondaryPreferred'];
  var secondaryOptions = ['secondary', 'secondaryPreferred'];

  Store.prototype.execute = function (options) {
    options = options || {};
    // Get current ops
    var ops = this.s.storedOps;
    // Reset the ops
    this.s.storedOps = [];

    // Unpack options
    var executePrimary = typeof options.executePrimary === 'boolean' ? options.executePrimary : true;
    var executeSecondary = typeof options.executeSecondary === 'boolean' ? options.executeSecondary : true;

    // Execute all the stored ops
    while (ops.length > 0) {
      var op = ops.shift();

      if (op.t == 'cursor') {
        if (executePrimary && executeSecondary) {
          op.o[op.m].apply(op.o, op.p);
        } else if (executePrimary && op.o.options && op.o.options.readPreference && primaryOptions.indexOf(op.o.options.readPreference.mode) != -1) {
          op.o[op.m].apply(op.o, op.p);
        } else if (!executePrimary && executeSecondary && op.o.options && op.o.options.readPreference && secondaryOptions.indexOf(op.o.options.readPreference.mode) != -1) {
          op.o[op.m].apply(op.o, op.p);
        }
      } else if (op.t == 'auth') {
        this.s.topology[op.t].apply(this.s.topology, op.o);
      } else {
        if (executePrimary && executeSecondary) {
          this.s.topology[op.t](op.n, op.o, op.op, op.c);
        } else if (executePrimary && op.op && op.op.readPreference && primaryOptions.indexOf(op.op.readPreference.mode) != -1) {
          this.s.topology[op.t](op.n, op.o, op.op, op.c);
        } else if (!executePrimary && executeSecondary && op.op && op.op.readPreference && secondaryOptions.indexOf(op.op.readPreference.mode) != -1) {
          this.s.topology[op.t](op.n, op.o, op.op, op.c);
        }
      }
    }
  };

  Store.prototype.all = function () {
    return this.s.storedOps;
  };

  // Server capabilities
  var ServerCapabilities = function (ismaster) {
    var setup_get_property = function (object, name, value) {
      Object.defineProperty(object, name, {
        enumerable: true,
        get: function () {
          return value;
        }
      });
    };

    // Capabilities
    var aggregationCursor = false;
    var writeCommands = false;
    var textSearch = false;
    var authCommands = false;
    var listCollections = false;
    var listIndexes = false;
    var maxNumberOfDocsInBatch = ismaster.maxWriteBatchSize || 1000;
    var commandsTakeWriteConcern = false;
    var commandsTakeCollation = false;

    if (ismaster.minWireVersion >= 0) {
      textSearch = true;
    }

    if (ismaster.maxWireVersion >= 1) {
      aggregationCursor = true;
      authCommands = true;
    }

    if (ismaster.maxWireVersion >= 2) {
      writeCommands = true;
    }

    if (ismaster.maxWireVersion >= 3) {
      listCollections = true;
      listIndexes = true;
    }

    if (ismaster.maxWireVersion >= 5) {
      commandsTakeWriteConcern = true;
      commandsTakeCollation = true;
    }

    // If no min or max wire version set to 0
    if (ismaster.minWireVersion == null) {
      ismaster.minWireVersion = 0;
    }

    if (ismaster.maxWireVersion == null) {
      ismaster.maxWireVersion = 0;
    }

    // Map up read only parameters
    setup_get_property(this, "hasAggregationCursor", aggregationCursor);
    setup_get_property(this, "hasWriteCommands", writeCommands);
    setup_get_property(this, "hasTextSearch", textSearch);
    setup_get_property(this, "hasAuthCommands", authCommands);
    setup_get_property(this, "hasListCollectionsCommand", listCollections);
    setup_get_property(this, "hasListIndexesCommand", listIndexes);
    setup_get_property(this, "minWireVersion", ismaster.minWireVersion);
    setup_get_property(this, "maxWireVersion", ismaster.maxWireVersion);
    setup_get_property(this, "maxNumberOfDocsInBatch", maxNumberOfDocsInBatch);
    setup_get_property(this, "commandsTakeWriteConcern", commandsTakeWriteConcern);
    setup_get_property(this, "commandsTakeCollation", commandsTakeCollation);
  };

  exports.Store = Store;
  exports.ServerCapabilities = ServerCapabilities;
  return module.exports;
});
$__System.registerDynamic('18a', ['55', '166', '18f', '184', '17f', '180', '192', '18d', '18e', '193', '2a', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  var __filename = 'jspm_packages/npm/mongodb@2.2.12/lib/server.js',
      __dirname = 'jspm_packages/npm/mongodb@2.2.12/lib';
  /* */
  (function (Buffer, process) {
    "use strict";

    var EventEmitter = $__require('55').EventEmitter,
        inherits = $__require('166').inherits,
        CServer = $__require('18f').Server,
        Cursor = $__require('184'),
        AggregationCursor = $__require('17f'),
        CommandCursor = $__require('180'),
        f = $__require('166').format,
        ServerCapabilities = $__require('192').ServerCapabilities,
        Store = $__require('192').Store,
        Define = $__require('18d'),
        MongoError = $__require('18f').MongoError,
        MAX_JS_INT = $__require('18e').MAX_JS_INT,
        translateOptions = $__require('18e').translateOptions,
        filterOptions = $__require('18e').filterOptions,
        mergeOptions = $__require('18e').mergeOptions,
        os = $__require('193');
    var driverVersion = $__require(__dirname + '/../package.json').version;
    var nodejsversion = f('Node.js %s, %s', process.version, os.endianness());
    var type = os.type();
    var name = process.platform;
    var architecture = process.arch;
    var release = os.release();
    var legalOptionNames = ['ha', 'haInterval', 'acceptableLatencyMS', 'poolSize', 'ssl', 'checkServerIdentity', 'sslValidate', 'sslCA', 'sslCert', 'sslKey', 'sslPass', 'socketOptions', 'bufferMaxEntries', 'store', 'auto_reconnect', 'autoReconnect', 'emitError', 'keepAlive', 'noDelay', 'connectTimeoutMS', 'socketTimeoutMS', 'loggerLevel', 'logger', 'reconnectTries', 'reconnectInterval', 'monitoring', 'appname', 'domainsEnabled', 'servername', 'promoteLongs', 'promoteValues', 'promoteBuffers'];
    var Server = function (host, port, options) {
      options = options || {};
      if (!(this instanceof Server)) return new Server(host, port, options);
      EventEmitter.call(this);
      var self = this;
      options = filterOptions(options, legalOptionNames);
      var storeOptions = {
        force: false,
        bufferMaxEntries: typeof options.bufferMaxEntries == 'number' ? options.bufferMaxEntries : MAX_JS_INT
      };
      var store = options.store || new Store(self, storeOptions);
      if (host.indexOf('\/') != -1) {
        if (port != null && typeof port == 'object') {
          options = port;
          port = null;
        }
      } else if (port == null) {
        throw MongoError.create({
          message: 'port must be specified',
          driver: true
        });
      }
      var reconnect = typeof options.auto_reconnect == 'boolean' ? options.auto_reconnect : true;
      reconnect = typeof options.autoReconnect == 'boolean' ? options.autoReconnect : reconnect;
      var clonedOptions = mergeOptions({}, {
        host: host,
        port: port,
        disconnectHandler: store,
        cursorFactory: Cursor,
        reconnect: reconnect,
        emitError: typeof options.emitError == 'boolean' ? options.emitError : true,
        size: typeof options.poolSize == 'number' ? options.poolSize : 5
      });
      clonedOptions = translateOptions(clonedOptions, options);
      var socketOptions = options.socketOptions && Object.keys(options.socketOptions).length > 0 ? options.socketOptions : options;
      clonedOptions = translateOptions(clonedOptions, socketOptions);
      if (typeof clonedOptions.keepAlive == 'number') {
        clonedOptions.keepAliveInitialDelay = clonedOptions.keepAlive;
        clonedOptions.keepAlive = clonedOptions.keepAlive > 0;
      }
      this.clientInfo = {
        driver: {
          name: "nodejs",
          version: driverVersion
        },
        os: {
          type: type,
          name: name,
          architecture: architecture,
          version: release
        },
        platform: nodejsversion
      };
      clonedOptions.clientInfo = this.clientInfo;
      if (options.appname) {
        clonedOptions.clientInfo.application = { name: options.appname };
      }
      var server = new CServer(clonedOptions);
      this.s = {
        server: server,
        sCapabilities: null,
        clonedOptions: clonedOptions,
        reconnect: clonedOptions.reconnect,
        emitError: clonedOptions.emitError,
        poolSize: clonedOptions.size,
        storeOptions: storeOptions,
        store: store,
        host: host,
        port: port,
        options: options
      };
    };
    inherits(Server, EventEmitter);
    var define = Server.define = new Define('Server', Server, false);
    Object.defineProperty(Server.prototype, 'bson', {
      enumerable: true,
      get: function () {
        return this.s.server.s.bson;
      }
    });
    Object.defineProperty(Server.prototype, 'isMasterDoc', {
      enumerable: true,
      get: function () {
        return this.s.server.lastIsMaster();
      }
    });
    Object.defineProperty(Server.prototype, 'poolSize', {
      enumerable: true,
      get: function () {
        return this.s.server.connections().length;
      }
    });
    Object.defineProperty(Server.prototype, 'autoReconnect', {
      enumerable: true,
      get: function () {
        return this.s.reconnect;
      }
    });
    Object.defineProperty(Server.prototype, 'host', {
      enumerable: true,
      get: function () {
        return this.s.host;
      }
    });
    Object.defineProperty(Server.prototype, 'port', {
      enumerable: true,
      get: function () {
        return this.s.port;
      }
    });
    Server.prototype.connect = function (db, _options, callback) {
      var self = this;
      if ('function' === typeof _options) callback = _options, _options = {};
      if (_options == null) _options = {};
      if (!('function' === typeof callback)) callback = null;
      self.s.options = _options;
      self.s.storeOptions.bufferMaxEntries = db.bufferMaxEntries;
      var connectErrorHandler = function () {
        return function (err) {
          var events = ['timeout', 'error', 'close'];
          events.forEach(function (e) {
            self.s.server.removeListener(e, connectHandlers[e]);
          });
          self.s.server.removeListener('connect', connectErrorHandler);
          try {
            callback(err);
          } catch (err) {
            process.nextTick(function () {
              throw err;
            });
          }
        };
      };
      var errorHandler = function (event) {
        return function (err) {
          if (event != 'error') {
            self.emit(event, err);
          }
        };
      };
      var reconnectHandler = function () {
        self.emit('reconnect', self);
        self.s.store.execute();
      };
      var reconnectFailedHandler = function (err) {
        self.emit('reconnectFailed', err);
        self.s.store.flush(err);
      };
      var destroyHandler = function () {
        self.s.store.flush();
      };
      var connectHandler = function () {
        ["timeout", "error", "close", 'serverOpening', 'serverDescriptionChanged', 'serverHeartbeatStarted', 'serverHeartbeatSucceeded', 'serverHeartbeatFailed', 'serverClosed', 'topologyOpening', 'topologyClosed', 'topologyDescriptionChanged'].forEach(function (e) {
          self.s.server.removeAllListeners(e);
        });
        self.s.server.on('timeout', errorHandler('timeout'));
        self.s.server.once('error', errorHandler('error'));
        self.s.server.on('close', errorHandler('close'));
        self.s.server.on('destroy', destroyHandler);
        var relay = function (event) {
          return function (t, server) {
            self.emit(event, t, server);
          };
        };
        self.s.server.on('serverDescriptionChanged', relay('serverDescriptionChanged'));
        self.s.server.on('serverHeartbeatStarted', relay('serverHeartbeatStarted'));
        self.s.server.on('serverHeartbeatSucceeded', relay('serverHeartbeatSucceeded'));
        self.s.server.on('serverHeartbeatFailed', relay('serverHeartbeatFailed'));
        self.s.server.on('serverOpening', relay('serverOpening'));
        self.s.server.on('serverClosed', relay('serverClosed'));
        self.s.server.on('topologyOpening', relay('topologyOpening'));
        self.s.server.on('topologyClosed', relay('topologyClosed'));
        self.s.server.on('topologyDescriptionChanged', relay('topologyDescriptionChanged'));
        self.s.server.on('attemptReconnect', relay('attemptReconnect'));
        self.s.server.on('monitoring', relay('monitoring'));
        self.emit('open', null, self);
        try {
          callback(null, self);
        } catch (err) {
          console.log(err.stack);
          process.nextTick(function () {
            throw err;
          });
        }
      };
      var connectHandlers = {
        timeout: connectErrorHandler('timeout'),
        error: connectErrorHandler('error'),
        close: connectErrorHandler('close')
      };
      self.s.server.once('timeout', connectHandlers.timeout);
      self.s.server.once('error', connectHandlers.error);
      self.s.server.once('close', connectHandlers.close);
      self.s.server.once('connect', connectHandler);
      self.s.server.on('reconnect', reconnectHandler);
      self.s.server.on('reconnectFailed', reconnectFailedHandler);
      self.s.server.connect(_options);
    };
    Server.prototype.capabilities = function () {
      if (this.s.sCapabilities) return this.s.sCapabilities;
      if (this.s.server.lastIsMaster() == null) return null;
      this.s.sCapabilities = new ServerCapabilities(this.s.server.lastIsMaster());
      return this.s.sCapabilities;
    };
    define.classMethod('capabilities', {
      callback: false,
      promise: false,
      returns: [ServerCapabilities]
    });
    Server.prototype.command = function (ns, cmd, options, callback) {
      this.s.server.command(ns, cmd, options, callback);
    };
    define.classMethod('command', {
      callback: true,
      promise: false
    });
    Server.prototype.insert = function (ns, ops, options, callback) {
      this.s.server.insert(ns, ops, options, callback);
    };
    define.classMethod('insert', {
      callback: true,
      promise: false
    });
    Server.prototype.update = function (ns, ops, options, callback) {
      this.s.server.update(ns, ops, options, callback);
    };
    define.classMethod('update', {
      callback: true,
      promise: false
    });
    Server.prototype.remove = function (ns, ops, options, callback) {
      this.s.server.remove(ns, ops, options, callback);
    };
    define.classMethod('remove', {
      callback: true,
      promise: false
    });
    Server.prototype.isConnected = function () {
      return this.s.server.isConnected();
    };
    Server.prototype.isDestroyed = function () {
      return this.s.server.isDestroyed();
    };
    define.classMethod('isConnected', {
      callback: false,
      promise: false,
      returns: [Boolean]
    });
    Server.prototype.cursor = function (ns, cmd, options) {
      options.disconnectHandler = this.s.store;
      return this.s.server.cursor(ns, cmd, options);
    };
    define.classMethod('cursor', {
      callback: false,
      promise: false,
      returns: [Cursor, AggregationCursor, CommandCursor]
    });
    Server.prototype.lastIsMaster = function () {
      return this.s.server.lastIsMaster();
    };
    Server.prototype.unref = function () {
      this.s.server.unref();
    };
    Server.prototype.close = function (forceClosed) {
      this.s.server.destroy();
      if (forceClosed == true) {
        this.s.storeOptions.force = forceClosed;
        this.s.store.flush();
      }
    };
    define.classMethod('close', {
      callback: false,
      promise: false
    });
    Server.prototype.auth = function () {
      var args = Array.prototype.slice.call(arguments, 0);
      this.s.server.auth.apply(this.s.server, args);
    };
    define.classMethod('auth', {
      callback: true,
      promise: false
    });
    Server.prototype.logout = function () {
      var args = Array.prototype.slice.call(arguments, 0);
      this.s.server.logout.apply(this.s.server, args);
    };
    define.classMethod('logout', {
      callback: true,
      promise: false
    });
    Server.prototype.connections = function () {
      return this.s.server.connections();
    };
    define.classMethod('connections', {
      callback: false,
      promise: false,
      returns: [Array]
    });
    module.exports = Server;
  })($__require('2a').Buffer, $__require('13'));
  return module.exports;
});
$__System.registerDynamic('18b', ['55', '166', '192', '18f', '184', '17f', '180', '18d', '18a', '18e', '193', '2a', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  var __filename = 'jspm_packages/npm/mongodb@2.2.12/lib/mongos.js',
      __dirname = 'jspm_packages/npm/mongodb@2.2.12/lib';
  /* */
  (function (Buffer, process) {
    "use strict";

    var EventEmitter = $__require('55').EventEmitter,
        inherits = $__require('166').inherits,
        f = $__require('166').format,
        ServerCapabilities = $__require('192').ServerCapabilities,
        MongoError = $__require('18f').MongoError,
        CMongos = $__require('18f').Mongos,
        Cursor = $__require('184'),
        AggregationCursor = $__require('17f'),
        CommandCursor = $__require('180'),
        Define = $__require('18d'),
        Server = $__require('18a'),
        Store = $__require('192').Store,
        MAX_JS_INT = $__require('18e').MAX_JS_INT,
        translateOptions = $__require('18e').translateOptions,
        filterOptions = $__require('18e').filterOptions,
        mergeOptions = $__require('18e').mergeOptions,
        os = $__require('193');
    var driverVersion = $__require(__dirname + '/../package.json').version;
    var nodejsversion = f('Node.js %s, %s', process.version, os.endianness());
    var type = os.type();
    var name = process.platform;
    var architecture = process.arch;
    var release = os.release();
    var legalOptionNames = ['ha', 'haInterval', 'acceptableLatencyMS', 'poolSize', 'ssl', 'checkServerIdentity', 'sslValidate', 'sslCA', 'sslCert', 'sslKey', 'sslPass', 'socketOptions', 'bufferMaxEntries', 'store', 'auto_reconnect', 'autoReconnect', 'emitError', 'keepAlive', 'noDelay', 'connectTimeoutMS', 'socketTimeoutMS', 'loggerLevel', 'logger', 'reconnectTries', 'appname', 'domainsEnabled', 'servername', 'promoteLongs', 'promoteValues', 'promoteBuffers'];
    var Mongos = function (servers, options) {
      if (!(this instanceof Mongos)) return new Mongos(servers, options);
      options = options || {};
      var self = this;
      options = filterOptions(options, legalOptionNames);
      for (var i = 0; i < servers.length; i++) {
        if (!(servers[i] instanceof Server)) {
          throw MongoError.create({
            message: "all seed list instances must be of the Server type",
            driver: true
          });
        }
      }
      var storeOptions = {
        force: false,
        bufferMaxEntries: typeof options.bufferMaxEntries == 'number' ? options.bufferMaxEntries : MAX_JS_INT
      };
      var store = options.store || new Store(self, storeOptions);
      EventEmitter.call(this);
      var seedlist = servers.map(function (x) {
        return {
          host: x.host,
          port: x.port
        };
      });
      var reconnect = typeof options.auto_reconnect == 'boolean' ? options.auto_reconnect : true;
      reconnect = typeof options.autoReconnect == 'boolean' ? options.autoReconnect : reconnect;
      var clonedOptions = mergeOptions({}, {
        disconnectHandler: store,
        cursorFactory: Cursor,
        reconnect: reconnect,
        emitError: typeof options.emitError == 'boolean' ? options.emitError : true,
        size: typeof options.poolSize == 'number' ? options.poolSize : 5
      });
      clonedOptions = translateOptions(clonedOptions, options);
      var socketOptions = options.socketOptions && Object.keys(options.socketOptions).length > 0 ? options.socketOptions : options;
      clonedOptions = translateOptions(clonedOptions, socketOptions);
      if (typeof clonedOptions.keepAlive == 'number') {
        clonedOptions.keepAliveInitialDelay = clonedOptions.keepAlive;
        clonedOptions.keepAlive = clonedOptions.keepAlive > 0;
      }
      this.clientInfo = {
        driver: {
          name: "nodejs",
          version: driverVersion
        },
        os: {
          type: type,
          name: name,
          architecture: architecture,
          version: release
        },
        platform: nodejsversion
      };
      clonedOptions.clientInfo = this.clientInfo;
      if (options.appname) {
        clonedOptions.clientInfo.application = { name: options.appname };
      }
      var mongos = new CMongos(seedlist, clonedOptions);
      var sCapabilities = null;
      this.s = {
        mongos: mongos,
        sCapabilities: sCapabilities,
        debug: clonedOptions.debug,
        storeOptions: storeOptions,
        clonedOptions: clonedOptions,
        store: store,
        options: options
      };
    };
    var define = Mongos.define = new Define('Mongos', Mongos, false);
    inherits(Mongos, EventEmitter);
    Object.defineProperty(Mongos.prototype, 'isMasterDoc', {
      enumerable: true,
      get: function () {
        return this.s.mongos.lastIsMaster();
      }
    });
    Object.defineProperty(Mongos.prototype, 'bson', {
      enumerable: true,
      get: function () {
        return this.s.mongos.s.bson;
      }
    });
    Object.defineProperty(Mongos.prototype, 'haInterval', {
      enumerable: true,
      get: function () {
        return this.s.mongos.s.haInterval;
      }
    });
    Mongos.prototype.connect = function (db, _options, callback) {
      var self = this;
      if ('function' === typeof _options) callback = _options, _options = {};
      if (_options == null) _options = {};
      if (!('function' === typeof callback)) callback = null;
      self.s.options = _options;
      self.s.storeOptions.bufferMaxEntries = db.bufferMaxEntries;
      var connectErrorHandler = function () {
        return function (err) {
          var events = ['timeout', 'error', 'close'];
          events.forEach(function (e) {
            self.removeListener(e, connectErrorHandler);
          });
          self.s.mongos.removeListener('connect', connectErrorHandler);
          try {
            callback(err);
          } catch (err) {
            process.nextTick(function () {
              throw err;
            });
          }
        };
      };
      var errorHandler = function (event) {
        return function (err) {
          if (event != 'error') {
            self.emit(event, err);
          }
        };
      };
      var reconnectHandler = function () {
        self.emit('reconnect');
        self.s.store.execute();
      };
      var relay = function (event) {
        return function (t, server) {
          self.emit(event, t, server);
        };
      };
      var connectHandler = function () {
        ["timeout", "error", "close", 'serverOpening', 'serverDescriptionChanged', 'serverHeartbeatStarted', 'serverHeartbeatSucceeded', 'serverHeartbeatFailed', 'serverClosed', 'topologyOpening', 'topologyClosed', 'topologyDescriptionChanged'].forEach(function (e) {
          self.s.mongos.removeAllListeners(e);
        });
        self.s.mongos.once('timeout', errorHandler('timeout'));
        self.s.mongos.once('error', errorHandler('error'));
        self.s.mongos.once('close', errorHandler('close'));
        self.s.mongos.on('serverDescriptionChanged', relay('serverDescriptionChanged'));
        self.s.mongos.on('serverHeartbeatStarted', relay('serverHeartbeatStarted'));
        self.s.mongos.on('serverHeartbeatSucceeded', relay('serverHeartbeatSucceeded'));
        self.s.mongos.on('serverHeartbeatFailed', relay('serverHeartbeatFailed'));
        self.s.mongos.on('serverOpening', relay('serverOpening'));
        self.s.mongos.on('serverClosed', relay('serverClosed'));
        self.s.mongos.on('topologyOpening', relay('topologyOpening'));
        self.s.mongos.on('topologyClosed', relay('topologyClosed'));
        self.s.mongos.on('topologyDescriptionChanged', relay('topologyDescriptionChanged'));
        self.s.mongos.on('fullsetup', relay('fullsetup'));
        self.emit('open', null, self);
        try {
          callback(null, self);
        } catch (err) {
          process.nextTick(function () {
            throw err;
          });
        }
      };
      self.s.mongos.once('timeout', connectErrorHandler('timeout'));
      self.s.mongos.once('error', connectErrorHandler('error'));
      self.s.mongos.once('close', connectErrorHandler('close'));
      self.s.mongos.once('connect', connectHandler);
      self.s.mongos.on('joined', relay('joined'));
      self.s.mongos.on('left', relay('left'));
      self.s.mongos.on('reconnect', reconnectHandler);
      self.s.mongos.connect(_options);
    };
    Mongos.prototype.capabilities = function () {
      if (this.s.sCapabilities) return this.s.sCapabilities;
      if (this.s.mongos.lastIsMaster() == null) return null;
      this.s.sCapabilities = new ServerCapabilities(this.s.mongos.lastIsMaster());
      return this.s.sCapabilities;
    };
    define.classMethod('capabilities', {
      callback: false,
      promise: false,
      returns: [ServerCapabilities]
    });
    Mongos.prototype.command = function (ns, cmd, options, callback) {
      this.s.mongos.command(ns, cmd, options, callback);
    };
    define.classMethod('command', {
      callback: true,
      promise: false
    });
    Mongos.prototype.insert = function (ns, ops, options, callback) {
      this.s.mongos.insert(ns, ops, options, function (e, m) {
        callback(e, m);
      });
    };
    define.classMethod('insert', {
      callback: true,
      promise: false
    });
    Mongos.prototype.update = function (ns, ops, options, callback) {
      this.s.mongos.update(ns, ops, options, callback);
    };
    define.classMethod('update', {
      callback: true,
      promise: false
    });
    Mongos.prototype.remove = function (ns, ops, options, callback) {
      this.s.mongos.remove(ns, ops, options, callback);
    };
    define.classMethod('remove', {
      callback: true,
      promise: false
    });
    Mongos.prototype.isDestroyed = function () {
      return this.s.mongos.isDestroyed();
    };
    Mongos.prototype.isConnected = function () {
      return this.s.mongos.isConnected();
    };
    define.classMethod('isConnected', {
      callback: false,
      promise: false,
      returns: [Boolean]
    });
    Mongos.prototype.cursor = function (ns, cmd, options) {
      options.disconnectHandler = this.s.store;
      return this.s.mongos.cursor(ns, cmd, options);
    };
    define.classMethod('cursor', {
      callback: false,
      promise: false,
      returns: [Cursor, AggregationCursor, CommandCursor]
    });
    Mongos.prototype.lastIsMaster = function () {
      return this.s.mongos.lastIsMaster();
    };
    Mongos.prototype.close = function (forceClosed) {
      this.s.mongos.destroy();
      if (forceClosed == true) {
        this.s.storeOptions.force = forceClosed;
        this.s.store.flush();
      }
    };
    define.classMethod('close', {
      callback: false,
      promise: false
    });
    Mongos.prototype.auth = function () {
      var args = Array.prototype.slice.call(arguments, 0);
      this.s.mongos.auth.apply(this.s.mongos, args);
    };
    define.classMethod('auth', {
      callback: true,
      promise: false
    });
    Mongos.prototype.logout = function () {
      var args = Array.prototype.slice.call(arguments, 0);
      this.s.mongos.logout.apply(this.s.mongos, args);
    };
    define.classMethod('logout', {
      callback: true,
      promise: false
    });
    Mongos.prototype.connections = function () {
      return this.s.mongos.connections();
    };
    define.classMethod('connections', {
      callback: false,
      promise: false,
      returns: [Array]
    });
    module.exports = Mongos;
  })($__require('2a').Buffer, $__require('13'));
  return module.exports;
});
$__System.registerDynamic('17f', ['166', '18f', '49', '194', '18d', '184', '190'], true, function ($__require, exports, module) {
  /* */
  "use strict";

  var define,
      global = this || self,
      GLOBAL = global;
  var inherits = $__require('166').inherits,
      MongoError = $__require('18f').MongoError,
      Readable = $__require('49').Readable || $__require('194').Readable,
      Define = $__require('18d'),
      CoreCursor = $__require('184');
  var AggregationCursor = function (bson, ns, cmd, options, topology, topologyOptions) {
    CoreCursor.apply(this, Array.prototype.slice.call(arguments, 0));
    var state = AggregationCursor.INIT;
    var streamOptions = {};
    var maxTimeMS = null;
    var promiseLibrary = options.promiseLibrary;
    if (!promiseLibrary) {
      promiseLibrary = typeof global.Promise == 'function' ? global.Promise : $__require('190').Promise;
    }
    Readable.call(this, { objectMode: true });
    this.s = {
      maxTimeMS: maxTimeMS,
      state: state,
      streamOptions: streamOptions,
      bson: bson,
      ns: ns,
      cmd: cmd,
      options: options,
      topology: topology,
      topologyOptions: topologyOptions,
      promiseLibrary: promiseLibrary
    };
  };
  inherits(AggregationCursor, Readable);
  for (var name in CoreCursor.prototype) {
    AggregationCursor.prototype[name] = CoreCursor.prototype[name];
  }
  var define = AggregationCursor.define = new Define('AggregationCursor', AggregationCursor, true);
  AggregationCursor.prototype.batchSize = function (value) {
    if (this.s.state == AggregationCursor.CLOSED || this.isDead()) throw MongoError.create({
      message: "Cursor is closed",
      driver: true
    });
    if (typeof value != 'number') throw MongoError.create({
      message: "batchSize requires an integer",
      drvier: true
    });
    if (this.s.cmd.cursor) this.s.cmd.cursor.batchSize = value;
    this.setCursorBatchSize(value);
    return this;
  };
  define.classMethod('batchSize', {
    callback: false,
    promise: false,
    returns: [AggregationCursor]
  });
  AggregationCursor.prototype.geoNear = function (document) {
    this.s.cmd.pipeline.push({ $geoNear: document });
    return this;
  };
  define.classMethod('geoNear', {
    callback: false,
    promise: false,
    returns: [AggregationCursor]
  });
  AggregationCursor.prototype.group = function (document) {
    this.s.cmd.pipeline.push({ $group: document });
    return this;
  };
  define.classMethod('group', {
    callback: false,
    promise: false,
    returns: [AggregationCursor]
  });
  AggregationCursor.prototype.limit = function (value) {
    this.s.cmd.pipeline.push({ $limit: value });
    return this;
  };
  define.classMethod('limit', {
    callback: false,
    promise: false,
    returns: [AggregationCursor]
  });
  AggregationCursor.prototype.match = function (document) {
    this.s.cmd.pipeline.push({ $match: document });
    return this;
  };
  define.classMethod('match', {
    callback: false,
    promise: false,
    returns: [AggregationCursor]
  });
  AggregationCursor.prototype.maxTimeMS = function (value) {
    if (this.s.topology.lastIsMaster().minWireVersion > 2) {
      this.s.cmd.maxTimeMS = value;
    }
    return this;
  };
  define.classMethod('maxTimeMS', {
    callback: false,
    promise: false,
    returns: [AggregationCursor]
  });
  AggregationCursor.prototype.out = function (destination) {
    this.s.cmd.pipeline.push({ $out: destination });
    return this;
  };
  define.classMethod('out', {
    callback: false,
    promise: false,
    returns: [AggregationCursor]
  });
  AggregationCursor.prototype.project = function (document) {
    this.s.cmd.pipeline.push({ $project: document });
    return this;
  };
  define.classMethod('project', {
    callback: false,
    promise: false,
    returns: [AggregationCursor]
  });
  AggregationCursor.prototype.lookup = function (document) {
    this.s.cmd.pipeline.push({ $lookup: document });
    return this;
  };
  define.classMethod('lookup', {
    callback: false,
    promise: false,
    returns: [AggregationCursor]
  });
  AggregationCursor.prototype.redact = function (document) {
    this.s.cmd.pipeline.push({ $redact: document });
    return this;
  };
  define.classMethod('redact', {
    callback: false,
    promise: false,
    returns: [AggregationCursor]
  });
  AggregationCursor.prototype.skip = function (value) {
    this.s.cmd.pipeline.push({ $skip: value });
    return this;
  };
  define.classMethod('skip', {
    callback: false,
    promise: false,
    returns: [AggregationCursor]
  });
  AggregationCursor.prototype.sort = function (document) {
    this.s.cmd.pipeline.push({ $sort: document });
    return this;
  };
  define.classMethod('sort', {
    callback: false,
    promise: false,
    returns: [AggregationCursor]
  });
  AggregationCursor.prototype.unwind = function (field) {
    this.s.cmd.pipeline.push({ $unwind: field });
    return this;
  };
  define.classMethod('unwind', {
    callback: false,
    promise: false,
    returns: [AggregationCursor]
  });
  AggregationCursor.prototype.get = AggregationCursor.prototype.toArray;
  define.classMethod('toArray', {
    callback: true,
    promise: true
  });
  define.classMethod('each', {
    callback: true,
    promise: false
  });
  define.classMethod('forEach', {
    callback: true,
    promise: false
  });
  define.classMethod('next', {
    callback: true,
    promise: true
  });
  define.classMethod('close', {
    callback: true,
    promise: true
  });
  define.classMethod('isClosed', {
    callback: false,
    promise: false,
    returns: [Boolean]
  });
  define.classMethod('rewind', {
    callback: false,
    promise: false
  });
  define.classMethod('bufferedCount', {
    callback: false,
    promise: false,
    returns: [Number]
  });
  define.classMethod('readBufferedDocuments', {
    callback: false,
    promise: false,
    returns: [Array]
  });
  AggregationCursor.INIT = 0;
  AggregationCursor.OPEN = 1;
  AggregationCursor.CLOSED = 2;
  module.exports = AggregationCursor;
  return module.exports;
});
$__System.registerDynamic('180', ['166', '188', '18f', '49', '194', '18d', '184', '190'], true, function ($__require, exports, module) {
  /* */
  "use strict";

  var define,
      global = this || self,
      GLOBAL = global;
  var inherits = $__require('166').inherits,
      ReadPreference = $__require('188'),
      MongoError = $__require('18f').MongoError,
      Readable = $__require('49').Readable || $__require('194').Readable,
      Define = $__require('18d'),
      CoreCursor = $__require('184'),
      CoreReadPreference = $__require('18f').ReadPreference;
  var CommandCursor = function (bson, ns, cmd, options, topology, topologyOptions) {
    CoreCursor.apply(this, Array.prototype.slice.call(arguments, 0));
    var state = CommandCursor.INIT;
    var streamOptions = {};
    var maxTimeMS = null;
    var promiseLibrary = options.promiseLibrary;
    if (!promiseLibrary) {
      promiseLibrary = typeof global.Promise == 'function' ? global.Promise : $__require('190').Promise;
    }
    Readable.call(this, { objectMode: true });
    this.s = {
      maxTimeMS: maxTimeMS,
      state: state,
      streamOptions: streamOptions,
      bson: bson,
      ns: ns,
      cmd: cmd,
      options: options,
      topology: topology,
      topologyOptions: topologyOptions,
      promiseLibrary: promiseLibrary
    };
  };
  inherits(CommandCursor, Readable);
  var methodsToInherit = ['_next', 'next', 'each', 'forEach', 'toArray', 'rewind', 'bufferedCount', 'readBufferedDocuments', 'close', 'isClosed', 'kill', '_find', '_getmore', '_killcursor', 'isDead', 'explain', 'isNotified', 'isKilled'];
  for (var i = 0; i < methodsToInherit.length; i++) {
    CommandCursor.prototype[methodsToInherit[i]] = CoreCursor.prototype[methodsToInherit[i]];
  }
  var define = CommandCursor.define = new Define('CommandCursor', CommandCursor, true);
  CommandCursor.prototype.setReadPreference = function (r) {
    if (this.s.state == CommandCursor.CLOSED || this.isDead()) throw MongoError.create({
      message: "Cursor is closed",
      driver: true
    });
    if (this.s.state != CommandCursor.INIT) throw MongoError.create({
      message: 'cannot change cursor readPreference after cursor has been accessed',
      driver: true
    });
    if (r instanceof ReadPreference) {
      this.s.options.readPreference = new CoreReadPreference(r.mode, r.tags, { maxStalenessSeconds: r.maxStalenessSeconds });
    } else if (typeof r == 'string') {
      this.s.options.readPreference = new CoreReadPreference(r);
    } else if (r instanceof CoreReadPreference) {
      this.s.options.readPreference = r;
    }
    return this;
  };
  define.classMethod('setReadPreference', {
    callback: false,
    promise: false,
    returns: [CommandCursor]
  });
  CommandCursor.prototype.batchSize = function (value) {
    if (this.s.state == CommandCursor.CLOSED || this.isDead()) throw MongoError.create({
      message: "Cursor is closed",
      driver: true
    });
    if (typeof value != 'number') throw MongoError.create({
      message: "batchSize requires an integer",
      driver: true
    });
    if (this.s.cmd.cursor) this.s.cmd.cursor.batchSize = value;
    this.setCursorBatchSize(value);
    return this;
  };
  define.classMethod('batchSize', {
    callback: false,
    promise: false,
    returns: [CommandCursor]
  });
  CommandCursor.prototype.maxTimeMS = function (value) {
    if (this.s.topology.lastIsMaster().minWireVersion > 2) {
      this.s.cmd.maxTimeMS = value;
    }
    return this;
  };
  define.classMethod('maxTimeMS', {
    callback: false,
    promise: false,
    returns: [CommandCursor]
  });
  CommandCursor.prototype.get = CommandCursor.prototype.toArray;
  define.classMethod('get', {
    callback: true,
    promise: false
  });
  define.classMethod('toArray', {
    callback: true,
    promise: true
  });
  define.classMethod('each', {
    callback: true,
    promise: false
  });
  define.classMethod('forEach', {
    callback: true,
    promise: false
  });
  define.classMethod('next', {
    callback: true,
    promise: true
  });
  define.classMethod('close', {
    callback: true,
    promise: true
  });
  define.classMethod('isClosed', {
    callback: false,
    promise: false,
    returns: [Boolean]
  });
  define.classMethod('rewind', {
    callback: false,
    promise: false
  });
  define.classMethod('bufferedCount', {
    callback: false,
    promise: false,
    returns: [Number]
  });
  define.classMethod('readBufferedDocuments', {
    callback: false,
    promise: false,
    returns: [Array]
  });
  CommandCursor.INIT = 0;
  CommandCursor.OPEN = 1;
  CommandCursor.CLOSED = 2;
  module.exports = CommandCursor;
  return module.exports;
});
$__System.registerDynamic('182', ['195', '18e', '18f', '18d', '190'], true, function ($__require, exports, module) {
  /* */
  "use strict";

  var define,
      global = this || self,
      GLOBAL = global;
  var common = $__require('195'),
      utils = $__require('18e'),
      toError = $__require('18e').toError,
      handleCallback = $__require('18e').handleCallback,
      shallowClone = utils.shallowClone,
      BulkWriteResult = common.BulkWriteResult,
      ObjectID = $__require('18f').BSON.ObjectID,
      BSON = $__require('18f').BSON,
      Define = $__require('18d'),
      Batch = common.Batch,
      mergeBatchResults = common.mergeBatchResults;
  var bson = new BSON.BSONPure();
  var FindOperatorsUnordered = function (self) {
    this.s = self.s;
  };
  FindOperatorsUnordered.prototype.update = function (updateDocument) {
    var upsert = typeof this.s.currentOp.upsert == 'boolean' ? this.s.currentOp.upsert : false;
    var document = {
      q: this.s.currentOp.selector,
      u: updateDocument,
      multi: true,
      upsert: upsert
    };
    this.s.currentOp = null;
    return addToOperationsList(this, common.UPDATE, document);
  };
  FindOperatorsUnordered.prototype.updateOne = function (updateDocument) {
    var upsert = typeof this.s.currentOp.upsert == 'boolean' ? this.s.currentOp.upsert : false;
    var document = {
      q: this.s.currentOp.selector,
      u: updateDocument,
      multi: false,
      upsert: upsert
    };
    this.s.currentOp = null;
    return addToOperationsList(this, common.UPDATE, document);
  };
  FindOperatorsUnordered.prototype.replaceOne = function (updateDocument) {
    this.updateOne(updateDocument);
  };
  FindOperatorsUnordered.prototype.upsert = function () {
    this.s.currentOp.upsert = true;
    return this;
  };
  FindOperatorsUnordered.prototype.removeOne = function () {
    var document = {
      q: this.s.currentOp.selector,
      limit: 1
    };
    this.s.currentOp = null;
    return addToOperationsList(this, common.REMOVE, document);
  };
  FindOperatorsUnordered.prototype.remove = function () {
    var document = {
      q: this.s.currentOp.selector,
      limit: 0
    };
    this.s.currentOp = null;
    return addToOperationsList(this, common.REMOVE, document);
  };
  var addToOperationsList = function (_self, docType, document) {
    var bsonSize = bson.calculateObjectSize(document, false);
    if (bsonSize >= _self.s.maxBatchSizeBytes) throw toError("document is larger than the maximum size " + _self.s.maxBatchSizeBytes);
    _self.s.currentBatch = null;
    if (docType == common.INSERT) {
      _self.s.currentBatch = _self.s.currentInsertBatch;
    } else if (docType == common.UPDATE) {
      _self.s.currentBatch = _self.s.currentUpdateBatch;
    } else if (docType == common.REMOVE) {
      _self.s.currentBatch = _self.s.currentRemoveBatch;
    }
    if (_self.s.currentBatch == null) _self.s.currentBatch = new Batch(docType, _self.s.currentIndex);
    if (_self.s.currentBatch.size + 1 >= _self.s.maxWriteBatchSize || _self.s.currentBatch.sizeBytes + bsonSize >= _self.s.maxBatchSizeBytes || _self.s.currentBatch.batchType != docType) {
      _self.s.batches.push(_self.s.currentBatch);
      _self.s.currentBatch = new Batch(docType, _self.s.currentIndex);
    }
    if (Array.isArray(document)) {
      throw toError("operation passed in cannot be an Array");
    } else {
      _self.s.currentBatch.operations.push(document);
      _self.s.currentBatch.originalIndexes.push(_self.s.currentIndex);
      _self.s.currentIndex = _self.s.currentIndex + 1;
    }
    if (docType == common.INSERT) {
      _self.s.currentInsertBatch = _self.s.currentBatch;
      _self.s.bulkResult.insertedIds.push({
        index: _self.s.currentIndex,
        _id: document._id
      });
    } else if (docType == common.UPDATE) {
      _self.s.currentUpdateBatch = _self.s.currentBatch;
    } else if (docType == common.REMOVE) {
      _self.s.currentRemoveBatch = _self.s.currentBatch;
    }
    _self.s.currentBatch.size = _self.s.currentBatch.size + 1;
    _self.s.currentBatch.sizeBytes = _self.s.currentBatch.sizeBytes + bsonSize;
    return _self;
  };
  var UnorderedBulkOperation = function (topology, collection, options) {
    options = options == null ? {} : options;
    var namespace = collection.collectionName;
    var executed = false;
    var currentOp = null;
    var bson = topology.bson;
    var maxBatchSizeBytes = topology.isMasterDoc && topology.isMasterDoc.maxBsonObjectSize ? topology.isMasterDoc.maxBsonObjectSize : 1024 * 1025 * 16;
    var maxWriteBatchSize = topology.isMasterDoc && topology.isMasterDoc.maxWriteBatchSize ? topology.isMasterDoc.maxWriteBatchSize : 1000;
    var writeConcern = common.writeConcern(shallowClone(options), collection, options);
    var promiseLibrary = options.promiseLibrary;
    if (!promiseLibrary) {
      promiseLibrary = typeof global.Promise == 'function' ? global.Promise : $__require('190').Promise;
    }
    var bulkResult = {
      ok: 1,
      writeErrors: [],
      writeConcernErrors: [],
      insertedIds: [],
      nInserted: 0,
      nUpserted: 0,
      nMatched: 0,
      nModified: 0,
      nRemoved: 0,
      upserted: []
    };
    this.s = {
      bulkResult: bulkResult,
      currentInsertBatch: null,
      currentUpdateBatch: null,
      currentRemoveBatch: null,
      currentBatch: null,
      currentIndex: 0,
      batches: [],
      writeConcern: writeConcern,
      maxBatchSizeBytes: maxBatchSizeBytes,
      maxWriteBatchSize: maxWriteBatchSize,
      namespace: namespace,
      bson: bson,
      topology: topology,
      options: options,
      currentOp: currentOp,
      executed: executed,
      collection: collection,
      promiseLibrary: promiseLibrary,
      bypassDocumentValidation: typeof options.bypassDocumentValidation == 'boolean' ? options.bypassDocumentValidation : false
    };
  };
  var define = UnorderedBulkOperation.define = new Define('UnorderedBulkOperation', UnorderedBulkOperation, false);
  UnorderedBulkOperation.prototype.insert = function (document) {
    if (this.s.collection.s.db.options.forceServerObjectId !== true && document._id == null) document._id = new ObjectID();
    return addToOperationsList(this, common.INSERT, document);
  };
  UnorderedBulkOperation.prototype.find = function (selector) {
    if (!selector) {
      throw toError("Bulk find operation must specify a selector");
    }
    this.s.currentOp = { selector: selector };
    return new FindOperatorsUnordered(this);
  };
  Object.defineProperty(UnorderedBulkOperation.prototype, 'length', {
    enumerable: true,
    get: function () {
      return this.s.currentIndex;
    }
  });
  UnorderedBulkOperation.prototype.raw = function (op) {
    var key = Object.keys(op)[0];
    var forceServerObjectId = typeof this.s.options.forceServerObjectId == 'boolean' ? this.s.options.forceServerObjectId : this.s.collection.s.db.options.forceServerObjectId;
    if (op.updateOne && op.updateOne.q || op.updateMany && op.updateMany.q || op.replaceOne && op.replaceOne.q) {
      op[key].multi = op.updateOne || op.replaceOne ? false : true;
      return addToOperationsList(this, common.UPDATE, op[key]);
    }
    if (op.updateOne || op.updateMany || op.replaceOne) {
      var multi = op.updateOne || op.replaceOne ? false : true;
      var operation = {
        q: op[key].filter,
        u: op[key].update || op[key].replacement,
        multi: multi
      };
      if (op[key].upsert) operation.upsert = true;
      return addToOperationsList(this, common.UPDATE, operation);
    }
    if (op.removeOne || op.removeMany || op.deleteOne && op.deleteOne.q || op.deleteMany && op.deleteMany.q) {
      op[key].limit = op.removeOne ? 1 : 0;
      return addToOperationsList(this, common.REMOVE, op[key]);
    }
    if (op.deleteOne || op.deleteMany) {
      var limit = op.deleteOne ? 1 : 0;
      operation = {
        q: op[key].filter,
        limit: limit
      };
      return addToOperationsList(this, common.REMOVE, operation);
    }
    if (op.insertOne && op.insertOne.document == null) {
      if (forceServerObjectId !== true && op.insertOne._id == null) op.insertOne._id = new ObjectID();
      return addToOperationsList(this, common.INSERT, op.insertOne);
    } else if (op.insertOne && op.insertOne.document) {
      if (forceServerObjectId !== true && op.insertOne.document._id == null) op.insertOne.document._id = new ObjectID();
      return addToOperationsList(this, common.INSERT, op.insertOne.document);
    }
    if (op.insertMany) {
      for (var i = 0; i < op.insertMany.length; i++) {
        if (forceServerObjectId !== true && op.insertMany[i]._id == null) op.insertMany[i]._id = new ObjectID();
        addToOperationsList(this, common.INSERT, op.insertMany[i]);
      }
      return;
    }
    throw toError("bulkWrite only supports insertOne, insertMany, updateOne, updateMany, removeOne, removeMany, deleteOne, deleteMany");
  };
  var executeBatch = function (self, batch, callback) {
    var finalOptions = { ordered: false };
    if (self.s.writeConcern != null) {
      finalOptions.writeConcern = self.s.writeConcern;
    }
    var resultHandler = function (err, result) {
      if (err && err.driver || err && err.message) {
        return handleCallback(callback, err);
      }
      if (err) err.ok = 0;
      handleCallback(callback, null, mergeBatchResults(false, batch, self.s.bulkResult, err, result));
    };
    if (self.operationId) {
      resultHandler.operationId = self.operationId;
    }
    if (self.s.options.serializeFunctions) {
      finalOptions.serializeFunctions = true;
    }
    if (self.s.bypassDocumentValidation == true) {
      finalOptions.bypassDocumentValidation = true;
    }
    try {
      if (batch.batchType == common.INSERT) {
        self.s.topology.insert(self.s.collection.namespace, batch.operations, finalOptions, resultHandler);
      } else if (batch.batchType == common.UPDATE) {
        self.s.topology.update(self.s.collection.namespace, batch.operations, finalOptions, resultHandler);
      } else if (batch.batchType == common.REMOVE) {
        self.s.topology.remove(self.s.collection.namespace, batch.operations, finalOptions, resultHandler);
      }
    } catch (err) {
      err.ok = 0;
      handleCallback(callback, null, mergeBatchResults(false, batch, self.s.bulkResult, err, null));
    }
  };
  var executeBatches = function (self, callback) {
    var numberOfCommandsToExecute = self.s.batches.length;
    for (var i = 0; i < self.s.batches.length; i++) {
      executeBatch(self, self.s.batches[i], function (err) {
        if (err) error = err;
        numberOfCommandsToExecute = numberOfCommandsToExecute - 1;
        if (numberOfCommandsToExecute == 0) {
          if (error) return handleCallback(callback, error);
          var error = self.s.bulkResult.writeErrors.length > 0 ? toError(self.s.bulkResult.writeErrors[0]) : null;
          handleCallback(callback, error, new BulkWriteResult(self.s.bulkResult));
        }
      });
    }
  };
  UnorderedBulkOperation.prototype.execute = function (_writeConcern, callback) {
    var self = this;
    if (this.s.executed) throw toError("batch cannot be re-executed");
    if (typeof _writeConcern == 'function') {
      callback = _writeConcern;
    } else if (_writeConcern && typeof _writeConcern == 'object') {
      this.s.writeConcern = _writeConcern;
    }
    if (this.s.currentInsertBatch) this.s.batches.push(this.s.currentInsertBatch);
    if (this.s.currentUpdateBatch) this.s.batches.push(this.s.currentUpdateBatch);
    if (this.s.currentRemoveBatch) this.s.batches.push(this.s.currentRemoveBatch);
    if (this.s.batches.length == 0) {
      throw toError("Invalid Operation, No operations in bulk");
    }
    if (typeof callback == 'function') return executeBatches(this, callback);
    return new this.s.promiseLibrary(function (resolve, reject) {
      executeBatches(self, function (err, r) {
        if (err) return reject(err);
        resolve(r);
      });
    });
  };
  define.classMethod('execute', {
    callback: true,
    promise: false
  });
  var initializeUnorderedBulkOp = function (topology, collection, options) {
    return new UnorderedBulkOperation(topology, collection, options);
  };
  initializeUnorderedBulkOp.UnorderedBulkOperation = UnorderedBulkOperation;
  module.exports = initializeUnorderedBulkOp;
  module.exports.Bulk = UnorderedBulkOperation;
  return module.exports;
});
$__System.registerDynamic('195', ['18f', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    "use strict";

    var Long = $__require('18f').BSON.Long,
        Timestamp = $__require('18f').BSON.Timestamp;
    var UNKNOWN_ERROR = 8;
    var INVALID_BSON_ERROR = 22;
    var WRITE_CONCERN_ERROR = 64;
    var MULTIPLE_ERROR = 65;
    var INSERT = 1;
    var UPDATE = 2;
    var REMOVE = 3;
    var writeConcern = function (target, col, options) {
      var writeConcern = {};
      if (col.writeConcern && col.writeConcern.w != null) writeConcern.w = col.writeConcern.w;
      if (col.writeConcern && col.writeConcern.j != null) writeConcern.j = col.writeConcern.j;
      if (col.writeConcern && col.writeConcern.fsync != null) writeConcern.fsync = col.writeConcern.fsync;
      if (col.writeConcern && col.writeConcern.wtimeout != null) writeConcern.wtimeout = col.writeConcern.wtimeout;
      if (options && options.w != null) writeConcern.w = options.w;
      if (options && options.wtimeout != null) writeConcern.wtimeout = options.wtimeout;
      if (options && options.j != null) writeConcern.j = options.j;
      if (options && options.fsync != null) writeConcern.fsync = options.fsync;
      return writeConcern;
    };
    var defineReadOnlyProperty = function (self, name, value) {
      Object.defineProperty(self, name, {
        enumerable: true,
        get: function () {
          return value;
        }
      });
    };
    var Batch = function (batchType, originalZeroIndex) {
      this.originalZeroIndex = originalZeroIndex;
      this.currentIndex = 0;
      this.originalIndexes = [];
      this.batchType = batchType;
      this.operations = [];
      this.size = 0;
      this.sizeBytes = 0;
    };
    var LegacyOp = function (batchType, operation, index) {
      this.batchType = batchType;
      this.index = index;
      this.operation = operation;
    };
    var BulkWriteResult = function (bulkResult) {
      defineReadOnlyProperty(this, "ok", bulkResult.ok);
      defineReadOnlyProperty(this, "nInserted", bulkResult.nInserted);
      defineReadOnlyProperty(this, "nUpserted", bulkResult.nUpserted);
      defineReadOnlyProperty(this, "nMatched", bulkResult.nMatched);
      defineReadOnlyProperty(this, "nModified", bulkResult.nModified);
      defineReadOnlyProperty(this, "nRemoved", bulkResult.nRemoved);
      this.getInsertedIds = function () {
        return bulkResult.insertedIds;
      };
      this.getUpsertedIds = function () {
        return bulkResult.upserted;
      };
      this.getUpsertedIdAt = function (index) {
        return bulkResult.upserted[index];
      };
      this.getRawResponse = function () {
        return bulkResult;
      };
      this.hasWriteErrors = function () {
        return bulkResult.writeErrors.length > 0;
      };
      this.getWriteErrorCount = function () {
        return bulkResult.writeErrors.length;
      };
      this.getWriteErrorAt = function (index) {
        if (index < bulkResult.writeErrors.length) {
          return bulkResult.writeErrors[index];
        }
        return null;
      };
      this.getWriteErrors = function () {
        return bulkResult.writeErrors;
      };
      this.getLastOp = function () {
        return bulkResult.lastOp;
      };
      this.getWriteConcernError = function () {
        if (bulkResult.writeConcernErrors.length == 0) {
          return null;
        } else if (bulkResult.writeConcernErrors.length == 1) {
          return bulkResult.writeConcernErrors[0];
        } else {
          var errmsg = "";
          for (var i = 0; i < bulkResult.writeConcernErrors.length; i++) {
            var err = bulkResult.writeConcernErrors[i];
            errmsg = errmsg + err.errmsg;
            if (i == 0) errmsg = errmsg + " and ";
          }
          return new WriteConcernError({
            errmsg: errmsg,
            code: WRITE_CONCERN_ERROR
          });
        }
      };
      this.toJSON = function () {
        return bulkResult;
      };
      this.toString = function () {
        return "BulkWriteResult(" + this.toJSON(bulkResult) + ")";
      };
      this.isOk = function () {
        return bulkResult.ok == 1;
      };
    };
    var WriteConcernError = function (err) {
      if (!(this instanceof WriteConcernError)) return new WriteConcernError(err);
      defineReadOnlyProperty(this, "code", err.code);
      defineReadOnlyProperty(this, "errmsg", err.errmsg);
      this.toJSON = function () {
        return {
          code: err.code,
          errmsg: err.errmsg
        };
      };
      this.toString = function () {
        return "WriteConcernError(" + err.errmsg + ")";
      };
    };
    var WriteError = function (err) {
      if (!(this instanceof WriteError)) return new WriteError(err);
      defineReadOnlyProperty(this, "code", err.code);
      defineReadOnlyProperty(this, "index", err.index);
      defineReadOnlyProperty(this, "errmsg", err.errmsg);
      this.getOperation = function () {
        return err.op;
      };
      this.toJSON = function () {
        return {
          code: err.code,
          index: err.index,
          errmsg: err.errmsg,
          op: err.op
        };
      };
      this.toString = function () {
        return "WriteError(" + JSON.stringify(this.toJSON()) + ")";
      };
    };
    var mergeBatchResults = function (ordered, batch, bulkResult, err, result) {
      if (err) {
        result = err;
      } else if (result && result.result) {
        result = result.result;
      } else if (result == null) {
        return;
      }
      if (result.ok == 0 && bulkResult.ok == 1) {
        bulkResult.ok = 0;
        var writeError = {
          index: 0,
          code: result.code || 0,
          errmsg: result.message,
          op: batch.operations[0]
        };
        bulkResult.writeErrors.push(new WriteError(writeError));
        return;
      } else if (result.ok == 0 && bulkResult.ok == 0) {
        return;
      }
      if (result.opTime || result.lastOp) {
        var opTime = result.lastOp || result.opTime;
        var lastOpTS = null;
        var lastOpT = null;
        if (opTime instanceof Timestamp) {
          if (bulkResult.lastOp == null) {
            bulkResult.lastOp = opTime;
          } else if (opTime.greaterThan(bulkResult.lastOp)) {
            bulkResult.lastOp = opTime;
          }
        } else {
          if (bulkResult.lastOp) {
            lastOpTS = typeof bulkResult.lastOp.ts == 'number' ? Long.fromNumber(bulkResult.lastOp.ts) : bulkResult.lastOp.ts;
            lastOpT = typeof bulkResult.lastOp.t == 'number' ? Long.fromNumber(bulkResult.lastOp.t) : bulkResult.lastOp.t;
          }
          var opTimeTS = typeof opTime.ts == 'number' ? Long.fromNumber(opTime.ts) : opTime.ts;
          var opTimeT = typeof opTime.t == 'number' ? Long.fromNumber(opTime.t) : opTime.t;
          if (bulkResult.lastOp == null) {
            bulkResult.lastOp = opTime;
          } else if (opTimeTS.greaterThan(lastOpTS)) {
            bulkResult.lastOp = opTime;
          } else if (opTimeTS.equals(lastOpTS)) {
            if (opTimeT.greaterThan(lastOpT)) {
              bulkResult.lastOp = opTime;
            }
          }
        }
      }
      if (batch.batchType == INSERT && result.n) {
        bulkResult.nInserted = bulkResult.nInserted + result.n;
      }
      if (batch.batchType == REMOVE && result.n) {
        bulkResult.nRemoved = bulkResult.nRemoved + result.n;
      }
      var nUpserted = 0;
      if (Array.isArray(result.upserted)) {
        nUpserted = result.upserted.length;
        for (var i = 0; i < result.upserted.length; i++) {
          bulkResult.upserted.push({
            index: result.upserted[i].index + batch.originalZeroIndex,
            _id: result.upserted[i]._id
          });
        }
      } else if (result.upserted) {
        nUpserted = 1;
        bulkResult.upserted.push({
          index: batch.originalZeroIndex,
          _id: result.upserted
        });
      }
      if (batch.batchType == UPDATE && result.n) {
        var nModified = result.nModified;
        bulkResult.nUpserted = bulkResult.nUpserted + nUpserted;
        bulkResult.nMatched = bulkResult.nMatched + (result.n - nUpserted);
        if (typeof nModified == 'number') {
          bulkResult.nModified = bulkResult.nModified + nModified;
        } else {
          bulkResult.nModified = null;
        }
      }
      if (Array.isArray(result.writeErrors)) {
        for (i = 0; i < result.writeErrors.length; i++) {
          writeError = {
            index: batch.originalZeroIndex + result.writeErrors[i].index,
            code: result.writeErrors[i].code,
            errmsg: result.writeErrors[i].errmsg,
            op: batch.operations[result.writeErrors[i].index]
          };
          bulkResult.writeErrors.push(new WriteError(writeError));
        }
      }
      if (result.writeConcernError) {
        bulkResult.writeConcernErrors.push(new WriteConcernError(result.writeConcernError));
      }
    };
    var cloneOptions = function (options) {
      var clone = {};
      var keys = Object.keys(options);
      for (var i = 0; i < keys.length; i++) {
        clone[keys[i]] = options[keys[i]];
      }
      return clone;
    };
    exports.BulkWriteResult = BulkWriteResult;
    exports.WriteError = WriteError;
    exports.Batch = Batch;
    exports.LegacyOp = LegacyOp;
    exports.mergeBatchResults = mergeBatchResults;
    exports.cloneOptions = cloneOptions;
    exports.writeConcern = writeConcern;
    exports.INVALID_BSON_ERROR = INVALID_BSON_ERROR;
    exports.WRITE_CONCERN_ERROR = WRITE_CONCERN_ERROR;
    exports.MULTIPLE_ERROR = MULTIPLE_ERROR;
    exports.UNKNOWN_ERROR = UNKNOWN_ERROR;
    exports.INSERT = INSERT;
    exports.UPDATE = UPDATE;
    exports.REMOVE = REMOVE;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('181', ['195', '18e', '18f', '18d', '190'], true, function ($__require, exports, module) {
  /* */
  "use strict";

  var define,
      global = this || self,
      GLOBAL = global;
  var common = $__require('195'),
      utils = $__require('18e'),
      toError = $__require('18e').toError,
      handleCallback = $__require('18e').handleCallback,
      shallowClone = utils.shallowClone,
      BulkWriteResult = common.BulkWriteResult,
      ObjectID = $__require('18f').BSON.ObjectID,
      Define = $__require('18d'),
      BSON = $__require('18f').BSON,
      Batch = common.Batch,
      mergeBatchResults = common.mergeBatchResults;
  var bson = new BSON.BSONPure();
  var FindOperatorsOrdered = function (self) {
    this.s = self.s;
  };
  FindOperatorsOrdered.prototype.update = function (updateDocument) {
    var upsert = typeof this.s.currentOp.upsert == 'boolean' ? this.s.currentOp.upsert : false;
    var document = {
      q: this.s.currentOp.selector,
      u: updateDocument,
      multi: true,
      upsert: upsert
    };
    this.s.currentOp = null;
    return addToOperationsList(this, common.UPDATE, document);
  };
  FindOperatorsOrdered.prototype.updateOne = function (updateDocument) {
    var upsert = typeof this.s.currentOp.upsert == 'boolean' ? this.s.currentOp.upsert : false;
    var document = {
      q: this.s.currentOp.selector,
      u: updateDocument,
      multi: false,
      upsert: upsert
    };
    this.s.currentOp = null;
    return addToOperationsList(this, common.UPDATE, document);
  };
  FindOperatorsOrdered.prototype.replaceOne = function (updateDocument) {
    this.updateOne(updateDocument);
  };
  FindOperatorsOrdered.prototype.upsert = function () {
    this.s.currentOp.upsert = true;
    return this;
  };
  FindOperatorsOrdered.prototype.deleteOne = function () {
    var document = {
      q: this.s.currentOp.selector,
      limit: 1
    };
    this.s.currentOp = null;
    return addToOperationsList(this, common.REMOVE, document);
  };
  FindOperatorsOrdered.prototype.removeOne = FindOperatorsOrdered.prototype.deleteOne;
  FindOperatorsOrdered.prototype.delete = function () {
    var document = {
      q: this.s.currentOp.selector,
      limit: 0
    };
    this.s.currentOp = null;
    return addToOperationsList(this, common.REMOVE, document);
  };
  FindOperatorsOrdered.prototype.remove = FindOperatorsOrdered.prototype.delete;
  var addToOperationsList = function (_self, docType, document) {
    var bsonSize = bson.calculateObjectSize(document, false);
    if (bsonSize >= _self.s.maxBatchSizeBytes) {
      throw toError("document is larger than the maximum size " + _self.s.maxBatchSizeBytes);
    }
    if (_self.s.currentBatch == null) _self.s.currentBatch = new Batch(docType, _self.s.currentIndex);
    if (_self.s.currentBatchSize + 1 >= _self.s.maxWriteBatchSize || _self.s.currentBatchSizeBytes + _self.s.currentBatchSizeBytes >= _self.s.maxBatchSizeBytes || _self.s.currentBatch.batchType != docType) {
      _self.s.batches.push(_self.s.currentBatch);
      _self.s.currentBatch = new Batch(docType, _self.s.currentIndex);
      _self.s.currentBatchSize = 0;
      _self.s.currentBatchSizeBytes = 0;
    } else {
      _self.s.currentBatchSize = _self.s.currentBatchSize + 1;
      _self.s.currentBatchSizeBytes = _self.s.currentBatchSizeBytes + bsonSize;
    }
    if (docType == common.INSERT) {
      _self.s.bulkResult.insertedIds.push({
        index: _self.s.currentIndex,
        _id: document._id
      });
    }
    if (Array.isArray(document)) {
      throw toError("operation passed in cannot be an Array");
    } else {
      _self.s.currentBatch.originalIndexes.push(_self.s.currentIndex);
      _self.s.currentBatch.operations.push(document);
      _self.s.currentBatchSizeBytes = _self.s.currentBatchSizeBytes + bsonSize;
      _self.s.currentIndex = _self.s.currentIndex + 1;
    }
    return _self;
  };
  function OrderedBulkOperation(topology, collection, options) {
    options = options == null ? {} : options;
    var executed = false;
    var currentOp = null;
    var bson = topology.bson;
    var namespace = collection.collectionName;
    var maxBatchSizeBytes = topology.isMasterDoc && topology.isMasterDoc.maxBsonObjectSize ? topology.isMasterDoc.maxBsonObjectSize : 1024 * 1025 * 16;
    var maxWriteBatchSize = topology.isMasterDoc && topology.isMasterDoc.maxWriteBatchSize ? topology.isMasterDoc.maxWriteBatchSize : 1000;
    var writeConcern = common.writeConcern(shallowClone(options), collection, options);
    var promiseLibrary = options.promiseLibrary;
    if (!promiseLibrary) {
      promiseLibrary = typeof global.Promise == 'function' ? global.Promise : $__require('190').Promise;
    }
    var bulkResult = {
      ok: 1,
      writeErrors: [],
      writeConcernErrors: [],
      insertedIds: [],
      nInserted: 0,
      nUpserted: 0,
      nMatched: 0,
      nModified: 0,
      nRemoved: 0,
      upserted: []
    };
    this.s = {
      bulkResult: bulkResult,
      currentBatch: null,
      currentIndex: 0,
      currentBatchSize: 0,
      currentBatchSizeBytes: 0,
      batches: [],
      writeConcern: writeConcern,
      maxBatchSizeBytes: maxBatchSizeBytes,
      maxWriteBatchSize: maxWriteBatchSize,
      namespace: namespace,
      bson: bson,
      topology: topology,
      options: options,
      currentOp: currentOp,
      executed: executed,
      collection: collection,
      promiseLibrary: promiseLibrary,
      err: null,
      bypassDocumentValidation: typeof options.bypassDocumentValidation == 'boolean' ? options.bypassDocumentValidation : false
    };
  }
  var define = OrderedBulkOperation.define = new Define('OrderedBulkOperation', OrderedBulkOperation, false);
  OrderedBulkOperation.prototype.raw = function (op) {
    var key = Object.keys(op)[0];
    var forceServerObjectId = typeof this.s.options.forceServerObjectId == 'boolean' ? this.s.options.forceServerObjectId : this.s.collection.s.db.options.forceServerObjectId;
    if (op.updateOne && op.updateOne.q || op.updateMany && op.updateMany.q || op.replaceOne && op.replaceOne.q) {
      op[key].multi = op.updateOne || op.replaceOne ? false : true;
      return addToOperationsList(this, common.UPDATE, op[key]);
    }
    if (op.updateOne || op.updateMany || op.replaceOne) {
      var multi = op.updateOne || op.replaceOne ? false : true;
      var operation = {
        q: op[key].filter,
        u: op[key].update || op[key].replacement,
        multi: multi
      };
      operation.upsert = op[key].upsert ? true : false;
      if (op.collation) operation.collation = op.collation;
      return addToOperationsList(this, common.UPDATE, operation);
    }
    if (op.removeOne || op.removeMany || op.deleteOne && op.deleteOne.q || op.deleteMany && op.deleteMany.q) {
      op[key].limit = op.removeOne ? 1 : 0;
      return addToOperationsList(this, common.REMOVE, op[key]);
    }
    if (op.deleteOne || op.deleteMany) {
      var limit = op.deleteOne ? 1 : 0;
      operation = {
        q: op[key].filter,
        limit: limit
      };
      if (op.collation) operation.collation = op.collation;
      return addToOperationsList(this, common.REMOVE, operation);
    }
    if (op.insertOne && op.insertOne.document == null) {
      if (forceServerObjectId !== true && op.insertOne._id == null) op.insertOne._id = new ObjectID();
      return addToOperationsList(this, common.INSERT, op.insertOne);
    } else if (op.insertOne && op.insertOne.document) {
      if (forceServerObjectId !== true && op.insertOne.document._id == null) op.insertOne.document._id = new ObjectID();
      return addToOperationsList(this, common.INSERT, op.insertOne.document);
    }
    if (op.insertMany) {
      for (var i = 0; i < op.insertMany.length; i++) {
        if (forceServerObjectId !== true && op.insertMany[i]._id == null) op.insertMany[i]._id = new ObjectID();
        addToOperationsList(this, common.INSERT, op.insertMany[i]);
      }
      return;
    }
    throw toError("bulkWrite only supports insertOne, insertMany, updateOne, updateMany, removeOne, removeMany, deleteOne, deleteMany");
  };
  OrderedBulkOperation.prototype.insert = function (document) {
    if (this.s.collection.s.db.options.forceServerObjectId !== true && document._id == null) document._id = new ObjectID();
    return addToOperationsList(this, common.INSERT, document);
  };
  OrderedBulkOperation.prototype.find = function (selector) {
    if (!selector) {
      throw toError("Bulk find operation must specify a selector");
    }
    this.s.currentOp = { selector: selector };
    return new FindOperatorsOrdered(this);
  };
  Object.defineProperty(OrderedBulkOperation.prototype, 'length', {
    enumerable: true,
    get: function () {
      return this.s.currentIndex;
    }
  });
  var executeCommands = function (self, callback) {
    if (self.s.batches.length == 0) {
      return handleCallback(callback, null, new BulkWriteResult(self.s.bulkResult));
    }
    var batch = self.s.batches.shift();
    var resultHandler = function (err, result) {
      if (err && err.driver || err && err.message) {
        return handleCallback(callback, err);
      }
      if (err) err.ok = 0;
      var mergeResult = mergeBatchResults(true, batch, self.s.bulkResult, err, result);
      if (mergeResult != null) {
        return handleCallback(callback, null, new BulkWriteResult(self.s.bulkResult));
      }
      if (self.s.bulkResult.writeErrors.length > 0) {
        return handleCallback(callback, toError(self.s.bulkResult.writeErrors[0]), new BulkWriteResult(self.s.bulkResult));
      }
      executeCommands(self, callback);
    };
    var finalOptions = { ordered: true };
    if (self.s.writeConcern != null) {
      finalOptions.writeConcern = self.s.writeConcern;
    }
    if (self.operationId) {
      resultHandler.operationId = self.operationId;
    }
    if (self.s.options.serializeFunctions) {
      finalOptions.serializeFunctions = true;
    }
    if (self.s.options.ignoreUndefined) {
      finalOptions.ignoreUndefined = true;
    }
    if (self.s.bypassDocumentValidation == true) {
      finalOptions.bypassDocumentValidation = true;
    }
    try {
      if (batch.batchType == common.INSERT) {
        self.s.topology.insert(self.s.collection.namespace, batch.operations, finalOptions, resultHandler);
      } else if (batch.batchType == common.UPDATE) {
        self.s.topology.update(self.s.collection.namespace, batch.operations, finalOptions, resultHandler);
      } else if (batch.batchType == common.REMOVE) {
        self.s.topology.remove(self.s.collection.namespace, batch.operations, finalOptions, resultHandler);
      }
    } catch (err) {
      err.ok = 0;
      handleCallback(callback, null, mergeBatchResults(false, batch, self.s.bulkResult, err, null));
    }
  };
  OrderedBulkOperation.prototype.execute = function (_writeConcern, callback) {
    var self = this;
    if (this.s.executed) throw new toError("batch cannot be re-executed");
    if (typeof _writeConcern == 'function') {
      callback = _writeConcern;
    } else if (_writeConcern && typeof _writeConcern == 'object') {
      this.s.writeConcern = _writeConcern;
    }
    if (this.s.currentBatch) this.s.batches.push(this.s.currentBatch);
    if (this.s.batches.length == 0) {
      throw toError("Invalid Operation, No operations in bulk");
    }
    if (typeof callback == 'function') {
      return executeCommands(this, callback);
    }
    return new this.s.promiseLibrary(function (resolve, reject) {
      executeCommands(self, function (err, r) {
        if (err) return reject(err);
        resolve(r);
      });
    });
  };
  define.classMethod('execute', {
    callback: true,
    promise: false
  });
  var initializeOrderedBulkOp = function (topology, collection, options) {
    return new OrderedBulkOperation(topology, collection, options);
  };
  initializeOrderedBulkOp.OrderedBulkOperation = OrderedBulkOperation;
  module.exports = initializeOrderedBulkOp;
  module.exports.Bulk = OrderedBulkOperation;
  return module.exports;
});
$__System.registerDynamic('185', ['18e', '18f', '166', '17f', '188', '180', '18d', '184', '182', '181', '190', '2a', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer, process) {
    "use strict";

    var checkCollectionName = $__require('18e').checkCollectionName,
        ObjectID = $__require('18f').BSON.ObjectID,
        Long = $__require('18f').BSON.Long,
        Code = $__require('18f').BSON.Code,
        f = $__require('166').format,
        AggregationCursor = $__require('17f'),
        MongoError = $__require('18f').MongoError,
        shallowClone = $__require('18e').shallowClone,
        isObject = $__require('18e').isObject,
        toError = $__require('18e').toError,
        normalizeHintField = $__require('18e').normalizeHintField,
        handleCallback = $__require('18e').handleCallback,
        decorateCommand = $__require('18e').decorateCommand,
        formattedOrderClause = $__require('18e').formattedOrderClause,
        ReadPreference = $__require('188'),
        CoreReadPreference = $__require('18f').ReadPreference,
        CommandCursor = $__require('180'),
        Define = $__require('18d'),
        Cursor = $__require('184'),
        unordered = $__require('182'),
        ordered = $__require('181'),
        assign = $__require('18e').assign;
    var Collection = function (db, topology, dbName, name, pkFactory, options) {
      checkCollectionName(name);
      var internalHint = null;
      var slaveOk = options == null || options.slaveOk == null ? db.slaveOk : options.slaveOk;
      var serializeFunctions = options == null || options.serializeFunctions == null ? db.s.options.serializeFunctions : options.serializeFunctions;
      var raw = options == null || options.raw == null ? db.s.options.raw : options.raw;
      var promoteLongs = options == null || options.promoteLongs == null ? db.s.options.promoteLongs : options.promoteLongs;
      var promoteValues = options == null || options.promoteValues == null ? db.s.options.promoteValues : options.promoteValues;
      var promoteBuffers = options == null || options.promoteBuffers == null ? db.s.options.promoteBuffers : options.promoteBuffers;
      var readPreference = null;
      var collectionHint = null;
      var namespace = f("%s.%s", dbName, name);
      var promiseLibrary = options.promiseLibrary;
      if (!promiseLibrary) {
        promiseLibrary = typeof global.Promise == 'function' ? global.Promise : $__require('190').Promise;
      }
      if (options && options.readPreference) {
        readPreference = options.readPreference;
      } else if (db.options.readPreference) {
        readPreference = db.options.readPreference;
      }
      pkFactory = pkFactory == null ? ObjectID : pkFactory;
      this.s = {
        pkFactory: pkFactory,
        db: db,
        topology: topology,
        dbName: dbName,
        options: options,
        namespace: namespace,
        readPreference: readPreference,
        slaveOk: slaveOk,
        serializeFunctions: serializeFunctions,
        raw: raw,
        promoteLongs: promoteLongs,
        promoteValues: promoteValues,
        promoteBuffers: promoteBuffers,
        internalHint: internalHint,
        collectionHint: collectionHint,
        name: name,
        promiseLibrary: promiseLibrary,
        readConcern: options.readConcern
      };
    };
    var define = Collection.define = new Define('Collection', Collection, false);
    Object.defineProperty(Collection.prototype, 'collectionName', {
      enumerable: true,
      get: function () {
        return this.s.name;
      }
    });
    Object.defineProperty(Collection.prototype, 'namespace', {
      enumerable: true,
      get: function () {
        return this.s.namespace;
      }
    });
    Object.defineProperty(Collection.prototype, 'readConcern', {
      enumerable: true,
      get: function () {
        return this.s.readConcern || { level: 'local' };
      }
    });
    Object.defineProperty(Collection.prototype, 'writeConcern', {
      enumerable: true,
      get: function () {
        var ops = {};
        if (this.s.options.w != null) ops.w = this.s.options.w;
        if (this.s.options.j != null) ops.j = this.s.options.j;
        if (this.s.options.fsync != null) ops.fsync = this.s.options.fsync;
        if (this.s.options.wtimeout != null) ops.wtimeout = this.s.options.wtimeout;
        return ops;
      }
    });
    Object.defineProperty(Collection.prototype, "hint", {
      enumerable: true,
      get: function () {
        return this.s.collectionHint;
      },
      set: function (v) {
        this.s.collectionHint = normalizeHintField(v);
      }
    });
    Collection.prototype.find = function () {
      var options,
          args = Array.prototype.slice.call(arguments, 0),
          has_callback = typeof args[args.length - 1] === 'function',
          has_weird_callback = typeof args[0] === 'function',
          callback = has_callback ? args.pop() : has_weird_callback ? args.shift() : null,
          len = args.length,
          selector = len >= 1 ? args[0] : {},
          fields = len >= 2 ? args[1] : undefined;
      if (len === 1 && has_weird_callback) {
        selector = {};
        options = args[0];
      }
      if (len === 2 && fields !== undefined && !Array.isArray(fields)) {
        var fieldKeys = Object.keys(fields);
        var is_option = false;
        for (var i = 0; i < fieldKeys.length; i++) {
          if (testForFields[fieldKeys[i]] != null) {
            is_option = true;
            break;
          }
        }
        if (is_option) {
          options = fields;
          fields = undefined;
        } else {
          options = {};
        }
      } else if (len === 2 && Array.isArray(fields) && !Array.isArray(fields[0])) {
        var newFields = {};
        for (i = 0; i < fields.length; i++) {
          newFields[fields[i]] = 1;
        }
        fields = newFields;
      }
      if (3 === len) {
        options = args[2];
      }
      selector = selector == null ? {} : selector;
      var object = selector;
      if (Buffer.isBuffer(object)) {
        var object_size = object[0] | object[1] << 8 | object[2] << 16 | object[3] << 24;
        if (object_size != object.length) {
          var error = new Error("query selector raw message size does not match message header size [" + object.length + "] != [" + object_size + "]");
          error.name = 'MongoError';
          throw error;
        }
      }
      object = fields;
      if (Buffer.isBuffer(object)) {
        object_size = object[0] | object[1] << 8 | object[2] << 16 | object[3] << 24;
        if (object_size != object.length) {
          error = new Error("query fields raw message size does not match message header size [" + object.length + "] != [" + object_size + "]");
          error.name = 'MongoError';
          throw error;
        }
      }
      if (selector instanceof ObjectID || selector != null && selector._bsontype == 'ObjectID') {
        selector = { _id: selector };
      }
      if (options && options.fields && !Buffer.isBuffer(options.fields)) {
        fields = {};
        if (Array.isArray(options.fields)) {
          if (!options.fields.length) {
            fields['_id'] = 1;
          } else {
            var l = options.fields.length;
            for (i = 0; i < l; i++) {
              fields[options.fields[i]] = 1;
            }
          }
        } else {
          fields = options.fields;
        }
      }
      if (!options) options = {};
      var newOptions = {};
      for (var key in options) {
        newOptions[key] = options[key];
      }
      newOptions.skip = len > 3 ? args[2] : options.skip ? options.skip : 0;
      newOptions.limit = len > 3 ? args[3] : options.limit ? options.limit : 0;
      newOptions.raw = options.raw != null && typeof options.raw === 'boolean' ? options.raw : this.s.raw;
      newOptions.hint = options.hint != null ? normalizeHintField(options.hint) : this.s.collectionHint;
      newOptions.timeout = len == 5 ? args[4] : typeof options.timeout === 'undefined' ? undefined : options.timeout;
      newOptions.slaveOk = options.slaveOk != null ? options.slaveOk : this.s.db.slaveOk;
      newOptions = getReadPreference(this, newOptions, this.s.db, this);
      if (newOptions.readPreference != null && (newOptions.readPreference != 'primary' || newOptions.readPreference.mode != 'primary')) {
        newOptions.slaveOk = true;
      }
      if (selector != null && typeof selector != 'object') {
        throw MongoError.create({
          message: "query selector must be an object",
          driver: true
        });
      }
      var findCommand = {
        find: this.s.namespace,
        limit: newOptions.limit,
        skip: newOptions.skip,
        query: selector
      };
      if (typeof newOptions.awaitdata == 'boolean') {
        newOptions.awaitData = newOptions.awaitdata;
      }
      if (typeof newOptions.timeout == 'boolean') newOptions.noCursorTimeout = newOptions.timeout;
      for (var name in newOptions) {
        if (newOptions[name] != null) findCommand[name] = newOptions[name];
      }
      var formatFields = function (fields) {
        var object = {};
        if (Array.isArray(fields)) {
          for (var i = 0; i < fields.length; i++) {
            if (Array.isArray(fields[i])) {
              object[fields[i][0]] = fields[i][1];
            } else {
              object[fields[i][0]] = 1;
            }
          }
        } else {
          object = fields;
        }
        return object;
      };
      if (fields) findCommand.fields = formatFields(fields);
      newOptions.db = this.s.db;
      newOptions.promiseLibrary = this.s.promiseLibrary;
      if (newOptions.raw == null && typeof this.s.raw == 'boolean') newOptions.raw = this.s.raw;
      if (newOptions.promoteLongs == null && typeof this.s.promoteLongs == 'boolean') newOptions.promoteLongs = this.s.promoteLongs;
      if (newOptions.promoteValues == null && typeof this.s.promoteValues == 'boolean') newOptions.promoteValues = this.s.promoteValues;
      if (newOptions.promoteBuffers == null && typeof this.s.promoteBuffers == 'boolean') newOptions.promoteBuffers = this.s.promoteBuffers;
      if (findCommand.sort) {
        findCommand.sort = formattedOrderClause(findCommand.sort);
      }
      if (this.s.readConcern) {
        findCommand.readConcern = this.s.readConcern;
      }
      decorateWithCollation(findCommand, this, options);
      if (typeof callback == 'function') return handleCallback(callback, null, this.s.topology.cursor(this.s.namespace, findCommand, newOptions));
      return this.s.topology.cursor(this.s.namespace, findCommand, newOptions);
    };
    define.classMethod('find', {
      callback: false,
      promise: false,
      returns: [Cursor]
    });
    Collection.prototype.insertOne = function (doc, options, callback) {
      var self = this;
      if (typeof options == 'function') callback = options, options = {};
      options = options || {};
      if (Array.isArray(doc) && typeof callback == 'function') {
        return callback(MongoError.create({
          message: 'doc parameter must be an object',
          driver: true
        }));
      } else if (Array.isArray(doc)) {
        return new this.s.promiseLibrary(function (resolve, reject) {
          reject(MongoError.create({
            message: 'doc parameter must be an object',
            driver: true
          }));
        });
      }
      if (this.s.options.ignoreUndefined) {
        options = shallowClone(options);
        options.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      if (typeof callback == 'function') return insertOne(self, doc, options, callback);
      return new this.s.promiseLibrary(function (resolve, reject) {
        insertOne(self, doc, options, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var insertOne = function (self, doc, options, callback) {
      insertDocuments(self, [doc], options, function (err, r) {
        if (callback == null) return;
        if (err && callback) return callback(err);
        if (r == null) return callback(null, { result: { ok: 1 } });
        r.insertedCount = r.result.n;
        r.insertedId = doc._id;
        if (callback) callback(null, r);
      });
    };
    var mapInserManyResults = function (docs, r) {
      var ids = r.getInsertedIds();
      var keys = Object.keys(ids);
      var finalIds = new Array(keys.length);
      for (var i = 0; i < keys.length; i++) {
        if (ids[keys[i]]._id) {
          finalIds[ids[keys[i]].index] = ids[keys[i]]._id;
        }
      }
      var finalResult = {
        result: {
          ok: 1,
          n: r.insertedCount
        },
        ops: docs,
        insertedCount: r.insertedCount,
        insertedIds: finalIds
      };
      if (r.getLastOp()) {
        finalResult.result.opTime = r.getLastOp();
      }
      return finalResult;
    };
    define.classMethod('insertOne', {
      callback: true,
      promise: true
    });
    Collection.prototype.insertMany = function (docs, options, callback) {
      var self = this;
      if (typeof options == 'function') callback = options, options = {};
      options = options || { ordered: true };
      if (!Array.isArray(docs) && typeof callback == 'function') {
        return callback(MongoError.create({
          message: 'docs parameter must be an array of documents',
          driver: true
        }));
      } else if (!Array.isArray(docs)) {
        return new this.s.promiseLibrary(function (resolve, reject) {
          reject(MongoError.create({
            message: 'docs parameter must be an array of documents',
            driver: true
          }));
        });
      }
      if (typeof options.checkKeys != 'boolean') {
        options.checkKeys = true;
      }
      options['serializeFunctions'] = options['serializeFunctions'] || self.s.serializeFunctions;
      var forceServerObjectId = typeof options.forceServerObjectId == 'boolean' ? options.forceServerObjectId : self.s.db.options.forceServerObjectId;
      if (forceServerObjectId !== true) {
        for (var i = 0; i < docs.length; i++) {
          if (docs[i]._id == null) docs[i]._id = self.s.pkFactory.createPk();
        }
      }
      var operations = [{ insertMany: docs }];
      if (typeof callback == 'function') return bulkWrite(self, operations, options, function (err, r) {
        if (err) return callback(err, r);
        callback(null, mapInserManyResults(docs, r));
      });
      return new this.s.promiseLibrary(function (resolve, reject) {
        bulkWrite(self, operations, options, function (err, r) {
          if (err) return reject(err);
          resolve(mapInserManyResults(docs, r));
        });
      });
    };
    define.classMethod('insertMany', {
      callback: true,
      promise: true
    });
    Collection.prototype.bulkWrite = function (operations, options, callback) {
      var self = this;
      if (typeof options == 'function') callback = options, options = {};
      options = options || { ordered: true };
      if (!Array.isArray(operations)) {
        throw MongoError.create({
          message: "operations must be an array of documents",
          driver: true
        });
      }
      if (typeof callback == 'function') return bulkWrite(self, operations, options, callback);
      return new this.s.promiseLibrary(function (resolve, reject) {
        bulkWrite(self, operations, options, function (err, r) {
          if (err && r == null) return reject(err);
          resolve(r);
        });
      });
    };
    var bulkWrite = function (self, operations, options, callback) {
      if (self.s.options.ignoreUndefined) {
        options = shallowClone(options);
        options.ignoreUndefined = self.s.options.ignoreUndefined;
      }
      var bulk = options.ordered == true || options.ordered == null ? self.initializeOrderedBulkOp(options) : self.initializeUnorderedBulkOp(options);
      var collation = false;
      try {
        for (var i = 0; i < operations.length; i++) {
          var key = Object.keys(operations[i])[0];
          if (operations[i][key].collation) {
            collation = true;
          }
          bulk.raw(operations[i]);
        }
      } catch (err) {
        return callback(err, null);
      }
      var finalOptions = writeConcern(shallowClone(options), self.s.db, self, options);
      var writeCon = finalOptions.writeConcern ? finalOptions.writeConcern : {};
      var capabilities = self.s.topology.capabilities();
      if (collation && capabilities && !capabilities.commandsTakeCollation) {
        return callback(new MongoError(f('server/primary/mongos does not support collation')));
      }
      bulk.execute(writeCon, function (err, r) {
        if (!r && err) return callback(err, null);
        if (r && r.hasWriteErrors() && r.getWriteErrorCount() == 1) {
          return callback(toError(r.getWriteErrorAt(0)), r);
        }
        r.insertedCount = r.nInserted;
        r.matchedCount = r.nMatched;
        r.modifiedCount = r.nModified || 0;
        r.deletedCount = r.nRemoved;
        r.upsertedCount = r.getUpsertedIds().length;
        r.upsertedIds = {};
        r.insertedIds = {};
        r.n = r.insertedCount;
        var inserted = r.getInsertedIds();
        for (var i = 0; i < inserted.length; i++) {
          r.insertedIds[inserted[i].index] = inserted[i]._id;
        }
        var upserted = r.getUpsertedIds();
        for (i = 0; i < upserted.length; i++) {
          r.upsertedIds[upserted[i].index] = upserted[i]._id;
        }
        if (r.hasWriteErrors()) {
          var errors = r.getWriteErrors();
          return callback(toError({
            message: 'write operation failed',
            code: errors[0].code,
            writeErrors: errors
          }), r);
        }
        if (r.getWriteConcernError()) {
          return callback(toError(r.getWriteConcernError()), r);
        }
        callback(null, r);
      });
    };
    var insertDocuments = function (self, docs, options, callback) {
      if (typeof options == 'function') callback = options, options = {};
      options = options || {};
      docs = Array.isArray(docs) ? docs : [docs];
      var finalOptions = writeConcern(shallowClone(options), self.s.db, self, options);
      if (typeof finalOptions.checkKeys != 'boolean') finalOptions.checkKeys = true;
      if (finalOptions.keepGoing == true) finalOptions.ordered = false;
      finalOptions['serializeFunctions'] = options['serializeFunctions'] || self.s.serializeFunctions;
      var forceServerObjectId = typeof options.forceServerObjectId == 'boolean' ? options.forceServerObjectId : self.s.db.options.forceServerObjectId;
      if (forceServerObjectId !== true) {
        for (var i = 0; i < docs.length; i++) {
          if (docs[i]._id == null) docs[i]._id = self.s.pkFactory.createPk();
        }
      }
      self.s.topology.insert(self.s.namespace, docs, finalOptions, function (err, result) {
        if (callback == null) return;
        if (err) return handleCallback(callback, err);
        if (result == null) return handleCallback(callback, null, null);
        if (result.result.code) return handleCallback(callback, toError(result.result));
        if (result.result.writeErrors) return handleCallback(callback, toError(result.result.writeErrors[0]));
        result.ops = docs;
        handleCallback(callback, null, result);
      });
    };
    define.classMethod('bulkWrite', {
      callback: true,
      promise: true
    });
    Collection.prototype.insert = function (docs, options, callback) {
      if (typeof options == 'function') callback = options, options = {};
      options = options || { ordered: false };
      docs = !Array.isArray(docs) ? [docs] : docs;
      if (options.keepGoing == true) {
        options.ordered = false;
      }
      return this.insertMany(docs, options, callback);
    };
    define.classMethod('insert', {
      callback: true,
      promise: true
    });
    Collection.prototype.updateOne = function (filter, update, options, callback) {
      var self = this;
      if (typeof options == 'function') callback = options, options = {};
      options = shallowClone(options);
      if (this.s.options.ignoreUndefined) {
        options = shallowClone(options);
        options.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      if (typeof callback == 'function') return updateOne(self, filter, update, options, callback);
      return new this.s.promiseLibrary(function (resolve, reject) {
        updateOne(self, filter, update, options, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var updateOne = function (self, filter, update, options, callback) {
      options.multi = false;
      updateDocuments(self, filter, update, options, function (err, r) {
        if (callback == null) return;
        if (err && callback) return callback(err);
        if (r == null) return callback(null, { result: { ok: 1 } });
        r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;
        r.upsertedId = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? r.result.upserted[0]._id : null;
        r.upsertedCount = Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;
        r.matchedCount = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;
        if (callback) callback(null, r);
      });
    };
    define.classMethod('updateOne', {
      callback: true,
      promise: true
    });
    Collection.prototype.replaceOne = function (filter, doc, options, callback) {
      var self = this;
      if (typeof options == 'function') callback = options, options = {};
      options = shallowClone(options);
      if (this.s.options.ignoreUndefined) {
        options = shallowClone(options);
        options.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      if (typeof callback == 'function') return replaceOne(self, filter, doc, options, callback);
      return new this.s.promiseLibrary(function (resolve, reject) {
        replaceOne(self, filter, doc, options, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var replaceOne = function (self, filter, doc, options, callback) {
      options.multi = false;
      updateDocuments(self, filter, doc, options, function (err, r) {
        if (callback == null) return;
        if (err && callback) return callback(err);
        if (r == null) return callback(null, { result: { ok: 1 } });
        r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;
        r.upsertedId = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? r.result.upserted[0]._id : null;
        r.upsertedCount = Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;
        r.matchedCount = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;
        r.ops = [doc];
        if (callback) callback(null, r);
      });
    };
    define.classMethod('replaceOne', {
      callback: true,
      promise: true
    });
    Collection.prototype.updateMany = function (filter, update, options, callback) {
      var self = this;
      if (typeof options == 'function') callback = options, options = {};
      options = shallowClone(options);
      if (this.s.options.ignoreUndefined) {
        options = shallowClone(options);
        options.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      if (typeof callback == 'function') return updateMany(self, filter, update, options, callback);
      return new this.s.promiseLibrary(function (resolve, reject) {
        updateMany(self, filter, update, options, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var updateMany = function (self, filter, update, options, callback) {
      options.multi = true;
      updateDocuments(self, filter, update, options, function (err, r) {
        if (callback == null) return;
        if (err && callback) return callback(err);
        if (r == null) return callback(null, { result: { ok: 1 } });
        r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;
        r.upsertedId = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? r.result.upserted[0]._id : null;
        r.upsertedCount = Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;
        r.matchedCount = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;
        if (callback) callback(null, r);
      });
    };
    define.classMethod('updateMany', {
      callback: true,
      promise: true
    });
    var updateDocuments = function (self, selector, document, options, callback) {
      if ('function' === typeof options) callback = options, options = null;
      if (options == null) options = {};
      if (!('function' === typeof callback)) callback = null;
      if (selector == null || typeof selector != 'object') return callback(toError("selector must be a valid JavaScript object"));
      if (document == null || typeof document != 'object') return callback(toError("document must be a valid JavaScript object"));
      var finalOptions = writeConcern(shallowClone(options), self.s.db, self, options);
      finalOptions['serializeFunctions'] = options['serializeFunctions'] || self.s.serializeFunctions;
      var op = {
        q: selector,
        u: document
      };
      op.upsert = typeof options.upsert == 'boolean' ? options.upsert : false;
      op.multi = typeof options.multi == 'boolean' ? options.multi : false;
      decorateWithCollation(finalOptions, self, options);
      self.s.topology.update(self.s.namespace, [op], finalOptions, function (err, result) {
        if (callback == null) return;
        if (err) return handleCallback(callback, err, null);
        if (result == null) return handleCallback(callback, null, null);
        if (result.result.code) return handleCallback(callback, toError(result.result));
        if (result.result.writeErrors) return handleCallback(callback, toError(result.result.writeErrors[0]));
        handleCallback(callback, null, result);
      });
    };
    Collection.prototype.update = function (selector, document, options, callback) {
      var self = this;
      if (this.s.options.ignoreUndefined) {
        options = shallowClone(options);
        options.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      if (typeof callback == 'function') return updateDocuments(self, selector, document, options, callback);
      return new this.s.promiseLibrary(function (resolve, reject) {
        updateDocuments(self, selector, document, options, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    define.classMethod('update', {
      callback: true,
      promise: true
    });
    Collection.prototype.deleteOne = function (filter, options, callback) {
      var self = this;
      if (typeof options == 'function') callback = options, options = {};
      options = shallowClone(options);
      if (this.s.options.ignoreUndefined) {
        options = shallowClone(options);
        options.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      if (typeof callback == 'function') return deleteOne(self, filter, options, callback);
      return new this.s.promiseLibrary(function (resolve, reject) {
        deleteOne(self, filter, options, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var deleteOne = function (self, filter, options, callback) {
      options.single = true;
      removeDocuments(self, filter, options, function (err, r) {
        if (callback == null) return;
        if (err && callback) return callback(err);
        if (r == null) return callback(null, { result: { ok: 1 } });
        r.deletedCount = r.result.n;
        if (callback) callback(null, r);
      });
    };
    define.classMethod('deleteOne', {
      callback: true,
      promise: true
    });
    Collection.prototype.removeOne = Collection.prototype.deleteOne;
    define.classMethod('removeOne', {
      callback: true,
      promise: true
    });
    Collection.prototype.deleteMany = function (filter, options, callback) {
      var self = this;
      if (typeof options == 'function') callback = options, options = {};
      options = shallowClone(options);
      if (this.s.options.ignoreUndefined) {
        options = shallowClone(options);
        options.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      if (typeof callback == 'function') return deleteMany(self, filter, options, callback);
      return new this.s.promiseLibrary(function (resolve, reject) {
        deleteMany(self, filter, options, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var deleteMany = function (self, filter, options, callback) {
      options.single = false;
      removeDocuments(self, filter, options, function (err, r) {
        if (callback == null) return;
        if (err && callback) return callback(err);
        if (r == null) return callback(null, { result: { ok: 1 } });
        r.deletedCount = r.result.n;
        if (callback) callback(null, r);
      });
    };
    var removeDocuments = function (self, selector, options, callback) {
      if (typeof options == 'function') {
        callback = options, options = {};
      } else if (typeof selector === 'function') {
        callback = selector;
        options = {};
        selector = {};
      }
      options = options || {};
      var finalOptions = writeConcern(shallowClone(options), self.s.db, self, options);
      if (selector == null) selector = {};
      var op = {
        q: selector,
        limit: 0
      };
      if (options.single) op.limit = 1;
      decorateWithCollation(finalOptions, self, options);
      self.s.topology.remove(self.s.namespace, [op], finalOptions, function (err, result) {
        if (callback == null) return;
        if (err) return handleCallback(callback, err, null);
        if (result == null) return handleCallback(callback, null, null);
        if (result.result.code) return handleCallback(callback, toError(result.result));
        if (result.result.writeErrors) return handleCallback(callback, toError(result.result.writeErrors[0]));
        handleCallback(callback, null, result);
      });
    };
    define.classMethod('deleteMany', {
      callback: true,
      promise: true
    });
    Collection.prototype.removeMany = Collection.prototype.deleteMany;
    define.classMethod('removeMany', {
      callback: true,
      promise: true
    });
    Collection.prototype.remove = function (selector, options, callback) {
      var self = this;
      if (this.s.options.ignoreUndefined) {
        options = shallowClone(options);
        options.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      if (typeof callback == 'function') return removeDocuments(self, selector, options, callback);
      return new this.s.promiseLibrary(function (resolve, reject) {
        removeDocuments(self, selector, options, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    define.classMethod('remove', {
      callback: true,
      promise: true
    });
    Collection.prototype.save = function (doc, options, callback) {
      var self = this;
      if (typeof options == 'function') callback = options, options = {};
      options = options || {};
      if (this.s.options.ignoreUndefined) {
        options = shallowClone(options);
        options.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      if (typeof callback == 'function') return save(self, doc, options, callback);
      return new this.s.promiseLibrary(function (resolve, reject) {
        save(self, doc, options, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var save = function (self, doc, options, callback) {
      var finalOptions = writeConcern(shallowClone(options), self.s.db, self, options);
      if (doc._id != null) {
        finalOptions.upsert = true;
        return updateDocuments(self, { _id: doc._id }, doc, finalOptions, callback);
      }
      insertDocuments(self, [doc], options, function (err, r) {
        if (callback == null) return;
        if (doc == null) return handleCallback(callback, null, null);
        if (err) return handleCallback(callback, err, null);
        handleCallback(callback, null, r);
      });
    };
    define.classMethod('save', {
      callback: true,
      promise: true
    });
    Collection.prototype.findOne = function () {
      var self = this;
      var args = Array.prototype.slice.call(arguments, 0);
      var callback = args.pop();
      if (typeof callback != 'function') args.push(callback);
      if (typeof callback == 'function') return findOne(self, args, callback);
      return new this.s.promiseLibrary(function (resolve, reject) {
        findOne(self, args, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var findOne = function (self, args, callback) {
      var cursor = self.find.apply(self, args).limit(-1).batchSize(1);
      cursor.next(function (err, item) {
        if (err != null) return handleCallback(callback, toError(err), null);
        handleCallback(callback, null, item);
      });
    };
    define.classMethod('findOne', {
      callback: true,
      promise: true
    });
    Collection.prototype.rename = function (newName, opt, callback) {
      var self = this;
      if (typeof opt == 'function') callback = opt, opt = {};
      opt = assign({}, opt, { readPreference: ReadPreference.PRIMARY });
      if (typeof callback == 'function') return rename(self, newName, opt, callback);
      return new this.s.promiseLibrary(function (resolve, reject) {
        rename(self, newName, opt, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var rename = function (self, newName, opt, callback) {
      checkCollectionName(newName);
      var renameCollection = f("%s.%s", self.s.dbName, self.s.name);
      var toCollection = f("%s.%s", self.s.dbName, newName);
      var dropTarget = typeof opt.dropTarget == 'boolean' ? opt.dropTarget : false;
      var cmd = {
        'renameCollection': renameCollection,
        'to': toCollection,
        'dropTarget': dropTarget
      };
      decorateWithWriteConcern(cmd, self, opt);
      self.s.db.admin().command(cmd, opt, function (err, doc) {
        if (err) return handleCallback(callback, err, null);
        if (doc.errmsg) return handleCallback(callback, toError(doc), null);
        try {
          return handleCallback(callback, null, new Collection(self.s.db, self.s.topology, self.s.dbName, newName, self.s.pkFactory, self.s.options));
        } catch (err) {
          return handleCallback(callback, toError(err), null);
        }
      });
    };
    define.classMethod('rename', {
      callback: true,
      promise: true
    });
    Collection.prototype.drop = function (options, callback) {
      var self = this;
      if (typeof options == 'function') callback = options, options = {};
      options = options || {};
      if (typeof callback == 'function') return self.s.db.dropCollection(self.s.name, options, callback);
      return new this.s.promiseLibrary(function (resolve, reject) {
        self.s.db.dropCollection(self.s.name, options, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    define.classMethod('drop', {
      callback: true,
      promise: true
    });
    Collection.prototype.options = function (callback) {
      var self = this;
      if (typeof callback == 'function') return options(self, callback);
      return new this.s.promiseLibrary(function (resolve, reject) {
        options(self, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var options = function (self, callback) {
      self.s.db.listCollections({ name: self.s.name }).toArray(function (err, collections) {
        if (err) return handleCallback(callback, err);
        if (collections.length == 0) {
          return handleCallback(callback, MongoError.create({
            message: f("collection %s not found", self.s.namespace),
            driver: true
          }));
        }
        handleCallback(callback, err, collections[0].options || null);
      });
    };
    define.classMethod('options', {
      callback: true,
      promise: true
    });
    Collection.prototype.isCapped = function (callback) {
      var self = this;
      if (typeof callback == 'function') return isCapped(self, callback);
      return new this.s.promiseLibrary(function (resolve, reject) {
        isCapped(self, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var isCapped = function (self, callback) {
      self.options(function (err, document) {
        if (err) return handleCallback(callback, err);
        handleCallback(callback, null, document && document.capped);
      });
    };
    define.classMethod('isCapped', {
      callback: true,
      promise: true
    });
    Collection.prototype.createIndex = function (fieldOrSpec, options, callback) {
      var self = this;
      var args = Array.prototype.slice.call(arguments, 1);
      callback = args.pop();
      if (typeof callback != 'function') args.push(callback);
      options = args.length ? args.shift() || {} : {};
      options = typeof callback === 'function' ? options : callback;
      options = options == null ? {} : options;
      if (typeof callback == 'function') return createIndex(self, fieldOrSpec, options, callback);
      return new this.s.promiseLibrary(function (resolve, reject) {
        createIndex(self, fieldOrSpec, options, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var createIndex = function (self, fieldOrSpec, options, callback) {
      self.s.db.createIndex(self.s.name, fieldOrSpec, options, callback);
    };
    define.classMethod('createIndex', {
      callback: true,
      promise: true
    });
    Collection.prototype.createIndexes = function (indexSpecs, callback) {
      var self = this;
      if (typeof callback == 'function') return createIndexes(self, indexSpecs, callback);
      return new this.s.promiseLibrary(function (resolve, reject) {
        createIndexes(self, indexSpecs, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var createIndexes = function (self, indexSpecs, callback) {
      var capabilities = self.s.topology.capabilities();
      for (var i = 0; i < indexSpecs.length; i++) {
        if (indexSpecs[i].name == null) {
          var keys = [];
          if (indexSpecs[i].collation && capabilities && !capabilities.commandsTakeCollation) {
            return callback(new MongoError(f('server/primary/mongos does not support collation')));
          }
          for (var name in indexSpecs[i].key) {
            keys.push(f('%s_%s', name, indexSpecs[i].key[name]));
          }
          indexSpecs[i].name = keys.join('_');
        }
      }
      self.s.db.command({
        createIndexes: self.s.name,
        indexes: indexSpecs
      }, { readPreference: ReadPreference.PRIMARY }, callback);
    };
    define.classMethod('createIndexes', {
      callback: true,
      promise: true
    });
    Collection.prototype.dropIndex = function (indexName, options, callback) {
      var self = this;
      var args = Array.prototype.slice.call(arguments, 1);
      callback = args.pop();
      if (typeof callback != 'function') args.push(callback);
      options = args.length ? args.shift() || {} : {};
      options.readPreference = ReadPreference.PRIMARY;
      if (typeof callback == 'function') return dropIndex(self, indexName, options, callback);
      return new this.s.promiseLibrary(function (resolve, reject) {
        dropIndex(self, indexName, options, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var dropIndex = function (self, indexName, options, callback) {
      var cmd = {
        'dropIndexes': self.s.name,
        'index': indexName
      };
      decorateWithWriteConcern(cmd, self, options);
      self.s.db.command(cmd, options, function (err, result) {
        if (typeof callback != 'function') return;
        if (err) return handleCallback(callback, err, null);
        handleCallback(callback, null, result);
      });
    };
    define.classMethod('dropIndex', {
      callback: true,
      promise: true
    });
    Collection.prototype.dropIndexes = function (options, callback) {
      var self = this;
      if (typeof options == 'function') callback = options, options = {};
      options = options || {};
      if (typeof callback == 'function') return dropIndexes(self, options, callback);
      return new this.s.promiseLibrary(function (resolve, reject) {
        dropIndexes(self, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var dropIndexes = function (self, options, callback) {
      self.dropIndex('*', options, function (err) {
        if (err) return handleCallback(callback, err, false);
        handleCallback(callback, null, true);
      });
    };
    define.classMethod('dropIndexes', {
      callback: true,
      promise: true
    });
    Collection.prototype.dropAllIndexes = Collection.prototype.dropIndexes;
    define.classMethod('dropAllIndexes', {
      callback: true,
      promise: true
    });
    Collection.prototype.reIndex = function (options, callback) {
      var self = this;
      if (typeof options == 'function') callback = options, options = {};
      options = options || {};
      if (typeof callback == 'function') return reIndex(self, options, callback);
      return new this.s.promiseLibrary(function (resolve, reject) {
        reIndex(self, options, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var reIndex = function (self, options, callback) {
      var cmd = { 'reIndex': self.s.name };
      decorateWithWriteConcern(cmd, self, options);
      self.s.db.command(cmd, options, function (err, result) {
        if (callback == null) return;
        if (err) return handleCallback(callback, err, null);
        handleCallback(callback, null, result.ok ? true : false);
      });
    };
    define.classMethod('reIndex', {
      callback: true,
      promise: true
    });
    Collection.prototype.listIndexes = function (options) {
      options = options || {};
      options = shallowClone(options);
      options = getReadPreference(this, options, this.s.db, this);
      options.cursorFactory = CommandCursor;
      options.promiseLibrary = this.s.promiseLibrary;
      if (!this.s.topology.capabilities()) {
        throw new MongoError('cannot connect to server');
      }
      if (this.s.topology.capabilities().hasListIndexesCommand) {
        var cursor = options.batchSize ? { batchSize: options.batchSize } : {};
        var command = {
          listIndexes: this.s.name,
          cursor: cursor
        };
        cursor = this.s.topology.cursor(f('%s.$cmd', this.s.dbName), command, options);
        if (options.readPreference) cursor.setReadPreference(options.readPreference);
        return cursor;
      }
      var ns = f('%s.system.indexes', this.s.dbName);
      cursor = this.s.topology.cursor(ns, {
        find: ns,
        query: { ns: this.s.namespace }
      }, options);
      if (options.readPreference) cursor.setReadPreference(options.readPreference);
      if (options.batchSize) cursor = cursor.batchSize(options.batchSize);
      return cursor;
    };
    define.classMethod('listIndexes', {
      callback: false,
      promise: false,
      returns: [CommandCursor]
    });
    Collection.prototype.ensureIndex = function (fieldOrSpec, options, callback) {
      var self = this;
      if (typeof options == 'function') callback = options, options = {};
      options = options || {};
      if (typeof callback == 'function') return ensureIndex(self, fieldOrSpec, options, callback);
      return new this.s.promiseLibrary(function (resolve, reject) {
        ensureIndex(self, fieldOrSpec, options, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var ensureIndex = function (self, fieldOrSpec, options, callback) {
      self.s.db.ensureIndex(self.s.name, fieldOrSpec, options, callback);
    };
    define.classMethod('ensureIndex', {
      callback: true,
      promise: true
    });
    Collection.prototype.indexExists = function (indexes, callback) {
      var self = this;
      if (typeof callback == 'function') return indexExists(self, indexes, callback);
      return new this.s.promiseLibrary(function (resolve, reject) {
        indexExists(self, indexes, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var indexExists = function (self, indexes, callback) {
      self.indexInformation(function (err, indexInformation) {
        if (err != null) return handleCallback(callback, err, null);
        if (!Array.isArray(indexes)) return handleCallback(callback, null, indexInformation[indexes] != null);
        for (var i = 0; i < indexes.length; i++) {
          if (indexInformation[indexes[i]] == null) {
            return handleCallback(callback, null, false);
          }
        }
        return handleCallback(callback, null, true);
      });
    };
    define.classMethod('indexExists', {
      callback: true,
      promise: true
    });
    Collection.prototype.indexInformation = function (options, callback) {
      var self = this;
      var args = Array.prototype.slice.call(arguments, 0);
      callback = args.pop();
      if (typeof callback != 'function') args.push(callback);
      options = args.length ? args.shift() || {} : {};
      if (typeof callback == 'function') return indexInformation(self, options, callback);
      return new this.s.promiseLibrary(function (resolve, reject) {
        indexInformation(self, options, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var indexInformation = function (self, options, callback) {
      self.s.db.indexInformation(self.s.name, options, callback);
    };
    define.classMethod('indexInformation', {
      callback: true,
      promise: true
    });
    Collection.prototype.count = function (query, options, callback) {
      var self = this;
      var args = Array.prototype.slice.call(arguments, 0);
      callback = args.pop();
      if (typeof callback != 'function') args.push(callback);
      var queryOption = args.length ? args.shift() || {} : {};
      var optionsOption = args.length ? args.shift() || {} : {};
      if (typeof callback == 'function') return count(self, queryOption, optionsOption, callback);
      query = query || {};
      options = options || {};
      return new this.s.promiseLibrary(function (resolve, reject) {
        count(self, query, options, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var count = function (self, query, options, callback) {
      var skip = options.skip;
      var limit = options.limit;
      var hint = options.hint;
      var maxTimeMS = options.maxTimeMS;
      var cmd = {
        'count': self.s.name,
        'query': query
      };
      if (typeof skip == 'number') cmd.skip = skip;
      if (typeof limit == 'number') cmd.limit = limit;
      if (typeof maxTimeMS == 'number') cmd.maxTimeMS = maxTimeMS;
      if (hint) options.hint = hint;
      options = shallowClone(options);
      options = getReadPreference(self, options, self.s.db, self);
      if (self.s.readConcern) {
        cmd.readConcern = self.s.readConcern;
      }
      decorateWithCollation(cmd, self, options);
      self.s.db.command(cmd, options, function (err, result) {
        if (err) return handleCallback(callback, err);
        handleCallback(callback, null, result.n);
      });
    };
    define.classMethod('count', {
      callback: true,
      promise: true
    });
    Collection.prototype.distinct = function (key, query, options, callback) {
      var self = this;
      var args = Array.prototype.slice.call(arguments, 1);
      callback = args.pop();
      if (typeof callback != 'function') args.push(callback);
      var queryOption = args.length ? args.shift() || {} : {};
      var optionsOption = args.length ? args.shift() || {} : {};
      if (typeof callback == 'function') return distinct(self, key, queryOption, optionsOption, callback);
      query = query || {};
      options = options || {};
      return new this.s.promiseLibrary(function (resolve, reject) {
        distinct(self, key, query, options, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var distinct = function (self, key, query, options, callback) {
      var maxTimeMS = options.maxTimeMS;
      var cmd = {
        'distinct': self.s.name,
        'key': key,
        'query': query
      };
      options = shallowClone(options);
      options = getReadPreference(self, options, self.s.db, self);
      if (typeof maxTimeMS == 'number') cmd.maxTimeMS = maxTimeMS;
      if (self.s.readConcern) {
        cmd.readConcern = self.s.readConcern;
      }
      decorateWithCollation(cmd, self, options);
      self.s.db.command(cmd, options, function (err, result) {
        if (err) return handleCallback(callback, err);
        handleCallback(callback, null, result.values);
      });
    };
    define.classMethod('distinct', {
      callback: true,
      promise: true
    });
    Collection.prototype.indexes = function (callback) {
      var self = this;
      if (typeof callback == 'function') return indexes(self, callback);
      return new this.s.promiseLibrary(function (resolve, reject) {
        indexes(self, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var indexes = function (self, callback) {
      self.s.db.indexInformation(self.s.name, { full: true }, callback);
    };
    define.classMethod('indexes', {
      callback: true,
      promise: true
    });
    Collection.prototype.stats = function (options, callback) {
      var self = this;
      var args = Array.prototype.slice.call(arguments, 0);
      callback = args.pop();
      if (typeof callback != 'function') args.push(callback);
      options = args.length ? args.shift() || {} : {};
      if (typeof callback == 'function') return stats(self, options, callback);
      return new this.s.promiseLibrary(function (resolve, reject) {
        stats(self, options, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var stats = function (self, options, callback) {
      var commandObject = { collStats: self.s.name };
      if (options['scale'] != null) commandObject['scale'] = options['scale'];
      options = shallowClone(options);
      options = getReadPreference(self, options, self.s.db, self);
      self.s.db.command(commandObject, options, callback);
    };
    define.classMethod('stats', {
      callback: true,
      promise: true
    });
    Collection.prototype.findOneAndDelete = function (filter, options, callback) {
      var self = this;
      if (typeof options == 'function') callback = options, options = {};
      options = options || {};
      if (filter == null || typeof filter != 'object') throw toError('filter parameter must be an object');
      if (typeof callback == 'function') return findOneAndDelete(self, filter, options, callback);
      return new this.s.promiseLibrary(function (resolve, reject) {
        options = options || {};
        findOneAndDelete(self, filter, options, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var findOneAndDelete = function (self, filter, options, callback) {
      var finalOptions = shallowClone(options);
      finalOptions['fields'] = options.projection;
      finalOptions['remove'] = true;
      self.findAndModify(filter, options.sort, null, finalOptions, callback);
    };
    define.classMethod('findOneAndDelete', {
      callback: true,
      promise: true
    });
    Collection.prototype.findOneAndReplace = function (filter, replacement, options, callback) {
      var self = this;
      if (typeof options == 'function') callback = options, options = {};
      options = options || {};
      if (filter == null || typeof filter != 'object') throw toError('filter parameter must be an object');
      if (replacement == null || typeof replacement != 'object') throw toError('replacement parameter must be an object');
      if (typeof callback == 'function') return findOneAndReplace(self, filter, replacement, options, callback);
      return new this.s.promiseLibrary(function (resolve, reject) {
        options = options || {};
        findOneAndReplace(self, filter, replacement, options, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var findOneAndReplace = function (self, filter, replacement, options, callback) {
      var finalOptions = shallowClone(options);
      finalOptions['fields'] = options.projection;
      finalOptions['update'] = true;
      finalOptions['new'] = typeof options.returnOriginal == 'boolean' ? !options.returnOriginal : false;
      finalOptions['upsert'] = typeof options.upsert == 'boolean' ? options.upsert : false;
      self.findAndModify(filter, options.sort, replacement, finalOptions, callback);
    };
    define.classMethod('findOneAndReplace', {
      callback: true,
      promise: true
    });
    Collection.prototype.findOneAndUpdate = function (filter, update, options, callback) {
      var self = this;
      if (typeof options == 'function') callback = options, options = {};
      options = options || {};
      if (filter == null || typeof filter != 'object') throw toError('filter parameter must be an object');
      if (update == null || typeof update != 'object') throw toError('update parameter must be an object');
      if (typeof callback == 'function') return findOneAndUpdate(self, filter, update, options, callback);
      return new this.s.promiseLibrary(function (resolve, reject) {
        options = options || {};
        findOneAndUpdate(self, filter, update, options, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var findOneAndUpdate = function (self, filter, update, options, callback) {
      var finalOptions = shallowClone(options);
      finalOptions['fields'] = options.projection;
      finalOptions['update'] = true;
      finalOptions['new'] = typeof options.returnOriginal == 'boolean' ? !options.returnOriginal : false;
      finalOptions['upsert'] = typeof options.upsert == 'boolean' ? options.upsert : false;
      self.findAndModify(filter, options.sort, update, finalOptions, callback);
    };
    define.classMethod('findOneAndUpdate', {
      callback: true,
      promise: true
    });
    Collection.prototype.findAndModify = function (query, sort, doc, options, callback) {
      var self = this;
      var args = Array.prototype.slice.call(arguments, 1);
      callback = args.pop();
      if (typeof callback != 'function') args.push(callback);
      sort = args.length ? args.shift() || [] : [];
      doc = args.length ? args.shift() : null;
      options = args.length ? args.shift() || {} : {};
      options = shallowClone(options);
      options.readPreference = ReadPreference.PRIMARY;
      if (typeof callback == 'function') return findAndModify(self, query, sort, doc, options, callback);
      return new this.s.promiseLibrary(function (resolve, reject) {
        options = options || {};
        findAndModify(self, query, sort, doc, options, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var findAndModify = function (self, query, sort, doc, options, callback) {
      var queryObject = {
        'findandmodify': self.s.name,
        'query': query
      };
      sort = formattedOrderClause(sort);
      if (sort) {
        queryObject.sort = sort;
      }
      queryObject.new = options.new ? true : false;
      queryObject.remove = options.remove ? true : false;
      queryObject.upsert = options.upsert ? true : false;
      if (options.fields) {
        queryObject.fields = options.fields;
      }
      if (doc && !options.remove) {
        queryObject.update = doc;
      }
      if (options.maxTimeMS) queryObject.maxTimeMS = options.maxTimeMS;
      if (options['serializeFunctions'] != null) {
        options['serializeFunctions'] = options['serializeFunctions'];
      } else {
        options['serializeFunctions'] = self.s.serializeFunctions;
      }
      options.checkKeys = false;
      var finalOptions = writeConcern(options, self.s.db, self, options);
      if (finalOptions.writeConcern) {
        queryObject.writeConcern = finalOptions.writeConcern;
      }
      if (typeof finalOptions.bypassDocumentValidation == 'boolean') {
        queryObject.bypassDocumentValidation = finalOptions.bypassDocumentValidation;
      }
      decorateWithCollation(queryObject, self, options);
      self.s.db.command(queryObject, options, function (err, result) {
        if (err) return handleCallback(callback, err, null);
        return handleCallback(callback, null, result);
      });
    };
    define.classMethod('findAndModify', {
      callback: true,
      promise: true
    });
    Collection.prototype.findAndRemove = function (query, sort, options, callback) {
      var self = this;
      var args = Array.prototype.slice.call(arguments, 1);
      callback = args.pop();
      if (typeof callback != 'function') args.push(callback);
      sort = args.length ? args.shift() || [] : [];
      options = args.length ? args.shift() || {} : {};
      if (typeof callback == 'function') return findAndRemove(self, query, sort, options, callback);
      return new this.s.promiseLibrary(function (resolve, reject) {
        findAndRemove(self, query, sort, options, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var findAndRemove = function (self, query, sort, options, callback) {
      options['remove'] = true;
      self.findAndModify(query, sort, null, options, callback);
    };
    define.classMethod('findAndRemove', {
      callback: true,
      promise: true
    });
    function decorateWithWriteConcern(command, self, options) {
      var capabilities = self.s.topology.capabilities();
      if (capabilities && capabilities.commandsTakeWriteConcern) {
        var finalOptions = writeConcern(shallowClone(options), self.s.db, self, options);
        if (finalOptions.writeConcern) {
          command.writeConcern = finalOptions.writeConcern;
        }
      }
    }
    function decorateWithCollation(command, self, options) {
      var capabilities = self.s.topology.capabilities();
      if (capabilities && capabilities.commandsTakeCollation) {
        if (options.collation && typeof options.collation == 'object') {
          command.collation = options.collation;
        }
      }
    }
    Collection.prototype.aggregate = function (pipeline, options, callback) {
      var self = this;
      if (Array.isArray(pipeline)) {
        if (typeof options == 'function') {
          callback = options;
          options = {};
        }
        if (options == null && callback == null) {
          options = {};
        }
      } else {
        var args = Array.prototype.slice.call(arguments, 0);
        callback = args.pop();
        var opts = args[args.length - 1];
        options = opts && (opts.readPreference || opts.explain || opts.cursor || opts.out || opts.maxTimeMS || opts.allowDiskUse) ? args.pop() : {};
        pipeline = args;
      }
      var ignoreReadConcern = false;
      var command = {
        aggregate: this.s.name,
        pipeline: pipeline
      };
      if (typeof options.out == 'string') {
        pipeline.push({ $out: options.out });
        ignoreReadConcern = true;
      } else if (pipeline.length > 0 && pipeline[pipeline.length - 1]['$out']) {
        ignoreReadConcern = true;
      }
      if (pipeline.length > 0 && pipeline[pipeline.length - 1]['$out']) {
        decorateWithWriteConcern(command, self, options);
      }
      decorateWithCollation(command, self, options);
      if (typeof options.bypassDocumentValidation == 'boolean') {
        command.bypassDocumentValidation = options.bypassDocumentValidation;
      }
      if (!ignoreReadConcern && this.s.readConcern) {
        command.readConcern = this.s.readConcern;
      }
      if (options.allowDiskUse) command.allowDiskUse = options.allowDiskUse;
      if (typeof options.maxTimeMS == 'number') command.maxTimeMS = options.maxTimeMS;
      options = shallowClone(options);
      options = getReadPreference(this, options, this.s.db, this);
      if (options.explain) command.explain = options.explain;
      if (options.cursor != null && typeof options.cursor != 'object') {
        throw toError('cursor options must be an object');
      }
      options.promiseLibrary = this.s.promiseLibrary;
      options.cursorFactory = AggregationCursor;
      if (typeof callback != 'function') {
        if (!this.s.topology.capabilities()) {
          throw new MongoError('cannot connect to server');
        }
        if (this.s.topology.capabilities().hasAggregationCursor) {
          options.cursor = options.cursor || { batchSize: 1000 };
          command.cursor = options.cursor;
        }
        if (typeof options.allowDiskUse == 'boolean') command.allowDiskUse = options.allowDiskUse;
        if (typeof options.maxTimeMS == 'number') command.maxTimeMS = options.maxTimeMS;
        return this.s.topology.cursor(this.s.namespace, command, options);
      }
      if (options.cursor) {
        return this.s.topology.cursor(this.s.namespace, command, options);
      }
      this.s.db.command(command, options, function (err, result) {
        if (err) {
          handleCallback(callback, err);
        } else if (result['err'] || result['errmsg']) {
          handleCallback(callback, toError(result));
        } else if (typeof result == 'object' && result['serverPipeline']) {
          handleCallback(callback, null, result['serverPipeline']);
        } else if (typeof result == 'object' && result['stages']) {
          handleCallback(callback, null, result['stages']);
        } else {
          handleCallback(callback, null, result.result);
        }
      });
    };
    define.classMethod('aggregate', {
      callback: true,
      promise: false
    });
    Collection.prototype.parallelCollectionScan = function (options, callback) {
      var self = this;
      if (typeof options == 'function') callback = options, options = { numCursors: 1 };
      options.numCursors = options.numCursors || 1;
      options.batchSize = options.batchSize || 1000;
      options = shallowClone(options);
      options = getReadPreference(this, options, this.s.db, this);
      options.promiseLibrary = this.s.promiseLibrary;
      if (typeof callback == 'function') return parallelCollectionScan(self, options, callback);
      return new this.s.promiseLibrary(function (resolve, reject) {
        parallelCollectionScan(self, options, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var parallelCollectionScan = function (self, options, callback) {
      var commandObject = {
        parallelCollectionScan: self.s.name,
        numCursors: options.numCursors
      };
      if (self.s.readConcern) {
        commandObject.readConcern = self.s.readConcern;
      }
      var raw = options.raw;
      delete options['raw'];
      self.s.db.command(commandObject, options, function (err, result) {
        if (err) return handleCallback(callback, err, null);
        if (result == null) return handleCallback(callback, new Error("no result returned for parallelCollectionScan"), null);
        var cursors = [];
        if (raw) options.raw = raw;
        for (var i = 0; i < result.cursors.length; i++) {
          var rawId = result.cursors[i].cursor.id;
          var cursorId = typeof rawId == 'number' ? Long.fromNumber(rawId) : rawId;
          cursors.push(self.s.topology.cursor(self.s.namespace, cursorId, options));
        }
        handleCallback(callback, null, cursors);
      });
    };
    define.classMethod('parallelCollectionScan', {
      callback: true,
      promise: true
    });
    Collection.prototype.geoNear = function (x, y, options, callback) {
      var self = this;
      var point = typeof x == 'object' && x,
          args = Array.prototype.slice.call(arguments, point ? 1 : 2);
      callback = args.pop();
      if (typeof callback != 'function') args.push(callback);
      options = args.length ? args.shift() || {} : {};
      if (typeof callback == 'function') return geoNear(self, x, y, point, options, callback);
      return new this.s.promiseLibrary(function (resolve, reject) {
        geoNear(self, x, y, point, options, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var geoNear = function (self, x, y, point, options, callback) {
      var commandObject = {
        geoNear: self.s.name,
        near: point || [x, y]
      };
      options = shallowClone(options);
      options = getReadPreference(self, options, self.s.db, self);
      var exclude = {
        readPreference: true,
        geoNear: true,
        near: true
      };
      commandObject = decorateCommand(commandObject, options, exclude);
      if (self.s.readConcern) {
        commandObject.readConcern = self.s.readConcern;
      }
      decorateWithCollation(commandObject, self, options);
      self.s.db.command(commandObject, options, function (err, res) {
        if (err) return handleCallback(callback, err);
        if (res.err || res.errmsg) return handleCallback(callback, toError(res));
        handleCallback(callback, null, res);
      });
    };
    define.classMethod('geoNear', {
      callback: true,
      promise: true
    });
    Collection.prototype.geoHaystackSearch = function (x, y, options, callback) {
      var self = this;
      var args = Array.prototype.slice.call(arguments, 2);
      callback = args.pop();
      if (typeof callback != 'function') args.push(callback);
      options = args.length ? args.shift() || {} : {};
      if (typeof callback == 'function') return geoHaystackSearch(self, x, y, options, callback);
      return new this.s.promiseLibrary(function (resolve, reject) {
        geoHaystackSearch(self, x, y, options, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var geoHaystackSearch = function (self, x, y, options, callback) {
      var commandObject = {
        geoSearch: self.s.name,
        near: [x, y]
      };
      commandObject = decorateCommand(commandObject, options, { readPreference: true });
      options = shallowClone(options);
      options = getReadPreference(self, options, self.s.db, self);
      if (self.s.readConcern) {
        commandObject.readConcern = self.s.readConcern;
      }
      self.s.db.command(commandObject, options, function (err, res) {
        if (err) return handleCallback(callback, err);
        if (res.err || res.errmsg) handleCallback(callback, toError(res));
        handleCallback(callback, null, res);
      });
    };
    define.classMethod('geoHaystackSearch', {
      callback: true,
      promise: true
    });
    var groupFunction = 'function () {\nvar c = db[ns].find(condition);\nvar map = new Map();\nvar reduce_function = reduce;\n\nwhile (c.hasNext()) {\nvar obj = c.next();\nvar key = {};\n\nfor (var i = 0, len = keys.length; i < len; ++i) {\nvar k = keys[i];\nkey[k] = obj[k];\n}\n\nvar aggObj = map.get(key);\n\nif (aggObj == null) {\nvar newObj = Object.extend({}, key);\naggObj = Object.extend(newObj, initial);\nmap.put(key, aggObj);\n}\n\nreduce_function(obj, aggObj);\n}\n\nreturn { "result": map.values() };\n}';
    Collection.prototype.group = function (keys, condition, initial, reduce, finalize, command, options, callback) {
      var self = this;
      var args = Array.prototype.slice.call(arguments, 3);
      callback = args.pop();
      if (typeof callback != 'function') args.push(callback);
      reduce = args.length ? args.shift() : null;
      finalize = args.length ? args.shift() : null;
      command = args.length ? args.shift() : null;
      options = args.length ? args.shift() || {} : {};
      if (!(typeof finalize == 'function')) {
        command = finalize;
        finalize = null;
      }
      if (!Array.isArray(keys) && keys instanceof Object && typeof keys !== 'function' && !(keys instanceof Code)) {
        keys = Object.keys(keys);
      }
      if (typeof reduce === 'function') {
        reduce = reduce.toString();
      }
      if (typeof finalize === 'function') {
        finalize = finalize.toString();
      }
      command = command == null ? true : command;
      if (typeof callback == 'function') return group(self, keys, condition, initial, reduce, finalize, command, options, callback);
      return new this.s.promiseLibrary(function (resolve, reject) {
        group(self, keys, condition, initial, reduce, finalize, command, options, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var group = function (self, keys, condition, initial, reduce, finalize, command, options, callback) {
      if (command) {
        var reduceFunction = reduce instanceof Code ? reduce : new Code(reduce);
        var selector = { group: {
            'ns': self.s.name,
            '$reduce': reduceFunction,
            'cond': condition,
            'initial': initial,
            'out': "inline"
          } };
        if (finalize != null) selector.group['finalize'] = finalize;
        if ('function' === typeof keys || keys instanceof Code) {
          selector.group.$keyf = keys instanceof Code ? keys : new Code(keys);
        } else {
          var hash = {};
          keys.forEach(function (key) {
            hash[key] = 1;
          });
          selector.group.key = hash;
        }
        options = shallowClone(options);
        options = getReadPreference(self, options, self.s.db, self);
        if (self.s.readConcern) {
          selector.readConcern = self.s.readConcern;
        }
        decorateWithCollation(selector, self, options);
        self.s.db.command(selector, options, function (err, result) {
          if (err) return handleCallback(callback, err, null);
          handleCallback(callback, null, result.retval);
        });
      } else {
        var scope = reduce != null && reduce instanceof Code ? reduce.scope : {};
        scope.ns = self.s.name;
        scope.keys = keys;
        scope.condition = condition;
        scope.initial = initial;
        var groupfn = groupFunction.replace(/ reduce;/, reduce.toString() + ';');
        self.s.db.eval(new Code(groupfn, scope), function (err, results) {
          if (err) return handleCallback(callback, err, null);
          handleCallback(callback, null, results.result || results);
        });
      }
    };
    define.classMethod('group', {
      callback: true,
      promise: true
    });
    function processScope(scope) {
      if (!isObject(scope) || scope instanceof ObjectID) {
        return scope;
      }
      var keys = Object.keys(scope);
      var i = keys.length;
      var key;
      var new_scope = {};
      while (i--) {
        key = keys[i];
        if ('function' == typeof scope[key]) {
          new_scope[key] = new Code(String(scope[key]));
        } else {
          new_scope[key] = processScope(scope[key]);
        }
      }
      return new_scope;
    }
    Collection.prototype.mapReduce = function (map, reduce, options, callback) {
      var self = this;
      if ('function' === typeof options) callback = options, options = {};
      if (null == options.out) {
        throw new Error("the out option parameter must be defined, see mongodb docs for possible values");
      }
      if ('function' === typeof map) {
        map = map.toString();
      }
      if ('function' === typeof reduce) {
        reduce = reduce.toString();
      }
      if ('function' === typeof options.finalize) {
        options.finalize = options.finalize.toString();
      }
      if (typeof callback == 'function') return mapReduce(self, map, reduce, options, callback);
      return new this.s.promiseLibrary(function (resolve, reject) {
        mapReduce(self, map, reduce, options, function (err, r, r1) {
          if (err) return reject(err);
          if (!r1) return resolve(r);
          resolve({
            results: r,
            stats: r1
          });
        });
      });
    };
    var mapReduce = function (self, map, reduce, options, callback) {
      var mapCommandHash = {
        mapreduce: self.s.name,
        map: map,
        reduce: reduce
      };
      for (var n in options) {
        if ('scope' == n) {
          mapCommandHash[n] = processScope(options[n]);
        } else {
          mapCommandHash[n] = options[n];
        }
      }
      options = shallowClone(options);
      options = getReadPreference(self, options, self.s.db, self);
      if (options.readPreference != false && options.readPreference != 'primary' && options['out'] && options['out'].inline != 1 && options['out'] != 'inline') {
        options.readPreference = 'primary';
        decorateWithWriteConcern(mapCommandHash, self, options);
      } else if (self.s.readConcern) {
        mapCommandHash.readConcern = self.s.readConcern;
      }
      if (typeof options.bypassDocumentValidation == 'boolean') {
        mapCommandHash.bypassDocumentValidation = options.bypassDocumentValidation;
      }
      decorateWithCollation(mapCommandHash, self, options);
      self.s.db.command(mapCommandHash, { readPreference: options.readPreference }, function (err, result) {
        if (err) return handleCallback(callback, err);
        if (1 != result.ok || result.err || result.errmsg) {
          return handleCallback(callback, toError(result));
        }
        var stats = {};
        if (result.timeMillis) stats['processtime'] = result.timeMillis;
        if (result.counts) stats['counts'] = result.counts;
        if (result.timing) stats['timing'] = result.timing;
        if (result.results) {
          if (options['verbose'] == null || !options['verbose']) {
            return handleCallback(callback, null, result.results);
          }
          return handleCallback(callback, null, result.results, stats);
        }
        var collection = null;
        if (result.result != null && typeof result.result == 'object') {
          var doc = result.result;
          collection = self.s.db.db(doc.db).collection(doc.collection);
        } else {
          collection = self.s.db.collection(result.result);
        }
        if (options['verbose'] == null || !options['verbose']) {
          return handleCallback(callback, err, collection);
        }
        handleCallback(callback, err, collection, stats);
      });
    };
    define.classMethod('mapReduce', {
      callback: true,
      promise: true
    });
    Collection.prototype.initializeUnorderedBulkOp = function (options) {
      options = options || {};
      options.promiseLibrary = this.s.promiseLibrary;
      return unordered(this.s.topology, this, options);
    };
    define.classMethod('initializeUnorderedBulkOp', {
      callback: false,
      promise: false,
      returns: [ordered.UnorderedBulkOperation]
    });
    Collection.prototype.initializeOrderedBulkOp = function (options) {
      options = options || {};
      options.promiseLibrary = this.s.promiseLibrary;
      return ordered(this.s.topology, this, options);
    };
    define.classMethod('initializeOrderedBulkOp', {
      callback: false,
      promise: false,
      returns: [ordered.OrderedBulkOperation]
    });
    var writeConcern = function (target, db, col, options) {
      if (options.w != null || options.j != null || options.fsync != null) {
        var opts = {};
        if (options.w != null) opts.w = options.w;
        if (options.wtimeout != null) opts.wtimeout = options.wtimeout;
        if (options.j != null) opts.j = options.j;
        if (options.fsync != null) opts.fsync = options.fsync;
        target.writeConcern = opts;
      } else if (col.writeConcern.w != null || col.writeConcern.j != null || col.writeConcern.fsync != null) {
        target.writeConcern = col.writeConcern;
      } else if (db.writeConcern.w != null || db.writeConcern.j != null || db.writeConcern.fsync != null) {
        target.writeConcern = db.writeConcern;
      }
      return target;
    };
    var getReadPreference = function (self, options, db) {
      var r = null;
      if (options.readPreference) {
        r = options.readPreference;
      } else if (self.s.readPreference) {
        r = self.s.readPreference;
      } else if (db.s.readPreference) {
        r = db.s.readPreference;
      }
      if (r instanceof ReadPreference) {
        options.readPreference = new CoreReadPreference(r.mode, r.tags, { maxStalenessSeconds: r.maxStalenessSeconds });
      } else if (typeof r == 'string') {
        options.readPreference = new CoreReadPreference(r);
      } else if (r && !(r instanceof ReadPreference) && typeof r == 'object') {
        var mode = r.mode || r.preference;
        if (mode && typeof mode == 'string') {
          options.readPreference = new CoreReadPreference(mode, r.tags, { maxStalenessSeconds: r.maxStalenessSeconds });
        }
      }
      return options;
    };
    var testForFields = {
      limit: 1,
      sort: 1,
      fields: 1,
      skip: 1,
      hint: 1,
      explain: 1,
      snapshot: 1,
      timeout: 1,
      tailable: 1,
      tailableRetryInterval: 1,
      numberOfRetries: 1,
      awaitdata: 1,
      awaitData: 1,
      exhaust: 1,
      batchSize: 1,
      returnKey: 1,
      maxScan: 1,
      min: 1,
      max: 1,
      showDiskLoc: 1,
      comment: 1,
      raw: 1,
      readPreference: 1,
      partial: 1,
      read: 1,
      dbName: 1,
      oplogReplay: 1,
      connection: 1,
      maxTimeMS: 1,
      transforms: 1,
      collation: 1
    };
    module.exports = Collection;
  })($__require('2a').Buffer, $__require('13'));
  return module.exports;
});
$__System.registerDynamic('183', ['196', '18f', '188', '2a', '185', '7', '166', '18d', '49', '194', '18e', '190', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer, process) {
    "use strict";

    var Chunk = $__require('196'),
        ObjectID = $__require('18f').BSON.ObjectID,
        ReadPreference = $__require('188'),
        Buffer = $__require('2a').Buffer,
        Collection = $__require('185'),
        fs = $__require('7'),
        f = $__require('166').format,
        util = $__require('166'),
        Define = $__require('18d'),
        MongoError = $__require('18f').MongoError,
        inherits = util.inherits,
        Duplex = $__require('49').Duplex || $__require('194').Duplex,
        shallowClone = $__require('18e').shallowClone;
    var REFERENCE_BY_FILENAME = 0,
        REFERENCE_BY_ID = 1;
    var GridStore = function GridStore(db, id, filename, mode, options) {
      if (!(this instanceof GridStore)) return new GridStore(db, id, filename, mode, options);
      this.db = db;
      if (typeof options === 'undefined') options = {};
      if (typeof mode === 'undefined') {
        mode = filename;
        filename = undefined;
      } else if (typeof mode == 'object') {
        options = mode;
        mode = filename;
        filename = undefined;
      }
      if (id instanceof ObjectID) {
        this.referenceBy = REFERENCE_BY_ID;
        this.fileId = id;
        this.filename = filename;
      } else if (typeof filename == 'undefined') {
        this.referenceBy = REFERENCE_BY_FILENAME;
        this.filename = id;
        if (mode.indexOf('w') != null) {
          this.fileId = new ObjectID();
        }
      } else {
        this.referenceBy = REFERENCE_BY_ID;
        this.fileId = id;
        this.filename = filename;
      }
      this.mode = mode == null ? "r" : mode;
      this.options = options || {};
      this.isOpen = false;
      this.root = this.options['root'] == null ? GridStore.DEFAULT_ROOT_COLLECTION : this.options['root'];
      this.position = 0;
      this.readPreference = this.options.readPreference || db.options.readPreference || ReadPreference.PRIMARY;
      this.writeConcern = _getWriteConcern(db, this.options);
      this.internalChunkSize = this.options['chunkSize'] == null ? Chunk.DEFAULT_CHUNK_SIZE : this.options['chunkSize'];
      var promiseLibrary = this.options.promiseLibrary;
      if (!promiseLibrary) {
        promiseLibrary = typeof global.Promise == 'function' ? global.Promise : $__require('190').Promise;
      }
      this.promiseLibrary = promiseLibrary;
      Object.defineProperty(this, "chunkSize", {
        enumerable: true,
        get: function () {
          return this.internalChunkSize;
        },
        set: function (value) {
          if (!(this.mode[0] == "w" && this.position == 0 && this.uploadDate == null)) {
            this.internalChunkSize = this.internalChunkSize;
          } else {
            this.internalChunkSize = value;
          }
        }
      });
      Object.defineProperty(this, "md5", {
        enumerable: true,
        get: function () {
          return this.internalMd5;
        }
      });
      Object.defineProperty(this, "chunkNumber", {
        enumerable: true,
        get: function () {
          return this.currentChunk && this.currentChunk.chunkNumber ? this.currentChunk.chunkNumber : null;
        }
      });
    };
    var define = GridStore.define = new Define('Gridstore', GridStore, true);
    GridStore.prototype.open = function (callback) {
      var self = this;
      if (this.mode != "w" && this.mode != "w+" && this.mode != "r") {
        throw MongoError.create({
          message: "Illegal mode " + this.mode,
          driver: true
        });
      }
      if (typeof callback == 'function') return open(self, callback);
      return new self.promiseLibrary(function (resolve, reject) {
        open(self, function (err, store) {
          if (err) return reject(err);
          resolve(store);
        });
      });
    };
    var open = function (self, callback) {
      var writeConcern = _getWriteConcern(self.db, self.options);
      if (self.mode == "w" || self.mode == "w+") {
        var collection = self.collection();
        collection.ensureIndex([['filename', 1]], writeConcern, function () {
          var chunkCollection = self.chunkCollection();
          var chunkIndexOptions = shallowClone(writeConcern);
          chunkIndexOptions.unique = true;
          chunkCollection.ensureIndex([['files_id', 1], ['n', 1]], chunkIndexOptions, function () {
            _open(self, writeConcern, function (err, r) {
              if (err) return callback(err);
              self.isOpen = true;
              callback(err, r);
            });
          });
        });
      } else {
        _open(self, writeConcern, function (err, r) {
          if (err) return callback(err);
          self.isOpen = true;
          callback(err, r);
        });
      }
    };
    define.classMethod('open', {
      callback: true,
      promise: true
    });
    GridStore.prototype.eof = function () {
      return this.position == this.length ? true : false;
    };
    define.classMethod('eof', {
      callback: false,
      promise: false,
      returns: [Boolean]
    });
    GridStore.prototype.getc = function (callback) {
      var self = this;
      if (typeof callback == 'function') return eof(self, callback);
      return new self.promiseLibrary(function (resolve, reject) {
        eof(self, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var eof = function (self, callback) {
      if (self.eof()) {
        callback(null, null);
      } else if (self.currentChunk.eof()) {
        nthChunk(self, self.currentChunk.chunkNumber + 1, function (err, chunk) {
          self.currentChunk = chunk;
          self.position = self.position + 1;
          callback(err, self.currentChunk.getc());
        });
      } else {
        self.position = self.position + 1;
        callback(null, self.currentChunk.getc());
      }
    };
    define.classMethod('getc', {
      callback: true,
      promise: true
    });
    GridStore.prototype.puts = function (string, callback) {
      var self = this;
      var finalString = string.match(/\n$/) == null ? string + "\n" : string;
      if (typeof callback == 'function') return this.write(finalString, callback);
      return new self.promiseLibrary(function (resolve, reject) {
        self.write(finalString, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    define.classMethod('puts', {
      callback: true,
      promise: true
    });
    GridStore.prototype.stream = function () {
      return new GridStoreStream(this);
    };
    define.classMethod('stream', {
      callback: false,
      promise: false,
      returns: [GridStoreStream]
    });
    GridStore.prototype.write = function write(data, close, callback) {
      var self = this;
      if (typeof callback == 'function') return _writeNormal(this, data, close, callback);
      return new self.promiseLibrary(function (resolve, reject) {
        _writeNormal(self, data, close, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    define.classMethod('write', {
      callback: true,
      promise: true
    });
    GridStore.prototype.destroy = function destroy() {
      if (!this.writable) return;
      this.readable = false;
      if (this.writable) {
        this.writable = false;
        this._q.length = 0;
        this.emit('close');
      }
    };
    define.classMethod('destroy', {
      callback: false,
      promise: false
    });
    GridStore.prototype.writeFile = function (file, callback) {
      var self = this;
      if (typeof callback == 'function') return writeFile(self, file, callback);
      return new self.promiseLibrary(function (resolve, reject) {
        writeFile(self, file, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var writeFile = function (self, file, callback) {
      if (typeof file === 'string') {
        fs.open(file, 'r', function (err, fd) {
          if (err) return callback(err);
          self.writeFile(fd, callback);
        });
        return;
      }
      self.open(function (err, self) {
        if (err) return callback(err, self);
        fs.fstat(file, function (err, stats) {
          if (err) return callback(err, self);
          var offset = 0;
          var index = 0;
          var writeChunk = function () {
            fs.read(file, self.chunkSize, offset, 'binary', function (err, data, bytesRead) {
              if (err) return callback(err, self);
              offset = offset + bytesRead;
              var chunk = new Chunk(self, { n: index++ }, self.writeConcern);
              chunk.write(data, function (err, chunk) {
                if (err) return callback(err, self);
                chunk.save({}, function (err) {
                  if (err) return callback(err, self);
                  self.position = self.position + data.length;
                  self.currentChunk = chunk;
                  if (offset >= stats.size) {
                    fs.close(file);
                    self.close(function (err) {
                      if (err) return callback(err, self);
                      return callback(null, self);
                    });
                  } else {
                    return process.nextTick(writeChunk);
                  }
                });
              });
            });
          };
          process.nextTick(writeChunk);
        });
      });
    };
    define.classMethod('writeFile', {
      callback: true,
      promise: true
    });
    GridStore.prototype.close = function (callback) {
      var self = this;
      if (typeof callback == 'function') return close(self, callback);
      return new self.promiseLibrary(function (resolve, reject) {
        close(self, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var close = function (self, callback) {
      if (self.mode[0] == "w") {
        var options = self.writeConcern;
        if (self.currentChunk != null && self.currentChunk.position > 0) {
          self.currentChunk.save({}, function (err) {
            if (err && typeof callback == 'function') return callback(err);
            self.collection(function (err, files) {
              if (err && typeof callback == 'function') return callback(err);
              if (self.uploadDate != null) {
                buildMongoObject(self, function (err, mongoObject) {
                  if (err) {
                    if (typeof callback == 'function') return callback(err);else throw err;
                  }
                  files.save(mongoObject, options, function (err) {
                    if (typeof callback == 'function') callback(err, mongoObject);
                  });
                });
              } else {
                self.uploadDate = new Date();
                buildMongoObject(self, function (err, mongoObject) {
                  if (err) {
                    if (typeof callback == 'function') return callback(err);else throw err;
                  }
                  files.save(mongoObject, options, function (err) {
                    if (typeof callback == 'function') callback(err, mongoObject);
                  });
                });
              }
            });
          });
        } else {
          self.collection(function (err, files) {
            if (err && typeof callback == 'function') return callback(err);
            self.uploadDate = new Date();
            buildMongoObject(self, function (err, mongoObject) {
              if (err) {
                if (typeof callback == 'function') return callback(err);else throw err;
              }
              files.save(mongoObject, options, function (err) {
                if (typeof callback == 'function') callback(err, mongoObject);
              });
            });
          });
        }
      } else if (self.mode[0] == "r") {
        if (typeof callback == 'function') callback(null, null);
      } else {
        if (typeof callback == 'function') callback(MongoError.create({
          message: f("Illegal mode %s", self.mode),
          driver: true
        }));
      }
    };
    define.classMethod('close', {
      callback: true,
      promise: true
    });
    GridStore.prototype.chunkCollection = function (callback) {
      if (typeof callback == 'function') return this.db.collection(this.root + ".chunks", callback);
      return this.db.collection(this.root + ".chunks");
    };
    define.classMethod('chunkCollection', {
      callback: true,
      promise: false,
      returns: [Collection]
    });
    GridStore.prototype.unlink = function (callback) {
      var self = this;
      if (typeof callback == 'function') return unlink(self, callback);
      return new self.promiseLibrary(function (resolve, reject) {
        unlink(self, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var unlink = function (self, callback) {
      deleteChunks(self, function (err) {
        if (err !== null) {
          err.message = "at deleteChunks: " + err.message;
          return callback(err);
        }
        self.collection(function (err, collection) {
          if (err !== null) {
            err.message = "at collection: " + err.message;
            return callback(err);
          }
          collection.remove({ '_id': self.fileId }, self.writeConcern, function (err) {
            callback(err, self);
          });
        });
      });
    };
    define.classMethod('unlink', {
      callback: true,
      promise: true
    });
    GridStore.prototype.collection = function (callback) {
      if (typeof callback == 'function') this.db.collection(this.root + ".files", callback);
      return this.db.collection(this.root + ".files");
    };
    define.classMethod('collection', {
      callback: true,
      promise: false,
      returns: [Collection]
    });
    GridStore.prototype.readlines = function (separator, callback) {
      var self = this;
      var args = Array.prototype.slice.call(arguments, 0);
      callback = args.pop();
      if (typeof callback != 'function') args.push(callback);
      separator = args.length ? args.shift() : "\n";
      separator = separator || "\n";
      if (typeof callback == 'function') return readlines(self, separator, callback);
      return new self.promiseLibrary(function (resolve, reject) {
        readlines(self, separator, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var readlines = function (self, separator, callback) {
      self.read(function (err, data) {
        if (err) return callback(err);
        var items = data.toString().split(separator);
        items = items.length > 0 ? items.splice(0, items.length - 1) : [];
        for (var i = 0; i < items.length; i++) {
          items[i] = items[i] + separator;
        }
        callback(null, items);
      });
    };
    define.classMethod('readlines', {
      callback: true,
      promise: true
    });
    GridStore.prototype.rewind = function (callback) {
      var self = this;
      if (typeof callback == 'function') return rewind(self, callback);
      return new self.promiseLibrary(function (resolve, reject) {
        rewind(self, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var rewind = function (self, callback) {
      if (self.currentChunk.chunkNumber != 0) {
        if (self.mode[0] == "w") {
          deleteChunks(self, function (err) {
            if (err) return callback(err);
            self.currentChunk = new Chunk(self, { 'n': 0 }, self.writeConcern);
            self.position = 0;
            callback(null, self);
          });
        } else {
          self.currentChunk(0, function (err, chunk) {
            if (err) return callback(err);
            self.currentChunk = chunk;
            self.currentChunk.rewind();
            self.position = 0;
            callback(null, self);
          });
        }
      } else {
        self.currentChunk.rewind();
        self.position = 0;
        callback(null, self);
      }
    };
    define.classMethod('rewind', {
      callback: true,
      promise: true
    });
    GridStore.prototype.read = function (length, buffer, callback) {
      var self = this;
      var args = Array.prototype.slice.call(arguments, 0);
      callback = args.pop();
      if (typeof callback != 'function') args.push(callback);
      length = args.length ? args.shift() : null;
      buffer = args.length ? args.shift() : null;
      if (typeof callback == 'function') return read(self, length, buffer, callback);
      return new self.promiseLibrary(function (resolve, reject) {
        read(self, length, buffer, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var read = function (self, length, buffer, callback) {
      var finalLength = length == null ? self.length - self.position : length;
      var finalBuffer = buffer == null ? new Buffer(finalLength) : buffer;
      finalBuffer._index = buffer != null && buffer._index != null ? buffer._index : 0;
      if (self.currentChunk.length() - self.currentChunk.position + finalBuffer._index >= finalLength) {
        var slice = self.currentChunk.readSlice(finalLength - finalBuffer._index);
        slice.copy(finalBuffer, finalBuffer._index);
        self.position = self.position + finalBuffer.length;
        if (finalLength == 0 && finalBuffer.length == 0) return callback(MongoError.create({
          message: "File does not exist",
          driver: true
        }), null);
        return callback(null, finalBuffer);
      }
      slice = self.currentChunk.readSlice(self.currentChunk.length() - self.currentChunk.position);
      slice.copy(finalBuffer, finalBuffer._index);
      finalBuffer._index += slice.length;
      nthChunk(self, self.currentChunk.chunkNumber + 1, function (err, chunk) {
        if (err) return callback(err);
        if (chunk.length() > 0) {
          self.currentChunk = chunk;
          self.read(length, finalBuffer, callback);
        } else {
          if (finalBuffer._index > 0) {
            callback(null, finalBuffer);
          } else {
            callback(MongoError.create({
              message: "no chunks found for file, possibly corrupt",
              driver: true
            }), null);
          }
        }
      });
    };
    define.classMethod('read', {
      callback: true,
      promise: true
    });
    GridStore.prototype.tell = function (callback) {
      var self = this;
      if (typeof callback == 'function') return callback(null, this.position);
      return new self.promiseLibrary(function (resolve) {
        resolve(self.position);
      });
    };
    define.classMethod('tell', {
      callback: true,
      promise: true
    });
    GridStore.prototype.seek = function (position, seekLocation, callback) {
      var self = this;
      var args = Array.prototype.slice.call(arguments, 1);
      callback = args.pop();
      if (typeof callback != 'function') args.push(callback);
      seekLocation = args.length ? args.shift() : null;
      if (typeof callback == 'function') return seek(self, position, seekLocation, callback);
      return new self.promiseLibrary(function (resolve, reject) {
        seek(self, position, seekLocation, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var seek = function (self, position, seekLocation, callback) {
      if (self.mode != 'r') {
        return callback(MongoError.create({
          message: "seek is only supported for mode r",
          driver: true
        }));
      }
      var seekLocationFinal = seekLocation == null ? GridStore.IO_SEEK_SET : seekLocation;
      var finalPosition = position;
      var targetPosition = 0;
      if (seekLocationFinal == GridStore.IO_SEEK_CUR) {
        targetPosition = self.position + finalPosition;
      } else if (seekLocationFinal == GridStore.IO_SEEK_END) {
        targetPosition = self.length + finalPosition;
      } else {
        targetPosition = finalPosition;
      }
      var newChunkNumber = Math.floor(targetPosition / self.chunkSize);
      var seekChunk = function () {
        nthChunk(self, newChunkNumber, function (err, chunk) {
          if (err) return callback(err, null);
          if (chunk == null) return callback(new Error('no chunk found'));
          self.currentChunk = chunk;
          self.position = targetPosition;
          self.currentChunk.position = self.position % self.chunkSize;
          callback(err, self);
        });
      };
      seekChunk();
    };
    define.classMethod('seek', {
      callback: true,
      promise: true
    });
    var _open = function (self, options, callback) {
      var collection = self.collection();
      var query = self.referenceBy == REFERENCE_BY_ID ? { _id: self.fileId } : { filename: self.filename };
      query = null == self.fileId && self.filename == null ? null : query;
      options.readPreference = self.readPreference;
      if (query != null) {
        collection.findOne(query, options, function (err, doc) {
          if (err) return error(err);
          if (doc != null) {
            self.fileId = doc._id;
            self.filename = self.mode == 'r' || self.filename == undefined ? doc.filename : self.filename;
            self.contentType = doc.contentType;
            self.internalChunkSize = doc.chunkSize;
            self.uploadDate = doc.uploadDate;
            self.aliases = doc.aliases;
            self.length = doc.length;
            self.metadata = doc.metadata;
            self.internalMd5 = doc.md5;
          } else if (self.mode != 'r') {
            self.fileId = self.fileId == null ? new ObjectID() : self.fileId;
            self.contentType = GridStore.DEFAULT_CONTENT_TYPE;
            self.internalChunkSize = self.internalChunkSize == null ? Chunk.DEFAULT_CHUNK_SIZE : self.internalChunkSize;
            self.length = 0;
          } else {
            self.length = 0;
            var txtId = self.fileId instanceof ObjectID ? self.fileId.toHexString() : self.fileId;
            return error(MongoError.create({
              message: f("file with id %s not opened for writing", self.referenceBy == REFERENCE_BY_ID ? txtId : self.filename),
              driver: true
            }), self);
          }
          if (self.mode == "r") {
            nthChunk(self, 0, options, function (err, chunk) {
              if (err) return error(err);
              self.currentChunk = chunk;
              self.position = 0;
              callback(null, self);
            });
          } else if (self.mode == "w" && doc) {
            deleteChunks(self, options, function (err) {
              if (err) return error(err);
              self.currentChunk = new Chunk(self, { 'n': 0 }, self.writeConcern);
              self.contentType = self.options['content_type'] == null ? self.contentType : self.options['content_type'];
              self.internalChunkSize = self.options['chunk_size'] == null ? self.internalChunkSize : self.options['chunk_size'];
              self.metadata = self.options['metadata'] == null ? self.metadata : self.options['metadata'];
              self.aliases = self.options['aliases'] == null ? self.aliases : self.options['aliases'];
              self.position = 0;
              callback(null, self);
            });
          } else if (self.mode == "w") {
            self.currentChunk = new Chunk(self, { 'n': 0 }, self.writeConcern);
            self.contentType = self.options['content_type'] == null ? self.contentType : self.options['content_type'];
            self.internalChunkSize = self.options['chunk_size'] == null ? self.internalChunkSize : self.options['chunk_size'];
            self.metadata = self.options['metadata'] == null ? self.metadata : self.options['metadata'];
            self.aliases = self.options['aliases'] == null ? self.aliases : self.options['aliases'];
            self.position = 0;
            callback(null, self);
          } else if (self.mode == "w+") {
            nthChunk(self, lastChunkNumber(self), options, function (err, chunk) {
              if (err) return error(err);
              self.currentChunk = chunk == null ? new Chunk(self, { 'n': 0 }, self.writeConcern) : chunk;
              self.currentChunk.position = self.currentChunk.data.length();
              self.metadata = self.options['metadata'] == null ? self.metadata : self.options['metadata'];
              self.aliases = self.options['aliases'] == null ? self.aliases : self.options['aliases'];
              self.position = self.length;
              callback(null, self);
            });
          }
        });
      } else {
        self.fileId = null == self.fileId ? new ObjectID() : self.fileId;
        self.contentType = GridStore.DEFAULT_CONTENT_TYPE;
        self.internalChunkSize = self.internalChunkSize == null ? Chunk.DEFAULT_CHUNK_SIZE : self.internalChunkSize;
        self.length = 0;
        if (self.mode == "w") {
          deleteChunks(self, options, function (err) {
            if (err) return error(err);
            self.currentChunk = new Chunk(self, { 'n': 0 }, self.writeConcern);
            self.contentType = self.options['content_type'] == null ? self.contentType : self.options['content_type'];
            self.internalChunkSize = self.options['chunk_size'] == null ? self.internalChunkSize : self.options['chunk_size'];
            self.metadata = self.options['metadata'] == null ? self.metadata : self.options['metadata'];
            self.aliases = self.options['aliases'] == null ? self.aliases : self.options['aliases'];
            self.position = 0;
            callback(null, self);
          });
        } else if (self.mode == "w+") {
          nthChunk(self, lastChunkNumber(self), options, function (err, chunk) {
            if (err) return error(err);
            self.currentChunk = chunk == null ? new Chunk(self, { 'n': 0 }, self.writeConcern) : chunk;
            self.currentChunk.position = self.currentChunk.data.length();
            self.metadata = self.options['metadata'] == null ? self.metadata : self.options['metadata'];
            self.aliases = self.options['aliases'] == null ? self.aliases : self.options['aliases'];
            self.position = self.length;
            callback(null, self);
          });
        }
      }
      function error(err) {
        if (error.err) return;
        callback(error.err = err);
      }
    };
    var writeBuffer = function (self, buffer, close, callback) {
      if (typeof close === "function") {
        callback = close;
        close = null;
      }
      var finalClose = typeof close == 'boolean' ? close : false;
      if (self.mode != "w") {
        callback(MongoError.create({
          message: f("file with id %s not opened for writing", self.referenceBy == REFERENCE_BY_ID ? self.referenceBy : self.filename),
          driver: true
        }), null);
      } else {
        if (self.currentChunk.position + buffer.length >= self.chunkSize) {
          var previousChunkNumber = self.currentChunk.chunkNumber;
          var leftOverDataSize = self.chunkSize - self.currentChunk.position;
          var firstChunkData = buffer.slice(0, leftOverDataSize);
          var leftOverData = buffer.slice(leftOverDataSize);
          var chunksToWrite = [self.currentChunk.write(firstChunkData)];
          while (leftOverData.length >= self.chunkSize) {
            var newChunk = new Chunk(self, { 'n': previousChunkNumber + 1 }, self.writeConcern);
            firstChunkData = leftOverData.slice(0, self.chunkSize);
            leftOverData = leftOverData.slice(self.chunkSize);
            previousChunkNumber = previousChunkNumber + 1;
            newChunk.write(firstChunkData);
            chunksToWrite.push(newChunk);
          }
          self.currentChunk = new Chunk(self, { 'n': previousChunkNumber + 1 }, self.writeConcern);
          if (leftOverData.length > 0) self.currentChunk.write(leftOverData);
          self.position = self.position + buffer.length;
          var numberOfChunksToWrite = chunksToWrite.length;
          for (var i = 0; i < chunksToWrite.length; i++) {
            chunksToWrite[i].save({}, function (err) {
              if (err) return callback(err);
              numberOfChunksToWrite = numberOfChunksToWrite - 1;
              if (numberOfChunksToWrite <= 0) {
                if (finalClose) {
                  return self.close(function (err) {
                    callback(err, self);
                  });
                }
                return callback(null, self);
              }
            });
          }
        } else {
          self.position = self.position + buffer.length;
          self.currentChunk.write(buffer);
          if (finalClose) {
            return self.close(function (err) {
              callback(err, self);
            });
          }
          return callback(null, self);
        }
      }
    };
    var buildMongoObject = function (self, callback) {
      var mongoObject = {
        '_id': self.fileId,
        'filename': self.filename,
        'contentType': self.contentType,
        'length': self.position ? self.position : 0,
        'chunkSize': self.chunkSize,
        'uploadDate': self.uploadDate,
        'aliases': self.aliases,
        'metadata': self.metadata
      };
      var md5Command = {
        filemd5: self.fileId,
        root: self.root
      };
      self.db.command(md5Command, function (err, results) {
        if (err) return callback(err);
        mongoObject.md5 = results.md5;
        callback(null, mongoObject);
      });
    };
    var nthChunk = function (self, chunkNumber, options, callback) {
      if (typeof options == 'function') {
        callback = options;
        options = {};
      }
      options = options || self.writeConcern;
      options.readPreference = self.readPreference;
      self.chunkCollection().findOne({
        'files_id': self.fileId,
        'n': chunkNumber
      }, options, function (err, chunk) {
        if (err) return callback(err);
        var finalChunk = chunk == null ? {} : chunk;
        callback(null, new Chunk(self, finalChunk, self.writeConcern));
      });
    };
    var lastChunkNumber = function (self) {
      return Math.floor((self.length ? self.length - 1 : 0) / self.chunkSize);
    };
    var deleteChunks = function (self, options, callback) {
      if (typeof options == 'function') {
        callback = options;
        options = {};
      }
      options = options || self.writeConcern;
      if (self.fileId != null) {
        self.chunkCollection().remove({ 'files_id': self.fileId }, options, function (err) {
          if (err) return callback(err, false);
          callback(null, true);
        });
      } else {
        callback(null, true);
      }
    };
    GridStore.DEFAULT_ROOT_COLLECTION = 'fs';
    GridStore.DEFAULT_CONTENT_TYPE = 'binary/octet-stream';
    GridStore.IO_SEEK_SET = 0;
    GridStore.IO_SEEK_CUR = 1;
    GridStore.IO_SEEK_END = 2;
    GridStore.exist = function (db, fileIdObject, rootCollection, options, callback) {
      var args = Array.prototype.slice.call(arguments, 2);
      callback = args.pop();
      if (typeof callback != 'function') args.push(callback);
      rootCollection = args.length ? args.shift() : null;
      options = args.length ? args.shift() : {};
      options = options || {};
      var promiseLibrary = options.promiseLibrary;
      if (!promiseLibrary) {
        promiseLibrary = typeof global.Promise == 'function' ? global.Promise : $__require('190').Promise;
      }
      if (typeof callback == 'function') return exists(db, fileIdObject, rootCollection, options, callback);
      return new promiseLibrary(function (resolve, reject) {
        exists(db, fileIdObject, rootCollection, options, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var exists = function (db, fileIdObject, rootCollection, options, callback) {
      var readPreference = options.readPreference || ReadPreference.PRIMARY;
      var rootCollectionFinal = rootCollection != null ? rootCollection : GridStore.DEFAULT_ROOT_COLLECTION;
      db.collection(rootCollectionFinal + ".files", function (err, collection) {
        if (err) return callback(err);
        var query = typeof fileIdObject == 'string' || Object.prototype.toString.call(fileIdObject) == '[object RegExp]' ? { 'filename': fileIdObject } : { '_id': fileIdObject };
        if (fileIdObject != null && typeof fileIdObject == 'object' && Object.prototype.toString.call(fileIdObject) != '[object RegExp]') {
          query = fileIdObject;
        }
        collection.findOne(query, { readPreference: readPreference }, function (err, item) {
          if (err) return callback(err);
          callback(null, item == null ? false : true);
        });
      });
    };
    define.staticMethod('exist', {
      callback: true,
      promise: true
    });
    GridStore.list = function (db, rootCollection, options, callback) {
      var args = Array.prototype.slice.call(arguments, 1);
      callback = args.pop();
      if (typeof callback != 'function') args.push(callback);
      rootCollection = args.length ? args.shift() : null;
      options = args.length ? args.shift() : {};
      options = options || {};
      var promiseLibrary = options.promiseLibrary;
      if (!promiseLibrary) {
        promiseLibrary = typeof global.Promise == 'function' ? global.Promise : $__require('190').Promise;
      }
      if (typeof callback == 'function') return list(db, rootCollection, options, callback);
      return new promiseLibrary(function (resolve, reject) {
        list(db, rootCollection, options, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var list = function (db, rootCollection, options, callback) {
      if (rootCollection != null && typeof rootCollection == 'object') {
        options = rootCollection;
        rootCollection = null;
      }
      var readPreference = options.readPreference || ReadPreference.PRIMARY;
      var byId = options['id'] != null ? options['id'] : false;
      var rootCollectionFinal = rootCollection != null ? rootCollection : GridStore.DEFAULT_ROOT_COLLECTION;
      var items = [];
      db.collection(rootCollectionFinal + ".files", function (err, collection) {
        if (err) return callback(err);
        collection.find({}, { readPreference: readPreference }, function (err, cursor) {
          if (err) return callback(err);
          cursor.each(function (err, item) {
            if (item != null) {
              items.push(byId ? item._id : item.filename);
            } else {
              callback(err, items);
            }
          });
        });
      });
    };
    define.staticMethod('list', {
      callback: true,
      promise: true
    });
    GridStore.read = function (db, name, length, offset, options, callback) {
      var args = Array.prototype.slice.call(arguments, 2);
      callback = args.pop();
      if (typeof callback != 'function') args.push(callback);
      length = args.length ? args.shift() : null;
      offset = args.length ? args.shift() : null;
      options = args.length ? args.shift() : null;
      options = options || {};
      var promiseLibrary = options ? options.promiseLibrary : null;
      if (!promiseLibrary) {
        promiseLibrary = typeof global.Promise == 'function' ? global.Promise : $__require('190').Promise;
      }
      if (typeof callback == 'function') return readStatic(db, name, length, offset, options, callback);
      return new promiseLibrary(function (resolve, reject) {
        readStatic(db, name, length, offset, options, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var readStatic = function (db, name, length, offset, options, callback) {
      new GridStore(db, name, "r", options).open(function (err, gridStore) {
        if (err) return callback(err);
        if (offset && offset >= gridStore.length) return callback("offset larger than size of file", null);
        if (length && length > gridStore.length) return callback("length is larger than the size of the file", null);
        if (offset && length && offset + length > gridStore.length) return callback("offset and length is larger than the size of the file", null);
        if (offset != null) {
          gridStore.seek(offset, function (err, gridStore) {
            if (err) return callback(err);
            gridStore.read(length, callback);
          });
        } else {
          gridStore.read(length, callback);
        }
      });
    };
    define.staticMethod('read', {
      callback: true,
      promise: true
    });
    GridStore.readlines = function (db, name, separator, options, callback) {
      var args = Array.prototype.slice.call(arguments, 2);
      callback = args.pop();
      if (typeof callback != 'function') args.push(callback);
      separator = args.length ? args.shift() : null;
      options = args.length ? args.shift() : null;
      options = options || {};
      var promiseLibrary = options ? options.promiseLibrary : null;
      if (!promiseLibrary) {
        promiseLibrary = typeof global.Promise == 'function' ? global.Promise : $__require('190').Promise;
      }
      if (typeof callback == 'function') return readlinesStatic(db, name, separator, options, callback);
      return new promiseLibrary(function (resolve, reject) {
        readlinesStatic(db, name, separator, options, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var readlinesStatic = function (db, name, separator, options, callback) {
      var finalSeperator = separator == null ? "\n" : separator;
      new GridStore(db, name, "r", options).open(function (err, gridStore) {
        if (err) return callback(err);
        gridStore.readlines(finalSeperator, callback);
      });
    };
    define.staticMethod('readlines', {
      callback: true,
      promise: true
    });
    GridStore.unlink = function (db, names, options, callback) {
      var self = this;
      var args = Array.prototype.slice.call(arguments, 2);
      callback = args.pop();
      if (typeof callback != 'function') args.push(callback);
      options = args.length ? args.shift() : {};
      options = options || {};
      var promiseLibrary = options.promiseLibrary;
      if (!promiseLibrary) {
        promiseLibrary = typeof global.Promise == 'function' ? global.Promise : $__require('190').Promise;
      }
      if (typeof callback == 'function') return unlinkStatic(self, db, names, options, callback);
      return new promiseLibrary(function (resolve, reject) {
        unlinkStatic(self, db, names, options, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var unlinkStatic = function (self, db, names, options, callback) {
      var writeConcern = _getWriteConcern(db, options);
      if (names.constructor == Array) {
        var tc = 0;
        for (var i = 0; i < names.length; i++) {
          ++tc;
          GridStore.unlink(db, names[i], options, function () {
            if (--tc == 0) {
              callback(null, self);
            }
          });
        }
      } else {
        new GridStore(db, names, "w", options).open(function (err, gridStore) {
          if (err) return callback(err);
          deleteChunks(gridStore, function (err) {
            if (err) return callback(err);
            gridStore.collection(function (err, collection) {
              if (err) return callback(err);
              collection.remove({ '_id': gridStore.fileId }, writeConcern, function (err) {
                callback(err, self);
              });
            });
          });
        });
      }
    };
    define.staticMethod('unlink', {
      callback: true,
      promise: true
    });
    var _writeNormal = function (self, data, close, callback) {
      if (Buffer.isBuffer(data)) {
        return writeBuffer(self, data, close, callback);
      } else {
        return writeBuffer(self, new Buffer(data, 'binary'), close, callback);
      }
    };
    var _setWriteConcernHash = function (options) {
      var finalOptions = {};
      if (options.w != null) finalOptions.w = options.w;
      if (options.journal == true) finalOptions.j = options.journal;
      if (options.j == true) finalOptions.j = options.j;
      if (options.fsync == true) finalOptions.fsync = options.fsync;
      if (options.wtimeout != null) finalOptions.wtimeout = options.wtimeout;
      return finalOptions;
    };
    var _getWriteConcern = function (self, options) {
      var finalOptions = { w: 1 };
      options = options || {};
      if (options.w != null || typeof options.j == 'boolean' || typeof options.journal == 'boolean' || typeof options.fsync == 'boolean') {
        finalOptions = _setWriteConcernHash(options);
      } else if (options.safe != null && typeof options.safe == 'object') {
        finalOptions = _setWriteConcernHash(options.safe);
      } else if (typeof options.safe == "boolean") {
        finalOptions = { w: options.safe ? 1 : 0 };
      } else if (self.options.w != null || typeof self.options.j == 'boolean' || typeof self.options.journal == 'boolean' || typeof self.options.fsync == 'boolean') {
        finalOptions = _setWriteConcernHash(self.options);
      } else if (self.safe && (self.safe.w != null || typeof self.safe.j == 'boolean' || typeof self.safe.journal == 'boolean' || typeof self.safe.fsync == 'boolean')) {
        finalOptions = _setWriteConcernHash(self.safe);
      } else if (typeof self.safe == "boolean") {
        finalOptions = { w: self.safe ? 1 : 0 };
      }
      if (finalOptions.w < 1 && (finalOptions.journal == true || finalOptions.j == true || finalOptions.fsync == true)) throw MongoError.create({
        message: "No acknowledgement using w < 1 cannot be combined with journal:true or fsync:true",
        driver: true
      });
      return finalOptions;
    };
    var GridStoreStream = function (gs) {
      Duplex.call(this);
      this.gs = gs;
      this.endCalled = false;
      this.totalBytesToRead = this.gs.length - this.gs.position;
      this.seekPosition = this.gs.position;
    };
    inherits(GridStoreStream, Duplex);
    GridStoreStream.prototype._pipe = GridStoreStream.prototype.pipe;
    GridStoreStream.prototype.pipe = function (destination) {
      var self = this;
      if (!self.gs.isOpen) {
        self.gs.open(function (err) {
          if (err) return self.emit('error', err);
          self.totalBytesToRead = self.gs.length - self.gs.position;
          self._pipe.apply(self, [destination]);
        });
      } else {
        self.totalBytesToRead = self.gs.length - self.gs.position;
        self._pipe.apply(self, [destination]);
      }
      return destination;
    };
    GridStoreStream.prototype._read = function () {
      var self = this;
      var read = function () {
        self.gs.read(length, function (err, buffer) {
          if (err && !self.endCalled) return self.emit('error', err);
          if (self.endCalled || buffer == null) return self.push(null);
          if (buffer.length <= self.totalBytesToRead) {
            self.totalBytesToRead = self.totalBytesToRead - buffer.length;
            self.push(buffer);
          } else if (buffer.length > self.totalBytesToRead) {
            self.totalBytesToRead = self.totalBytesToRead - buffer._index;
            self.push(buffer.slice(0, buffer._index));
          }
          if (self.totalBytesToRead <= 0) {
            self.endCalled = true;
          }
        });
      };
      var length = self.gs.length < self.gs.chunkSize ? self.gs.length - self.seekPosition : self.gs.chunkSize;
      if (!self.gs.isOpen) {
        self.gs.open(function (err) {
          self.totalBytesToRead = self.gs.length - self.gs.position;
          if (err) return self.emit('error', err);
          read();
        });
      } else {
        read();
      }
    };
    GridStoreStream.prototype.destroy = function () {
      this.pause();
      this.endCalled = true;
      this.gs.close();
      this.emit('end');
    };
    GridStoreStream.prototype.write = function (chunk) {
      var self = this;
      if (self.endCalled) return self.emit('error', MongoError.create({
        message: 'attempting to write to stream after end called',
        driver: true
      }));
      if (!self.gs.isOpen) {
        self.gs.open(function () {
          self.gs.isOpen = true;
          self.gs.write(chunk, function () {
            process.nextTick(function () {
              self.emit('drain');
            });
          });
        });
        return false;
      } else {
        self.gs.write(chunk, function () {
          self.emit('drain');
        });
        return true;
      }
    };
    GridStoreStream.prototype.end = function (chunk, encoding, callback) {
      var self = this;
      var args = Array.prototype.slice.call(arguments, 0);
      callback = args.pop();
      if (typeof callback != 'function') args.push(callback);
      chunk = args.length ? args.shift() : null;
      encoding = args.length ? args.shift() : null;
      self.endCalled = true;
      if (chunk) {
        self.gs.write(chunk, function () {
          self.gs.close(function () {
            if (typeof callback == 'function') callback();
            self.emit('end');
          });
        });
      }
      self.gs.close(function () {
        if (typeof callback == 'function') callback();
        self.emit('end');
      });
    };
    module.exports = GridStore;
  })($__require('2a').Buffer, $__require('13'));
  return module.exports;
});
$__System.registerDynamic('196', ['18f', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    "use strict";

    var Binary = $__require('18f').BSON.Binary,
        ObjectID = $__require('18f').BSON.ObjectID;
    var Chunk = function (file, mongoObject, writeConcern) {
      if (!(this instanceof Chunk)) return new Chunk(file, mongoObject);
      this.file = file;
      var mongoObjectFinal = mongoObject == null ? {} : mongoObject;
      this.writeConcern = writeConcern || { w: 1 };
      this.objectId = mongoObjectFinal._id == null ? new ObjectID() : mongoObjectFinal._id;
      this.chunkNumber = mongoObjectFinal.n == null ? 0 : mongoObjectFinal.n;
      this.data = new Binary();
      if (typeof mongoObjectFinal.data == "string") {
        var buffer = new Buffer(mongoObjectFinal.data.length);
        buffer.write(mongoObjectFinal.data, 0, mongoObjectFinal.data.length, 'binary');
        this.data = new Binary(buffer);
      } else if (Array.isArray(mongoObjectFinal.data)) {
        buffer = new Buffer(mongoObjectFinal.data.length);
        var data = mongoObjectFinal.data.join('');
        buffer.write(data, 0, data.length, 'binary');
        this.data = new Binary(buffer);
      } else if (mongoObjectFinal.data && mongoObjectFinal.data._bsontype === 'Binary') {
        this.data = mongoObjectFinal.data;
      } else if (!Buffer.isBuffer(mongoObjectFinal.data) && !(mongoObjectFinal.data == null)) {
        throw Error("Illegal chunk format");
      }
      this.internalPosition = 0;
    };
    Chunk.prototype.write = function (data, callback) {
      this.data.write(data, this.internalPosition, data.length, 'binary');
      this.internalPosition = this.data.length();
      if (callback != null) return callback(null, this);
      return this;
    };
    Chunk.prototype.read = function (length) {
      length = length == null || length == 0 ? this.length() : length;
      if (this.length() - this.internalPosition + 1 >= length) {
        var data = this.data.read(this.internalPosition, length);
        this.internalPosition = this.internalPosition + length;
        return data;
      } else {
        return '';
      }
    };
    Chunk.prototype.readSlice = function (length) {
      if (this.length() - this.internalPosition >= length) {
        var data = null;
        if (this.data.buffer != null) {
          data = this.data.buffer.slice(this.internalPosition, this.internalPosition + length);
        } else {
          data = new Buffer(length);
          length = this.data.readInto(data, this.internalPosition);
        }
        this.internalPosition = this.internalPosition + length;
        return data;
      } else {
        return null;
      }
    };
    Chunk.prototype.eof = function () {
      return this.internalPosition == this.length() ? true : false;
    };
    Chunk.prototype.getc = function () {
      return this.read(1);
    };
    Chunk.prototype.rewind = function () {
      this.internalPosition = 0;
      this.data = new Binary();
    };
    Chunk.prototype.save = function (options, callback) {
      var self = this;
      if (typeof options == 'function') {
        callback = options;
        options = {};
      }
      self.file.chunkCollection(function (err, collection) {
        if (err) return callback(err);
        var writeOptions = { upsert: true };
        for (var name in options) writeOptions[name] = options[name];
        for (name in self.writeConcern) writeOptions[name] = self.writeConcern[name];
        if (self.data.length() > 0) {
          self.buildMongoObject(function (mongoObject) {
            var options = { forceServerObjectId: true };
            for (var name in self.writeConcern) {
              options[name] = self.writeConcern[name];
            }
            collection.replaceOne({ '_id': self.objectId }, mongoObject, writeOptions, function (err) {
              callback(err, self);
            });
          });
        } else {
          callback(null, self);
        }
      });
    };
    Chunk.prototype.buildMongoObject = function (callback) {
      var mongoObject = {
        'files_id': this.file.fileId,
        'n': this.chunkNumber,
        'data': this.data
      };
      if (this.objectId != null) mongoObject._id = this.objectId;
      callback(mongoObject);
    };
    Chunk.prototype.length = function () {
      return this.data.length();
    };
    Object.defineProperty(Chunk.prototype, "position", {
      enumerable: true,
      get: function () {
        return this.internalPosition;
      },
      set: function (value) {
        this.internalPosition = value;
      }
    });
    Chunk.DEFAULT_CHUNK_SIZE = 1024 * 255;
    module.exports = Chunk;
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic('188', [], true, function ($__require, exports, module) {
  /* */
  "use strict";

  /**
   * @fileOverview The **ReadPreference** class is a class that represents a MongoDB ReadPreference and is
   * used to construct connections.
   *
   * @example
   * var Db = require('mongodb').Db,
   *   ReplSet = require('mongodb').ReplSet,
   *   Server = require('mongodb').Server,
   *   ReadPreference = require('mongodb').ReadPreference,
   *   test = require('assert');
   * // Connect using ReplSet
   * var server = new Server('localhost', 27017);
   * var db = new Db('test', new ReplSet([server]));
   * db.open(function(err, db) {
   *   test.equal(null, err);
   *   // Perform a read
   *   var cursor = db.collection('t').find({});
   *   cursor.setReadPreference(ReadPreference.PRIMARY);
   *   cursor.toArray(function(err, docs) {
   *     test.equal(null, err);
   *     db.close();
   *   });
   * });
   */

  /**
   * Creates a new ReadPreference instance
   *
   * Read Preferences
   *  - **ReadPreference.PRIMARY**, Read from primary only. All operations produce an error (throw an exception where applicable) if primary is unavailable. Cannot be combined with tags (This is the default.).
   *  - **ReadPreference.PRIMARY_PREFERRED**, Read from primary if available, otherwise a secondary.
   *  - **ReadPreference.SECONDARY**, Read from secondary if available, otherwise error.
   *  - **ReadPreference.SECONDARY_PREFERRED**, Read from a secondary if available, otherwise read from the primary.
   *  - **ReadPreference.NEAREST**, All modes read from among the nearest candidates, but unlike other modes, NEAREST will include both the primary and all secondaries in the random selection.
   *
   * @class
   * @param {string} mode The ReadPreference mode as listed above.
   * @param {array|object} tags An object representing read preference tags.
   * @param {object} [options] Additional read preference options
   * @param {number} [options.maxStalenessSeconds] Max Secondary Read Stalleness in Seconds
   * @return {ReadPreference} a ReadPreference instance.
   */

  var define,
      global = this || self,
      GLOBAL = global;
  var ReadPreference = function (mode, tags, options) {
    if (!(this instanceof ReadPreference)) {
      return new ReadPreference(mode, tags, options);
    }

    this._type = 'ReadPreference';
    this.mode = mode;
    this.tags = tags;
    this.options = options;

    // If no tags were passed in
    if (tags && typeof tags == 'object' && !Array.isArray(tags)) {
      if (tags.maxStalenessSeconds) {
        this.options = tags;
        this.tags = null;
      }
    }

    // Add the maxStalenessSeconds value to the read Preference
    if (this.options && this.options.maxStalenessSeconds) {
      this.maxStalenessSeconds = this.options.maxStalenessSeconds;
    }
  };

  /**
   * Validate if a mode is legal
   *
   * @method
   * @param {string} mode The string representing the read preference mode.
   * @return {boolean}
   */
  ReadPreference.isValid = function (_mode) {
    return _mode == ReadPreference.PRIMARY || _mode == ReadPreference.PRIMARY_PREFERRED || _mode == ReadPreference.SECONDARY || _mode == ReadPreference.SECONDARY_PREFERRED || _mode == ReadPreference.NEAREST || _mode == true || _mode == false || _mode == null;
  };

  /**
   * Validate if a mode is legal
   *
   * @method
   * @param {string} mode The string representing the read preference mode.
   * @return {boolean}
   */
  ReadPreference.prototype.isValid = function (mode) {
    var _mode = typeof mode == 'string' ? mode : this.mode;
    return ReadPreference.isValid(_mode);
  };

  /**
   * @ignore
   */
  ReadPreference.prototype.toObject = function () {
    var object = { mode: this.mode };

    if (this.tags != null) {
      object['tags'] = this.tags;
    }

    if (this.maxStalenessSeconds) {
      object['maxStalenessSeconds'] = this.maxStalenessSeconds;
    }

    return object;
  };

  /**
   * @ignore
   */
  ReadPreference.prototype.toJSON = function () {
    return this.toObject();
  };

  /**
   * @ignore
   */
  ReadPreference.PRIMARY = 'primary';
  ReadPreference.PRIMARY_PREFERRED = 'primaryPreferred';
  ReadPreference.SECONDARY = 'secondary';
  ReadPreference.SECONDARY_PREFERRED = 'secondaryPreferred';
  ReadPreference.NEAREST = 'nearest';

  /**
   * @ignore
   */
  module.exports = ReadPreference;
  return module.exports;
});
$__System.registerDynamic('197', ['2a', '198'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    'use strict';

    var Buffer = $__require('2a').Buffer;
    var bufferShim = $__require('198');
    module.exports = BufferList;
    function BufferList() {
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    BufferList.prototype.push = function (v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    };
    BufferList.prototype.unshift = function (v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    };
    BufferList.prototype.shift = function () {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    };
    BufferList.prototype.clear = function () {
      this.head = this.tail = null;
      this.length = 0;
    };
    BufferList.prototype.join = function (s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;
      while (p = p.next) {
        ret += s + p.data;
      }
      return ret;
    };
    BufferList.prototype.concat = function (n) {
      if (this.length === 0) return bufferShim.alloc(0);
      if (this.length === 1) return this.head.data;
      var ret = bufferShim.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        p.data.copy(ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    };
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic('199', ['19b', '19c', '55', '2a', '198', '19d', '46', '@empty', '197', '19a', '19e', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer, process) {
    'use strict';

    module.exports = Readable;
    var processNextTick = $__require('19b');
    var isArray = $__require('19c');
    Readable.ReadableState = ReadableState;
    var EE = $__require('55').EventEmitter;
    var EElistenerCount = function (emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream;
    (function () {
      try {
        Stream = $__require('st' + 'ream');
      } catch (_) {} finally {
        if (!Stream) Stream = $__require('55').EventEmitter;
      }
    })();
    var Buffer = $__require('2a').Buffer;
    var bufferShim = $__require('198');
    var util = $__require('19d');
    util.inherits = $__require('46');
    var debugUtil = $__require('@empty');
    var debug = void 0;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog('stream');
    } else {
      debug = function () {};
    }
    var BufferList = $__require('197');
    var StringDecoder;
    util.inherits(Readable, Stream);
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === 'function') {
        return emitter.prependListener(event, fn);
      } else {
        if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
      }
    }
    var Duplex;
    function ReadableState(options, stream) {
      Duplex = Duplex || $__require('19a');
      options = options || {};
      this.objectMode = !!options.objectMode;
      if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
      var hwm = options.highWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
      this.highWaterMark = ~~this.highWaterMark;
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.defaultEncoding = options.defaultEncoding || 'utf8';
      this.ranOut = false;
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder) StringDecoder = $__require('19e').StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    var Duplex;
    function Readable(options) {
      Duplex = Duplex || $__require('19a');
      if (!(this instanceof Readable)) return new Readable(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      if (options && typeof options.read === 'function') this._read = options.read;
      Stream.call(this);
    }
    Readable.prototype.push = function (chunk, encoding) {
      var state = this._readableState;
      if (!state.objectMode && typeof chunk === 'string') {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = bufferShim.from(chunk, encoding);
          encoding = '';
        }
      }
      return readableAddChunk(this, state, chunk, encoding, false);
    };
    Readable.prototype.unshift = function (chunk) {
      var state = this._readableState;
      return readableAddChunk(this, state, chunk, '', true);
    };
    Readable.prototype.isPaused = function () {
      return this._readableState.flowing === false;
    };
    function readableAddChunk(stream, state, chunk, encoding, addToFront) {
      var er = chunkInvalid(state, chunk);
      if (er) {
        stream.emit('error', er);
      } else if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (state.ended && !addToFront) {
          var e = new Error('stream.push() after EOF');
          stream.emit('error', e);
        } else if (state.endEmitted && addToFront) {
          var _e = new Error('stream.unshift() after end event');
          stream.emit('error', _e);
        } else {
          var skipAdd;
          if (state.decoder && !addToFront && !encoding) {
            chunk = state.decoder.write(chunk);
            skipAdd = !state.objectMode && chunk.length === 0;
          }
          if (!addToFront) state.reading = false;
          if (!skipAdd) {
            if (state.flowing && state.length === 0 && !state.sync) {
              stream.emit('data', chunk);
              stream.read(0);
            } else {
              state.length += state.objectMode ? 1 : chunk.length;
              if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
              if (state.needReadable) emitReadable(stream);
            }
          }
          maybeReadMore(stream, state);
        }
      } else if (!addToFront) {
        state.reading = false;
      }
      return needMoreData(state);
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable.prototype.setEncoding = function (enc) {
      if (!StringDecoder) StringDecoder = $__require('19e').StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 0x800000;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended) return 0;
      if (state.objectMode) return 1;
      if (n !== n) {
        if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
      }
      if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length) return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function (n) {
      debug('read', n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0) state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug('read: emitReadable', state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug('need readable', doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug('length less than watermark', doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug('reading or ended', doRead);
      } else if (doRead) {
        debug('do read');
        state.reading = true;
        state.sync = true;
        if (state.length === 0) state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading) n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0) ret = fromList(n, state);else ret = null;
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }
      if (state.length === 0) {
        if (!state.ended) state.needReadable = true;
        if (nOrig !== n && state.ended) endReadable(this);
      }
      if (ret !== null) this.emit('data', ret);
      return ret;
    };
    function chunkInvalid(state, chunk) {
      var er = null;
      if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
        er = new TypeError('Invalid non-string/buffer chunk');
      }
      return er;
    }
    function onEofChunk(stream, state) {
      if (state.ended) return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      emitReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug('emitReadable', state.flowing);
        state.emittedReadable = true;
        if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);
      }
    }
    function emitReadable_(stream) {
      debug('emit readable');
      stream.emit('readable');
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        processNextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug('maybeReadMore read 0');
        stream.read(0);
        if (len === state.length) break;else len = state.length;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function (n) {
      this.emit('error', new Error('not implemented'));
    };
    Readable.prototype.pipe = function (dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : cleanup;
      if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);
      dest.on('unpipe', onunpipe);
      function onunpipe(readable) {
        debug('onunpipe');
        if (readable === src) {
          cleanup();
        }
      }
      function onend() {
        debug('onend');
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on('drain', ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug('cleanup');
        dest.removeListener('close', onclose);
        dest.removeListener('finish', onfinish);
        dest.removeListener('drain', ondrain);
        dest.removeListener('error', onerror);
        dest.removeListener('unpipe', onunpipe);
        src.removeListener('end', onend);
        src.removeListener('end', cleanup);
        src.removeListener('data', ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
      }
      var increasedAwaitDrain = false;
      src.on('data', ondata);
      function ondata(chunk) {
        debug('ondata');
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (false === ret && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug('false write response, pause', src._readableState.awaitDrain);
            src._readableState.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug('onerror', er);
        unpipe();
        dest.removeListener('error', onerror);
        if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
      }
      prependListener(dest, 'error', onerror);
      function onclose() {
        dest.removeListener('finish', onfinish);
        unpipe();
      }
      dest.once('close', onclose);
      function onfinish() {
        debug('onfinish');
        dest.removeListener('close', onclose);
        unpipe();
      }
      dest.once('finish', onfinish);
      function unpipe() {
        debug('unpipe');
        src.unpipe(dest);
      }
      dest.emit('pipe', src);
      if (!state.flowing) {
        debug('pipe resume');
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function () {
        var state = src._readableState;
        debug('pipeOnDrain', state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function (dest) {
      var state = this._readableState;
      if (state.pipesCount === 0) return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes) return this;
        if (!dest) dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit('unpipe', this);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var _i = 0; _i < len; _i++) {
          dests[_i].emit('unpipe', this);
        }
        return this;
      }
      var i = indexOf(state.pipes, dest);
      if (i === -1) return this;
      state.pipes.splice(i, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1) state.pipes = state.pipes[0];
      dest.emit('unpipe', this);
      return this;
    };
    Readable.prototype.on = function (ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      if (ev === 'data') {
        if (this._readableState.flowing !== false) this.resume();
      } else if (ev === 'readable') {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            processNextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this, state);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    function nReadingNextTick(self) {
      debug('readable nexttick read 0');
      self.read(0);
    }
    Readable.prototype.resume = function () {
      var state = this._readableState;
      if (!state.flowing) {
        debug('resume');
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        processNextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      if (!state.reading) {
        debug('resume read 0');
        stream.read(0);
      }
      state.resumeScheduled = false;
      state.awaitDrain = 0;
      stream.emit('resume');
      flow(stream);
      if (state.flowing && !state.reading) stream.read(0);
    }
    Readable.prototype.pause = function () {
      debug('call pause flowing=%j', this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug('pause');
        this._readableState.flowing = false;
        this.emit('pause');
      }
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug('flow', state.flowing);
      while (state.flowing && stream.read() !== null) {}
    }
    Readable.prototype.wrap = function (stream) {
      var state = this._readableState;
      var paused = false;
      var self = this;
      stream.on('end', function () {
        debug('wrapped end');
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) self.push(chunk);
        }
        self.push(null);
      });
      stream.on('data', function (chunk) {
        debug('wrapped data');
        if (state.decoder) chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
        var ret = self.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === undefined && typeof stream[i] === 'function') {
          this[i] = function (method) {
            return function () {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      var events = ['error', 'close', 'destroy', 'pause', 'resume'];
      forEach(events, function (ev) {
        stream.on(ev, self.emit.bind(self, ev));
      });
      self._read = function (n) {
        debug('wrapped _read', n);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return self;
    };
    Readable._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0) return null;
      var ret;
      if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
        if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = fromListPartial(n, state.buffer, state.decoder);
      }
      return ret;
    }
    function fromListPartial(n, list, hasStrings) {
      var ret;
      if (n < list.head.data.length) {
        ret = list.head.data.slice(0, n);
        list.head.data = list.head.data.slice(n);
      } else if (n === list.head.data.length) {
        ret = list.shift();
      } else {
        ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
      }
      return ret;
    }
    function copyFromBufferString(n, list) {
      var p = list.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) list.head = p.next;else list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    function copyFromBuffer(n, list) {
      var ret = bufferShim.allocUnsafe(n);
      var p = list.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) list.head = p.next;else list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');
      if (!state.endEmitted) {
        state.ended = true;
        processNextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    }
    function forEach(xs, f) {
      for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) return i;
      }
      return -1;
    }
  })($__require('2a').Buffer, $__require('13'));
  return module.exports;
});
$__System.registerDynamic('19f', ['13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    if (!process.version || process.version.indexOf('v0.') === 0 || process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
      module.exports = nextTick;
    } else {
      module.exports = process.nextTick;
    }
    function nextTick(fn, arg1, arg2, arg3) {
      if (typeof fn !== 'function') {
        throw new TypeError('"callback" argument must be a function');
      }
      var len = arguments.length;
      var args, i;
      switch (len) {
        case 0:
        case 1:
          return process.nextTick(fn);
        case 2:
          return process.nextTick(function afterTickOne() {
            fn.call(null, arg1);
          });
        case 3:
          return process.nextTick(function afterTickTwo() {
            fn.call(null, arg1, arg2);
          });
        case 4:
          return process.nextTick(function afterTickThree() {
            fn.call(null, arg1, arg2, arg3);
          });
        default:
          args = new Array(len - 1);
          i = 0;
          while (i < args.length) {
            args[i++] = arguments[i];
          }
          return process.nextTick(function afterTick() {
            fn.apply(null, args);
          });
      }
    }
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic("19b", ["19f"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("19f");
  return module.exports;
});
$__System.registerDynamic('1a0', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;

  /**
   * Module exports.
   */

  module.exports = deprecate;

  /**
   * Mark that a method should not be used.
   * Returns a modified function which warns once by default.
   *
   * If `localStorage.noDeprecation = true` is set, then it is a no-op.
   *
   * If `localStorage.throwDeprecation = true` is set, then deprecated functions
   * will throw an Error when invoked.
   *
   * If `localStorage.traceDeprecation = true` is set, then deprecated functions
   * will invoke `console.trace()` instead of `console.error()`.
   *
   * @param {Function} fn - the function to deprecate
   * @param {String} msg - the string to print to the console when `fn` is invoked
   * @returns {Function} a new "deprecated" version of `fn`
   * @api public
   */

  function deprecate(fn, msg) {
    if (config('noDeprecation')) {
      return fn;
    }

    var warned = false;
    function deprecated() {
      if (!warned) {
        if (config('throwDeprecation')) {
          throw new Error(msg);
        } else if (config('traceDeprecation')) {
          console.trace(msg);
        } else {
          console.warn(msg);
        }
        warned = true;
      }
      return fn.apply(this, arguments);
    }

    return deprecated;
  }

  /**
   * Checks `localStorage` for boolean values for the given `name`.
   *
   * @param {String} name
   * @returns {Boolean}
   * @api private
   */

  function config(name) {
    // accessing global.localStorage can trigger a DOMException in sandboxed iframes
    try {
      if (!global.localStorage) return false;
    } catch (_) {
      return false;
    }
    var val = global.localStorage[name];
    if (null == val) return false;
    return String(val).toLowerCase() === 'true';
  }
  return module.exports;
});
$__System.registerDynamic("1a1", ["1a0"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("1a0");
  return module.exports;
});
$__System.registerDynamic('1a2', ['2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    'use strict';

    var buffer = $__require('2a');
    var Buffer = buffer.Buffer;
    var SlowBuffer = buffer.SlowBuffer;
    var MAX_LEN = buffer.kMaxLength || 2147483647;
    exports.alloc = function alloc(size, fill, encoding) {
      if (typeof Buffer.alloc === 'function') {
        return Buffer.alloc(size, fill, encoding);
      }
      if (typeof encoding === 'number') {
        throw new TypeError('encoding must not be number');
      }
      if (typeof size !== 'number') {
        throw new TypeError('size must be a number');
      }
      if (size > MAX_LEN) {
        throw new RangeError('size is too large');
      }
      var enc = encoding;
      var _fill = fill;
      if (_fill === undefined) {
        enc = undefined;
        _fill = 0;
      }
      var buf = new Buffer(size);
      if (typeof _fill === 'string') {
        var fillBuf = new Buffer(_fill, enc);
        var flen = fillBuf.length;
        var i = -1;
        while (++i < size) {
          buf[i] = fillBuf[i % flen];
        }
      } else {
        buf.fill(_fill);
      }
      return buf;
    };
    exports.allocUnsafe = function allocUnsafe(size) {
      if (typeof Buffer.allocUnsafe === 'function') {
        return Buffer.allocUnsafe(size);
      }
      if (typeof size !== 'number') {
        throw new TypeError('size must be a number');
      }
      if (size > MAX_LEN) {
        throw new RangeError('size is too large');
      }
      return new Buffer(size);
    };
    exports.from = function from(value, encodingOrOffset, length) {
      if (typeof Buffer.from === 'function' && (!global.Uint8Array || Uint8Array.from !== Buffer.from)) {
        return Buffer.from(value, encodingOrOffset, length);
      }
      if (typeof value === 'number') {
        throw new TypeError('"value" argument must not be a number');
      }
      if (typeof value === 'string') {
        return new Buffer(value, encodingOrOffset);
      }
      if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
        var offset = encodingOrOffset;
        if (arguments.length === 1) {
          return new Buffer(value);
        }
        if (typeof offset === 'undefined') {
          offset = 0;
        }
        var len = length;
        if (typeof len === 'undefined') {
          len = value.byteLength - offset;
        }
        if (offset >= value.byteLength) {
          throw new RangeError('\'offset\' is out of bounds');
        }
        if (len > value.byteLength - offset) {
          throw new RangeError('\'length\' is out of bounds');
        }
        return new Buffer(value.slice(offset, offset + len));
      }
      if (Buffer.isBuffer(value)) {
        var out = new Buffer(value.length);
        value.copy(out, 0, 0, value.length);
        return out;
      }
      if (value) {
        if (Array.isArray(value) || typeof ArrayBuffer !== 'undefined' && value.buffer instanceof ArrayBuffer || 'length' in value) {
          return new Buffer(value);
        }
        if (value.type === 'Buffer' && Array.isArray(value.data)) {
          return new Buffer(value.data);
        }
      }
      throw new TypeError('First argument must be a string, Buffer, ' + 'ArrayBuffer, Array, or array-like object.');
    };
    exports.allocUnsafeSlow = function allocUnsafeSlow(size) {
      if (typeof Buffer.allocUnsafeSlow === 'function') {
        return Buffer.allocUnsafeSlow(size);
      }
      if (typeof size !== 'number') {
        throw new TypeError('size must be a number');
      }
      if (size >= MAX_LEN) {
        throw new RangeError('size is too large');
      }
      return new SlowBuffer(size);
    };
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic("198", ["1a2"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("1a2");
  return module.exports;
});
$__System.registerDynamic('1a3', ['19b', '19d', '46', '1a1', '55', '2a', '198', '19a', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer, process) {
    'use strict';

    module.exports = Writable;
    var processNextTick = $__require('19b');
    var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
    Writable.WritableState = WritableState;
    var util = $__require('19d');
    util.inherits = $__require('46');
    var internalUtil = { deprecate: $__require('1a1') };
    var Stream;
    (function () {
      try {
        Stream = $__require('st' + 'ream');
      } catch (_) {} finally {
        if (!Stream) Stream = $__require('55').EventEmitter;
      }
    })();
    var Buffer = $__require('2a').Buffer;
    var bufferShim = $__require('198');
    util.inherits(Writable, Stream);
    function nop() {}
    function WriteReq(chunk, encoding, cb) {
      this.chunk = chunk;
      this.encoding = encoding;
      this.callback = cb;
      this.next = null;
    }
    var Duplex;
    function WritableState(options, stream) {
      Duplex = Duplex || $__require('19a');
      options = options || {};
      this.objectMode = !!options.objectMode;
      if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
      var hwm = options.highWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
      this.highWaterMark = ~~this.highWaterMark;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || 'utf8';
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function (er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function writableStateGetBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function () {
      try {
        Object.defineProperty(WritableState.prototype, 'buffer', { get: internalUtil.deprecate(function () {
            return this.getBuffer();
          }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.') });
      } catch (_) {}
    })();
    var Duplex;
    function Writable(options) {
      Duplex = Duplex || $__require('19a');
      if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);
      this._writableState = new WritableState(options, this);
      this.writable = true;
      if (options) {
        if (typeof options.write === 'function') this._write = options.write;
        if (typeof options.writev === 'function') this._writev = options.writev;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function () {
      this.emit('error', new Error('Cannot pipe, not readable'));
    };
    function writeAfterEnd(stream, cb) {
      var er = new Error('write after end');
      stream.emit('error', er);
      processNextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      var er = false;
      if (chunk === null) {
        er = new TypeError('May not write null values to stream');
      } else if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
        er = new TypeError('Invalid non-string/buffer chunk');
      }
      if (er) {
        stream.emit('error', er);
        processNextTick(cb, er);
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function (chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
      }
      if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
      if (typeof cb !== 'function') cb = nop;
      if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function () {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function () {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === 'string') encoding = encoding.toLowerCase();
      if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
        chunk = bufferShim.from(chunk, encoding);
      }
      return chunk;
    }
    function writeOrBuffer(stream, state, chunk, encoding, cb) {
      chunk = decodeChunk(state, chunk, encoding);
      if (Buffer.isBuffer(chunk)) encoding = 'buffer';
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret) state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) processNextTick(cb, er);else cb(er);
      stream._writableState.errorEmitted = true;
      stream.emit('error', er);
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er) onwriteError(stream, state, sync, er, cb);else {
        var finished = needFinish(state);
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          asyncWrite(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished) onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit('drain');
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        while (entry) {
          buffer[count] = entry;
          entry = entry.next;
          count += 1;
        }
        doWrite(stream, state, true, state.length, buffer, '', holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          if (state.writing) {
            break;
          }
        }
        if (entry === null) state.lastBufferedRequest = null;
      }
      state.bufferedRequestCount = 0;
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function (chunk, encoding, cb) {
      cb(new Error('not implemented'));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function (chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === 'function') {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending && !state.finished) endWritable(this, state, cb);
    };
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function prefinish(stream, state) {
      if (!state.prefinished) {
        state.prefinished = true;
        stream.emit('prefinish');
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        if (state.pendingcb === 0) {
          prefinish(stream, state);
          state.finished = true;
          stream.emit('finish');
        } else {
          prefinish(stream, state);
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished) processNextTick(cb);else stream.once('finish', cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function (err) {
        var entry = _this.entry;
        _this.entry = null;
        while (entry) {
          var cb = entry.callback;
          state.pendingcb--;
          cb(err);
          entry = entry.next;
        }
        if (state.corkedRequestsFree) {
          state.corkedRequestsFree.next = _this;
        } else {
          state.corkedRequestsFree = _this;
        }
      };
    }
  })($__require('2a').Buffer, $__require('13'));
  return module.exports;
});
$__System.registerDynamic('19a', ['19b', '19d', '46', '199', '1a3', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var objectKeys = Object.keys || function (obj) {
      var keys = [];
      for (var key in obj) {
        keys.push(key);
      }
      return keys;
    };
    module.exports = Duplex;
    var processNextTick = $__require('19b');
    var util = $__require('19d');
    util.inherits = $__require('46');
    var Readable = $__require('199');
    var Writable = $__require('1a3');
    util.inherits(Duplex, Readable);
    var keys = objectKeys(Writable.prototype);
    for (var v = 0; v < keys.length; v++) {
      var method = keys[v];
      if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
    }
    function Duplex(options) {
      if (!(this instanceof Duplex)) return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false) this.readable = false;
      if (options && options.writable === false) this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
      this.once('end', onend);
    }
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended) return;
      processNextTick(onEndNT, this);
    }
    function onEndNT(self) {
      self.end();
    }
    function forEach(xs, f) {
      for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('153', ['19a', '19d', '46', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    module.exports = Transform;
    var Duplex = $__require('19a');
    var util = $__require('19d');
    util.inherits = $__require('46');
    util.inherits(Transform, Duplex);
    function TransformState(stream) {
      this.afterTransform = function (er, data) {
        return afterTransform(stream, er, data);
      };
      this.needTransform = false;
      this.transforming = false;
      this.writecb = null;
      this.writechunk = null;
      this.writeencoding = null;
    }
    function afterTransform(stream, er, data) {
      var ts = stream._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));
      ts.writechunk = null;
      ts.writecb = null;
      if (data !== null && data !== undefined) stream.push(data);
      cb(er);
      var rs = stream._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        stream._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform)) return new Transform(options);
      Duplex.call(this, options);
      this._transformState = new TransformState(this);
      var stream = this;
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === 'function') this._transform = options.transform;
        if (typeof options.flush === 'function') this._flush = options.flush;
      }
      this.once('prefinish', function () {
        if (typeof this._flush === 'function') this._flush(function (er) {
          done(stream, er);
        });else done(stream);
      });
    }
    Transform.prototype.push = function (chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function (chunk, encoding, cb) {
      throw new Error('Not implemented');
    };
    Transform.prototype._write = function (chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function (n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    function done(stream, er) {
      if (er) return stream.emit('error', er);
      var ws = stream._writableState;
      var ts = stream._transformState;
      if (ws.length) throw new Error('Calling transform done when ws.length != 0');
      if (ts.transforming) throw new Error('Calling transform done when still transforming');
      return stream.push(null);
    }
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('1a4', ['153', '19d', '46'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = PassThrough;
  var Transform = $__require('153');
  var util = $__require('19d');
  util.inherits = $__require('46');
  util.inherits(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough)) return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function (chunk, encoding, cb) {
    cb(null, chunk);
  };
  return module.exports;
});
$__System.registerDynamic('1a5', ['199', '1a3', '19a', '153', '1a4', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    var Stream = function () {
      try {
        return $__require('st' + 'ream');
      } catch (_) {}
    }();
    exports = module.exports = $__require('199');
    exports.Stream = Stream || exports;
    exports.Readable = exports;
    exports.Writable = $__require('1a3');
    exports.Duplex = $__require('19a');
    exports.Transform = $__require('153');
    exports.PassThrough = $__require('1a4');
    if (!process.browser && process.env.READABLE_STREAM === 'disable' && Stream) {
      module.exports = Stream;
    }
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic("194", ["1a5"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("1a5");
  return module.exports;
});
$__System.registerDynamic('18d', ['166'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var f = $__require('166').format;

  var Define = function (name, object, stream) {
    this.name = name;
    this.object = object;
    this.stream = typeof stream == 'boolean' ? stream : false;
    this.instrumentations = {};
  };

  Define.prototype.classMethod = function (name, options) {
    var keys = Object.keys(options).sort();
    var key = generateKey(keys, options);

    // Add a list of instrumentations
    if (this.instrumentations[key] == null) {
      this.instrumentations[key] = {
        methods: [], options: options
      };
    }

    // Push to list of method for this instrumentation
    this.instrumentations[key].methods.push(name);
  };

  var generateKey = function (keys, options) {
    var parts = [];
    for (var i = 0; i < keys.length; i++) {
      parts.push(f('%s=%s', keys[i], options[keys[i]]));
    }

    return parts.join();
  };

  Define.prototype.staticMethod = function (name, options) {
    options.static = true;
    var keys = Object.keys(options).sort();
    var key = generateKey(keys, options);

    // Add a list of instrumentations
    if (this.instrumentations[key] == null) {
      this.instrumentations[key] = {
        methods: [], options: options
      };
    }

    // Push to list of method for this instrumentation
    this.instrumentations[key].methods.push(name);
  };

  Define.prototype.generate = function () {
    // Generate the return object
    var object = {
      name: this.name, obj: this.object, stream: this.stream,
      instrumentations: []
    };

    for (var name in this.instrumentations) {
      object.instrumentations.push(this.instrumentations[name]);
    }

    return object;
  };

  module.exports = Define;
  return module.exports;
});
$__System.registerDynamic('184', ['166', '18e', '188', '18f', '49', '194', '18d', '190', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    "use strict";

    var inherits = $__require('166').inherits,
        f = $__require('166').format,
        formattedOrderClause = $__require('18e').formattedOrderClause,
        handleCallback = $__require('18e').handleCallback,
        ReadPreference = $__require('188'),
        MongoError = $__require('18f').MongoError,
        Readable = $__require('49').Readable || $__require('194').Readable,
        Define = $__require('18d'),
        CoreCursor = $__require('18f').Cursor,
        Map = $__require('18f').BSON.Map,
        CoreReadPreference = $__require('18f').ReadPreference;
    var flags = ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'exhaust', 'partial'];
    var fields = ['numberOfRetries', 'tailableRetryInterval'];
    var push = Array.prototype.push;
    var Cursor = function (bson, ns, cmd, options, topology, topologyOptions) {
      CoreCursor.apply(this, Array.prototype.slice.call(arguments, 0));
      var self = this;
      var state = Cursor.INIT;
      var streamOptions = {};
      var numberOfRetries = options.numberOfRetries || 5;
      var tailableRetryInterval = options.tailableRetryInterval || 500;
      var currentNumberOfRetries = numberOfRetries;
      var promiseLibrary = options.promiseLibrary;
      if (!promiseLibrary) {
        promiseLibrary = typeof global.Promise == 'function' ? global.Promise : $__require('190').Promise;
      }
      Readable.call(this, { objectMode: true });
      this.s = {
        numberOfRetries: numberOfRetries,
        tailableRetryInterval: tailableRetryInterval,
        currentNumberOfRetries: currentNumberOfRetries,
        state: state,
        streamOptions: streamOptions,
        bson: bson,
        ns: ns,
        cmd: cmd,
        options: options,
        topology: topology,
        topologyOptions: topologyOptions,
        promiseLibrary: promiseLibrary,
        currentDoc: null
      };
      if (self.s.options.noCursorTimeout == true) {
        self.addCursorFlag('noCursorTimeout', true);
      }
      this.sortValue = self.s.cmd.sort;
    };
    inherits(Cursor, Readable);
    CoreCursor.prototype._next = CoreCursor.prototype.next;
    for (var name in CoreCursor.prototype) {
      Cursor.prototype[name] = CoreCursor.prototype[name];
    }
    var define = Cursor.define = new Define('Cursor', Cursor, true);
    Cursor.prototype.hasNext = function (callback) {
      var self = this;
      if (typeof callback == 'function') {
        if (self.s.currentDoc) {
          return callback(null, true);
        } else {
          return nextObject(self, function (err, doc) {
            if (!doc) return callback(null, false);
            self.s.currentDoc = doc;
            callback(null, true);
          });
        }
      }
      return new this.s.promiseLibrary(function (resolve, reject) {
        if (self.s.currentDoc) {
          resolve(true);
        } else {
          nextObject(self, function (err, doc) {
            if (self.s.state == Cursor.CLOSED || self.isDead()) return resolve(false);
            if (err) return reject(err);
            if (!doc) return resolve(false);
            self.s.currentDoc = doc;
            resolve(true);
          });
        }
      });
    };
    define.classMethod('hasNext', {
      callback: true,
      promise: true
    });
    Cursor.prototype.next = function (callback) {
      var self = this;
      if (typeof callback == 'function') {
        if (self.s.currentDoc) {
          var doc = self.s.currentDoc;
          self.s.currentDoc = null;
          return callback(null, doc);
        }
        return nextObject(self, callback);
      }
      return new this.s.promiseLibrary(function (resolve, reject) {
        if (self.s.currentDoc) {
          var doc = self.s.currentDoc;
          self.s.currentDoc = null;
          return resolve(doc);
        }
        nextObject(self, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    define.classMethod('next', {
      callback: true,
      promise: true
    });
    Cursor.prototype.filter = function (filter) {
      if (this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({
        message: "Cursor is closed",
        driver: true
      });
      this.s.cmd.query = filter;
      return this;
    };
    define.classMethod('filter', {
      callback: false,
      promise: false,
      returns: [Cursor]
    });
    Cursor.prototype.maxScan = function (maxScan) {
      if (this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({
        message: "Cursor is closed",
        driver: true
      });
      this.s.cmd.maxScan = maxScan;
      return this;
    };
    define.classMethod('maxScan', {
      callback: false,
      promise: false,
      returns: [Cursor]
    });
    Cursor.prototype.hint = function (hint) {
      if (this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({
        message: "Cursor is closed",
        driver: true
      });
      this.s.cmd.hint = hint;
      return this;
    };
    define.classMethod('hint', {
      callback: false,
      promise: false,
      returns: [Cursor]
    });
    Cursor.prototype.min = function (min) {
      if (this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({
        message: "Cursor is closed",
        driver: true
      });
      this.s.cmd.min = min;
      return this;
    };
    define.classMethod('min', {
      callback: false,
      promise: false,
      returns: [Cursor]
    });
    Cursor.prototype.max = function (max) {
      if (this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({
        message: "Cursor is closed",
        driver: true
      });
      this.s.cmd.max = max;
      return this;
    };
    define.classMethod('max', {
      callback: false,
      promise: false,
      returns: [Cursor]
    });
    Cursor.prototype.returnKey = function (value) {
      if (this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({
        message: "Cursor is closed",
        driver: true
      });
      this.s.cmd.returnKey = value;
      return this;
    };
    define.classMethod('returnKey', {
      callback: false,
      promise: false,
      returns: [Cursor]
    });
    Cursor.prototype.showRecordId = function (value) {
      if (this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({
        message: "Cursor is closed",
        driver: true
      });
      this.s.cmd.showDiskLoc = value;
      return this;
    };
    define.classMethod('showRecordId', {
      callback: false,
      promise: false,
      returns: [Cursor]
    });
    Cursor.prototype.snapshot = function (value) {
      if (this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({
        message: "Cursor is closed",
        driver: true
      });
      this.s.cmd.snapshot = value;
      return this;
    };
    define.classMethod('snapshot', {
      callback: false,
      promise: false,
      returns: [Cursor]
    });
    Cursor.prototype.setCursorOption = function (field, value) {
      if (this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({
        message: "Cursor is closed",
        driver: true
      });
      if (fields.indexOf(field) == -1) throw MongoError.create({
        message: f("option %s not a supported option %s", field, fields),
        driver: true
      });
      this.s[field] = value;
      if (field == 'numberOfRetries') this.s.currentNumberOfRetries = value;
      return this;
    };
    define.classMethod('setCursorOption', {
      callback: false,
      promise: false,
      returns: [Cursor]
    });
    Cursor.prototype.addCursorFlag = function (flag, value) {
      if (this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({
        message: "Cursor is closed",
        driver: true
      });
      if (flags.indexOf(flag) == -1) throw MongoError.create({
        message: f("flag %s not a supported flag %s", flag, flags),
        driver: true
      });
      if (typeof value != 'boolean') throw MongoError.create({
        message: f("flag %s must be a boolean value", flag),
        driver: true
      });
      this.s.cmd[flag] = value;
      return this;
    };
    define.classMethod('addCursorFlag', {
      callback: false,
      promise: false,
      returns: [Cursor]
    });
    Cursor.prototype.addQueryModifier = function (name, value) {
      if (this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({
        message: "Cursor is closed",
        driver: true
      });
      if (name[0] != '$') throw MongoError.create({
        message: f("%s is not a valid query modifier"),
        driver: true
      });
      var field = name.substr(1);
      this.s.cmd[field] = value;
      if (field == 'orderby') this.s.cmd.sort = this.s.cmd[field];
      return this;
    };
    define.classMethod('addQueryModifier', {
      callback: false,
      promise: false,
      returns: [Cursor]
    });
    Cursor.prototype.comment = function (value) {
      if (this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({
        message: "Cursor is closed",
        driver: true
      });
      this.s.cmd.comment = value;
      return this;
    };
    define.classMethod('comment', {
      callback: false,
      promise: false,
      returns: [Cursor]
    });
    Cursor.prototype.maxAwaitTimeMS = function (value) {
      if (typeof value != 'number') throw MongoError.create({
        message: "maxAwaitTimeMS must be a number",
        driver: true
      });
      if (this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({
        message: "Cursor is closed",
        driver: true
      });
      this.s.cmd.maxAwaitTimeMS = value;
      return this;
    };
    define.classMethod('maxAwaitTimeMS', {
      callback: false,
      promise: false,
      returns: [Cursor]
    });
    Cursor.prototype.maxTimeMS = function (value) {
      if (typeof value != 'number') throw MongoError.create({
        message: "maxTimeMS must be a number",
        driver: true
      });
      if (this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({
        message: "Cursor is closed",
        driver: true
      });
      this.s.cmd.maxTimeMS = value;
      return this;
    };
    define.classMethod('maxTimeMS', {
      callback: false,
      promise: false,
      returns: [Cursor]
    });
    Cursor.prototype.maxTimeMs = Cursor.prototype.maxTimeMS;
    define.classMethod('maxTimeMs', {
      callback: false,
      promise: false,
      returns: [Cursor]
    });
    Cursor.prototype.project = function (value) {
      if (this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({
        message: "Cursor is closed",
        driver: true
      });
      this.s.cmd.fields = value;
      return this;
    };
    define.classMethod('project', {
      callback: false,
      promise: false,
      returns: [Cursor]
    });
    Cursor.prototype.sort = function (keyOrList, direction) {
      if (this.s.options.tailable) throw MongoError.create({
        message: "Tailable cursor doesn't support sorting",
        driver: true
      });
      if (this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({
        message: "Cursor is closed",
        driver: true
      });
      var order = keyOrList;
      if (Array.isArray(order) && Array.isArray(order[0])) {
        order = new Map(order.map(function (x) {
          var value = [x[0], null];
          if (x[1] == 'asc') {
            value[1] = 1;
          } else if (x[1] == 'desc') {
            value[1] = -1;
          } else if (x[1] == 1 || x[1] == -1) {
            value[1] = x[1];
          } else {
            throw new MongoError("Illegal sort clause, must be of the form [['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]");
          }
          return value;
        }));
      }
      if (direction != null) {
        order = [[keyOrList, direction]];
      }
      this.s.cmd.sort = order;
      this.sortValue = order;
      return this;
    };
    define.classMethod('sort', {
      callback: false,
      promise: false,
      returns: [Cursor]
    });
    Cursor.prototype.batchSize = function (value) {
      if (this.s.options.tailable) throw MongoError.create({
        message: "Tailable cursor doesn't support batchSize",
        driver: true
      });
      if (this.s.state == Cursor.CLOSED || this.isDead()) throw MongoError.create({
        message: "Cursor is closed",
        driver: true
      });
      if (typeof value != 'number') throw MongoError.create({
        message: "batchSize requires an integer",
        driver: true
      });
      this.s.cmd.batchSize = value;
      this.setCursorBatchSize(value);
      return this;
    };
    define.classMethod('batchSize', {
      callback: false,
      promise: false,
      returns: [Cursor]
    });
    Cursor.prototype.collation = function (value) {
      this.s.cmd.collation = value;
      return this;
    };
    define.classMethod('collation', {
      callback: false,
      promise: false,
      returns: [Cursor]
    });
    Cursor.prototype.limit = function (value) {
      if (this.s.options.tailable) throw MongoError.create({
        message: "Tailable cursor doesn't support limit",
        driver: true
      });
      if (this.s.state == Cursor.OPEN || this.s.state == Cursor.CLOSED || this.isDead()) throw MongoError.create({
        message: "Cursor is closed",
        driver: true
      });
      if (typeof value != 'number') throw MongoError.create({
        message: "limit requires an integer",
        driver: true
      });
      this.s.cmd.limit = value;
      this.setCursorLimit(value);
      return this;
    };
    define.classMethod('limit', {
      callback: false,
      promise: false,
      returns: [Cursor]
    });
    Cursor.prototype.skip = function (value) {
      if (this.s.options.tailable) throw MongoError.create({
        message: "Tailable cursor doesn't support skip",
        driver: true
      });
      if (this.s.state == Cursor.OPEN || this.s.state == Cursor.CLOSED || this.isDead()) throw MongoError.create({
        message: "Cursor is closed",
        driver: true
      });
      if (typeof value != 'number') throw MongoError.create({
        message: "skip requires an integer",
        driver: true
      });
      this.s.cmd.skip = value;
      this.setCursorSkip(value);
      return this;
    };
    define.classMethod('skip', {
      callback: false,
      promise: false,
      returns: [Cursor]
    });
    Cursor.prototype.nextObject = Cursor.prototype.next;
    var nextObject = function (self, callback) {
      if (self.s.state == Cursor.CLOSED || self.isDead && self.isDead()) return handleCallback(callback, MongoError.create({
        message: "Cursor is closed",
        driver: true
      }));
      if (self.s.state == Cursor.INIT && self.s.cmd.sort) {
        try {
          self.s.cmd.sort = formattedOrderClause(self.s.cmd.sort);
        } catch (err) {
          return handleCallback(callback, err);
        }
      }
      self._next(function (err, doc) {
        self.s.state = Cursor.OPEN;
        if (err) return handleCallback(callback, err);
        handleCallback(callback, null, doc);
      });
    };
    define.classMethod('nextObject', {
      callback: true,
      promise: true
    });
    var loop = function (self, callback) {
      if (self.bufferedCount() == 0) return;
      self._next(callback);
      return loop;
    };
    Cursor.prototype.next = Cursor.prototype.nextObject;
    define.classMethod('next', {
      callback: true,
      promise: true
    });
    Cursor.prototype.each = function (callback) {
      this.rewind();
      this.s.state = Cursor.INIT;
      _each(this, callback);
    };
    define.classMethod('each', {
      callback: true,
      promise: false
    });
    var _each = function (self, callback) {
      if (!callback) throw MongoError.create({
        message: 'callback is mandatory',
        driver: true
      });
      if (self.isNotified()) return;
      if (self.s.state == Cursor.CLOSED || self.isDead()) {
        return handleCallback(callback, MongoError.create({
          message: "Cursor is closed",
          driver: true
        }));
      }
      if (self.s.state == Cursor.INIT) self.s.state = Cursor.OPEN;
      var fn = null;
      if (self.bufferedCount() > 0) {
        while (fn = loop(self, callback)) fn(self, callback);
        _each(self, callback);
      } else {
        self.next(function (err, item) {
          if (err) return handleCallback(callback, err);
          if (item == null) {
            self.s.state = Cursor.CLOSED;
            return handleCallback(callback, null, null);
          }
          if (handleCallback(callback, null, item) == false) return;
          _each(self, callback);
        });
      }
    };
    Cursor.prototype.forEach = function (iterator, callback) {
      this.each(function (err, doc) {
        if (err) {
          callback(err);
          return false;
        }
        if (doc != null) {
          iterator(doc);
          return true;
        }
        if (doc == null && callback) {
          var internalCallback = callback;
          callback = null;
          internalCallback(null);
          return false;
        }
      });
    };
    define.classMethod('forEach', {
      callback: true,
      promise: false
    });
    Cursor.prototype.setReadPreference = function (r) {
      if (this.s.state != Cursor.INIT) throw MongoError.create({
        message: 'cannot change cursor readPreference after cursor has been accessed',
        driver: true
      });
      if (r instanceof ReadPreference) {
        this.s.options.readPreference = new CoreReadPreference(r.mode, r.tags, { maxStalenessSeconds: r.maxStalenessSeconds });
      } else if (typeof r == 'string') {
        this.s.options.readPreference = new CoreReadPreference(r);
      } else if (r instanceof CoreReadPreference) {
        this.s.options.readPreference = r;
      }
      return this;
    };
    define.classMethod('setReadPreference', {
      callback: false,
      promise: false,
      returns: [Cursor]
    });
    Cursor.prototype.toArray = function (callback) {
      var self = this;
      if (self.s.options.tailable) throw MongoError.create({
        message: 'Tailable cursor cannot be converted to array',
        driver: true
      });
      if (typeof callback == 'function') return toArray(self, callback);
      return new this.s.promiseLibrary(function (resolve, reject) {
        toArray(self, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var toArray = function (self, callback) {
      var items = [];
      self.rewind();
      self.s.state = Cursor.INIT;
      var fetchDocs = function () {
        self._next(function (err, doc) {
          if (err) return handleCallback(callback, err);
          if (doc == null) {
            self.s.state = Cursor.CLOSED;
            return handleCallback(callback, null, items);
          }
          items.push(doc);
          if (self.bufferedCount() > 0) {
            var docs = self.readBufferedDocuments(self.bufferedCount());
            if (self.s.transforms && typeof self.s.transforms.doc == 'function') {
              docs = docs.map(self.s.transforms.doc);
            }
            push.apply(items, docs);
          }
          fetchDocs();
        });
      };
      fetchDocs();
    };
    define.classMethod('toArray', {
      callback: true,
      promise: true
    });
    Cursor.prototype.count = function (applySkipLimit, opts, callback) {
      var self = this;
      if (self.s.cmd.query == null) throw MongoError.create({
        message: "count can only be used with find command",
        driver: true
      });
      if (typeof opts == 'function') callback = opts, opts = {};
      opts = opts || {};
      if (typeof callback == 'function') return count(self, applySkipLimit, opts, callback);
      return new this.s.promiseLibrary(function (resolve, reject) {
        count(self, applySkipLimit, opts, function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    var count = function (self, applySkipLimit, opts, callback) {
      if (typeof applySkipLimit == 'function') {
        callback = applySkipLimit;
        applySkipLimit = true;
      }
      if (applySkipLimit) {
        if (typeof self.cursorSkip() == 'number') opts.skip = self.cursorSkip();
        if (typeof self.cursorLimit() == 'number') opts.limit = self.cursorLimit();
      }
      var delimiter = self.s.ns.indexOf('.');
      var command = {
        'count': self.s.ns.substr(delimiter + 1),
        'query': self.s.cmd.query
      };
      if (typeof opts.maxTimeMS == 'number') {
        command.maxTimeMS = opts.maxTimeMS;
      } else if (self.s.cmd && typeof self.s.cmd.maxTimeMS == 'number') {
        command.maxTimeMS = self.s.cmd.maxTimeMS;
      }
      if (opts.skip) command.skip = opts.skip;
      if (opts.limit) command.limit = opts.limit;
      if (self.s.options.hint) command.hint = self.s.options.hint;
      self.topology.command(f("%s.$cmd", self.s.ns.substr(0, delimiter)), command, function (err, result) {
        callback(err, result ? result.result.n : null);
      });
    };
    define.classMethod('count', {
      callback: true,
      promise: true
    });
    Cursor.prototype.close = function (callback) {
      this.s.state = Cursor.CLOSED;
      this.kill();
      this.emit('close');
      if (typeof callback == 'function') return handleCallback(callback, null, this);
      return new this.s.promiseLibrary(function (resolve) {
        resolve();
      });
    };
    define.classMethod('close', {
      callback: true,
      promise: true
    });
    Cursor.prototype.map = function (transform) {
      this.cursorState.transforms = { doc: transform };
      return this;
    };
    define.classMethod('map', {
      callback: false,
      promise: false,
      returns: [Cursor]
    });
    Cursor.prototype.isClosed = function () {
      return this.isDead();
    };
    define.classMethod('isClosed', {
      callback: false,
      promise: false,
      returns: [Boolean]
    });
    Cursor.prototype.destroy = function (err) {
      if (err) this.emit('error', err);
      this.pause();
      this.close();
    };
    define.classMethod('destroy', {
      callback: false,
      promise: false
    });
    Cursor.prototype.stream = function (options) {
      this.s.streamOptions = options || {};
      return this;
    };
    define.classMethod('stream', {
      callback: false,
      promise: false,
      returns: [Cursor]
    });
    Cursor.prototype.explain = function (callback) {
      var self = this;
      this.s.cmd.explain = true;
      if (this.s.cmd.readConcern) {
        delete this.s.cmd['readConcern'];
      }
      if (typeof callback == 'function') return this._next(callback);
      return new this.s.promiseLibrary(function (resolve, reject) {
        self._next(function (err, r) {
          if (err) return reject(err);
          resolve(r);
        });
      });
    };
    define.classMethod('explain', {
      callback: true,
      promise: true
    });
    Cursor.prototype._read = function () {
      var self = this;
      if (self.s.state == Cursor.CLOSED || self.isDead()) {
        return self.push(null);
      }
      self.nextObject(function (err, result) {
        if (err) {
          if (self.listeners('error') && self.listeners('error').length > 0) {
            self.emit('error', err);
          }
          if (!self.isDead()) self.close();
          self.emit('end');
          return self.emit('finish');
        }
        if (typeof self.s.streamOptions.transform == 'function' && result != null) {
          return self.push(self.s.streamOptions.transform(result));
        }
        if (self.cursorState.transforms && typeof self.cursorState.transforms.doc == 'function' && result != null) {
          return self.push(self.cursorState.transforms.doc(result));
        }
        self.push(result);
      });
    };
    Object.defineProperty(Cursor.prototype, 'readPreference', {
      enumerable: true,
      get: function () {
        if (!this || !this.s) {
          return null;
        }
        return this.s.options.readPreference;
      }
    });
    Object.defineProperty(Cursor.prototype, 'namespace', {
      enumerable: true,
      get: function () {
        if (!this || !this.s) {
          return null;
        }
        var ns = this.s.ns || '';
        var firstDot = ns.indexOf('.');
        if (firstDot < 0) {
          return {
            database: this.s.ns,
            collection: ''
          };
        }
        return {
          database: ns.substr(0, firstDot),
          collection: ns.substr(firstDot + 1)
        };
      }
    });
    Cursor.INIT = 0;
    Cursor.OPEN = 1;
    Cursor.CLOSED = 2;
    Cursor.GET_MORE = 3;
    module.exports = Cursor;
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic('1a6', ['49', '166'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var stream = $__require('49'),
      util = $__require('166');

  module.exports = GridFSBucketReadStream;

  /**
   * A readable stream that enables you to read buffers from GridFS.
   *
   * Do not instantiate this class directly. Use `openDownloadStream()` instead.
   *
   * @class
   * @param {Collection} chunks Handle for chunks collection
   * @param {Collection} files Handle for files collection
   * @param {Object} readPreference The read preference to use
   * @param {Object} filter The query to use to find the file document
   * @param {Object} [options=null] Optional settings.
   * @param {Number} [options.sort=null] Optional sort for the file find query
   * @param {Number} [options.skip=null] Optional skip for the file find query
   * @param {Number} [options.start=null] Optional 0-based offset in bytes to start streaming from
   * @param {Number} [options.end=null] Optional 0-based offset in bytes to stop streaming before
   * @fires GridFSBucketReadStream#error
   * @fires GridFSBucketReadStream#file
   * @return {GridFSBucketReadStream} a GridFSBucketReadStream instance.
   */

  function GridFSBucketReadStream(chunks, files, readPreference, filter, options) {
    this.s = {
      bytesRead: 0,
      chunks: chunks,
      cursor: null,
      expected: 0,
      files: files,
      filter: filter,
      init: false,
      expectedEnd: 0,
      file: null,
      options: options,
      readPreference: readPreference
    };

    stream.Readable.call(this);
  }

  util.inherits(GridFSBucketReadStream, stream.Readable);

  /**
   * An error occurred
   *
   * @event GridFSBucketReadStream#error
   * @type {Error}
   */

  /**
   * Fires when the stream loaded the file document corresponding to the
   * provided id.
   *
   * @event GridFSBucketReadStream#file
   * @type {object}
   */

  /**
   * Emitted when a chunk of data is available to be consumed.
   *
   * @event GridFSBucketReadStream#data
   * @type {object}
   */

  /**
   * Fired when the stream is exhausted (no more data events).
   *
   * @event GridFSBucketReadStream#end
   * @type {object}
   */

  /**
   * Fired when the stream is exhausted and the underlying cursor is killed
   *
   * @event GridFSBucketReadStream#close
   * @type {object}
   */

  /**
   * Reads from the cursor and pushes to the stream.
   * @method
   */

  GridFSBucketReadStream.prototype._read = function () {
    var _this = this;
    if (this.destroyed) {
      return;
    }

    waitForFile(_this, function () {
      doRead(_this);
    });
  };

  /**
   * Sets the 0-based offset in bytes to start streaming from. Throws
   * an error if this stream has entered flowing mode
   * (e.g. if you've already called `on('data')`)
   * @method
   * @param {Number} start Offset in bytes to start reading at
   * @return {GridFSBucketReadStream}
   */

  GridFSBucketReadStream.prototype.start = function (start) {
    throwIfInitialized(this);
    this.s.options.start = start;
    return this;
  };

  /**
   * Sets the 0-based offset in bytes to start streaming from. Throws
   * an error if this stream has entered flowing mode
   * (e.g. if you've already called `on('data')`)
   * @method
   * @param {Number} end Offset in bytes to stop reading at
   * @return {GridFSBucketReadStream}
   */

  GridFSBucketReadStream.prototype.end = function (end) {
    throwIfInitialized(this);
    this.s.options.end = end;
    return this;
  };

  /**
   * Marks this stream as aborted (will never push another `data` event)
   * and kills the underlying cursor. Will emit the 'end' event, and then
   * the 'close' event once the cursor is successfully killed.
   *
   * @method
   * @param {GridFSBucket~errorCallback} [callback] called when the cursor is successfully closed or an error occurred.
   * @fires GridFSBucketWriteStream#close
   * @fires GridFSBucketWriteStream#end
   */

  GridFSBucketReadStream.prototype.abort = function (callback) {
    var _this = this;
    this.push(null);
    this.destroyed = true;
    if (this.s.cursor) {
      this.s.cursor.close(function (error) {
        _this.emit('close');
        callback && callback(error);
      });
    } else {
      if (!this.s.init) {
        // If not initialized, fire close event because we will never
        // get a cursor
        _this.emit('close');
      }
      callback && callback();
    }
  };

  /**
   * @ignore
   */

  function throwIfInitialized(self) {
    if (self.s.init) {
      throw new Error('You cannot change options after the stream has entered' + 'flowing mode!');
    }
  }

  /**
   * @ignore
   */

  function doRead(_this) {
    if (_this.destroyed) {
      return;
    }

    _this.s.cursor.next(function (error, doc) {
      if (_this.destroyed) {
        return;
      }
      if (error) {
        return __handleError(_this, error);
      }
      if (!doc) {
        _this.push(null);
        return _this.s.cursor.close(function (error) {
          if (error) {
            return __handleError(_this, error);
          }
          _this.emit('close');
        });
      }

      var bytesRemaining = _this.s.file.length - _this.s.bytesRead;
      var expectedN = _this.s.expected++;
      var expectedLength = Math.min(_this.s.file.chunkSize, bytesRemaining);

      if (doc.n > expectedN) {
        var errmsg = 'ChunkIsMissing: Got unexpected n: ' + doc.n + ', expected: ' + expectedN;
        return __handleError(_this, new Error(errmsg));
      }

      if (doc.n < expectedN) {
        errmsg = 'ExtraChunk: Got unexpected n: ' + doc.n + ', expected: ' + expectedN;
        return __handleError(_this, new Error(errmsg));
      }

      if (doc.data.length() !== expectedLength) {
        if (bytesRemaining <= 0) {
          errmsg = 'ExtraChunk: Got unexpected n: ' + doc.n;
          return __handleError(_this, new Error(errmsg));
        }

        errmsg = 'ChunkIsWrongSize: Got unexpected length: ' + doc.data.length() + ', expected: ' + expectedLength;
        return __handleError(_this, new Error(errmsg));
      }

      _this.s.bytesRead += doc.data.length();

      if (doc.data.buffer.length === 0) {
        return _this.push(null);
      }

      var sliceStart = null;
      var sliceEnd = null;
      var buf = doc.data.buffer;

      if (_this.s.bytesToSkip != null) {
        sliceStart = _this.s.bytesToSkip;
        _this.s.bytesToSkip = 0;
      }

      if (expectedN === _this.s.expectedEnd && _this.s.bytesToTrim != null) {
        sliceEnd = _this.s.bytesToTrim;
      }

      // If the remaining amount of data left is < chunkSize read the right amount of data
      if (_this.s.options.end && _this.s.options.end - _this.s.bytesToSkip < doc.data.length()) {
        sliceEnd = _this.s.options.end - _this.s.bytesToSkip;
      }

      if (sliceStart != null || sliceEnd != null) {
        buf = buf.slice(sliceStart || 0, sliceEnd || buf.length);
      }

      _this.push(buf);
    });
  }

  /**
   * @ignore
   */

  function init(self) {
    var findOneOptions = {};
    if (self.s.readPreference) {
      findOneOptions.readPreference = self.s.readPreference;
    }
    if (self.s.options && self.s.options.sort) {
      findOneOptions.sort = self.s.options.sort;
    }
    if (self.s.options && self.s.options.skip) {
      findOneOptions.skip = self.s.options.skip;
    }

    self.s.files.findOne(self.s.filter, findOneOptions, function (error, doc) {
      if (error) {
        return __handleError(self, error);
      }
      if (!doc) {
        var identifier = self.s.filter._id ? self.s.filter._id.toString() : self.s.filter.filename;
        var errmsg = 'FileNotFound: file ' + identifier + ' was not found';
        var err = new Error(errmsg);
        err.code = 'ENOENT';
        return __handleError(self, err);
      }

      // If document is empty, kill the stream immediately and don't
      // execute any reads
      if (doc.length <= 0) {
        self.push(null);
        return;
      }

      if (self.destroyed) {
        // If user destroys the stream before we have a cursor, wait
        // until the query is done to say we're 'closed' because we can't
        // cancel a query.
        self.emit('close');
        return;
      }

      self.s.cursor = self.s.chunks.find({ files_id: doc._id }).sort({ n: 1 });
      if (self.s.readPreference) {
        self.s.cursor.setReadPreference(self.s.readPreference);
      }

      self.s.expectedEnd = Math.ceil(doc.length / doc.chunkSize);
      self.s.file = doc;
      self.s.bytesToSkip = handleStartOption(self, doc, self.s.cursor, self.s.options);
      self.s.bytesToTrim = handleEndOption(self, doc, self.s.cursor, self.s.options);
      self.emit('file', doc);
    });
  }

  /**
   * @ignore
   */

  function waitForFile(_this, callback) {
    if (_this.s.file) {
      return callback();
    }

    if (!_this.s.init) {
      init(_this);
      _this.s.init = true;
    }

    _this.once('file', function () {
      callback();
    });
  }

  /**
   * @ignore
   */

  function handleStartOption(stream, doc, cursor, options) {
    if (options && options.start != null) {
      if (options.start > doc.length) {
        throw new Error('Stream start (' + options.start + ') must not be ' + 'more than the length of the file (' + doc.length + ')');
      }
      if (options.start < 0) {
        throw new Error('Stream start (' + options.start + ') must not be ' + 'negative');
      }
      if (options.end != null && options.end < options.start) {
        throw new Error('Stream start (' + options.start + ') must not be ' + 'greater than stream end (' + options.end + ')');
      }

      cursor.skip(Math.floor(options.start / doc.chunkSize));

      stream.s.bytesRead = Math.floor(options.start / doc.chunkSize) * doc.chunkSize;
      stream.s.expected = Math.floor(options.start / doc.chunkSize);

      return options.start - stream.s.bytesRead;
    }
  }

  /**
   * @ignore
   */

  function handleEndOption(stream, doc, cursor, options) {
    if (options && options.end != null) {
      if (options.end > doc.length) {
        throw new Error('Stream end (' + options.end + ') must not be ' + 'more than the length of the file (' + doc.length + ')');
      }
      if (options.start < 0) {
        throw new Error('Stream end (' + options.end + ') must not be ' + 'negative');
      }

      var start = options.start != null ? Math.floor(options.start / doc.chunkSize) : 0;

      cursor.limit(Math.ceil(options.end / doc.chunkSize) - start);

      stream.s.expectedEnd = Math.ceil(options.end / doc.chunkSize);

      return Math.ceil(options.end / doc.chunkSize) * doc.chunkSize - options.end;
    }
  }

  /**
   * @ignore
   */

  function __handleError(_this, error) {
    _this.emit('error', error);
  }
  return module.exports;
});
$__System.registerDynamic('1a7', ['18f', '38', '49', '166', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    var core = $__require('18f');
    var crypto = $__require('38');
    var stream = $__require('49');
    var util = $__require('166');
    var ERROR_NAMESPACE_NOT_FOUND = 26;
    module.exports = GridFSBucketWriteStream;
    function GridFSBucketWriteStream(bucket, filename, options) {
      options = options || {};
      this.bucket = bucket;
      this.chunks = bucket.s._chunksCollection;
      this.filename = filename;
      this.files = bucket.s._filesCollection;
      this.options = options;
      this.id = options.id ? options.id : core.BSON.ObjectId();
      this.chunkSizeBytes = this.options.chunkSizeBytes;
      this.bufToStore = new Buffer(this.chunkSizeBytes);
      this.length = 0;
      this.md5 = crypto.createHash('md5');
      this.n = 0;
      this.pos = 0;
      this.state = {
        streamEnd: false,
        outstandingRequests: 0,
        errored: false,
        aborted: false,
        promiseLibrary: this.bucket.s.promiseLibrary
      };
      if (!this.bucket.s.calledOpenUploadStream) {
        this.bucket.s.calledOpenUploadStream = true;
        var _this = this;
        checkIndexes(this, function () {
          _this.bucket.s.checkedIndexes = true;
          _this.bucket.emit('index');
        });
      }
    }
    util.inherits(GridFSBucketWriteStream, stream.Writable);
    GridFSBucketWriteStream.prototype.write = function (chunk, encoding, callback) {
      var _this = this;
      return waitForIndexes(this, function () {
        return doWrite(_this, chunk, encoding, callback);
      });
    };
    GridFSBucketWriteStream.prototype.abort = function (callback) {
      if (this.state.streamEnd) {
        var error = new Error('Cannot abort a stream that has already completed');
        if (typeof callback == 'function') {
          return callback(error);
        }
        return this.state.promiseLibrary.reject(error);
      }
      if (this.state.aborted) {
        error = new Error('Cannot call abort() on a stream twice');
        if (typeof callback == 'function') {
          return callback(error);
        }
        return this.state.promiseLibrary.reject(error);
      }
      this.state.aborted = true;
      this.chunks.deleteMany({ files_id: this.id }, function (error) {
        if (typeof callback == 'function') callback(error);
      });
    };
    GridFSBucketWriteStream.prototype.end = function (chunk, encoding, callback) {
      var _this = this;
      if (typeof chunk == 'function') {
        callback = chunk, chunk = null, encoding = null;
      } else if (typeof encoding == 'function') {
        callback = encoding, encoding = null;
      }
      if (checkAborted(this, callback)) {
        return;
      }
      this.state.streamEnd = true;
      if (callback) {
        this.once('finish', function (result) {
          callback(null, result);
        });
      }
      if (!chunk) {
        waitForIndexes(this, function () {
          writeRemnant(_this);
        });
        return;
      }
      this.write(chunk, encoding, function () {
        writeRemnant(_this);
      });
    };
    function __handleError(_this, error, callback) {
      if (_this.state.errored) {
        return;
      }
      _this.state.errored = true;
      if (callback) {
        return callback(error);
      }
      _this.emit('error', error);
    }
    function createChunkDoc(filesId, n, data) {
      return {
        _id: core.BSON.ObjectId(),
        files_id: filesId,
        n: n,
        data: data
      };
    }
    function checkChunksIndex(_this, callback) {
      _this.chunks.listIndexes().toArray(function (error, indexes) {
        if (error) {
          if (error.code === ERROR_NAMESPACE_NOT_FOUND) {
            var index = {
              files_id: 1,
              n: 1
            };
            _this.chunks.createIndex(index, {
              background: false,
              unique: true
            }, function (error) {
              if (error) {
                return callback(error);
              }
              callback();
            });
            return;
          }
          return callback(error);
        }
        var hasChunksIndex = false;
        indexes.forEach(function (index) {
          if (index.key) {
            var keys = Object.keys(index.key);
            if (keys.length === 2 && index.key.files_id === 1 && index.key.n === 1) {
              hasChunksIndex = true;
            }
          }
        });
        if (hasChunksIndex) {
          callback();
        } else {
          index = {
            files_id: 1,
            n: 1
          };
          var indexOptions = getWriteOptions(_this);
          indexOptions.background = false;
          indexOptions.unique = true;
          _this.chunks.createIndex(index, indexOptions, function (error) {
            if (error) {
              return callback(error);
            }
            callback();
          });
        }
      });
    }
    function checkDone(_this, callback) {
      if (_this.state.streamEnd && _this.state.outstandingRequests === 0 && !_this.state.errored) {
        var filesDoc = createFilesDoc(_this.id, _this.length, _this.chunkSizeBytes, _this.md5.digest('hex'), _this.filename, _this.options.contentType, _this.options.aliases, _this.options.metadata);
        if (checkAborted(_this, callback)) {
          return false;
        }
        _this.files.insert(filesDoc, getWriteOptions(_this), function (error) {
          if (error) {
            return __handleError(_this, error, callback);
          }
          _this.emit('finish', filesDoc);
        });
        return true;
      }
      return false;
    }
    function checkIndexes(_this, callback) {
      _this.files.findOne({}, { _id: 1 }, function (error, doc) {
        if (error) {
          return callback(error);
        }
        if (doc) {
          return callback();
        }
        _this.files.listIndexes().toArray(function (error, indexes) {
          if (error) {
            if (error.code === ERROR_NAMESPACE_NOT_FOUND) {
              var index = {
                filename: 1,
                uploadDate: 1
              };
              _this.files.createIndex(index, { background: false }, function (error) {
                if (error) {
                  return callback(error);
                }
                checkChunksIndex(_this, callback);
              });
              return;
            }
            return callback(error);
          }
          var hasFileIndex = false;
          indexes.forEach(function (index) {
            var keys = Object.keys(index.key);
            if (keys.length === 2 && index.key.filename === 1 && index.key.uploadDate === 1) {
              hasFileIndex = true;
            }
          });
          if (hasFileIndex) {
            checkChunksIndex(_this, callback);
          } else {
            index = {
              filename: 1,
              uploadDate: 1
            };
            var indexOptions = getWriteOptions(_this);
            indexOptions.background = false;
            _this.files.createIndex(index, indexOptions, function (error) {
              if (error) {
                return callback(error);
              }
              checkChunksIndex(_this, callback);
            });
          }
        });
      });
    }
    function createFilesDoc(_id, length, chunkSize, md5, filename, contentType, aliases, metadata) {
      var ret = {
        _id: _id,
        length: length,
        chunkSize: chunkSize,
        uploadDate: new Date(),
        md5: md5,
        filename: filename
      };
      if (contentType) {
        ret.contentType = contentType;
      }
      if (aliases) {
        ret.aliases = aliases;
      }
      if (metadata) {
        ret.metadata = metadata;
      }
      return ret;
    }
    function doWrite(_this, chunk, encoding, callback) {
      if (checkAborted(_this, callback)) {
        return false;
      }
      var inputBuf = Buffer.isBuffer(chunk) ? chunk : new Buffer(chunk, encoding);
      _this.length += inputBuf.length;
      if (_this.pos + inputBuf.length < _this.chunkSizeBytes) {
        inputBuf.copy(_this.bufToStore, _this.pos);
        _this.pos += inputBuf.length;
        callback && callback();
        return true;
      }
      var inputBufRemaining = inputBuf.length;
      var spaceRemaining = _this.chunkSizeBytes - _this.pos;
      var numToCopy = Math.min(spaceRemaining, inputBuf.length);
      var outstandingRequests = 0;
      while (inputBufRemaining > 0) {
        var inputBufPos = inputBuf.length - inputBufRemaining;
        inputBuf.copy(_this.bufToStore, _this.pos, inputBufPos, inputBufPos + numToCopy);
        _this.pos += numToCopy;
        spaceRemaining -= numToCopy;
        if (spaceRemaining === 0) {
          _this.md5.update(_this.bufToStore);
          var doc = createChunkDoc(_this.id, _this.n, _this.bufToStore);
          ++_this.state.outstandingRequests;
          ++outstandingRequests;
          if (checkAborted(_this, callback)) {
            return false;
          }
          _this.chunks.insert(doc, getWriteOptions(_this), function (error) {
            if (error) {
              return __handleError(_this, error);
            }
            --_this.state.outstandingRequests;
            --outstandingRequests;
            if (!outstandingRequests) {
              _this.emit('drain', doc);
              callback && callback();
              checkDone(_this);
            }
          });
          spaceRemaining = _this.chunkSizeBytes;
          _this.pos = 0;
          ++_this.n;
        }
        inputBufRemaining -= numToCopy;
        numToCopy = Math.min(spaceRemaining, inputBufRemaining);
      }
      return false;
    }
    function getWriteOptions(_this) {
      var obj = {};
      if (_this.options.writeConcern) {
        obj.w = _this.options.writeConcern.w;
        obj.wtimeout = _this.options.writeConcern.wtimeout;
        obj.j = _this.options.writeConcern.j;
      }
      return obj;
    }
    function waitForIndexes(_this, callback) {
      if (_this.bucket.s.checkedIndexes) {
        return callback(false);
      }
      _this.bucket.once('index', function () {
        callback(true);
      });
      return true;
    }
    function writeRemnant(_this, callback) {
      if (_this.pos === 0) {
        return checkDone(_this, callback);
      }
      ++_this.state.outstandingRequests;
      var remnant = new Buffer(_this.pos);
      _this.bufToStore.copy(remnant, 0, 0, _this.pos);
      _this.md5.update(remnant);
      var doc = createChunkDoc(_this.id, _this.n, remnant);
      if (checkAborted(_this, callback)) {
        return false;
      }
      _this.chunks.insert(doc, getWriteOptions(_this), function (error) {
        if (error) {
          return __handleError(_this, error);
        }
        --_this.state.outstandingRequests;
        checkDone(_this);
      });
    }
    function checkAborted(_this, callback) {
      if (_this.state.aborted) {
        if (typeof callback == 'function') {
          callback(new Error('this stream has been aborted'));
        }
        return true;
      }
      return false;
    }
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic('1a8', ['166', '55', '1a9', '1aa', '1ab', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    "use strict";

    var inherits = $__require('166').inherits,
        f = $__require('166').format,
        EventEmitter = $__require('55').EventEmitter,
        Logger = $__require('1a9'),
        ReadPreference = $__require('1aa'),
        MongoError = $__require('1ab');
    var TopologyType = {
      'Single': 'Single',
      'ReplicaSetNoPrimary': 'ReplicaSetNoPrimary',
      'ReplicaSetWithPrimary': 'ReplicaSetWithPrimary',
      'Sharded': 'Sharded',
      'Unknown': 'Unknown'
    };
    var ServerType = {
      'Standalone': 'Standalone',
      'Mongos': 'Mongos',
      'PossiblePrimary': 'PossiblePrimary',
      'RSPrimary': 'RSPrimary',
      'RSSecondary': 'RSSecondary',
      'RSArbiter': 'RSArbiter',
      'RSOther': 'RSOther',
      'RSGhost': 'RSGhost',
      'Unknown': 'Unknown'
    };
    var ReplSetState = function (options) {
      options = options || {};
      EventEmitter.call(this);
      this.topologyType = TopologyType.ReplicaSetNoPrimary;
      this.setName = options.setName;
      this.set = {};
      this.id = options.id;
      this.setName = options.setName;
      this.logger = options.logger || Logger('ReplSet', options);
      this.index = 0;
      this.acceptableLatency = options.acceptableLatency || 15;
      this.heartbeatFrequencyMS = options.heartbeatFrequencyMS || 10000;
      this.primary = null;
      this.secondaries = [];
      this.arbiters = [];
      this.passives = [];
      this.ghosts = [];
      this.unknownServers = [];
      this.set = {};
      this.maxElectionId = null;
      this.maxSetVersion = 0;
      this.replicasetDescription = {
        "topologyType": "Unknown",
        "servers": []
      };
    };
    inherits(ReplSetState, EventEmitter);
    ReplSetState.prototype.hasPrimaryAndSecondary = function () {
      return this.primary != null && this.secondaries.length > 0;
    };
    ReplSetState.prototype.hasPrimary = function () {
      return this.primary != null;
    };
    ReplSetState.prototype.hasSecondary = function () {
      return this.secondaries.length > 0;
    };
    ReplSetState.prototype.allServers = function (options) {
      options = options || {};
      var servers = this.primary ? [this.primary] : [];
      servers = servers.concat(this.secondaries);
      if (!options.ignoreArbiters) servers = servers.concat(this.arbiters);
      servers = servers.concat(this.passives);
      return servers;
    };
    ReplSetState.prototype.destroy = function (options) {
      if (this.primary) this.primary.destroy(options);
      this.secondaries.forEach(function (x) {
        x.destroy(options);
      });
      this.arbiters.forEach(function (x) {
        x.destroy(options);
      });
      this.passives.forEach(function (x) {
        x.destroy(options);
      });
      this.ghosts.forEach(function (x) {
        x.destroy(options);
      });
      this.secondaries = [];
      this.arbiters = [];
      this.passives = [];
      this.ghosts = [];
      this.unknownServers = [];
      this.set = {};
    };
    ReplSetState.prototype.remove = function (server, options) {
      options = options || {};
      var servers = this.primary ? [this.primary] : [];
      servers = servers.concat(this.secondaries);
      servers = servers.concat(this.arbiters);
      servers = servers.concat(this.passives);
      for (var i = 0; i < servers.length; i++) {
        if (!options.force && servers[i].equals(server) && servers[i].isConnected && servers[i].isConnected()) {
          return;
        }
      }
      if (this.set[server.name.toLowerCase()]) {
        this.set[server.name.toLowerCase()].type = ServerType.Unknown;
        this.set[server.name.toLowerCase()].electionId = null;
        this.set[server.name.toLowerCase()].setName = null;
        this.set[server.name.toLowerCase()].setVersion = null;
      }
      var removeType = null;
      if (this.primary && this.primary.equals(server)) {
        this.primary = null;
        this.topologyType = TopologyType.ReplicaSetNoPrimary;
        removeType = 'primary';
      }
      removeType = removeFrom(server, this.secondaries) ? 'secondary' : removeType;
      removeType = removeFrom(server, this.arbiters) ? 'arbiter' : removeType;
      removeType = removeFrom(server, this.passives) ? 'secondary' : removeType;
      removeFrom(server, this.ghosts);
      removeFrom(server, this.unknownServers);
      if (removeType) {
        this.emit('left', removeType, server);
      }
    };
    ReplSetState.prototype.update = function (server) {
      var self = this;
      var ismaster = server.lastIsMaster();
      if (ismaster) {
        var hosts = Array.isArray(ismaster.hosts) ? ismaster.hosts : [];
        hosts = hosts.concat(Array.isArray(ismaster.arbiters) ? ismaster.arbiters : []);
        hosts = hosts.concat(Array.isArray(ismaster.passives) ? ismaster.passives : []);
        for (var i = 0; i < hosts.length; i++) {
          if (this.unknownServers.indexOf(hosts[i]) == -1 && (!this.set[hosts[i].toLowerCase()] || this.set[hosts[i].toLowerCase()].type == ServerType.Unknown)) {
            this.unknownServers.push(hosts[i]);
          }
          if (!this.set[hosts[i].toLowerCase()]) {
            this.set[hosts[i].toLowerCase()] = {
              type: ServerType.Unknown,
              electionId: null,
              setName: null,
              setVersion: null
            };
          }
        }
      }
      if (!ismaster && !inList(ismaster, server, this.unknownServers)) {
        self.set[server.name.toLowerCase()] = {
          type: ServerType.Unknown,
          setVersion: null,
          electionId: null,
          setName: null
        };
        self.set[server.name.toLowerCase()].type = ServerType.Unknown;
        self.set[server.name.toLowerCase()].electionId = ismaster ? ismaster.electionId : ismaster;
        self.set[server.name.toLowerCase()].setName = ismaster ? ismaster.setName : ismaster;
        self.set[server.name.toLowerCase()].setVersion = ismaster ? ismaster.setVersion : ismaster;
        if (self.unknownServers.indexOf(server.name) == -1) {
          self.unknownServers.push(server.name);
        }
        return false;
      }
      if (ismaster && ismaster.msg == 'isdbgrid') {
        return false;
      }
      if (ismaster.setName && ismaster.hidden || ismaster.setName && !ismaster.ismaster && !ismaster.secondary && !ismaster.arbiterOnly && !ismaster.passive) {
        self.set[server.name.toLowerCase()] = {
          type: ServerType.RSOther,
          setVersion: null,
          electionId: null,
          setName: ismaster.setName
        };
        this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
        if (ismaster.setName) this.setName = ismaster.setName;
        return false;
      }
      if (ismaster.isreplicaset) {
        self.set[server.name.toLowerCase()] = {
          type: ServerType.RSGhost,
          setVersion: null,
          electionId: null,
          setName: null
        };
        this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
        if (ismaster.setName) this.setName = ismaster.setName;
        return false;
      }
      if (ismaster && ismaster.ismaster && !ismaster.setName) {
        this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.Unknown;
        this.remove(server, { force: true });
        return false;
      }
      if (ismaster && !ismaster.ismaster && !ismaster.secondary && !ismaster.arbiterOnly) {
        this.remove(server, { force: true });
        return false;
      }
      if (ismaster.me && ismaster.me != server.name) {
        if (this.logger.isWarn()) {
          this.logger.warn(f('the seedlist server was removed due to its address %s not matching its ismaster.me address %s', server.name, ismaster.me));
        }
        delete this.set[server.name.toLowerCase()];
        if (this.primary && !this.primary.equals(server)) {
          this.topologyType = TopologyType.ReplicaSetWithPrimary;
        } else {
          this.topologyType = TopologyType.ReplicaSetNoPrimary;
        }
        if (!this.primary && ismaster.primary) {
          this.set[ismaster.primary.toLowerCase()] = {
            type: ServerType.PossiblePrimary,
            setName: null,
            electionId: null,
            setVersion: null
          };
        }
        return false;
      }
      if (!this.primary && ismaster.ismaster && ismaster.setName) {
        var ismasterElectionId = server.lastIsMaster().electionId;
        if (this.setName && this.setName != ismaster.setName) {
          this.topologyType = TopologyType.ReplicaSetNoPrimary;
          return new MongoError(f('setName from ismaster does not match provided connection setName [%s] != [%s]', ismaster.setName, this.setName));
        }
        if (!this.maxElectionId && ismasterElectionId) {
          this.maxElectionId = ismasterElectionId;
        } else if (this.maxElectionId && ismasterElectionId) {
          var result = compareObjectIds(this.maxElectionId, ismasterElectionId);
          var ismasterSetVersion = server.lastIsMaster().setVersion;
          if (result == 1) {
            this.topologyType = TopologyType.ReplicaSetNoPrimary;
            return false;
          } else if (result == 0 && ismasterSetVersion) {
            if (ismasterSetVersion < this.maxSetVersion) {
              this.topologyType = TopologyType.ReplicaSetNoPrimary;
              return false;
            }
          }
          this.maxSetVersion = ismasterSetVersion;
          this.maxElectionId = ismasterElectionId;
        }
        var normalizedHosts = ismaster.hosts.map(function (x) {
          return x.toLowerCase();
        });
        var locationIndex = normalizedHosts.indexOf(server.name.toLowerCase());
        if (locationIndex != -1) {
          self.primary = server;
          self.set[server.name.toLowerCase()] = {
            type: ServerType.RSPrimary,
            setVersion: ismaster.setVersion,
            electionId: ismaster.electionId,
            setName: ismaster.setName
          };
          this.topologyType = TopologyType.ReplicaSetWithPrimary;
          if (ismaster.setName) this.setName = ismaster.setName;
          removeFrom(server, self.unknownServers);
          removeFrom(server, self.secondaries);
          removeFrom(server, self.passives);
          self.emit('joined', 'primary', server);
        } else {
          this.topologyType = TopologyType.ReplicaSetNoPrimary;
        }
        emitTopologyDescriptionChanged(self);
        return true;
      } else if (ismaster.ismaster && ismaster.setName) {
        var currentElectionId = self.set[self.primary.name.toLowerCase()].electionId;
        var currentSetVersion = self.set[self.primary.name.toLowerCase()].setVersion;
        var currentSetName = self.set[self.primary.name.toLowerCase()].setName;
        ismasterElectionId = server.lastIsMaster().electionId;
        ismasterSetVersion = server.lastIsMaster().setVersion;
        var ismasterSetName = server.lastIsMaster().setName;
        if (this.primary.equals(server) && currentSetName == ismasterSetName) {
          return false;
        }
        if (currentSetName && currentSetName != ismasterSetName) {
          if (!this.primary.equals(server)) {
            this.topologyType = TopologyType.ReplicaSetWithPrimary;
          } else {
            this.topologyType = TopologyType.ReplicaSetNoPrimary;
          }
          return false;
        }
        if (currentElectionId && ismasterElectionId) {
          result = compareObjectIds(currentElectionId, ismasterElectionId);
          if (result == 1) {
            return false;
          } else if (result == 0 && currentSetVersion > ismasterSetVersion) {
            return false;
          }
        } else if (!currentElectionId && ismasterElectionId && ismasterSetVersion) {
          if (ismasterSetVersion < this.maxSetVersion) {
            return false;
          }
        }
        if (!this.maxElectionId && ismasterElectionId) {
          this.maxElectionId = ismasterElectionId;
        } else if (this.maxElectionId && ismasterElectionId) {
          result = compareObjectIds(this.maxElectionId, ismasterElectionId);
          if (result == 1) {
            return false;
          } else if (result == 0 && currentSetVersion && ismasterSetVersion) {
            if (ismasterSetVersion < this.maxSetVersion) {
              return false;
            }
          } else {
            if (ismasterSetVersion < this.maxSetVersion) {
              return false;
            }
          }
          this.maxElectionId = ismasterElectionId;
          this.maxSetVersion = ismasterSetVersion;
        } else {
          this.maxSetVersion = ismasterSetVersion;
        }
        self.set[self.primary.name.toLowerCase()] = {
          type: ServerType.Unknown,
          setVersion: null,
          electionId: null,
          setName: null
        };
        self.emit('left', 'primary', this.primary);
        self.primary.destroy();
        self.primary = server;
        self.set[server.name.toLowerCase()] = {
          type: ServerType.RSPrimary,
          setVersion: ismaster.setVersion,
          electionId: ismaster.electionId,
          setName: ismaster.setName
        };
        this.topologyType = TopologyType.ReplicaSetWithPrimary;
        if (ismaster.setName) this.setName = ismaster.setName;
        removeFrom(server, self.unknownServers);
        removeFrom(server, self.secondaries);
        removeFrom(server, self.passives);
        self.emit('joined', 'primary', server);
        emitTopologyDescriptionChanged(self);
        return true;
      }
      if (!this.primary && ismaster.primary) {
        self.set[ismaster.primary.toLowerCase()] = {
          type: ServerType.PossiblePrimary,
          setVersion: null,
          electionId: null,
          setName: null
        };
      }
      if (ismaster.secondary && ismaster.setName && !inList(ismaster, server, this.secondaries) && this.setName && this.setName == ismaster.setName) {
        addToList(self, ServerType.RSSecondary, ismaster, server, this.secondaries);
        this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
        if (ismaster.setName) this.setName = ismaster.setName;
        removeFrom(server, self.unknownServers);
        if (this.primary && this.primary.name == server.name) {
          server.destroy();
          this.primary = null;
          self.emit('left', 'primary', server);
        }
        self.emit('joined', 'secondary', server);
        emitTopologyDescriptionChanged(self);
        return true;
      }
      if (ismaster.arbiterOnly && ismaster.setName && !inList(ismaster, server, this.arbiters) && this.setName && this.setName == ismaster.setName) {
        addToList(self, ServerType.RSArbiter, ismaster, server, this.arbiters);
        this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
        if (ismaster.setName) this.setName = ismaster.setName;
        removeFrom(server, self.unknownServers);
        self.emit('joined', 'arbiter', server);
        emitTopologyDescriptionChanged(self);
        return true;
      }
      if (ismaster.passive && ismaster.setName && !inList(ismaster, server, this.passives) && this.setName && this.setName == ismaster.setName) {
        addToList(self, ServerType.RSSecondary, ismaster, server, this.passives);
        this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
        if (ismaster.setName) this.setName = ismaster.setName;
        removeFrom(server, self.unknownServers);
        if (this.primary && this.primary.name == server.name) {
          server.destroy();
          this.primary = null;
          self.emit('left', 'primary', server);
        }
        self.emit('joined', 'secondary', server);
        emitTopologyDescriptionChanged(self);
        return true;
      }
      if (this.set[server.name.toLowerCase()] && this.set[server.name.toLowerCase()].type == ServerType.RSPrimary) {
        self.emit('left', 'primary', this.primary);
        this.primary.destroy();
        this.primary = null;
        this.topologyType = TopologyType.ReplicaSetNoPrimary;
        return false;
      }
      this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
      return false;
    };
    ReplSetState.prototype.updateServerMaxStaleness = function (server, haInterval) {
      var max = 0;
      for (var i = 0; i < this.secondaries.length; i++) {
        max = Math.max(max, this.secondaries[i].lastWriteDate);
      }
      if (server.ismaster.maxWireVersion >= 5 && server.ismaster.secondary && this.hasPrimary()) {
        server.staleness = server.lastUpdateTime - server.lastWriteDate - (this.primary.lastUpdateTime - this.primary.lastWriteDate) + haInterval;
      } else if (server.ismaster.maxWireVersion >= 5 && server.ismaster.secondary) {
        server.staleness = max - server.lastWriteDate + haInterval;
      }
    };
    ReplSetState.prototype.updateSecondariesMaxStaleness = function (haInterval) {
      for (var i = 0; i < this.secondaries.length; i++) {
        this.updateServerMaxStaleness(this.secondaries[i], haInterval);
      }
    };
    ReplSetState.prototype.pickServer = function (readPreference) {
      readPreference = readPreference || ReadPreference.primary;
      if (readPreference.preference == 'primary' && readPreference.maxStalenessSeconds != null) {
        return new MongoError('primary readPreference incompatible with maxStalenessSeconds');
      }
      var allservers = this.primary ? [this.primary] : [];
      allservers = allservers.concat(this.secondaries);
      if (readPreference.maxStalenessSeconds != null) {
        for (var i = 0; i < allservers.length; i++) {
          if (allservers[i].ismaster.maxWireVersion < 5) {
            return new MongoError('maxStalenessSeconds not supported by at least one of the replicaset members');
          }
        }
      }
      if (readPreference.preference == 'nearest' && readPreference.maxStalenessSeconds == null) {
        return pickNearest(this, readPreference);
      } else if (readPreference.preference == 'nearest' && readPreference.maxStalenessSeconds != null) {
        return pickNearestMaxStalenessSeconds(this, readPreference);
      }
      var secondaries = this.secondaries;
      if (readPreference.equals(ReadPreference.secondary) && secondaries.length == 0) {
        return new MongoError("no secondary server available");
      }
      if (readPreference.equals(ReadPreference.secondaryPreferred) && secondaries.length == 0 && this.primary == null) {
        return new MongoError("no secondary or primary server available");
      }
      if (readPreference.equals(ReadPreference.primary) && this.primary == null) {
        return new MongoError("no primary server available");
      }
      if (readPreference.equals(ReadPreference.secondaryPreferred) || readPreference.equals(ReadPreference.secondary)) {
        if (secondaries.length > 0 && readPreference.maxStalenessSeconds == null) {
          var server = pickNearest(this, readPreference);
          if (server) {
            return server;
          }
        } else if (secondaries.length > 0 && readPreference.maxStalenessSeconds != null) {
          server = pickNearestMaxStalenessSeconds(this, readPreference);
          if (server) {
            return server;
          }
        }
        if (readPreference.equals(ReadPreference.secondaryPreferred)) {
          return this.primary;
        }
        return null;
      }
      if (readPreference.equals(ReadPreference.primaryPreferred)) {
        server = null;
        if (this.primary) {
          return this.primary;
        }
        if (secondaries.length > 0 && readPreference.maxStalenessSeconds == null) {
          server = pickNearest(this, readPreference);
        } else if (secondaries.length > 0 && readPreference.maxStalenessSeconds != null) {
          server = pickNearestMaxStalenessSeconds(this, readPreference);
        }
        if (server) return server;
      }
      return this.primary;
    };
    var filterByTags = function (readPreference, servers) {
      if (readPreference.tags == null) return servers;
      var filteredServers = [];
      var tagsArray = Array.isArray(readPreference.tags) ? readPreference.tags : [readPreference.tags];
      for (var j = 0; j < tagsArray.length; j++) {
        var tags = tagsArray[j];
        for (var i = 0; i < servers.length; i++) {
          var serverTag = servers[i].lastIsMaster().tags || {};
          var found = true;
          for (var name in tags) {
            if (serverTag[name] != tags[name]) {
              found = false;
            }
          }
          if (found) {
            filteredServers.push(servers[i]);
          }
        }
      }
      return filteredServers;
    };
    function pickNearestMaxStalenessSeconds(self, readPreference) {
      var servers = [];
      var heartbeatFrequencyMS = self.heartbeatFrequencyMS;
      var maxStalenessMS = readPreference.maxStalenessSeconds * 1000;
      if (maxStalenessMS < 90 * 1000) {
        return new MongoError('maxStalenessSeconds must be set to at least 90 seconds');
      }
      if (self.primary && readPreference.preference != 'secondary') {
        servers.push(self.primary);
      }
      for (var i = 0; i < self.secondaries.length; i++) {
        servers.push(self.secondaries[i]);
      }
      servers = filterByTags(readPreference, servers);
      servers = servers.filter(function (s) {
        return s.staleness <= maxStalenessMS;
      });
      servers.sort(function (a, b) {
        return a.lastIsMasterMS > b.lastIsMasterMS;
      });
      if (servers.length == 0) {
        return null;
      }
      self.index = self.index % servers.length;
      var server = servers[self.index];
      self.index = self.index + 1;
      return server;
    }
    function pickNearest(self, readPreference) {
      var servers = [];
      if (self.primary && readPreference.preference != 'secondary') {
        servers.push(self.primary);
      }
      for (var i = 0; i < self.secondaries.length; i++) {
        servers.push(self.secondaries[i]);
      }
      servers = filterByTags(readPreference, servers);
      servers.sort(function (a, b) {
        return a.lastIsMasterMS > b.lastIsMasterMS;
      });
      var lowest = servers.length > 0 ? servers[0].lastIsMasterMS : 0;
      servers = servers.filter(function (s) {
        return s.lastIsMasterMS <= lowest + self.acceptableLatency;
      });
      if (servers.length == 0) {
        return null;
      }
      self.index = self.index % servers.length;
      var server = servers[self.index];
      self.index = self.index + 1;
      return server;
    }
    function inList(ismaster, server, list) {
      for (var i = 0; i < list.length; i++) {
        if (list[i].name == server.name) return true;
      }
      return false;
    }
    function addToList(self, type, ismaster, server, list) {
      self.set[server.name.toLowerCase()].type = type;
      self.set[server.name.toLowerCase()].electionId = ismaster ? ismaster.electionId : ismaster;
      self.set[server.name.toLowerCase()].setName = ismaster ? ismaster.setName : ismaster;
      self.set[server.name.toLowerCase()].setVersion = ismaster ? ismaster.setVersion : ismaster;
      list.push(server);
    }
    function compareObjectIds(id1, id2) {
      var a = new Buffer(id1.toHexString(), 'hex');
      var b = new Buffer(id2.toHexString(), 'hex');
      if (a === b) {
        return 0;
      }
      if (typeof Buffer.compare === 'function') {
        return Buffer.compare(a, b);
      }
      var x = a.length;
      var y = b.length;
      var len = Math.min(x, y);
      for (var i = 0; i < len; i++) {
        if (a[i] !== b[i]) {
          break;
        }
      }
      if (i !== len) {
        x = a[i];
        y = b[i];
      }
      return x < y ? -1 : y < x ? 1 : 0;
    }
    function removeFrom(server, list) {
      for (var i = 0; i < list.length; i++) {
        if (list[i].equals && list[i].equals(server)) {
          list.splice(i, 1);
          return true;
        } else if (typeof list[i] == 'string' && list[i] == server.name) {
          list.splice(i, 1);
          return true;
        }
      }
      return false;
    }
    function emitTopologyDescriptionChanged(self) {
      if (self.listeners('topologyDescriptionChanged').length > 0) {
        var topology = 'Unknown';
        var setName = self.setName;
        if (self.hasPrimaryAndSecondary()) {
          topology = 'ReplicaSetWithPrimary';
        } else if (!self.hasPrimary() && self.hasSecondary()) {
          topology = 'ReplicaSetNoPrimary';
        }
        var description = {
          topologyType: topology,
          setName: setName,
          servers: []
        };
        if (self.hasPrimary()) {
          var desc = self.primary.getDescription();
          desc.type = 'RSPrimary';
          description.servers.push(desc);
        }
        description.servers = description.servers.concat(self.secondaries.map(function (x) {
          var description = x.getDescription();
          description.type = 'RSSecondary';
          return description;
        }));
        description.servers = description.servers.concat(self.arbiters.map(function (x) {
          var description = x.getDescription();
          description.type = 'RSArbiter';
          return description;
        }));
        description.servers = description.servers.concat(self.passives.map(function (x) {
          var description = x.getDescription();
          description.type = 'RSSecondary';
          return description;
        }));
        var result = {
          topologyId: self.id,
          previousDescription: self.replicasetDescription,
          newDescription: description,
          diff: diff(self.replicasetDescription, description)
        };
        self.emit('topologyDescriptionChanged', result);
        self.replicasetDescription = description;
      }
    }
    function diff(previous, current) {
      var diff = { servers: [] };
      if (!previous) {
        previous = { servers: [] };
      }
      for (var i = 0; i < previous.servers.length; i++) {
        var prevServer = previous.servers[i];
        for (var j = 0; j < current.servers.length; j++) {
          var currServer = current.servers[j];
          if (prevServer.address === currServer.address) {
            if (prevServer.type != currServer.type) {
              diff.servers.push({
                address: prevServer.address,
                from: prevServer.type,
                to: currServer.type
              });
            }
          }
        }
      }
      return diff;
    }
    module.exports = ReplSetState;
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic('1ac', ['166', '55', '1b6', '1aa', '1ad', '1a9', '1ab', '1ae', '1a8', '1af', '1b0', '1b1', '1b2', '1b3', '1b4', '1b5', '2a', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer, process) {
    "use strict";

    var inherits = $__require('166').inherits,
        f = $__require('166').format,
        EventEmitter = $__require('55').EventEmitter,
        BSON = $__require('1b6').native().BSON,
        ReadPreference = $__require('1aa'),
        BasicCursor = $__require('1ad'),
        Logger = $__require('1a9'),
        MongoError = $__require('1ab'),
        Server = $__require('1ae'),
        ReplSetState = $__require('1a8'),
        assign = $__require('1af').assign,
        clone = $__require('1af').clone,
        createClientInfo = $__require('1af').createClientInfo;
    var MongoCR = $__require('1b0'),
        X509 = $__require('1b1'),
        Plain = $__require('1b2'),
        GSSAPI = $__require('1b3'),
        SSPI = $__require('1b4'),
        ScramSHA1 = $__require('1b5');
    var DISCONNECTED = 'disconnected';
    var CONNECTING = 'connecting';
    var CONNECTED = 'connected';
    var DESTROYED = 'destroyed';
    function stateTransition(self, newState) {
      var legalTransitions = {
        'disconnected': [CONNECTING, DESTROYED, DISCONNECTED],
        'connecting': [CONNECTING, DESTROYED, CONNECTED, DISCONNECTED],
        'connected': [CONNECTED, DISCONNECTED, DESTROYED],
        'destroyed': [DESTROYED]
      };
      var legalStates = legalTransitions[self.state];
      if (legalStates && legalStates.indexOf(newState) != -1) {
        self.state = newState;
      } else {
        self.logger.error(f('Pool with id [%s] failed attempted illegal state transition from [%s] to [%s] only following state allowed [%s]', self.id, self.state, newState, legalStates));
      }
    }
    var id = 1;
    var handlers = ['connect', 'close', 'error', 'timeout', 'parseError'];
    var ReplSet = function (seedlist, options) {
      var self = this;
      options = options || {};
      if (!Array.isArray(seedlist)) throw new MongoError("seedlist must be an array");
      if (seedlist.length == 0) throw new MongoError("seedlist must contain at least one entry");
      seedlist.forEach(function (e) {
        if (typeof e.host != 'string' || typeof e.port != 'number') throw new MongoError("seedlist entry must contain a host and port");
      });
      EventEmitter.call(this);
      this.id = id++;
      var localThresholdMS = options.localThresholdMS || 15;
      if (options.acceptableLatency) localThresholdMS = options.acceptableLatency;
      var logger = Logger('ReplSet', options);
      this.s = {
        options: assign({}, options),
        bson: options.bson || new BSON(),
        Cursor: options.cursorFactory || BasicCursor,
        logger: logger,
        seedlist: seedlist,
        replicaSetState: new ReplSetState({
          id: this.id,
          setName: options.setName,
          acceptableLatency: localThresholdMS,
          heartbeatFrequencyMS: options.haInterval ? options.haInterval : 10000,
          logger: logger
        }),
        connectingServers: [],
        haInterval: options.haInterval ? options.haInterval : 10000,
        minHeartbeatFrequencyMS: 500,
        disconnectHandler: options.disconnectHandler,
        index: 0,
        connectOptions: {},
        debug: typeof options.debug == 'boolean' ? options.debug : false,
        clientInfo: createClientInfo(options)
      };
      this.s.replicaSetState.on('topologyDescriptionChanged', function (r) {
        self.emit('topologyDescriptionChanged', r);
      });
      if (this.s.logger.isWarn() && this.s.options.socketTimeout != 0 && this.s.options.socketTimeout < this.s.haInterval) {
        this.s.logger.warn(f('warning socketTimeout %s is less than haInterval %s. This might cause unnecessary server reconnections due to socket timeouts', this.s.options.socketTimeout, this.s.haInterval));
      }
      this.authProviders = options.authProviders || {
        'mongocr': new MongoCR(this.s.bson),
        'x509': new X509(this.s.bson),
        'plain': new Plain(this.s.bson),
        'gssapi': new GSSAPI(this.s.bson),
        'sspi': new SSPI(this.s.bson),
        'scram-sha-1': new ScramSHA1(this.s.bson)
      };
      var types = ['joined', 'left'];
      types.forEach(function (x) {
        self.s.replicaSetState.on(x, function (t, s) {
          self.emit(x, t, s);
        });
      });
      this.initialConnectState = {
        connect: false,
        fullsetup: false,
        all: false
      };
      this.state = DISCONNECTED;
      this.haTimeoutId = null;
      this.authenticating = false;
      this.ismaster = null;
    };
    inherits(ReplSet, EventEmitter);
    Object.defineProperty(ReplSet.prototype, 'type', {
      enumerable: true,
      get: function () {
        return 'replset';
      }
    });
    function attemptReconnect(self) {
      if (self.runningAttempReconnect) return;
      self.runningAttempReconnect = true;
      self.haTimeoutId = setTimeout(function () {
        if (self.state == DESTROYED) return;
        if (self.s.logger.isDebug()) {
          self.s.logger.debug(f('attemptReconnect for replset with id %s', self.id));
        }
        var keys = Object.keys(self.s.replicaSetState.set);
        var servers = keys.map(function (x) {
          return new Server(assign({}, self.s.options, {
            host: x.split(':')[0],
            port: parseInt(x.split(':')[1], 10)
          }, {
            authProviders: self.authProviders,
            reconnect: false,
            monitoring: false,
            inTopology: true
          }, { clientInfo: clone(self.s.clientInfo) }));
        });
        self.s.connectingServers = servers.slice(0);
        function _handleEvent(self, event) {
          return function () {
            if (self.state == DESTROYED) {
              return this.destroy();
            }
            if (self.s.logger.isDebug()) {
              self.s.logger.debug(f('attemptReconnect for replset with id %s using server %s ended with event %s', self.id, this.name, event));
            }
            function done() {
              if (self.s.connectingServers.length == 0) {
                if (self.state == DESTROYED) return;
                if (self.s.replicaSetState.hasPrimaryAndSecondary() && self.s.disconnectHandler) {
                  self.s.disconnectHandler.execute();
                } else if (self.s.replicaSetState.hasPrimary() && self.s.disconnectHandler) {
                  self.s.disconnectHandler.execute({ executePrimary: true });
                } else if (self.s.replicaSetState.hasSecondary() && self.s.disconnectHandler) {
                  self.s.disconnectHandler.execute({ executeSecondary: true });
                }
                if (self.s.replicaSetState.hasPrimary()) {
                  connectNewServers(self, self.s.replicaSetState.unknownServers, function () {
                    if (self.s.logger.isDebug()) {
                      self.s.logger.debug(f('attemptReconnect for replset with id successful resuming topologyMonitor', self.id));
                    }
                    self.runningAttempReconnect = false;
                    topologyMonitor(self);
                  });
                } else {
                  if (self.listeners("close").length > 0) {
                    self.emit('close', self);
                  }
                  self.runningAttempReconnect = false;
                  attemptReconnect(self);
                }
              }
            }
            for (var i = 0; i < self.s.connectingServers.length; i++) {
              if (self.s.connectingServers[i].equals(this)) {
                self.s.connectingServers.splice(i, 1);
              }
            }
            var _self = this;
            if (self.s.logger.isDebug()) {
              self.s.logger.debug(f('attemptReconnect in replset with id %s for', self.id));
            }
            if (event == 'connect' && !self.authenticating) {
              if (self.state == DESTROYED) {
                return _self.destroy();
              }
              if (self.s.replicaSetState.update(_self)) {
                if (_self.lastIsMaster() && _self.lastIsMaster().ismaster) {
                  self.ismaster = _self.lastIsMaster();
                }
                for (i = 0; i < handlers.length; i++) {
                  _self.removeAllListeners(handlers[i]);
                }
                _self.on('error', handleEvent(self, 'error'));
                _self.on('close', handleEvent(self, 'close'));
                _self.on('timeout', handleEvent(self, 'timeout'));
                _self.on('parseError', handleEvent(self, 'parseError'));
              } else {
                _self.destroy();
              }
            } else if (event == 'connect' && self.authenticating) {
              this.destroy();
            }
            done();
          };
        }
        var timeoutInterval = 0;
        function connect(server, timeoutInterval) {
          setTimeout(function () {
            server.once('connect', _handleEvent(self, 'connect'));
            server.once('close', _handleEvent(self, 'close'));
            server.once('timeout', _handleEvent(self, 'timeout'));
            server.once('error', _handleEvent(self, 'error'));
            server.once('parseError', _handleEvent(self, 'parseError'));
            server.on('serverOpening', function (e) {
              self.emit('serverOpening', e);
            });
            server.on('serverDescriptionChanged', function (e) {
              self.emit('serverDescriptionChanged', e);
            });
            server.on('serverClosed', function (e) {
              self.emit('serverClosed', e);
            });
            server.connect(self.s.connectOptions);
          }, timeoutInterval);
        }
        while (servers.length > 0) {
          connect(servers.shift(), timeoutInterval++);
        }
      }, self.s.minHeartbeatFrequencyMS);
    }
    function connectNewServers(self, servers, callback) {
      var count = servers.length;
      var _handleEvent = function (self, event) {
        return function () {
          var _self = this;
          count = count - 1;
          if (self.state == DESTROYED) {
            return this.destroy();
          }
          if (event == 'connect' && !self.authenticating) {
            if (self.state == DESTROYED) {
              return _self.destroy();
            }
            var result = self.s.replicaSetState.update(_self);
            if (result) {
              if (_self.lastIsMaster() && _self.lastIsMaster().ismaster) {
                self.ismaster = _self.lastIsMaster();
              }
              for (var i = 0; i < handlers.length; i++) {
                _self.removeAllListeners(handlers[i]);
              }
              _self.on('error', handleEvent(self, 'error'));
              _self.on('close', handleEvent(self, 'close'));
              _self.on('timeout', handleEvent(self, 'timeout'));
              _self.on('parseError', handleEvent(self, 'parseError'));
            } else {
              _self.destroy();
            }
          } else if (event == 'connect' && self.authenticating) {
            this.destroy();
          }
          if (count == 0) {
            callback();
          }
        };
      };
      if (count == 0) return callback();
      function execute(_server, i) {
        setTimeout(function () {
          if (self.state == DESTROYED) {
            return;
          }
          var server = new Server(assign({}, self.s.options, {
            host: _server.split(':')[0],
            port: parseInt(_server.split(':')[1], 10)
          }, {
            authProviders: self.authProviders,
            reconnect: false,
            monitoring: false,
            inTopology: true
          }, { clientInfo: clone(self.s.clientInfo) }));
          server.once('connect', _handleEvent(self, 'connect'));
          server.once('close', _handleEvent(self, 'close'));
          server.once('timeout', _handleEvent(self, 'timeout'));
          server.once('error', _handleEvent(self, 'error'));
          server.once('parseError', _handleEvent(self, 'parseError'));
          server.on('serverOpening', function (e) {
            self.emit('serverOpening', e);
          });
          server.on('serverDescriptionChanged', function (e) {
            self.emit('serverDescriptionChanged', e);
          });
          server.on('serverClosed', function (e) {
            self.emit('serverClosed', e);
          });
          server.connect(self.s.connectOptions);
        }, i);
      }
      for (var i = 0; i < servers.length; i++) {
        execute(servers[i], i);
      }
    }
    function topologyMonitor(self, options) {
      options = options || {};
      self.haTimeoutId = setTimeout(function () {
        if (self.state == DESTROYED) return;
        if (options.haInterval) {
          topologyMonitor(self);
        }
        if (self.s.replicaSetState.hasPrimaryAndSecondary() && self.s.disconnectHandler) {
          self.s.disconnectHandler.execute();
        } else if (self.s.replicaSetState.hasPrimary() && self.s.disconnectHandler) {
          self.s.disconnectHandler.execute({ executePrimary: true });
        } else if (self.s.replicaSetState.hasSecondary() && self.s.disconnectHandler) {
          self.s.disconnectHandler.execute({ executeSecondary: true });
        }
        var connectingServers = self.s.replicaSetState.allServers();
        if (self.s.logger.isDebug()) {
          self.s.logger.debug(f('topologyMonitor in replset with id %s connected servers [%s]', self.id, connectingServers.map(function (x) {
            return x.name;
          })));
        }
        var count = connectingServers.length;
        if (count == 0 && !options.haInterval) {
          if (self.listeners("close").length > 0) {
            self.emit('close', self);
          }
          return attemptReconnect(self);
        }
        function pingServer(_self, _server, cb) {
          var start = new Date().getTime();
          emitSDAMEvent(self, 'serverHeartbeatStarted', { connectionId: _server.name });
          _server.command('admin.$cmd', { ismaster: true }, {
            monitoring: true,
            socketTimeout: self.s.options.connectionTimeout || 2000
          }, function (err, r) {
            if (self.state == DESTROYED) {
              _server.destroy();
              return cb(err, r);
            }
            var latencyMS = new Date().getTime() - start;
            var hrTime = process.hrtime();
            _server.lastUpdateTime = hrTime[0] * 1000 + Math.round(hrTime[1] / 1000);
            if (err) {
              emitSDAMEvent(self, 'serverHeartbeatFailed', {
                durationMS: latencyMS,
                failure: err,
                connectionId: _server.name
              });
              _self.s.replicaSetState.remove(_server);
            } else {
              _server.ismaster = r.result;
              if (_server.ismaster.lastWrite && _server.ismaster.lastWrite.lastWriteDate) {
                _server.lastWriteDate = _server.ismaster.lastWrite.lastWriteDate.getTime();
              }
              if (_server.lastIsMasterMS == -1) {
                _server.lastIsMasterMS = latencyMS;
              } else if (_server.lastIsMasterMS) {
                _server.lastIsMasterMS = 0.2 * latencyMS + (1 - 0.2) * _server.lastIsMasterMS;
              }
              if (_self.s.replicaSetState.update(_server)) {
                if (_server.lastIsMaster() && _server.lastIsMaster().ismaster) {
                  self.ismaster = _server.lastIsMaster();
                }
              }
              emitSDAMEvent(self, 'serverHeartbeatSucceeded', {
                durationMS: latencyMS,
                reply: r.result,
                connectionId: _server.name
              });
            }
            self.s.replicaSetState.updateServerMaxStaleness(_server, self.s.haInterval);
            cb(err, r);
          });
        }
        function connectMissingServers() {
          if (self.state == DESTROYED) return;
          connectNewServers(self, self.s.replicaSetState.unknownServers, function () {
            if (self.state == DESTROYED) return;
            if (options.haInterval) {
              if (self.state == CONNECTING && self.s.replicaSetState.hasPrimaryAndSecondary()) {
                stateTransition(self, CONNECTED);
                self.initialConnectState.connect = true;
                self.initialConnectState.fullsetup = true;
                self.initialConnectState.all = true;
                process.nextTick(function () {
                  self.emit('connect', self);
                  self.emit('fullsetup', self);
                  self.emit('all', self);
                });
              } else if (self.state == CONNECTING && self.s.replicaSetState.hasPrimary()) {
                stateTransition(self, CONNECTED);
                self.initialConnectState.connect = true;
                process.nextTick(function () {
                  self.emit('connect', self);
                });
              } else if (self.state == CONNECTING && self.s.replicaSetState.hasSecondary() && self.s.options.secondaryOnlyConnectionAllowed) {
                stateTransition(self, CONNECTED);
                self.initialConnectState.connect = true;
                process.nextTick(function () {
                  self.emit('connect', self);
                });
              } else if (self.state == CONNECTING) {
                self.emit('error', new MongoError('no primary found in replicaset'));
                return self.destroy();
              } else if (self.state == CONNECTED && self.s.replicaSetState.hasPrimaryAndSecondary() && !self.initialConnectState.fullsetup) {
                self.initialConnectState.fullsetup = true;
                process.nextTick(function () {
                  self.emit('fullsetup', self);
                  self.emit('all', self);
                });
              }
            }
            if (!options.haInterval) topologyMonitor(self);
          });
        }
        if (connectingServers.length == 0 && self.s.replicaSetState.unknownServers.length > 0 && options.haInterval) {
          return connectMissingServers();
        } else if (connectingServers.length == 0 && options.haInterval) {
          self.destroy();
          return self.emit('error', new MongoError('no valid replicaset members found'));
        }
        for (var i = 0; i < connectingServers.length; i++) {
          pingServer(self, connectingServers[i], function () {
            count = count - 1;
            if (count == 0) {
              connectMissingServers();
            }
          });
        }
      }, options.haInterval || self.s.haInterval);
    }
    function handleEvent(self, event) {
      return function () {
        if (self.state == DESTROYED) return;
        if (self.s.logger.isDebug()) {
          self.s.logger.debug(f('handleEvent %s from server %s in replset with id %s', event, this.name, self.id));
        }
        self.s.replicaSetState.remove(this);
      };
    }
    function handleInitialConnectEvent(self, event) {
      return function () {
        if (self.s.logger.isDebug()) {
          self.s.logger.debug(f('handleInitialConnectEvent %s from server %s in replset with id %s', event, this.name, self.id));
        }
        if (self.state == DESTROYED) {
          return this.destroy();
        }
        if (event == 'connect') {
          var result = self.s.replicaSetState.update(this);
          if (result == true) {
            if (this.lastIsMaster() && this.lastIsMaster().ismaster) {
              self.ismaster = this.lastIsMaster();
            }
            if (self.s.logger.isDebug()) {
              self.s.logger.debug(f('handleInitialConnectEvent %s from server %s in replset with id %s has state [%s]', event, this.name, self.id, JSON.stringify(self.s.replicaSetState.set)));
            }
            for (var i = 0; i < handlers.length; i++) {
              this.removeAllListeners(handlers[i]);
            }
            this.on('error', handleEvent(self, 'error'));
            this.on('close', handleEvent(self, 'close'));
            this.on('timeout', handleEvent(self, 'timeout'));
            this.on('parseError', handleEvent(self, 'parseError'));
          } else if (result instanceof MongoError) {
            this.destroy();
            self.destroy();
            return self.emit('error', result);
          } else {
            this.destroy();
          }
        } else {
          self.emit('failed', this);
          self.s.replicaSetState.remove(this);
        }
        for (i = 0; i < self.s.connectingServers.length; i++) {
          if (self.s.connectingServers[i].equals(this)) {
            self.s.connectingServers.splice(i, 1);
          }
        }
        if (self.s.connectingServers.length == 0) {
          topologyMonitor(self, { haInterval: 1 });
        }
      };
    }
    function connectServers(self, servers) {
      self.s.connectingServers = self.s.connectingServers.concat(servers);
      var timeoutInterval = 0;
      function connect(server, timeoutInterval) {
        setTimeout(function () {
          if (self.s.replicaSetState.update(server)) {
            if (server.lastIsMaster() && server.lastIsMaster().ismaster) {
              self.ismaster = server.lastIsMaster();
            }
          }
          server.once('close', handleInitialConnectEvent(self, 'close'));
          server.once('timeout', handleInitialConnectEvent(self, 'timeout'));
          server.once('parseError', handleInitialConnectEvent(self, 'parseError'));
          server.once('error', handleInitialConnectEvent(self, 'error'));
          server.once('connect', handleInitialConnectEvent(self, 'connect'));
          server.on('serverOpening', function (e) {
            self.emit('serverOpening', e);
          });
          server.on('serverDescriptionChanged', function (e) {
            self.emit('serverDescriptionChanged', e);
          });
          server.on('serverClosed', function (e) {
            self.emit('serverClosed', e);
          });
          server.connect(self.s.connectOptions);
        }, timeoutInterval);
      }
      while (servers.length > 0) {
        connect(servers.shift(), timeoutInterval++);
      }
    }
    function emitSDAMEvent(self, event, description) {
      if (self.listeners(event).length > 0) {
        self.emit(event, description);
      }
    }
    ReplSet.prototype.connect = function (options) {
      var self = this;
      this.s.connectOptions = options || {};
      stateTransition(this, CONNECTING);
      var servers = this.s.seedlist.map(function (x) {
        return new Server(assign({}, self.s.options, x, {
          authProviders: self.authProviders,
          reconnect: false,
          monitoring: false,
          inTopology: true
        }, { clientInfo: clone(self.s.clientInfo) }));
      });
      emitSDAMEvent(this, 'topologyOpening', { topologyId: this.id });
      connectServers(self, servers);
    };
    ReplSet.prototype.destroy = function (options) {
      options = options || {};
      stateTransition(this, DESTROYED);
      if (this.haTimeoutId) clearTimeout(this.haTimeoutId);
      this.s.replicaSetState.destroy(options);
      this.s.connectingServers.forEach(function (x) {
        x.destroy(options);
      });
      emitSDAMEvent(this, 'topologyClosed', { topologyId: this.id });
    };
    ReplSet.prototype.unref = function () {
      stateTransition(this, DISCONNECTED);
      this.s.replicaSetState.allServers().forEach(function (x) {
        x.unref();
      });
      clearTimeout(this.haTimeoutId);
    };
    ReplSet.prototype.lastIsMaster = function () {
      return this.s.replicaSetState.primary ? this.s.replicaSetState.primary.lastIsMaster() : this.ismaster;
    };
    ReplSet.prototype.connections = function () {
      var servers = this.s.replicaSetState.allServers();
      var connections = [];
      for (var i = 0; i < servers.length; i++) {
        connections = connections.concat(servers[i].connections());
      }
      return connections;
    };
    ReplSet.prototype.isConnected = function (options) {
      options = options || {};
      if (this.authenticating) return false;
      if (options.readPreference && options.readPreference.equals(ReadPreference.secondary)) {
        return this.s.replicaSetState.hasSecondary();
      }
      if (options.readPreference && options.readPreference.equals(ReadPreference.primary)) {
        return this.s.replicaSetState.hasPrimary();
      }
      if (options.readPreference && options.readPreference.equals(ReadPreference.primaryPreferred)) {
        return this.s.replicaSetState.hasSecondary() || this.s.replicaSetState.hasPrimary();
      }
      if (options.readPreference && options.readPreference.equals(ReadPreference.secondaryPreferred)) {
        return this.s.replicaSetState.hasSecondary() || this.s.replicaSetState.hasPrimary();
      }
      if (this.s.secondaryOnlyConnectionAllowed && this.s.replicaSetState.hasSecondary()) {
        return true;
      }
      return this.s.replicaSetState.hasPrimary();
    };
    ReplSet.prototype.isDestroyed = function () {
      return this.state == DESTROYED;
    };
    ReplSet.prototype.getServer = function (options) {
      options = options || {};
      var server = this.s.replicaSetState.pickServer(options.readPreference);
      if (this.s.debug) this.emit('pickedServer', options.readPreference, server);
      return server;
    };
    ReplSet.prototype.getServers = function () {
      return this.s.replicaSetState.allServers();
    };
    var executeWriteOperation = function (self, op, ns, ops, options, callback) {
      if (typeof options == 'function') callback = options, options = {}, options = options || {};
      options = options || {};
      if (self.s.replicaSetState.primary == null) {
        return callback(new MongoError("no primary server found"));
      }
      self.s.replicaSetState.primary[op](ns, ops, options, callback);
    };
    ReplSet.prototype.insert = function (ns, ops, options, callback) {
      if (typeof options == 'function') callback = options, options = {}, options = options || {};
      if (this.state == DESTROYED) return callback(new MongoError(f('topology was destroyed')));
      if (!this.s.replicaSetState.hasPrimary() && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add('insert', ns, ops, options, callback);
      }
      executeWriteOperation(this, 'insert', ns, ops, options, callback);
    };
    ReplSet.prototype.update = function (ns, ops, options, callback) {
      if (typeof options == 'function') callback = options, options = {}, options = options || {};
      if (this.state == DESTROYED) return callback(new MongoError(f('topology was destroyed')));
      if (!this.s.replicaSetState.hasPrimary() && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add('update', ns, ops, options, callback);
      }
      executeWriteOperation(this, 'update', ns, ops, options, callback);
    };
    ReplSet.prototype.remove = function (ns, ops, options, callback) {
      if (typeof options == 'function') callback = options, options = {}, options = options || {};
      if (this.state == DESTROYED) return callback(new MongoError(f('topology was destroyed')));
      if (!this.s.replicaSetState.hasPrimary() && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add('remove', ns, ops, options, callback);
      }
      executeWriteOperation(this, 'remove', ns, ops, options, callback);
    };
    ReplSet.prototype.command = function (ns, cmd, options, callback) {
      if (typeof options == 'function') callback = options, options = {}, options = options || {};
      if (this.state == DESTROYED) return callback(new MongoError(f('topology was destroyed')));
      var self = this;
      var readPreference = options.readPreference ? options.readPreference : ReadPreference.primary;
      if (readPreference.preference == 'primary' && !this.s.replicaSetState.hasPrimary() && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add('command', ns, cmd, options, callback);
      } else if (readPreference.preference == 'secondary' && !this.s.replicaSetState.hasSecondary() && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add('command', ns, cmd, options, callback);
      } else if (readPreference.preference != 'primary' && !this.s.replicaSetState.hasSecondary() && !this.s.replicaSetState.hasPrimary() && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add('command', ns, cmd, options, callback);
      }
      var server = this.s.replicaSetState.pickServer(readPreference);
      if (!(server instanceof Server)) return callback(server);
      if (self.s.debug) self.emit('pickedServer', ReadPreference.primary, server);
      if (server == null) {
        return callback(new MongoError(f("no server found that matches the provided readPreference %s", readPreference)));
      }
      server.command(ns, cmd, options, callback);
    };
    ReplSet.prototype.auth = function (mechanism, db) {
      var allArgs = Array.prototype.slice.call(arguments, 0).slice(0);
      var self = this;
      var args = Array.prototype.slice.call(arguments, 2);
      var callback = args.pop();
      if (this.authProviders[mechanism] == null && mechanism != 'default') {
        return callback(new MongoError(f("auth provider %s does not exist", mechanism)));
      }
      if (this.authenticating) {
        return callback(new MongoError('authentication or logout allready in process'));
      }
      if (!self.s.replicaSetState.hasPrimary() && self.s.disconnectHandler != null) {
        return self.s.disconnectHandler.add('auth', db, allArgs, {}, callback);
      }
      this.authenticating = true;
      var errors = [];
      var servers = this.s.replicaSetState.allServers();
      if (servers.length == 0) {
        this.authenticating = false;
        callback(null, true);
      }
      function auth(server) {
        var argsWithoutCallback = [mechanism, db].concat(args.slice(0));
        var finalArguments = argsWithoutCallback.concat([function (err) {
          count = count - 1;
          if (err) errors.push({
            name: server.name,
            err: err
          });
          if (count == 0) {
            self.authenticating = false;
            if (errors.length) return callback(MongoError.create({
              message: 'authentication fail',
              errors: errors
            }), false);
            callback(null, self);
          }
        }]);
        if (!server.lastIsMaster().arbiterOnly) {
          server.auth.apply(server, finalArguments);
        } else {
          finalArguments.pop()(null);
        }
      }
      var count = servers.length;
      while (servers.length > 0) {
        auth(servers.shift());
      }
    };
    ReplSet.prototype.logout = function (dbName, callback) {
      var self = this;
      if (this.authenticating) {
        throw new MongoError('authentication or logout allready in process');
      }
      this.authenticating = true;
      var providers = Object.keys(this.authProviders);
      for (var i = 0; i < providers.length; i++) {
        this.authProviders[providers[i]].logout(dbName);
      }
      var servers = this.s.replicaSetState.allServers();
      var count = servers.length;
      if (count == 0) return callback();
      var errors = [];
      function logoutServer(_server, cb) {
        _server.logout(dbName, function (err) {
          if (err) errors.push({
            name: _server.name,
            err: err
          });
          cb();
        });
      }
      for (i = 0; i < servers.length; i++) {
        logoutServer(servers[i], function () {
          count = count - 1;
          if (count == 0) {
            self.authenticating = false;
            if (errors.length) return callback(MongoError.create({
              message: f('logout failed against db %s', dbName),
              errors: errors
            }), false);
            callback();
          }
        });
      }
    };
    ReplSet.prototype.cursor = function (ns, cmd, cursorOptions) {
      cursorOptions = cursorOptions || {};
      var FinalCursor = cursorOptions.cursorFactory || this.s.Cursor;
      return new FinalCursor(this.s.bson, ns, cmd, cursorOptions, this, this.s.options);
    };
    module.exports = ReplSet;
  })($__require('2a').Buffer, $__require('13'));
  return module.exports;
});
$__System.registerDynamic("1b7", ["1b9", "1b8"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    var nextTick = $__require("1b9").nextTick;
    var apply = Function.prototype.apply;
    var slice = Array.prototype.slice;
    var immediateIds = {};
    var nextImmediateId = 0;
    exports.setTimeout = function () {
      return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
    };
    exports.setInterval = function () {
      return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
    };
    exports.clearTimeout = exports.clearInterval = function (timeout) {
      timeout.close();
    };
    function Timeout(id, clearFn) {
      this._id = id;
      this._clearFn = clearFn;
    }
    Timeout.prototype.unref = Timeout.prototype.ref = function () {};
    Timeout.prototype.close = function () {
      this._clearFn.call(window, this._id);
    };
    exports.enroll = function (item, msecs) {
      clearTimeout(item._idleTimeoutId);
      item._idleTimeout = msecs;
    };
    exports.unenroll = function (item) {
      clearTimeout(item._idleTimeoutId);
      item._idleTimeout = -1;
    };
    exports._unrefActive = exports.active = function (item) {
      clearTimeout(item._idleTimeoutId);
      var msecs = item._idleTimeout;
      if (msecs >= 0) {
        item._idleTimeoutId = setTimeout(function onTimeout() {
          if (item._onTimeout) item._onTimeout();
        }, msecs);
      }
    };
    exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function (fn) {
      var id = nextImmediateId++;
      var args = arguments.length < 2 ? false : slice.call(arguments, 1);
      immediateIds[id] = true;
      nextTick(function onNextTick() {
        if (immediateIds[id]) {
          if (args) {
            fn.apply(null, args);
          } else {
            fn.call(null);
          }
          exports.clearImmediate(id);
        }
      });
      return id;
    };
    exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function (id) {
      delete immediateIds[id];
    };
  })($__require("1b8"));
  return module.exports;
});
$__System.registerDynamic("1ba", ["1b7"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("1b7");
  return module.exports;
});
$__System.registerDynamic('1bb', ['1ba'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  module.exports = $__System._nodeRequire ? $__System._nodeRequire('timers') : $__require('1ba');
  return module.exports;
});
$__System.registerDynamic("1bc", ["1bb"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("1bb");
  return module.exports;
});
$__System.registerDynamic('1bd', ['49', '166', '1bc', '11', '2a', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer, process) {
    if ($__System._nodeRequire) {
      module.exports = $__System._nodeRequire('net');
    } else {
      var stream = $__require('49');
      var util = $__require('166');
      var timers = $__require('1bc');
      var http = $__require('11');
      var debug = util.debuglog('net');
      var proxy = {
        hostname: window.location.hostname,
        port: window.location.port
      };
      function getProxy() {
        return proxy;
      }
      function getProxyHost() {
        var host = getProxy().hostname;
        if (getProxy().port) {
          host += ':' + getProxy().port;
        }
        return host;
      }
      exports.setProxy = function (options) {
        options = options || {};
        proxy.hostname = options.hostname;
        proxy.port = options.port;
      };
      exports.createServer = function () {
        throw new Error('Cannot create server in a browser');
      };
      exports.connect = exports.createConnection = function () {
        var args = normalizeConnectArgs(arguments);
        debug('createConnection', args);
        var s = new Socket(args[0]);
        return Socket.prototype.connect.apply(s, args);
      };
      function toNumber(x) {
        return (x = Number(x)) >= 0 ? x : false;
      }
      function isPipeName(s) {
        return util.isString(s) && toNumber(s) === false;
      }
      function normalizeConnectArgs(args) {
        var options = {};
        if (util.isObject(args[0])) {
          options = args[0];
        } else if (isPipeName(args[0])) {
          options.path = args[0];
        } else {
          options.port = args[0];
          if (util.isString(args[1])) {
            options.host = args[1];
          }
        }
        var cb = args[args.length - 1];
        return util.isFunction(cb) ? [options, cb] : [options];
      }
      exports._normalizeConnectArgs = normalizeConnectArgs;
      function Socket(options) {
        if (!(this instanceof Socket)) return new Socket(options);
        this._connecting = false;
        this._host = null;
        if (util.isNumber(options)) options = { fd: options };else if (util.isUndefined(options)) options = {};
        stream.Duplex.call(this, options);
        this.readable = this.writable = false;
        this._writableState.decodeStrings = false;
        this.allowHalfOpen = options && options.allowHalfOpen || false;
      }
      util.inherits(Socket, stream.Duplex);
      exports.Socket = Socket;
      exports.Stream = Socket;
      Socket.prototype.listen = function () {
        throw new Error('Cannot listen in a browser');
      };
      Socket.prototype.setTimeout = function (msecs, callback) {
        if (msecs > 0 && isFinite(msecs)) {
          timers.enroll(this, msecs);
          if (callback) {
            this.once('timeout', callback);
          }
        } else if (msecs === 0) {
          timers.unenroll(this);
          if (callback) {
            this.removeListener('timeout', callback);
          }
        }
      };
      Socket.prototype._onTimeout = function () {
        debug('_onTimeout');
        this.emit('timeout');
      };
      Socket.prototype.setNoDelay = function (enable) {};
      Socket.prototype.setKeepAlive = function (setting, msecs) {};
      Socket.prototype.address = function () {
        return {
          address: this.remoteAddress,
          port: this.remotePort,
          family: this.remoteFamily
        };
      };
      Object.defineProperty(Socket.prototype, 'readyState', { get: function () {
          if (this._connecting) {
            return 'opening';
          } else if (this.readable && this.writable) {
            return 'open';
          } else if (this.readable && !this.writable) {
            return 'readOnly';
          } else if (!this.readable && this.writable) {
            return 'writeOnly';
          } else {
            return 'closed';
          }
        } });
      Socket.prototype.bufferSize = undefined;
      Socket.prototype._read = function () {};
      Socket.prototype.end = function (data, encoding) {
        stream.Duplex.prototype.end.call(this, data, encoding);
        this.writable = false;
        if (this._ws) {
          this._ws.close();
        }
        if (this.readable && !this._readableState.endEmitted) this.read(0);else maybeDestroy(this);
      };
      function maybeDestroy(socket) {
        if (!socket.readable && !socket.writable && !socket.destroyed && !socket._connecting && !socket._writableState.length) {
          socket.destroy();
        }
      }
      Socket.prototype.destroySoon = function () {
        if (this.writable) this.end();
        if (this._writableState.finished) this.destroy();else this.once('finish', this.destroy);
      };
      Socket.prototype.destroy = function (exception) {
        debug('destroy', exception);
        if (this.destroyed) {
          return;
        }
        self._connecting = false;
        this.readable = this.writable = false;
        timers.unenroll(this);
        debug('close');
        this.destroyed = true;
      };
      Socket.prototype.remoteAddress = null;
      Socket.prototype.remoteFamily = null;
      Socket.prototype.remotePort = null;
      Socket.prototype.localAddress = null;
      Socket.prototype.localPort = null;
      Socket.prototype.bytesRead = 0;
      Socket.prototype.bytesWritten = 0;
      Socket.prototype._write = function (data, encoding, cb) {
        var self = this;
        cb = cb || function () {};
        if (this._connecting) {
          this._pendingData = data;
          this._pendingEncoding = encoding;
          this.once('connect', function () {
            this._write(data, encoding, cb);
          });
          return;
        }
        this._pendingData = null;
        this._pendingEncoding = '';
        if (encoding == 'binary' && typeof data == 'string') {
          data = new Buffer(data, encoding);
        }
        this._ws.send(data);
        process.nextTick(function () {
          self.bytesWritten += data.length;
          cb();
        });
      };
      Socket.prototype.write = function (chunk, encoding, cb) {
        if (!util.isString(chunk) && !util.isBuffer(chunk)) throw new TypeError('invalid data');
        return stream.Duplex.prototype.write.apply(this, arguments);
      };
      Socket.prototype.connect = function (options, cb) {
        var self = this;
        if (!util.isObject(options)) {
          var args = normalizeConnectArgs(arguments);
          return Socket.prototype.connect.apply(this, args);
        }
        cb = cb || function () {};
        if (this.write !== Socket.prototype.write) this.write = Socket.prototype.write;
        if (options.path) {
          throw new Error('options.path not supported in the browser');
        }
        self._connecting = true;
        self.writable = true;
        self._host = options.host;
        var req = http.request({
          hostname: getProxy().hostname,
          port: getProxy().port,
          path: '/api/vm/net/connect',
          method: 'POST'
        }, function (res) {
          var json = '';
          res.on('data', function (buf) {
            json += buf;
          });
          res.on('end', function () {
            var data = null;
            try {
              data = JSON.parse(json);
            } catch (e) {
              data = {
                code: res.statusCode,
                error: json
              };
            }
            if (data.error) {
              self.emit('error', 'Cannot open TCP connection [' + res.statusCode + ']: ' + data.error);
              self.destroy();
              return;
            }
            self.remoteAddress = data.remote.address;
            self.remoteFamily = data.remote.family;
            self.remotePort = data.remote.port;
            self._connectWebSocket(data.token, function (err) {
              if (err) {
                cb(err);
                return;
              }
              cb();
            });
          });
        });
        req.setHeader('Content-Type', 'application/json');
        req.write(JSON.stringify(options));
        req.end();
        return this;
      };
      Socket.prototype._connectWebSocket = function (token, cb) {
        var self = this;
        if (self._ws) {
          process.nextTick(function () {
            cb();
          });
          return;
        }
        this._ws = new WebSocket('ws://' + getProxyHost() + '/api/vm/net/socket?token=' + token);
        this._handleWebsocket();
        if (cb) {
          self.on('connect', cb);
        }
      };
      Socket.prototype._handleWebsocket = function () {
        var self = this;
        this._ws.addEventListener('open', function () {
          self._connecting = false;
          self.readable = true;
          self.emit('connect');
          self.read(0);
        });
        this._ws.addEventListener('error', function (e) {
          self.emit('error', 'An error occured with the WebSocket');
        });
        this._ws.addEventListener('message', function (e) {
          var contents = e.data;
          var gotBuffer = function (buffer) {
            self.bytesRead += buffer.length;
            self.push(buffer);
          };
          if (typeof contents == 'string') {
            var buffer = new Buffer(contents);
            gotBuffer(buffer);
          } else if (window.Blob && contents instanceof Blob) {
            var fileReader = new FileReader();
            fileReader.addEventListener('load', function (e) {
              var buf = fileReader.result;
              var arr = new Uint8Array(buf);
              gotBuffer(new Buffer(arr));
            });
            fileReader.readAsArrayBuffer(contents);
          } else {
            console.warn('Cannot read TCP stream: unsupported message type', contents);
          }
        });
        this._ws.addEventListener('close', function () {
          if (self.readyState == 'open') {
            self.destroy();
          }
        });
      };
      exports.isIP = function (input) {
        if (exports.isIPv4(input)) {
          return 4;
        } else if (exports.isIPv6(input)) {
          return 6;
        } else {
          return 0;
        }
      };
      exports.isIPv4 = function (input) {
        return (/^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(input)
        );
      };
      exports.isIPv6 = function (input) {
        return (/^(([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))$/.test(input)
        );
      };
    }
  })($__require('2a').Buffer, $__require('13'));
  return module.exports;
});
$__System.registerDynamic("26", ["1bd"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("1bd");
  return module.exports;
});
$__System.registerDynamic("1be", [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  if ($__System._nodeRequire) module.exports = $__System._nodeRequire('tls');else throw "Node tls module not supported in browsers.";
  return module.exports;
});
$__System.registerDynamic("1bf", ["1be"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("1be");
  return module.exports;
});
$__System.registerDynamic('1c0', ['166', '55', '26', '1bf', '38', '1c1', '1c2', '1ab', '1a9', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    "use strict";

    var inherits = $__require('166').inherits,
        EventEmitter = $__require('55').EventEmitter,
        net = $__require('26'),
        tls = $__require('1bf'),
        crypto = $__require('38'),
        f = $__require('166').format,
        debugOptions = $__require('1c1').debugOptions,
        Response = $__require('1c2').Response,
        MongoError = $__require('1ab'),
        Logger = $__require('1a9');
    var _id = 0;
    var debugFields = ['host', 'port', 'size', 'keepAlive', 'keepAliveInitialDelay', 'noDelay', 'connectionTimeout', 'socketTimeout', 'singleBufferSerializtion', 'ssl', 'ca', 'cert', 'rejectUnauthorized', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'checkServerIdentity'];
    var connectionAccounting = false;
    var connections = {};
    var Connection = function (messageHandler, options) {
      EventEmitter.call(this);
      this.options = options || {};
      this.id = _id++;
      this.logger = Logger('Connection', options);
      if (!options.bson) throw new Error("must pass in valid bson parser");
      this.bson = options.bson;
      this.tag = options.tag;
      this.messageHandler = messageHandler;
      this.maxBsonMessageSize = options.maxBsonMessageSize || 1024 * 1024 * 16 * 4;
      if (this.logger.isDebug()) this.logger.debug(f('creating connection %s with options [%s]', this.id, JSON.stringify(debugOptions(debugFields, options))));
      this.port = options.port || 27017;
      this.host = options.host || 'localhost';
      this.keepAlive = typeof options.keepAlive == 'boolean' ? options.keepAlive : true;
      this.keepAliveInitialDelay = options.keepAliveInitialDelay || 0;
      this.noDelay = typeof options.noDelay == 'boolean' ? options.noDelay : true;
      this.connectionTimeout = options.connectionTimeout || 0;
      this.socketTimeout = options.socketTimeout || 0;
      this.destroyed = false;
      this.domainSocket = this.host.indexOf('\/') != -1;
      this.singleBufferSerializtion = typeof options.singleBufferSerializtion == 'boolean' ? options.singleBufferSerializtion : true;
      this.serializationFunction = this.singleBufferSerializtion ? 'toBinUnified' : 'toBin';
      this.ca = options.ca || null;
      this.cert = options.cert || null;
      this.key = options.key || null;
      this.passphrase = options.passphrase || null;
      this.ssl = typeof options.ssl == 'boolean' ? options.ssl : false;
      this.rejectUnauthorized = typeof options.rejectUnauthorized == 'boolean' ? options.rejectUnauthorized : true;
      this.checkServerIdentity = typeof options.checkServerIdentity == 'boolean' || typeof options.checkServerIdentity == 'function' ? options.checkServerIdentity : true;
      if (!this.ssl) this.rejectUnauthorized = false;
      this.responseOptions = {
        promoteLongs: typeof options.promoteLongs == 'boolean' ? options.promoteLongs : true,
        promoteValues: typeof options.promoteValues == 'boolean' ? options.promoteValues : true,
        promoteBuffers: typeof options.promoteBuffers == 'boolean' ? options.promoteBuffers : false
      };
      this.flushing = false;
      this.queue = [];
      this.connection = null;
      this.writeStream = null;
      var hash = crypto.createHash('sha1');
      hash.update(f('%s:%s', this.host, this.port));
      this.hashedName = hash.digest('hex');
      this.workItems = [];
    };
    inherits(Connection, EventEmitter);
    Connection.prototype.setSocketTimeout = function (value) {
      if (this.connection) {
        this.connection.setTimeout(value);
      }
    };
    Connection.prototype.resetSocketTimeout = function () {
      if (this.connection) {
        this.connection.setTimeout(this.socketTimeout);
      }
    };
    Connection.enableConnectionAccounting = function () {
      connectionAccounting = true;
      connections = {};
    };
    Connection.disableConnectionAccounting = function () {
      connectionAccounting = false;
    };
    Connection.connections = function () {
      return connections;
    };
    function deleteConnection(id) {
      delete connections[id];
    }
    function addConnection(id, connection) {
      connections[id] = connection;
    }
    var errorHandler = function (self) {
      return function (err) {
        if (connectionAccounting) deleteConnection(self.id);
        if (self.logger.isDebug()) self.logger.debug(f('connection %s for [%s:%s] errored out with [%s]', self.id, self.host, self.port, JSON.stringify(err)));
        if (self.listeners('error').length > 0) self.emit("error", MongoError.create(err), self);
      };
    };
    var timeoutHandler = function (self) {
      return function () {
        if (connectionAccounting) deleteConnection(self.id);
        if (self.logger.isDebug()) self.logger.debug(f('connection %s for [%s:%s] timed out', self.id, self.host, self.port));
        self.emit("timeout", MongoError.create(f("connection %s to %s:%s timed out", self.id, self.host, self.port)), self);
      };
    };
    var closeHandler = function (self) {
      return function (hadError) {
        if (connectionAccounting) deleteConnection(self.id);
        if (self.logger.isDebug()) self.logger.debug(f('connection %s with for [%s:%s] closed', self.id, self.host, self.port));
        if (!hadError) {
          self.emit("close", MongoError.create(f("connection %s to %s:%s closed", self.id, self.host, self.port)), self);
        }
      };
    };
    var dataHandler = function (self) {
      return function (data) {
        while (data.length > 0) {
          if (self.bytesRead > 0 && self.sizeOfMessage > 0) {
            var remainingBytesToRead = self.sizeOfMessage - self.bytesRead;
            if (remainingBytesToRead > data.length) {
              data.copy(self.buffer, self.bytesRead);
              self.bytesRead = self.bytesRead + data.length;
              data = new Buffer(0);
            } else {
              data.copy(self.buffer, self.bytesRead, 0, remainingBytesToRead);
              data = data.slice(remainingBytesToRead);
              try {
                var emitBuffer = self.buffer;
                self.buffer = null;
                self.sizeOfMessage = 0;
                self.bytesRead = 0;
                self.stubBuffer = null;
                self.messageHandler(new Response(self.bson, emitBuffer, self.responseOptions), self);
              } catch (err) {
                var errorObject = {
                  err: "socketHandler",
                  trace: err,
                  bin: self.buffer,
                  parseState: {
                    sizeOfMessage: self.sizeOfMessage,
                    bytesRead: self.bytesRead,
                    stubBuffer: self.stubBuffer
                  }
                };
                self.emit("parseError", errorObject, self);
              }
            }
          } else {
            if (self.stubBuffer != null && self.stubBuffer.length > 0) {
              if (self.stubBuffer.length + data.length > 4) {
                var newData = new Buffer(self.stubBuffer.length + data.length);
                self.stubBuffer.copy(newData, 0);
                data.copy(newData, self.stubBuffer.length);
                data = newData;
                self.buffer = null;
                self.sizeOfMessage = 0;
                self.bytesRead = 0;
                self.stubBuffer = null;
              } else {
                var newStubBuffer = new Buffer(self.stubBuffer.length + data.length);
                self.stubBuffer.copy(newStubBuffer, 0);
                data.copy(newStubBuffer, self.stubBuffer.length);
                data = new Buffer(0);
              }
            } else {
              if (data.length > 4) {
                var sizeOfMessage = data[0] | data[1] << 8 | data[2] << 16 | data[3] << 24;
                if (sizeOfMessage < 0 || sizeOfMessage > self.maxBsonMessageSize) {
                  errorObject = {
                    err: "socketHandler",
                    trace: '',
                    bin: self.buffer,
                    parseState: {
                      sizeOfMessage: sizeOfMessage,
                      bytesRead: self.bytesRead,
                      stubBuffer: self.stubBuffer
                    }
                  };
                  self.emit("parseError", errorObject, self);
                  return;
                }
                if (sizeOfMessage > 4 && sizeOfMessage < self.maxBsonMessageSize && sizeOfMessage > data.length) {
                  self.buffer = new Buffer(sizeOfMessage);
                  data.copy(self.buffer, 0);
                  self.bytesRead = data.length;
                  self.sizeOfMessage = sizeOfMessage;
                  self.stubBuffer = null;
                  data = new Buffer(0);
                } else if (sizeOfMessage > 4 && sizeOfMessage < self.maxBsonMessageSize && sizeOfMessage == data.length) {
                  try {
                    emitBuffer = data;
                    self.buffer = null;
                    self.sizeOfMessage = 0;
                    self.bytesRead = 0;
                    self.stubBuffer = null;
                    data = new Buffer(0);
                    self.messageHandler(new Response(self.bson, emitBuffer, self.responseOptions), self);
                  } catch (err) {
                    self.emit("parseError", err, self);
                  }
                } else if (sizeOfMessage <= 4 || sizeOfMessage > self.maxBsonMessageSize) {
                  errorObject = {
                    err: "socketHandler",
                    trace: null,
                    bin: data,
                    parseState: {
                      sizeOfMessage: sizeOfMessage,
                      bytesRead: 0,
                      buffer: null,
                      stubBuffer: null
                    }
                  };
                  self.emit("parseError", errorObject, self);
                  self.buffer = null;
                  self.sizeOfMessage = 0;
                  self.bytesRead = 0;
                  self.stubBuffer = null;
                  data = new Buffer(0);
                } else {
                  emitBuffer = data.slice(0, sizeOfMessage);
                  self.buffer = null;
                  self.sizeOfMessage = 0;
                  self.bytesRead = 0;
                  self.stubBuffer = null;
                  data = data.slice(sizeOfMessage);
                  self.messageHandler(new Response(self.bson, emitBuffer, self.responseOptions), self);
                }
              } else {
                self.stubBuffer = new Buffer(data.length);
                data.copy(self.stubBuffer, 0);
                data = new Buffer(0);
              }
            }
          }
        }
      };
    };
    var legalSslSocketOptions = ['pfx', 'key', 'passphrase', 'cert', 'ca', 'ciphers', 'NPNProtocols', 'ALPNProtocols', 'servername', 'secureProtocol', 'secureContext', 'session', 'minDHSize'];
    function merge(options1, options2) {
      for (var name in options2) {
        if (options2[name] != null && legalSslSocketOptions.indexOf(name) != -1) {
          options1[name] = options2[name];
        }
      }
    }
    Connection.prototype.connect = function (_options) {
      var self = this;
      _options = _options || {};
      if (connectionAccounting) addConnection(this.id, this);
      if (typeof _options.promoteLongs == 'boolean') {
        self.responseOptions.promoteLongs = _options.promoteLongs;
        self.responseOptions.promoteValues = _options.promoteValues;
        self.responseOptions.promoteBuffers = _options.promoteBuffers;
      }
      self.connection = self.domainSocket ? net.createConnection(self.host) : net.createConnection(self.port, self.host);
      self.connection.setKeepAlive(self.keepAlive, self.keepAliveInitialDelay);
      self.connection.setTimeout(self.connectionTimeout);
      self.connection.setNoDelay(self.noDelay);
      if (self.ssl) {
        var sslOptions = {
          socket: self.connection,
          rejectUnauthorized: self.rejectUnauthorized
        };
        merge(sslOptions, this.options);
        merge(sslOptions, _options);
        if (self.ca) sslOptions.ca = self.ca;
        if (self.cert) sslOptions.cert = self.cert;
        if (self.key) sslOptions.key = self.key;
        if (self.passphrase) sslOptions.passphrase = self.passphrase;
        if (self.checkServerIdentity == false) {
          sslOptions.checkServerIdentity = function () {
            return undefined;
          };
        } else if (typeof self.checkServerIdentity == 'function') {
          sslOptions.checkServerIdentity = self.checkServerIdentity;
        }
        if (sslOptions.servername == null) {
          sslOptions.servername = self.host;
        }
        self.connection = tls.connect(self.port, self.host, sslOptions, function () {
          if (self.connection.authorizationError && self.rejectUnauthorized) {
            return self.emit("error", self.connection.authorizationError, self, { ssl: true });
          }
          self.connection.setTimeout(self.socketTimeout);
          self.emit('connect', self);
        });
        self.connection.setTimeout(self.connectionTimeout);
      } else {
        self.connection.on('connect', function () {
          self.connection.setTimeout(self.socketTimeout);
          self.emit('connect', self);
        });
      }
      self.connection.once('error', errorHandler(self));
      self.connection.once('timeout', timeoutHandler(self));
      self.connection.once('close', closeHandler(self));
      self.connection.on('data', dataHandler(self));
    };
    Connection.prototype.unref = function () {
      if (this.connection) this.connection.unref();else {
        var self = this;
        this.once('connect', function () {
          self.connection.unref();
        });
      }
    };
    Connection.prototype.destroy = function () {
      if (connectionAccounting) deleteConnection(this.id);
      if (this.connection) {
        this.connection.end();
        this.connection.destroy();
      }
      this.destroyed = true;
    };
    Connection.prototype.write = function (buffer) {
      var i;
      if (this.logger.isDebug()) {
        if (!Array.isArray(buffer)) {
          this.logger.debug(f('writing buffer [%s] to %s:%s', buffer.toString('hex'), this.host, this.port));
        } else {
          for (i = 0; i < buffer.length; i++) this.logger.debug(f('writing buffer [%s] to %s:%s', buffer[i].toString('hex'), this.host, this.port));
        }
      }
      if (!Array.isArray(buffer)) return this.connection.write(buffer, 'binary');
      for (i = 0; i < buffer.length; i++) this.connection.write(buffer[i], 'binary');
    };
    Connection.prototype.toString = function () {
      return "" + this.id;
    };
    Connection.prototype.toJSON = function () {
      return {
        id: this.id,
        host: this.host,
        port: this.port
      };
    };
    Connection.prototype.isConnected = function () {
      if (this.destroyed) return false;
      return !this.connection.destroyed && this.connection.writable;
    };
    module.exports = Connection;
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic('1c3', ['166', '55', '1c0', '1ab', '1a9', '1c2', '1c4', '1af', '1b0', '1b1', '1b2', '1b3', '1b4', '1b5', '2a', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer, process) {
    "use strict";

    var inherits = $__require('166').inherits,
        EventEmitter = $__require('55').EventEmitter,
        Connection = $__require('1c0'),
        MongoError = $__require('1ab'),
        Logger = $__require('1a9'),
        f = $__require('166').format,
        Query = $__require('1c2').Query,
        CommandResult = $__require('1c4'),
        assign = $__require('1af').assign;
    var MongoCR = $__require('1b0'),
        X509 = $__require('1b1'),
        Plain = $__require('1b2'),
        GSSAPI = $__require('1b3'),
        SSPI = $__require('1b4'),
        ScramSHA1 = $__require('1b5');
    var DISCONNECTED = 'disconnected';
    var CONNECTING = 'connecting';
    var CONNECTED = 'connected';
    var DESTROYING = 'destroying';
    var DESTROYED = 'destroyed';
    var _id = 0;
    var Pool = function (options) {
      EventEmitter.call(this);
      this.options = assign({
        host: 'localhost',
        port: 27017,
        size: 5,
        connectionTimeout: 30000,
        socketTimeout: 30000,
        keepAlive: true,
        keepAliveInitialDelay: 0,
        noDelay: true,
        ssl: false,
        checkServerIdentity: true,
        ca: null,
        cert: null,
        key: null,
        passPhrase: null,
        rejectUnauthorized: false,
        promoteLongs: true,
        promoteValues: true,
        promoteBuffers: false,
        reconnect: true,
        reconnectInterval: 1000,
        reconnectTries: 30,
        domainsEnabled: false
      }, options);
      this.id = _id++;
      this.retriesLeft = this.options.reconnectTries;
      this.reconnectId = null;
      if (!options.bson || options.bson && (typeof options.bson.serialize != 'function' || typeof options.bson.deserialize != 'function')) {
        throw new Error("must pass in valid bson parser");
      }
      this.logger = Logger('Pool', options);
      this.state = DISCONNECTED;
      this.availableConnections = [];
      this.inUseConnections = [];
      this.connectingConnections = [];
      this.executing = false;
      this.queue = [];
      this.authProviders = options.authProviders || {
        'mongocr': new MongoCR(options.bson),
        'x509': new X509(options.bson),
        'plain': new Plain(options.bson),
        'gssapi': new GSSAPI(options.bson),
        'sspi': new SSPI(options.bson),
        'scram-sha-1': new ScramSHA1(options.bson)
      };
      this.authenticating = false;
      this.loggingout = false;
      this.nonAuthenticatedConnections = [];
      this.authenticatingTimestamp = null;
      this.numberOfConsecutiveTimeouts = 0;
      this.connectionIndex = 0;
    };
    inherits(Pool, EventEmitter);
    Object.defineProperty(Pool.prototype, 'size', {
      enumerable: true,
      get: function () {
        return this.options.size;
      }
    });
    Object.defineProperty(Pool.prototype, 'connectionTimeout', {
      enumerable: true,
      get: function () {
        return this.options.connectionTimeout;
      }
    });
    Object.defineProperty(Pool.prototype, 'socketTimeout', {
      enumerable: true,
      get: function () {
        return this.options.socketTimeout;
      }
    });
    function stateTransition(self, newState) {
      var legalTransitions = {
        'disconnected': [CONNECTING, DESTROYING, DISCONNECTED],
        'connecting': [CONNECTING, DESTROYING, CONNECTED, DISCONNECTED],
        'connected': [CONNECTED, DISCONNECTED, DESTROYING],
        'destroying': [DESTROYING, DESTROYED],
        'destroyed': [DESTROYED]
      };
      var legalStates = legalTransitions[self.state];
      if (legalStates && legalStates.indexOf(newState) != -1) {
        self.state = newState;
      } else {
        self.logger.error(f('Pool with id [%s] failed attempted illegal state transition from [%s] to [%s] only following state allowed [%s]', self.id, self.state, newState, legalStates));
      }
    }
    function authenticate(pool, auth, connection, cb) {
      if (auth[0] === undefined) return cb(null);
      var mechanism = auth[0];
      var db = auth[1];
      if (!pool.authProviders[mechanism]) {
        throw new MongoError(f('authMechanism %s not supported', mechanism));
      }
      var provider = pool.authProviders[mechanism];
      provider.auth.apply(provider, [write(pool), [connection], db].concat(auth.slice(2)).concat([cb]));
    }
    function write(self) {
      return function (connection, command, callback) {
        if (self.state == DESTROYED || self.state == DESTROYING) {
          return callback(new MongoError('pool destroyed'));
        }
        connection.workItems.push({
          cb: callback,
          command: true,
          requestId: command.requestId
        });
        connection.write(command.toBin());
      };
    }
    function reauthenticate(pool, connection, cb) {
      function authenticateAgainstProvider(pool, connection, providers, cb) {
        if (providers.length == 0) return cb();
        var provider = pool.authProviders[providers.pop()];
        provider.reauthenticate(write(pool), [connection], function (err) {
          if (err) return cb(err);
          authenticateAgainstProvider(pool, connection, providers, cb);
        });
      }
      authenticateAgainstProvider(pool, connection, Object.keys(pool.authProviders), cb);
    }
    function connectionFailureHandler(self, event) {
      return function (err) {
        if (this._connectionFailHandled) return;
        this._connectionFailHandled = true;
        this.destroy();
        removeConnection(self, this);
        while (this.workItems.length > 0) {
          var workItem = this.workItems.shift();
          if (workItem.cb) workItem.cb(err);
        }
        if (event == 'timeout') {
          self.numberOfConsecutiveTimeouts = self.numberOfConsecutiveTimeouts + 1;
          if (self.numberOfConsecutiveTimeouts > self.options.reconnectTries) {
            self.numberOfConsecutiveTimeouts = 0;
            self.destroy(true);
            return self.emit('close', self);
          }
        }
        if (self.socketCount() == 0) {
          if (self.state != DESTROYED && self.state != DESTROYING) {
            stateTransition(self, DISCONNECTED);
          }
          event = event == 'error' ? 'close' : event;
          self.emit(event, err);
        }
        if (!self.reconnectId && self.options.reconnect) {
          self.reconnectId = setTimeout(attemptReconnect(self), self.options.reconnectInterval);
        }
      };
    }
    function attemptReconnect(self) {
      return function () {
        self.emit('attemptReconnect', self);
        if (self.state == DESTROYED || self.state == DESTROYING) return;
        if (self.isConnected()) {
          self.reconnectId = null;
          return;
        }
        function _connectionFailureHandler(self) {
          return function () {
            if (this._connectionFailHandled) return;
            this._connectionFailHandled = true;
            this.destroy();
            self.retriesLeft = self.retriesLeft - 1;
            if (self.retriesLeft == 0) {
              self.destroy();
              self.emit('reconnectFailed', new MongoError(f('failed to reconnect after %s attempts with interval %s ms', self.options.reconnectTries, self.options.reconnectInterval)));
            } else {
              self.reconnectId = setTimeout(attemptReconnect(self), self.options.reconnectInterval);
            }
          };
        }
        function _connectHandler(self) {
          return function () {
            var connection = this;
            if (self.state == DESTROYED || self.state == DESTROYING) {
              return connection.destroy();
            }
            handlers.forEach(function (event) {
              connection.removeAllListeners(event);
            });
            self.reconnectId = null;
            connection.on('error', connectionFailureHandler(self, 'error'));
            connection.on('close', connectionFailureHandler(self, 'close'));
            connection.on('timeout', connectionFailureHandler(self, 'timeout'));
            connection.on('parseError', connectionFailureHandler(self, 'parseError'));
            reauthenticate(self, this, function () {
              self.retriesLeft = self.options.reconnectTries;
              self.availableConnections.push(connection);
              self.emit('reconnect', self);
              _execute(self)();
            });
          };
        }
        var connection = new Connection(messageHandler(self), self.options);
        connection.on('close', _connectionFailureHandler(self, 'close'));
        connection.on('error', _connectionFailureHandler(self, 'error'));
        connection.on('timeout', _connectionFailureHandler(self, 'timeout'));
        connection.on('parseError', _connectionFailureHandler(self, 'parseError'));
        connection.on('connect', _connectHandler(self));
        connection.connect();
      };
    }
    function moveConnectionBetween(connection, from, to) {
      var index = from.indexOf(connection);
      if (index != -1) {
        from.splice(index, 1);
        to.push(connection);
      }
    }
    function messageHandler(self) {
      return function (message, connection) {
        var workItem = null;
        for (var i = 0; i < connection.workItems.length; i++) {
          if (connection.workItems[i].requestId == message.responseTo) {
            workItem = connection.workItems[i];
            connection.workItems.splice(i, 1);
          }
        }
        self.numberOfConsecutiveTimeouts = 0;
        if (workItem.socketTimeout) {
          connection.resetSocketTimeout();
        }
        if (self.logger.isDebug()) {
          self.logger.debug(f('message [%s] received from %s:%s', message.raw.toString('hex'), self.options.host, self.options.port));
        }
        function authenticateStragglers(self, connection, callback) {
          var connections = self.nonAuthenticatedConnections.slice(0);
          var nonAuthenticatedConnections = self.nonAuthenticatedConnections;
          self.nonAuthenticatedConnections = [];
          if (connection.workItems.length == 1 && (connection.workItems[0].authenticating == true || typeof connection.workItems[0].authenticatingTimestamp == 'number' && connection.workItems[0].authenticatingTimestamp != self.authenticatingTimestamp)) {
            connections.push(connection);
          }
          if (connections.length == 0) {
            moveConnectionBetween(connection, self.inUseConnections, self.availableConnections);
            return callback();
          }
          var connectionCount = connections.length;
          for (var i = 0; i < connectionCount; i++) {
            reauthenticate(self, connections[i], function () {
              connectionCount = connectionCount - 1;
              if (connectionCount == 0) {
                self.availableConnections = self.availableConnections.concat(nonAuthenticatedConnections);
                moveConnectionBetween(connection, self.inUseConnections, self.availableConnections);
                callback();
              }
            });
          }
        }
        function handleOperationCallback(self, cb, err, result) {
          if (!self.options.domainsEnabled) {
            return process.nextTick(function () {
              return cb(err, result);
            });
          }
          cb(err, result);
        }
        authenticateStragglers(self, connection, function () {
          if (!self.executing) {
            process.nextTick(function () {
              _execute(self)();
            });
          }
          if (!workItem.immediateRelease) {
            try {
              message.parse(workItem);
            } catch (err) {
              return handleOperationCallback(self, workItem.cb, MongoError.create(err));
            }
            if (workItem.command && message.documents[0] && (message.documents[0].ok == 0 || message.documents[0]['$err'] || message.documents[0]['errmsg'] || message.documents[0]['code'])) {
              return handleOperationCallback(self, workItem.cb, MongoError.create(message.documents[0]));
            }
            message.hashedName = connection.hashedName;
            handleOperationCallback(self, workItem.cb, null, new CommandResult(workItem.fullResult ? message : message.documents[0], connection, message));
          }
        });
      };
    }
    Pool.prototype.socketCount = function () {
      return this.availableConnections.length + this.inUseConnections.length + this.connectingConnections.length;
    };
    Pool.prototype.allConnections = function () {
      return this.availableConnections.concat(this.inUseConnections).concat(this.connectingConnections);
    };
    Pool.prototype.get = function () {
      return this.allConnections()[0];
    };
    Pool.prototype.isConnected = function () {
      if (this.state == DESTROYED || this.state == DESTROYING) {
        return false;
      }
      var connections = this.availableConnections.concat(this.inUseConnections);
      for (var i = 0; i < connections.length; i++) {
        if (connections[i].isConnected()) return true;
      }
      if (connections.length == 0 && this.authenticating) {
        return true;
      }
      return false;
    };
    Pool.prototype.isDestroyed = function () {
      return this.state == DESTROYED || this.state == DESTROYING;
    };
    Pool.prototype.isDisconnected = function () {
      return this.state == DISCONNECTED;
    };
    Pool.prototype.connect = function () {
      if (this.state != DISCONNECTED) {
        throw new MongoError('connection in unlawful state ' + this.state);
      }
      var self = this;
      stateTransition(this, CONNECTING);
      var args = Array.prototype.slice.call(arguments, 0);
      var connection = new Connection(messageHandler(self), this.options);
      this.connectingConnections.push(connection);
      connection.once('connect', function (connection) {
        if (self.state == DESTROYED || self.state == DESTROYING) return self.destroy();
        reauthenticate(self, connection, function (err) {
          if (self.state == DESTROYED || self.state == DESTROYING) return self.destroy();
          if (err) {
            self.destroy();
            return self.emit('error', err);
          }
          authenticate(self, args, connection, function (err) {
            if (self.state == DESTROYED || self.state == DESTROYING) return self.destroy();
            if (err) {
              self.destroy();
              return self.emit('error', err);
            }
            stateTransition(self, CONNECTED);
            moveConnectionBetween(connection, self.connectingConnections, self.availableConnections);
            self.emit('connect', self);
          });
        });
      });
      connection.once('error', connectionFailureHandler(this, 'error'));
      connection.once('close', connectionFailureHandler(this, 'close'));
      connection.once('timeout', connectionFailureHandler(this, 'timeout'));
      connection.once('parseError', connectionFailureHandler(this, 'parseError'));
      try {
        connection.connect();
      } catch (err) {
        self.emit('error', err);
      }
    };
    Pool.prototype.auth = function (mechanism) {
      var self = this;
      var args = Array.prototype.slice.call(arguments, 0);
      var callback = args.pop();
      if (self.authProviders[mechanism] == null && mechanism != 'default') {
        throw new MongoError(f("auth provider %s does not exist", mechanism));
      }
      this.authenticating = true;
      this.authenticatingTimestamp = new Date().getTime();
      function authenticateLiveConnections(self, args, cb) {
        var connections = self.availableConnections;
        self.availableConnections = [];
        var connectionsCount = connections.length;
        var error = null;
        if (connectionsCount == 0) return callback(null);
        for (var i = 0; i < connections.length; i++) {
          authenticate(self, args, connections[i], function (err) {
            connectionsCount = connectionsCount - 1;
            if (err) error = err;
            if (connectionsCount == 0) {
              self.authenticating = false;
              self.availableConnections = self.availableConnections.concat(connections);
              if (error) {
                if (self.logger.isError()) {
                  self.logger.error(f('[%s] failed to authenticate against server %s:%s', self.id, self.options.host, self.options.port));
                }
                return cb(error);
              }
              cb(null);
            }
          });
        }
      }
      function waitForLogout(self, cb) {
        if (!self.loggingout) return cb();
        setTimeout(function () {
          waitForLogout(self, cb);
        }, 1);
      }
      waitForLogout(self, function () {
        authenticateLiveConnections(self, args, function (err) {
          self.authenticating = false;
          callback(err);
        });
      });
    };
    Pool.prototype.logout = function (dbName, callback) {
      var self = this;
      if (typeof dbName != 'string') {
        throw new MongoError('logout method requires a db name as first argument');
      }
      if (typeof callback != 'function') {
        throw new MongoError('logout method requires a callback');
      }
      this.loggingout = true;
      var connections = self.availableConnections.concat(self.inUseConnections);
      var count = connections.length;
      var error = null;
      for (var i = 0; i < connections.length; i++) {
        write(self)(connections[i], new Query(this.options.bson, f('%s.$cmd', dbName), { logout: 1 }, {
          numberToSkip: 0,
          numberToReturn: 1
        }), function (err) {
          count = count - 1;
          if (err) error = err;
          if (count == 0) {
            self.loggingout = false;
            callback(error);
          }
        });
      }
    };
    Pool.prototype.unref = function () {
      var connections = this.availableConnections.concat(this.inUseConnections).concat(this.connectingConnections);
      connections.forEach(function (c) {
        c.unref();
      });
    };
    var events = ['error', 'close', 'timeout', 'parseError', 'connect'];
    function destroy(self, connections) {
      connections.forEach(function (c) {
        for (var i = 0; i < events.length; i++) {
          c.removeAllListeners(events[i]);
        }
        c.destroy();
      });
      self.inUseConnections = [];
      self.availableConnections = [];
      self.nonAuthenticatedConnections = [];
      self.connectingConnections = [];
      stateTransition(self, DESTROYED);
    }
    Pool.prototype.destroy = function (force) {
      var self = this;
      if (this.state == DESTROYED || self.state == DESTROYING) return;
      stateTransition(this, DESTROYING);
      if (force) {
        var connections = self.availableConnections.concat(self.inUseConnections).concat(self.nonAuthenticatedConnections).concat(self.connectingConnections);
        return destroy(self, connections);
      }
      function checkStatus() {
        if (self.queue.length == 0) {
          var connections = self.availableConnections.concat(self.inUseConnections).concat(self.nonAuthenticatedConnections).concat(self.connectingConnections);
          for (var i = 0; i < connections.length; i++) {
            if (connections[i].workItems.length > 0) {
              return setTimeout(checkStatus, 1);
            }
          }
          destroy(self, connections);
        } else {
          setTimeout(checkStatus, 1);
        }
      }
      checkStatus();
    };
    Pool.prototype.write = function (commands, options, cb) {
      var self = this;
      if (typeof options == 'function') {
        cb = options;
      }
      options = options || {};
      if (this.state == DESTROYED || this.state == DESTROYING) {
        if (cb) {
          try {
            cb(new MongoError('pool destroyed'));
          } catch (err) {
            process.nextTick(function () {
              throw err;
            });
          }
        }
        return;
      }
      if (this.options.domainsEnabled && process.domain && typeof cb === "function") {
        var oldCb = cb;
        cb = process.domain.bind(function () {
          var args = new Array(arguments.length);
          for (var i = 0; i < arguments.length; i++) {
            args[i] = arguments[i];
          }
          process.nextTick(function () {
            oldCb.apply(null, args);
          });
        });
      }
      var operation = {
        cb: cb,
        raw: false,
        promoteLongs: true,
        promoteValues: true,
        promoteBuffers: false,
        fullResult: false
      };
      var buffer = null;
      if (Array.isArray(commands)) {
        buffer = [];
        for (var i = 0; i < commands.length; i++) {
          buffer.push(commands[i].toBin());
        }
        operation.requestId = commands[commands.length - 1].requestId;
      } else {
        operation.requestId = commands.requestId;
        buffer = commands.toBin();
      }
      operation.buffer = buffer;
      operation.promoteLongs = typeof options.promoteLongs == 'boolean' ? options.promoteLongs : true;
      operation.promoteValues = typeof options.promoteValues == 'boolean' ? options.promoteValues : true;
      operation.promoteBuffers = typeof options.promoteBuffers == 'boolean' ? options.promoteBuffers : false;
      operation.raw = typeof options.raw == 'boolean' ? options.raw : false;
      operation.immediateRelease = typeof options.immediateRelease == 'boolean' ? options.immediateRelease : false;
      operation.documentsReturnedIn = options.documentsReturnedIn;
      operation.command = typeof options.command == 'boolean' ? options.command : false;
      operation.fullResult = typeof options.fullResult == 'boolean' ? options.fullResult : false;
      operation.noResponse = typeof options.noResponse == 'boolean' ? options.noResponse : false;
      operation.socketTimeout = options.socketTimeout;
      operation.monitoring = options.monitoring;
      if (options.socketTimeout) {
        operation.socketTimeout = options.socketTimeout;
      }
      if (!(typeof cb == 'function') && !options.noResponse) {
        throw new MongoError('write method must provide a callback');
      }
      if (options.monitoring) {
        this.queue.unshift(operation);
      } else {
        this.queue.push(operation);
      }
      if (!self.executing) {
        process.nextTick(function () {
          _execute(self)();
        });
      }
    };
    function remove(connection, connections) {
      for (var i = 0; i < connections.length; i++) {
        if (connections[i] === connection) {
          connections.splice(i, 1);
          return true;
        }
      }
    }
    function removeConnection(self, connection) {
      if (remove(connection, self.availableConnections)) return;
      if (remove(connection, self.inUseConnections)) return;
      if (remove(connection, self.connectingConnections)) return;
      if (remove(connection, self.nonAuthenticatedConnections)) return;
    }
    var handlers = ["close", "message", "error", "timeout", "parseError", "connect"];
    function _createConnection(self) {
      var connection = new Connection(messageHandler(self), self.options);
      self.connectingConnections.push(connection);
      var tempErrorHandler = function (_connection) {
        return function () {
          _connection.destroy();
          removeConnection(self, _connection);
          if (!self.reconnectId && self.options.reconnect) {
            self.reconnectId = setTimeout(attemptReconnect(self), self.options.reconnectInterval);
          }
        };
      };
      var tempConnectHandler = function (_connection) {
        return function () {
          if (self.state == DESTROYED || self.state == DESTROYING) {
            removeConnection(self, _connection);
            return _connection.destroy();
          }
          handlers.forEach(function (e) {
            _connection.removeAllListeners(e);
          });
          _connection.once('close', connectionFailureHandler(self, 'close'));
          _connection.once('error', connectionFailureHandler(self, 'error'));
          _connection.once('timeout', connectionFailureHandler(self, 'timeout'));
          _connection.once('parseError', connectionFailureHandler(self, 'parseError'));
          reauthenticate(self, _connection, function (err) {
            if (self.state == DESTROYED || self.state == DESTROYING) {
              return _connection.destroy();
            }
            removeConnection(self, _connection);
            if (err) {
              return _connection.destroy();
            }
            if (self.authenticating) {
              self.nonAuthenticatedConnections.push(_connection);
            } else {
              self.availableConnections.push(_connection);
              _execute(self)();
            }
          });
        };
      };
      connection.once('close', tempErrorHandler(connection));
      connection.once('error', tempErrorHandler(connection));
      connection.once('timeout', tempErrorHandler(connection));
      connection.once('parseError', tempErrorHandler(connection));
      connection.once('connect', tempConnectHandler(connection));
      connection.connect();
    }
    function flushMonitoringOperations(queue) {
      for (var i = 0; i < queue.length; i++) {
        if (queue[i].monitoring) {
          var workItem = queue[i];
          queue.splice(i, 1);
          workItem.cb(new MongoError({
            message: 'no connection available for monitoring',
            driver: true
          }));
        }
      }
    }
    function _execute(self) {
      return function () {
        if (self.state == DESTROYED) return;
        if (self.executing) return;
        self.executing = true;
        function waitForAuth(cb) {
          if (!self.authenticating) return cb();
          setTimeout(function () {
            waitForAuth(cb);
          }, 1);
        }
        waitForAuth(function () {
          while (true) {
            var totalConnections = self.availableConnections.length + self.connectingConnections.length + self.inUseConnections.length;
            if (self.availableConnections.length == 0) {
              flushMonitoringOperations(self.queue);
              break;
            }
            if (self.queue.length == 0) {
              break;
            }
            var connection = self.availableConnections[self.connectionIndex++ % self.availableConnections.length];
            if (connection.isConnected()) {
              var workItem = self.queue.shift();
              var buffer = workItem.buffer;
              workItem.authenticating = self.authenticating;
              workItem.authenticatingTimestamp = self.authenticatingTimestamp;
              if (workItem.monitoring) {
                moveConnectionBetween(connection, self.availableConnections, self.inUseConnections);
              }
              if (!workItem.noResponse) {
                connection.workItems.push(workItem);
              }
              if (!workItem.immediateRelease && typeof workItem.socketTimeout == 'number') {
                connection.setSocketTimeout(workItem.socketTimeout);
              }
              if (Array.isArray(buffer)) {
                for (var i = 0; i < buffer.length; i++) {
                  connection.write(buffer[i]);
                }
              } else {
                connection.write(buffer);
              }
              if (workItem.immediateRelease && self.authenticating) {
                self.nonAuthenticatedConnections.push(connection);
              }
              if (totalConnections < self.options.size && self.queue.length > 0) {
                _createConnection(self);
              }
            } else {
              removeConnection(self, connection);
              flushMonitoringOperations(self.queue);
            }
          }
        });
        self.executing = false;
      };
    }
    Pool._execute = _execute;
    module.exports = Pool;
  })($__require('2a').Buffer, $__require('13'));
  return module.exports;
});
$__System.registerDynamic("1c5", ["1ab", "2a"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    "use strict";

    var MongoError = $__require("1ab");
    var OP_UPDATE = 2001;
    var OP_INSERT = 2002;
    var OP_DELETE = 2006;
    var Insert = function (requestId, ismaster, bson, ns, documents, options) {
      if (ns == null) throw new MongoError("ns must be specified for query");
      if (!Array.isArray(documents) || documents.length == 0) throw new MongoError("documents array must contain at least one document to insert");
      if (!!~ns.indexOf("\x00")) {
        throw new MongoError("namespace cannot contain a null character");
      }
      this.requestId = requestId;
      this.bson = bson;
      this.ns = ns;
      this.documents = documents;
      this.ismaster = ismaster;
      options = options || {};
      this.serializeFunctions = typeof options.serializeFunctions == 'boolean' ? options.serializeFunctions : false;
      this.ignoreUndefined = typeof options.ignoreUndefined == 'boolean' ? options.ignoreUndefined : false;
      this.checkKeys = typeof options.checkKeys == 'boolean' ? options.checkKeys : true;
      this.continueOnError = typeof options.continueOnError == 'boolean' ? options.continueOnError : false;
      this.flags = this.continueOnError ? 1 : 0;
    };
    Insert.prototype.toBin = function () {
      var buffers = [];
      var header = new Buffer(4 * 4 + 4 + Buffer.byteLength(this.ns) + 1);
      buffers.push(header);
      var totalLength = header.length;
      for (var i = 0; i < this.documents.length; i++) {
        var buffer = this.bson.serialize(this.documents[i], this.checkKeys, true, this.serializeFunctions, 0, this.ignoreUndefined);
        if (buffer.length > this.ismaster.maxBsonObjectSize) {
          throw new MongoError("Document exceeds maximum allowed bson size of " + this.ismaster.maxBsonObjectSize + " bytes");
        }
        totalLength = totalLength + buffer.length;
        buffers.push(buffer);
      }
      if (totalLength > this.ismaster.maxMessageSizeBytes) {
        throw new MongoError("Command exceeds maximum message size of " + this.ismaster.maxMessageSizeBytes + " bytes");
      }
      var index = 0;
      header[index + 3] = totalLength >> 24 & 0xff;
      header[index + 2] = totalLength >> 16 & 0xff;
      header[index + 1] = totalLength >> 8 & 0xff;
      header[index] = totalLength & 0xff;
      index = index + 4;
      header[index + 3] = this.requestId >> 24 & 0xff;
      header[index + 2] = this.requestId >> 16 & 0xff;
      header[index + 1] = this.requestId >> 8 & 0xff;
      header[index] = this.requestId & 0xff;
      index = index + 4;
      header[index + 3] = 0 >> 24 & 0xff;
      header[index + 2] = 0 >> 16 & 0xff;
      header[index + 1] = 0 >> 8 & 0xff;
      header[index] = 0 & 0xff;
      index = index + 4;
      header[index + 3] = OP_INSERT >> 24 & 0xff;
      header[index + 2] = OP_INSERT >> 16 & 0xff;
      header[index + 1] = OP_INSERT >> 8 & 0xff;
      header[index] = OP_INSERT & 0xff;
      index = index + 4;
      header[index + 3] = this.flags >> 24 & 0xff;
      header[index + 2] = this.flags >> 16 & 0xff;
      header[index + 1] = this.flags >> 8 & 0xff;
      header[index] = this.flags & 0xff;
      index = index + 4;
      index = index + header.write(this.ns, index, 'utf8') + 1;
      header[index - 1] = 0;
      return buffers;
    };
    var Update = function (requestId, ismaster, bson, ns, update, options) {
      if (ns == null) throw new MongoError("ns must be specified for query");
      options = options || {};
      this.requestId = requestId;
      this.bson = bson;
      this.ns = ns;
      this.ismaster = ismaster;
      this.serializeFunctions = typeof options.serializeFunctions == 'boolean' ? options.serializeFunctions : false;
      this.ignoreUndefined = typeof options.ignoreUndefined == 'boolean' ? options.ignoreUndefined : false;
      this.checkKeys = typeof options.checkKeys == 'boolean' ? options.checkKeys : false;
      this.upsert = typeof update[0].upsert == 'boolean' ? update[0].upsert : false;
      this.multi = typeof update[0].multi == 'boolean' ? update[0].multi : false;
      this.q = update[0].q;
      this.u = update[0].u;
      this.flags = this.upsert ? 1 : 0;
      this.flags = this.multi ? this.flags | 2 : this.flags;
    };
    Update.prototype.toBin = function () {
      var buffers = [];
      var header = new Buffer(4 * 4 + 4 + Buffer.byteLength(this.ns) + 1 + 4);
      buffers.push(header);
      var totalLength = header.length;
      var selector = this.bson.serialize(this.q, this.checkKeys, true, this.serializeFunctions, 0, this.ignoreUndefined);
      buffers.push(selector);
      totalLength = totalLength + selector.length;
      var update = this.bson.serialize(this.u, this.checkKeys, true, this.serializeFunctions, 0, this.ignoreUndefined);
      buffers.push(update);
      totalLength = totalLength + update.length;
      var index = 0;
      header[index + 3] = totalLength >> 24 & 0xff;
      header[index + 2] = totalLength >> 16 & 0xff;
      header[index + 1] = totalLength >> 8 & 0xff;
      header[index] = totalLength & 0xff;
      index = index + 4;
      header[index + 3] = this.requestId >> 24 & 0xff;
      header[index + 2] = this.requestId >> 16 & 0xff;
      header[index + 1] = this.requestId >> 8 & 0xff;
      header[index] = this.requestId & 0xff;
      index = index + 4;
      header[index + 3] = 0 >> 24 & 0xff;
      header[index + 2] = 0 >> 16 & 0xff;
      header[index + 1] = 0 >> 8 & 0xff;
      header[index] = 0 & 0xff;
      index = index + 4;
      header[index + 3] = OP_UPDATE >> 24 & 0xff;
      header[index + 2] = OP_UPDATE >> 16 & 0xff;
      header[index + 1] = OP_UPDATE >> 8 & 0xff;
      header[index] = OP_UPDATE & 0xff;
      index = index + 4;
      header[index + 3] = 0 >> 24 & 0xff;
      header[index + 2] = 0 >> 16 & 0xff;
      header[index + 1] = 0 >> 8 & 0xff;
      header[index] = 0 & 0xff;
      index = index + 4;
      index = index + header.write(this.ns, index, 'utf8') + 1;
      header[index - 1] = 0;
      header[index + 3] = this.flags >> 24 & 0xff;
      header[index + 2] = this.flags >> 16 & 0xff;
      header[index + 1] = this.flags >> 8 & 0xff;
      header[index] = this.flags & 0xff;
      index = index + 4;
      return buffers;
    };
    var Remove = function (requestId, ismaster, bson, ns, remove, options) {
      if (ns == null) throw new MongoError("ns must be specified for query");
      options = options || {};
      this.requestId = requestId;
      this.bson = bson;
      this.ns = ns;
      this.ismaster = ismaster;
      this.serializeFunctions = typeof options.serializeFunctions == 'boolean' ? options.serializeFunctions : false;
      this.ignoreUndefined = typeof options.ignoreUndefined == 'boolean' ? options.ignoreUndefined : false;
      this.checkKeys = typeof options.checkKeys == 'boolean' ? options.checkKeys : false;
      this.limit = typeof remove[0].limit == 'number' ? remove[0].limit : 1;
      this.q = remove[0].q;
      this.flags = this.limit == 1 ? 1 : 0;
    };
    Remove.prototype.toBin = function () {
      var buffers = [];
      var header = new Buffer(4 * 4 + 4 + Buffer.byteLength(this.ns) + 1 + 4);
      buffers.push(header);
      var totalLength = header.length;
      var selector = this.bson.serialize(this.q, this.checkKeys, true, this.serializeFunctions, 0, this.ignoreUndefined);
      buffers.push(selector);
      totalLength = totalLength + selector.length;
      var index = 0;
      header[index + 3] = totalLength >> 24 & 0xff;
      header[index + 2] = totalLength >> 16 & 0xff;
      header[index + 1] = totalLength >> 8 & 0xff;
      header[index] = totalLength & 0xff;
      index = index + 4;
      header[index + 3] = this.requestId >> 24 & 0xff;
      header[index + 2] = this.requestId >> 16 & 0xff;
      header[index + 1] = this.requestId >> 8 & 0xff;
      header[index] = this.requestId & 0xff;
      index = index + 4;
      header[index + 3] = 0 >> 24 & 0xff;
      header[index + 2] = 0 >> 16 & 0xff;
      header[index + 1] = 0 >> 8 & 0xff;
      header[index] = 0 & 0xff;
      index = index + 4;
      header[index + 3] = OP_DELETE >> 24 & 0xff;
      header[index + 2] = OP_DELETE >> 16 & 0xff;
      header[index + 1] = OP_DELETE >> 8 & 0xff;
      header[index] = OP_DELETE & 0xff;
      index = index + 4;
      header[index + 3] = 0 >> 24 & 0xff;
      header[index + 2] = 0 >> 16 & 0xff;
      header[index + 1] = 0 >> 8 & 0xff;
      header[index] = 0 & 0xff;
      index = index + 4;
      index = index + header.write(this.ns, index, 'utf8') + 1;
      header[index - 1] = 0;
      header[index + 3] = this.flags >> 24 & 0xff;
      header[index + 2] = this.flags >> 16 & 0xff;
      header[index + 1] = this.flags >> 8 & 0xff;
      header[index] = this.flags & 0xff;
      index = index + 4;
      return buffers;
    };
    module.exports = {
      Insert: Insert,
      Update: Update,
      Remove: Remove
    };
  })($__require("2a").Buffer);
  return module.exports;
});
$__System.registerDynamic("1c4", [], true, function ($__require, exports, module) {
  /* */
  "use strict";

  /**
   * Creates a new CommandResult instance
   * @class
   * @param {object} result CommandResult object
   * @param {Connection} connection A connection instance associated with this result
   * @return {CommandResult} A cursor instance
   */

  var define,
      global = this || self,
      GLOBAL = global;
  var CommandResult = function (result, connection, message) {
    this.result = result;
    this.connection = connection;
    this.message = message;
  };

  /**
   * Convert CommandResult to JSON
   * @method
   * @return {object}
   */
  CommandResult.prototype.toJSON = function () {
    return this.result;
  };

  /**
   * Convert CommandResult to String representation
   * @method
   * @return {string}
   */
  CommandResult.prototype.toString = function () {
    return JSON.stringify(this.toJSON());
  };

  module.exports = CommandResult;
  return module.exports;
});
$__System.registerDynamic('1c6', ['1c5', '1c1', '1c2', '166', '1c4', '1ab', '1b6', '1c7', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    "use strict";

    var Insert = $__require('1c5').Insert,
        Update = $__require('1c5').Update,
        Remove = $__require('1c5').Remove,
        copy = $__require('1c1').copy,
        KillCursor = $__require('1c2').KillCursor,
        GetMore = $__require('1c2').GetMore,
        Query = $__require('1c2').Query,
        f = $__require('166').format,
        CommandResult = $__require('1c4'),
        MongoError = $__require('1ab'),
        Long = $__require('1b6').Long,
        getReadPreference = $__require('1c7').getReadPreference;
    var writeConcernFields = ['w', 'wtimeout', 'j', 'fsync'];
    var WireProtocol = function () {};
    WireProtocol.prototype.insert = function (pool, ismaster, ns, bson, ops, options, callback) {
      options = options || {};
      var ordered = typeof options.ordered == 'boolean' ? options.ordered : true;
      ops = Array.isArray(ops) ? ops : [ops];
      if (ops.length > 1000) return callback(new MongoError("exceeded maximum write batch size of 1000"));
      var writeConcern = options.writeConcern || { w: 1 };
      if (!ordered || writeConcern.w == 0) {
        return executeUnordered('insert', Insert, ismaster, ns, bson, pool, ops, options, callback);
      }
      return executeOrdered('insert', Insert, ismaster, ns, bson, pool, ops, options, callback);
    };
    WireProtocol.prototype.update = function (pool, ismaster, ns, bson, ops, options, callback) {
      options = options || {};
      var ordered = typeof options.ordered == 'boolean' ? options.ordered : true;
      ops = Array.isArray(ops) ? ops : [ops];
      var writeConcern = options.writeConcern || { w: 1 };
      if (!ordered || writeConcern.w == 0) {
        return executeUnordered('update', Update, ismaster, ns, bson, pool, ops, options, callback);
      }
      return executeOrdered('update', Update, ismaster, ns, bson, pool, ops, options, callback);
    };
    WireProtocol.prototype.remove = function (pool, ismaster, ns, bson, ops, options, callback) {
      options = options || {};
      var ordered = typeof options.ordered == 'boolean' ? options.ordered : true;
      ops = Array.isArray(ops) ? ops : [ops];
      var writeConcern = options.writeConcern || { w: 1 };
      if (!ordered || writeConcern.w == 0) {
        return executeUnordered('remove', Remove, ismaster, ns, bson, pool, ops, options, callback);
      }
      return executeOrdered('remove', Remove, ismaster, ns, bson, pool, ops, options, callback);
    };
    WireProtocol.prototype.killCursor = function (bson, ns, cursorId, pool, callback) {
      var killCursor = new KillCursor(bson, [cursorId]);
      if (pool && pool.isConnected()) {
        pool.write(killCursor, {
          immediateRelease: true,
          noResponse: true
        });
      }
      if (typeof callback == 'function') callback(null, null);
    };
    WireProtocol.prototype.getMore = function (bson, ns, cursorState, batchSize, raw, connection, options, callback) {
      var getMore = new GetMore(bson, ns, cursorState.cursorId, { numberToReturn: batchSize });
      var queryCallback = function (err, result) {
        if (err) return callback(err);
        var r = result.message;
        if ((r.responseFlags & 1 << 0) != 0) {
          return callback(new MongoError("cursor does not exist, was killed or timed out"), null);
        }
        var cursorId = typeof r.cursorId == 'number' ? Long.fromNumber(r.cursorId) : r.cursorId;
        cursorState.documents = r.documents;
        cursorState.cursorId = cursorId;
        callback(null, null, r.connection);
      };
      if (raw) {
        queryCallback.raw = raw;
      }
      if (typeof cursorState.promoteLongs == 'boolean') {
        queryCallback.promoteLongs = cursorState.promoteLongs;
      }
      if (typeof cursorState.promoteValues == 'boolean') {
        queryCallback.promoteValues = cursorState.promoteValues;
      }
      if (typeof cursorState.promoteBuffers == 'boolean') {
        queryCallback.promoteBuffers = cursorState.promoteBuffers;
      }
      connection.write(getMore, queryCallback);
    };
    WireProtocol.prototype.command = function (bson, ns, cmd, cursorState, topology, options) {
      if (cmd.find) {
        return setupClassicFind(bson, ns, cmd, cursorState, topology, options);
      } else if (cursorState.cursorId != null) {
        return;
      } else if (cmd) {
        return setupCommand(bson, ns, cmd, cursorState, topology, options);
      } else {
        throw new MongoError(f("command %s does not return a cursor", JSON.stringify(cmd)));
      }
    };
    var setupClassicFind = function (bson, ns, cmd, cursorState, topology, options) {
      options = options || {};
      var readPreference = getReadPreference(cmd, options);
      cursorState.batchSize = cmd.batchSize || cursorState.batchSize;
      var numberToReturn = 0;
      if (cursorState.limit == 0) {
        numberToReturn = cursorState.batchSize;
      } else if (cursorState.limit < 0 || cursorState.limit < cursorState.batchSize || cursorState.limit > 0 && cursorState.batchSize == 0) {
        numberToReturn = cursorState.limit;
      } else {
        numberToReturn = cursorState.batchSize;
      }
      var numberToSkip = cursorState.skip || 0;
      var findCmd = {};
      var usesSpecialModifier = false;
      if (topology.type == 'mongos' && readPreference) {
        findCmd['$readPreference'] = readPreference.toJSON();
        usesSpecialModifier = true;
      }
      if (cmd.sort) findCmd['orderby'] = cmd.sort, usesSpecialModifier = true;
      if (cmd.hint) findCmd['$hint'] = cmd.hint, usesSpecialModifier = true;
      if (cmd.snapshot) findCmd['$snapshot'] = cmd.snapshot, usesSpecialModifier = true;
      if (cmd.returnKey) findCmd['$returnKey'] = cmd.returnKey, usesSpecialModifier = true;
      if (cmd.maxScan) findCmd['$maxScan'] = cmd.maxScan, usesSpecialModifier = true;
      if (cmd.min) findCmd['$min'] = cmd.min, usesSpecialModifier = true;
      if (cmd.max) findCmd['$max'] = cmd.max, usesSpecialModifier = true;
      if (cmd.showDiskLoc) findCmd['$showDiskLoc'] = cmd.showDiskLoc, usesSpecialModifier = true;
      if (cmd.comment) findCmd['$comment'] = cmd.comment, usesSpecialModifier = true;
      if (cmd.maxTimeMS) findCmd['$maxTimeMS'] = cmd.maxTimeMS, usesSpecialModifier = true;
      if (cmd.explain) {
        numberToReturn = -Math.abs(cmd.limit || 0);
        usesSpecialModifier = true;
        findCmd['$explain'] = true;
      }
      if (usesSpecialModifier) {
        findCmd['$query'] = cmd.query;
      } else {
        findCmd = cmd.query;
      }
      if (cmd.readConcern && cmd.readConcern.level != 'local') {
        throw new MongoError(f('server find command does not support a readConcern level of %s', cmd.readConcern.level));
      }
      if (cmd.readConcern) {
        cmd = copy(cmd);
        delete cmd['readConcern'];
      }
      var serializeFunctions = typeof options.serializeFunctions == 'boolean' ? options.serializeFunctions : false;
      var ignoreUndefined = typeof options.ignoreUndefined == 'boolean' ? options.ignoreUndefined : false;
      var query = new Query(bson, ns, findCmd, {
        numberToSkip: numberToSkip,
        numberToReturn: numberToReturn,
        checkKeys: false,
        returnFieldSelector: cmd.fields,
        serializeFunctions: serializeFunctions,
        ignoreUndefined: ignoreUndefined
      });
      query.slaveOk = readPreference.slaveOk();
      if (typeof cmd.tailable == 'boolean') query.tailable = cmd.tailable;
      if (typeof cmd.oplogReplay == 'boolean') query.oplogReplay = cmd.oplogReplay;
      if (typeof cmd.noCursorTimeout == 'boolean') query.noCursorTimeout = cmd.noCursorTimeout;
      if (typeof cmd.awaitData == 'boolean') query.awaitData = cmd.awaitData;
      if (typeof cmd.partial == 'boolean') query.partial = cmd.partial;
      return query;
    };
    var setupCommand = function (bson, ns, cmd, cursorState, topology, options) {
      options = options || {};
      var readPreference = getReadPreference(cmd, options);
      var finalCmd = {};
      for (var name in cmd) {
        finalCmd[name] = cmd[name];
      }
      var parts = ns.split(/\./);
      if (cmd.readConcern && cmd.readConcern.level != 'local') {
        throw new MongoError(f('server %s command does not support a readConcern level of %s', JSON.stringify(cmd), cmd.readConcern.level));
      }
      if (cmd.readConcern) delete cmd['readConcern'];
      var serializeFunctions = typeof options.serializeFunctions == 'boolean' ? options.serializeFunctions : false;
      var ignoreUndefined = typeof options.ignoreUndefined == 'boolean' ? options.ignoreUndefined : false;
      if (topology.type == 'mongos' && readPreference && readPreference.preference != 'primary') {
        finalCmd = {
          '$query': finalCmd,
          '$readPreference': readPreference.toJSON()
        };
      }
      var query = new Query(bson, f('%s.$cmd', parts.shift()), finalCmd, {
        numberToSkip: 0,
        numberToReturn: -1,
        checkKeys: false,
        serializeFunctions: serializeFunctions,
        ignoreUndefined: ignoreUndefined
      });
      query.slaveOk = readPreference.slaveOk();
      return query;
    };
    var hasWriteConcern = function (writeConcern) {
      if (writeConcern.w || writeConcern.wtimeout || writeConcern.j == true || writeConcern.fsync == true || Object.keys(writeConcern).length == 0) {
        return true;
      }
      return false;
    };
    var cloneWriteConcern = function (writeConcern) {
      var wc = {};
      if (writeConcern.w != null) wc.w = writeConcern.w;
      if (writeConcern.wtimeout != null) wc.wtimeout = writeConcern.wtimeout;
      if (writeConcern.j != null) wc.j = writeConcern.j;
      if (writeConcern.fsync != null) wc.fsync = writeConcern.fsync;
      return wc;
    };
    var aggregateWriteOperationResults = function (opType, ops, results, connection) {
      var finalResult = {
        ok: 1,
        n: 0
      };
      if (opType == 'update') {
        finalResult.nModified = 0;
      }
      for (var i = 0; i < results.length; i++) {
        var result = results[i];
        var op = ops[i];
        if ((result.upserted || result.updatedExisting == false) && finalResult.upserted == null) {
          finalResult.upserted = [];
        }
        if (result.upserted) {
          finalResult.upserted.push({
            index: i,
            _id: result.upserted
          });
        }
        if (result.updatedExisting == false && result.n == 1 && result.upserted == null) {
          finalResult.upserted.push({
            index: i,
            _id: op.q._id
          });
        } else if (result.updatedExisting == true) {
          finalResult.nModified += result.n;
        }
        if (result.ok == 1 && opType == 'insert' && result.err == null) {
          finalResult.n = finalResult.n + 1;
        }
        if (result != null && result.ok == 0 || result.err || result.errmsg) {
          if (result.ok == 0) finalResult.ok = 0;
          finalResult.code = result.code;
          finalResult.errmsg = result.errmsg || result.err || result.errMsg;
          if (result.code == 11000 || result.code == 11001 || result.code == 12582 || result.code == 16544 || result.code == 16538 || result.code == 16542 || result.code == 14 || result.code == 13511) {
            if (finalResult.writeErrors == null) finalResult.writeErrors = [];
            finalResult.writeErrors.push({
              index: i,
              code: result.code,
              errmsg: result.errmsg || result.err || result.errMsg
            });
          } else {
            finalResult.writeConcernError = {
              code: result.code,
              errmsg: result.errmsg || result.err || result.errMsg
            };
          }
        } else if (typeof result.n == 'number') {
          finalResult.n += result.n;
        } else {
          finalResult.n += 1;
        }
        if (result != null && result.lastOp) finalResult.lastOp = result.lastOp;
      }
      return new CommandResult(finalResult, connection);
    };
    var executeOrdered = function (opType, command, ismaster, ns, bson, pool, ops, options, callback) {
      var _ops = ops.slice(0);
      var getLastErrors = [];
      var executeOp = function (list, _callback) {
        if (list.length == 0) {
          return process.nextTick(function () {
            _callback(null, aggregateWriteOperationResults(opType, ops, getLastErrors, null));
          });
        }
        var doc = list.shift();
        var op = new command(Query.getRequestId(), ismaster, bson, ns, [doc], options);
        var optionWriteConcern = options.writeConcern || { w: 1 };
        var writeConcern = cloneWriteConcern(optionWriteConcern);
        var db = ns.split('.').shift();
        try {
          var commands = [op];
          var getLastErrorCmd = { getlasterror: 1 };
          for (var i = 0; i < writeConcernFields.length; i++) {
            if (writeConcern[writeConcernFields[i]] != null) {
              getLastErrorCmd[writeConcernFields[i]] = writeConcern[writeConcernFields[i]];
            }
          }
          var getLastErrorOp = new Query(bson, f("%s.$cmd", db), getLastErrorCmd, { numberToReturn: -1 });
          commands.push(getLastErrorOp);
          var getLastErrorCallback = function (err, result) {
            if (err) return callback(err);
            var doc = result.result;
            getLastErrors.push(doc);
            if (doc.ok == 0 || doc.err || doc.errmsg) {
              return callback(null, aggregateWriteOperationResults(opType, ops, getLastErrors, result.connection));
            }
            executeOp(list, callback);
          };
          pool.write(commands, getLastErrorCallback);
        } catch (err) {
          getLastErrors.push({
            ok: 1,
            errmsg: typeof err == 'string' ? err : err.message,
            code: 14
          });
          process.nextTick(function () {
            _callback(null, aggregateWriteOperationResults(opType, ops, getLastErrors, null));
          });
        }
      };
      executeOp(_ops, callback);
    };
    var executeUnordered = function (opType, command, ismaster, ns, bson, pool, ops, options, callback) {
      var totalOps = ops.length;
      var getLastErrors = [];
      var optionWriteConcern = options.writeConcern || { w: 1 };
      var writeConcern = cloneWriteConcern(optionWriteConcern);
      var error;
      for (var i = 0; i < ops.length; i++) {
        var op = new command(Query.getRequestId(), ismaster, bson, ns, [ops[i]], options);
        var db = ns.split('.').shift();
        try {
          var commands = [op];
          if (hasWriteConcern(writeConcern)) {
            var getLastErrorCmd = { getlasterror: 1 };
            for (var j = 0; j < writeConcernFields.length; j++) {
              if (writeConcern[writeConcernFields[j]] != null) getLastErrorCmd[writeConcernFields[j]] = writeConcern[writeConcernFields[j]];
            }
            var getLastErrorOp = new Query(bson, f("%s.$cmd", db), getLastErrorCmd, { numberToReturn: -1 });
            commands.push(getLastErrorOp);
            var callbackOp = function (_index) {
              return function (err, result) {
                if (err) error = err;
                totalOps = totalOps - 1;
                if (!err) getLastErrors[_index] = result.result;
                if (totalOps == 0) {
                  process.nextTick(function () {
                    if (error) return callback(error);
                    callback(null, aggregateWriteOperationResults(opType, ops, getLastErrors, result.connection));
                  });
                }
              };
            };
            pool.write(commands, callbackOp(i));
          } else {
            pool.write(commands, {
              immediateRelease: true,
              noResponse: true
            });
          }
        } catch (err) {
          totalOps = totalOps - 1;
          getLastErrors[i] = {
            ok: 1,
            errmsg: typeof err == 'string' ? err : err.message,
            code: 14
          };
          if (totalOps == 0) {
            callback(null, aggregateWriteOperationResults(opType, ops, getLastErrors, null));
          }
        }
      }
      if (writeConcern && writeConcern.w == 0 && callback) {
        callback(null, new CommandResult({ ok: 1 }, null));
      }
    };
    module.exports = WireProtocol;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('1c1', ['166', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    "use strict";

    var f = $__require('166').format;
    var setProperty = function (obj, prop, flag, values) {
      Object.defineProperty(obj, prop.name, {
        enumerable: true,
        set: function (value) {
          if (typeof value != 'boolean') throw new Error(f("%s required a boolean", prop.name));
          if (value == true) values.flags |= flag;
          if (value == false && (values.flags & flag) == flag) values.flags ^= flag;
          prop.value = value;
        },
        get: function () {
          return prop.value;
        }
      });
    };
    var getProperty = function (obj, propName, fieldName, values, func) {
      Object.defineProperty(obj, propName, {
        enumerable: true,
        get: function () {
          if (values[fieldName] == null && obj.isParsed && !obj.isParsed()) {
            obj.parse();
          }
          if (typeof func == 'function') return func(values[fieldName]);
          return values[fieldName];
        }
      });
    };
    var getSingleProperty = function (obj, name, value) {
      Object.defineProperty(obj, name, {
        enumerable: true,
        get: function () {
          return value;
        }
      });
    };
    var copy = function (fObj, tObj) {
      tObj = tObj || {};
      for (var name in fObj) tObj[name] = fObj[name];
      return tObj;
    };
    var debugOptions = function (debugFields, options) {
      var finaloptions = {};
      debugFields.forEach(function (n) {
        finaloptions[n] = options[n];
      });
      return finaloptions;
    };
    exports.setProperty = setProperty;
    exports.getProperty = getProperty;
    exports.getSingleProperty = getSingleProperty;
    exports.copy = copy;
    exports.debugOptions = debugOptions;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('1c8', ['1c1', '1c2', '166', '1ab', '1b6', '1c7'], true, function ($__require, exports, module) {
  /* */
  "use strict";

  var define,
      global = this || self,
      GLOBAL = global;
  var copy = $__require('1c1').copy,
      KillCursor = $__require('1c2').KillCursor,
      GetMore = $__require('1c2').GetMore,
      Query = $__require('1c2').Query,
      f = $__require('166').format,
      MongoError = $__require('1ab'),
      Long = $__require('1b6').Long,
      getReadPreference = $__require('1c7').getReadPreference;
  var WireProtocol = function () {};
  var executeWrite = function (pool, bson, type, opsField, ns, ops, options, callback) {
    if (ops.length == 0) throw new MongoError("insert must contain at least one document");
    if (typeof options == 'function') {
      callback = options;
      options = {};
      options = options || {};
    }
    var p = ns.split(".");
    var d = p.shift();
    var ordered = typeof options.ordered == 'boolean' ? options.ordered : true;
    var writeConcern = options.writeConcern;
    var writeCommand = {};
    writeCommand[type] = p.join('.');
    writeCommand[opsField] = ops;
    writeCommand.ordered = ordered;
    if (writeConcern && Object.keys(writeConcern).length > 0) {
      writeCommand.writeConcern = writeConcern;
    }
    if (typeof options.bypassDocumentValidation == 'boolean') {
      writeCommand.bypassDocumentValidation = options.bypassDocumentValidation;
    }
    var opts = { command: true };
    var queryOptions = {
      checkKeys: false,
      numberToSkip: 0,
      numberToReturn: 1
    };
    if (type == 'insert') queryOptions.checkKeys = true;
    if (options.serializeFunctions) queryOptions.serializeFunctions = options.serializeFunctions;
    if (options.ignoreUndefined) queryOptions.ignoreUndefined = options.ignoreUndefined;
    try {
      var cmd = new Query(bson, f("%s.$cmd", d), writeCommand, queryOptions);
      pool.write(cmd, opts, callback);
    } catch (err) {
      callback(err);
    }
  };
  WireProtocol.prototype.insert = function (pool, ismaster, ns, bson, ops, options, callback) {
    executeWrite(pool, bson, 'insert', 'documents', ns, ops, options, callback);
  };
  WireProtocol.prototype.update = function (pool, ismaster, ns, bson, ops, options, callback) {
    executeWrite(pool, bson, 'update', 'updates', ns, ops, options, callback);
  };
  WireProtocol.prototype.remove = function (pool, ismaster, ns, bson, ops, options, callback) {
    executeWrite(pool, bson, 'delete', 'deletes', ns, ops, options, callback);
  };
  WireProtocol.prototype.killCursor = function (bson, ns, cursorId, pool, callback) {
    var killCursor = new KillCursor(bson, [cursorId]);
    if (pool && pool.isConnected()) {
      pool.write(killCursor, {
        immediateRelease: true,
        noResponse: true
      });
    }
    if (typeof callback == 'function') callback(null, null);
  };
  WireProtocol.prototype.getMore = function (bson, ns, cursorState, batchSize, raw, connection, options, callback) {
    var getMore = new GetMore(bson, ns, cursorState.cursorId, { numberToReturn: batchSize });
    var queryCallback = function (err, result) {
      if (err) return callback(err);
      var r = result.message;
      if ((r.responseFlags & 1 << 0) != 0) {
        return callback(new MongoError("cursor does not exist, was killed or timed out"), null);
      }
      var cursorId = typeof r.cursorId == 'number' ? Long.fromNumber(r.cursorId) : r.cursorId;
      cursorState.documents = r.documents;
      cursorState.cursorId = cursorId;
      callback(null, null, r.connection);
    };
    if (raw) {
      queryCallback.raw = raw;
    }
    if (typeof cursorState.promoteLongs == 'boolean') {
      queryCallback.promoteLongs = cursorState.promoteLongs;
    }
    if (typeof cursorState.promoteValues == 'boolean') {
      queryCallback.promoteValues = cursorState.promoteValues;
    }
    if (typeof cursorState.promoteBuffers == 'boolean') {
      queryCallback.promoteBuffers = cursorState.promoteBuffers;
    }
    connection.write(getMore, queryCallback);
  };
  WireProtocol.prototype.command = function (bson, ns, cmd, cursorState, topology, options) {
    if (cmd.find) {
      return setupClassicFind(bson, ns, cmd, cursorState, topology, options);
    } else if (cursorState.cursorId != null) {
      return;
    } else if (cmd) {
      return setupCommand(bson, ns, cmd, cursorState, topology, options);
    } else {
      throw new MongoError(f("command %s does not return a cursor", JSON.stringify(cmd)));
    }
  };
  var setupClassicFind = function (bson, ns, cmd, cursorState, topology, options) {
    options = options || {};
    var readPreference = getReadPreference(cmd, options);
    cursorState.batchSize = cmd.batchSize || cursorState.batchSize;
    var numberToReturn = 0;
    if (cursorState.limit == 0) {
      numberToReturn = cursorState.batchSize;
    } else if (cursorState.limit < 0 || cursorState.limit < cursorState.batchSize || cursorState.limit > 0 && cursorState.batchSize == 0) {
      numberToReturn = cursorState.limit;
    } else {
      numberToReturn = cursorState.batchSize;
    }
    var numberToSkip = cursorState.skip || 0;
    var findCmd = {};
    var usesSpecialModifier = false;
    if (topology.type == 'mongos' && readPreference) {
      findCmd['$readPreference'] = readPreference.toJSON();
      usesSpecialModifier = true;
    }
    if (cmd.sort) findCmd['orderby'] = cmd.sort, usesSpecialModifier = true;
    if (cmd.hint) findCmd['$hint'] = cmd.hint, usesSpecialModifier = true;
    if (cmd.snapshot) findCmd['$snapshot'] = cmd.snapshot, usesSpecialModifier = true;
    if (cmd.returnKey) findCmd['$returnKey'] = cmd.returnKey, usesSpecialModifier = true;
    if (cmd.maxScan) findCmd['$maxScan'] = cmd.maxScan, usesSpecialModifier = true;
    if (cmd.min) findCmd['$min'] = cmd.min, usesSpecialModifier = true;
    if (cmd.max) findCmd['$max'] = cmd.max, usesSpecialModifier = true;
    if (cmd.showDiskLoc) findCmd['$showDiskLoc'] = cmd.showDiskLoc, usesSpecialModifier = true;
    if (cmd.comment) findCmd['$comment'] = cmd.comment, usesSpecialModifier = true;
    if (cmd.maxTimeMS) findCmd['$maxTimeMS'] = cmd.maxTimeMS, usesSpecialModifier = true;
    if (cmd.explain) {
      numberToReturn = -Math.abs(cmd.limit || 0);
      usesSpecialModifier = true;
      findCmd['$explain'] = true;
    }
    if (usesSpecialModifier) {
      findCmd['$query'] = cmd.query;
    } else {
      findCmd = cmd.query;
    }
    if (cmd.readConcern && cmd.readConcern.level != 'local') {
      throw new MongoError(f('server find command does not support a readConcern level of %s', cmd.readConcern.level));
    }
    if (cmd.readConcern) {
      cmd = copy(cmd);
      delete cmd['readConcern'];
    }
    var serializeFunctions = typeof options.serializeFunctions == 'boolean' ? options.serializeFunctions : false;
    var ignoreUndefined = typeof options.ignoreUndefined == 'boolean' ? options.ignoreUndefined : false;
    var query = new Query(bson, ns, findCmd, {
      numberToSkip: numberToSkip,
      numberToReturn: numberToReturn,
      checkKeys: false,
      returnFieldSelector: cmd.fields,
      serializeFunctions: serializeFunctions,
      ignoreUndefined: ignoreUndefined
    });
    query.slaveOk = readPreference.slaveOk();
    if (typeof cmd.tailable == 'boolean') {
      query.tailable = cmd.tailable;
    }
    if (typeof cmd.oplogReplay == 'boolean') {
      query.oplogReplay = cmd.oplogReplay;
    }
    if (typeof cmd.noCursorTimeout == 'boolean') {
      query.noCursorTimeout = cmd.noCursorTimeout;
    }
    if (typeof cmd.awaitData == 'boolean') {
      query.awaitData = cmd.awaitData;
    }
    if (typeof cmd.partial == 'boolean') {
      query.partial = cmd.partial;
    }
    return query;
  };
  var setupCommand = function (bson, ns, cmd, cursorState, topology, options) {
    options = options || {};
    var readPreference = getReadPreference(cmd, options);
    var finalCmd = {};
    for (var name in cmd) {
      finalCmd[name] = cmd[name];
    }
    var parts = ns.split(/\./);
    var serializeFunctions = typeof options.serializeFunctions == 'boolean' ? options.serializeFunctions : false;
    var ignoreUndefined = typeof options.ignoreUndefined == 'boolean' ? options.ignoreUndefined : false;
    if (cmd.readConcern && cmd.readConcern.level != 'local') {
      throw new MongoError(f('server %s command does not support a readConcern level of %s', JSON.stringify(cmd), cmd.readConcern.level));
    }
    if (cmd.readConcern) delete cmd['readConcern'];
    if (topology.type == 'mongos' && readPreference && readPreference.preference != 'primary') {
      finalCmd = {
        '$query': finalCmd,
        '$readPreference': readPreference.toJSON()
      };
    }
    var query = new Query(bson, f('%s.$cmd', parts.shift()), finalCmd, {
      numberToSkip: 0,
      numberToReturn: -1,
      checkKeys: false,
      serializeFunctions: serializeFunctions,
      ignoreUndefined: ignoreUndefined
    });
    query.slaveOk = readPreference.slaveOk();
    return query;
  };
  module.exports = WireProtocol;
  return module.exports;
});
$__System.registerDynamic('1c7', ['1aa', '1ab'], true, function ($__require, exports, module) {
  /* */
  "use strict";

  var define,
      global = this || self,
      GLOBAL = global;
  var ReadPreference = $__require('1aa'),
      MongoError = $__require('1ab');
  var getReadPreference = function (cmd, options) {
    var readPreference = cmd.readPreference || new ReadPreference('primary');
    if (options.readPreference) {
      readPreference = options.readPreference;
    }
    if (typeof readPreference == 'string') {
      readPreference = new ReadPreference(readPreference);
    }
    if (!(readPreference instanceof ReadPreference)) {
      throw new MongoError('readPreference must be a ReadPreference instance');
    }
    return readPreference;
  };
  module.exports = { getReadPreference: getReadPreference };
  return module.exports;
});
$__System.registerDynamic('1c9', ['1c2', '166', '1ab', '1b6', '1c7'], true, function ($__require, exports, module) {
  /* */
  "use strict";

  var define,
      global = this || self,
      GLOBAL = global;
  var Query = $__require('1c2').Query,
      f = $__require('166').format,
      MongoError = $__require('1ab'),
      Long = $__require('1b6').Long,
      getReadPreference = $__require('1c7').getReadPreference;
  var WireProtocol = function (legacyWireProtocol) {
    this.legacyWireProtocol = legacyWireProtocol;
  };
  var executeWrite = function (pool, bson, type, opsField, ns, ops, options, callback) {
    if (ops.length == 0) throw new MongoError("insert must contain at least one document");
    if (typeof options == 'function') {
      callback = options;
      options = {};
      options = options || {};
    }
    var p = ns.split(".");
    var d = p.shift();
    var ordered = typeof options.ordered == 'boolean' ? options.ordered : true;
    var writeConcern = options.writeConcern;
    var writeCommand = {};
    writeCommand[type] = p.join('.');
    writeCommand[opsField] = ops;
    writeCommand.ordered = ordered;
    if (writeConcern && Object.keys(writeConcern).length > 0) {
      writeCommand.writeConcern = writeConcern;
    }
    if (options.collation) {
      for (var i = 0; i < writeCommand[opsField].length; i++) {
        if (!writeCommand[opsField][i].collation) {
          writeCommand[opsField][i].collation = options.collation;
        }
      }
    }
    if (typeof options.bypassDocumentValidation == 'boolean') {
      writeCommand.bypassDocumentValidation = options.bypassDocumentValidation;
    }
    var opts = { command: true };
    var queryOptions = {
      checkKeys: false,
      numberToSkip: 0,
      numberToReturn: 1
    };
    if (type == 'insert') queryOptions.checkKeys = true;
    if (options.serializeFunctions) queryOptions.serializeFunctions = options.serializeFunctions;
    if (options.ignoreUndefined) queryOptions.ignoreUndefined = options.ignoreUndefined;
    try {
      var cmd = new Query(bson, f("%s.$cmd", d), writeCommand, queryOptions);
      pool.write(cmd, opts, callback);
    } catch (err) {
      callback(err);
    }
  };
  WireProtocol.prototype.insert = function (pool, ismaster, ns, bson, ops, options, callback) {
    executeWrite(pool, bson, 'insert', 'documents', ns, ops, options, callback);
  };
  WireProtocol.prototype.update = function (pool, ismaster, ns, bson, ops, options, callback) {
    executeWrite(pool, bson, 'update', 'updates', ns, ops, options, callback);
  };
  WireProtocol.prototype.remove = function (pool, ismaster, ns, bson, ops, options, callback) {
    executeWrite(pool, bson, 'delete', 'deletes', ns, ops, options, callback);
  };
  WireProtocol.prototype.killCursor = function (bson, ns, cursorId, pool, callback) {
    var parts = ns.split(/\./);
    var commandns = f('%s.$cmd', parts.shift());
    var killcursorCmd = {
      killCursors: parts.join('.'),
      cursors: [cursorId]
    };
    var query = new Query(bson, commandns, killcursorCmd, {
      numberToSkip: 0,
      numberToReturn: -1,
      checkKeys: false,
      returnFieldSelector: null
    });
    query.slaveOk = true;
    var killCursorCallback = function (err, result) {
      if (err) {
        if (typeof callback != 'function') return;
        return callback(err);
      }
      var r = result.message;
      if ((r.responseFlags & 1 << 0) != 0) {
        if (typeof callback != 'function') return;
        return callback(new MongoError("cursor killed or timed out"), null);
      }
      if (!Array.isArray(r.documents) || r.documents.length == 0) {
        if (typeof callback != 'function') return;
        return callback(new MongoError(f('invalid killCursors result returned for cursor id %s', cursorId)));
      }
      if (typeof callback == 'function') {
        callback(null, r.documents[0]);
      }
    };
    if (pool && pool.isConnected()) {
      pool.write(query, { command: true }, killCursorCallback);
    }
  };
  WireProtocol.prototype.getMore = function (bson, ns, cursorState, batchSize, raw, connection, options, callback) {
    options = options || {};
    var parts = ns.split(/\./);
    var commandns = f('%s.$cmd', parts.shift());
    var getMoreCmd = {
      getMore: cursorState.cursorId,
      collection: parts.join('.'),
      batchSize: Math.abs(batchSize)
    };
    if (cursorState.cmd.tailable && typeof cursorState.cmd.maxAwaitTimeMS == 'number') {
      getMoreCmd.maxTimeMS = cursorState.cmd.maxAwaitTimeMS;
    }
    var query = new Query(bson, commandns, getMoreCmd, {
      numberToSkip: 0,
      numberToReturn: -1,
      checkKeys: false,
      returnFieldSelector: null
    });
    query.slaveOk = true;
    var queryCallback = function (err, result) {
      if (err) return callback(err);
      var r = result.message;
      if ((r.responseFlags & 1 << 0) != 0) {
        return callback(new MongoError("cursor killed or timed out"), null);
      }
      if (raw) {
        cursorState.documents = r.documents;
        cursorState.cursorId = r.cursorId;
        return callback(null, r.documents);
      }
      if (r.documents[0].ok == 0) {
        return callback(MongoError.create(r.documents[0]));
      }
      var cursorId = typeof r.documents[0].cursor.id == 'number' ? Long.fromNumber(r.documents[0].cursor.id) : r.documents[0].cursor.id;
      cursorState.documents = r.documents[0].cursor.nextBatch;
      cursorState.cursorId = cursorId;
      callback(null, r.documents[0], r.connection);
    };
    var queryOptions = { command: true };
    if (raw) {
      queryOptions.raw = raw;
    }
    queryOptions.documentsReturnedIn = 'nextBatch';
    if (typeof cursorState.promoteLongs == 'boolean') {
      queryOptions.promoteLongs = cursorState.promoteLongs;
    }
    if (typeof cursorState.promoteValues == 'boolean') {
      queryCallback.promoteValues = cursorState.promoteValues;
    }
    if (typeof cursorState.promoteBuffers == 'boolean') {
      queryCallback.promoteBuffers = cursorState.promoteBuffers;
    }
    connection.write(query, queryOptions, queryCallback);
  };
  WireProtocol.prototype.command = function (bson, ns, cmd, cursorState, topology, options) {
    if (cmd.find) {
      var query = executeFindCommand(bson, ns, cmd, cursorState, topology, options);
      cmd.virtual = false;
      query.documentsReturnedIn = 'firstBatch';
      return query;
    } else if (cursorState.cursorId != null) {
      return;
    } else if (cmd) {
      return setupCommand(bson, ns, cmd, cursorState, topology, options);
    } else {
      throw new MongoError(f("command %s does not return a cursor", JSON.stringify(cmd)));
    }
  };
  var executeFindCommand = function (bson, ns, cmd, cursorState, topology, options) {
    options = options || {};
    var readPreference = getReadPreference(cmd, options);
    cursorState.batchSize = cmd.batchSize || cursorState.batchSize;
    var parts = ns.split(/\./);
    var commandns = f('%s.$cmd', parts.shift());
    var findCmd = { find: parts.join('.') };
    if (cmd.query) {
      if (cmd.query['$query']) {
        findCmd.filter = cmd.query['$query'];
      } else {
        findCmd.filter = cmd.query;
      }
    }
    var sortValue = cmd.sort;
    if (Array.isArray(sortValue)) {
      var sortObject = {};
      if (sortValue.length > 0 && !Array.isArray(sortValue[0])) {
        var sortDirection = sortValue[1];
        if (sortDirection == 'asc') {
          sortDirection = 1;
        } else if (sortDirection == 'desc') {
          sortDirection = -1;
        }
        sortObject[sortValue[0]] = sortDirection;
      } else {
        for (var i = 0; i < sortValue.length; i++) {
          sortDirection = sortValue[i][1];
          if (sortDirection == 'asc') {
            sortDirection = 1;
          } else if (sortDirection == 'desc') {
            sortDirection = -1;
          }
          sortObject[sortValue[i][0]] = sortDirection;
        }
      }
      sortValue = sortObject;
    }
    if (cmd.sort) findCmd.sort = sortValue;
    if (cmd.fields) findCmd.projection = cmd.fields;
    if (cmd.hint) findCmd.hint = cmd.hint;
    if (cmd.skip) findCmd.skip = cmd.skip;
    if (cmd.limit) findCmd.limit = cmd.limit;
    if (typeof cmd.batchSize == 'number') findCmd.batchSize = Math.abs(cmd.batchSize);
    if (cmd.limit < 0) {
      findCmd.limit = Math.abs(cmd.limit);
      findCmd.singleBatch = true;
    }
    if (cmd.comment) findCmd.comment = cmd.comment;
    if (cmd.maxScan) findCmd.maxScan = cmd.maxScan;
    if (cmd.maxTimeMS) findCmd.maxTimeMS = cmd.maxTimeMS;
    if (cmd.min) findCmd.min = cmd.min;
    if (cmd.max) findCmd.max = cmd.max;
    if (cmd.returnKey) findCmd.returnKey = cmd.returnKey;
    if (cmd.showDiskLoc) findCmd.showRecordId = cmd.showDiskLoc;
    if (cmd.snapshot) findCmd.snapshot = cmd.snapshot;
    if (cmd.tailable) findCmd.tailable = cmd.tailable;
    if (cmd.oplogReplay) findCmd.oplogReplay = cmd.oplogReplay;
    if (cmd.noCursorTimeout) findCmd.noCursorTimeout = cmd.noCursorTimeout;
    if (cmd.awaitData) findCmd.awaitData = cmd.awaitData;
    if (cmd.awaitdata) findCmd.awaitData = cmd.awaitdata;
    if (cmd.partial) findCmd.partial = cmd.partial;
    if (cmd.collation) findCmd.collation = cmd.collation;
    if (cmd.explain) {
      findCmd = { explain: findCmd };
    }
    if (cmd.readConcern) findCmd.readConcern = cmd.readConcern;
    var serializeFunctions = typeof options.serializeFunctions == 'boolean' ? options.serializeFunctions : false;
    var ignoreUndefined = typeof options.ignoreUndefined == 'boolean' ? options.ignoreUndefined : false;
    if (topology.type == 'mongos' && readPreference && readPreference.preference != 'primary') {
      findCmd = {
        '$query': findCmd,
        '$readPreference': readPreference.toJSON()
      };
    }
    var query = new Query(bson, commandns, findCmd, {
      numberToSkip: 0,
      numberToReturn: 1,
      checkKeys: false,
      returnFieldSelector: null,
      serializeFunctions: serializeFunctions,
      ignoreUndefined: ignoreUndefined
    });
    query.slaveOk = readPreference.slaveOk();
    return query;
  };
  var setupCommand = function (bson, ns, cmd, cursorState, topology, options) {
    options = options || {};
    var readPreference = getReadPreference(cmd, options);
    var finalCmd = {};
    for (var name in cmd) {
      finalCmd[name] = cmd[name];
    }
    var parts = ns.split(/\./);
    var serializeFunctions = typeof options.serializeFunctions == 'boolean' ? options.serializeFunctions : false;
    var ignoreUndefined = typeof options.ignoreUndefined == 'boolean' ? options.ignoreUndefined : false;
    if (topology.type == 'mongos' && readPreference && readPreference.preference != 'primary') {
      finalCmd = {
        '$query': finalCmd,
        '$readPreference': readPreference.toJSON()
      };
    }
    var query = new Query(bson, f('%s.$cmd', parts.shift()), finalCmd, {
      numberToSkip: 0,
      numberToReturn: -1,
      checkKeys: false,
      serializeFunctions: serializeFunctions,
      ignoreUndefined: ignoreUndefined
    });
    query.slaveOk = readPreference.slaveOk();
    return query;
  };
  module.exports = WireProtocol;
  return module.exports;
});
$__System.registerDynamic('1ae', ['166', '55', '1b6', '1aa', '1a9', '1c1', '1c3', '1c2', '1ab', '1c6', '1c8', '1c9', '1ad', '1af', '2a', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer, process) {
    "use strict";

    var inherits = $__require('166').inherits,
        f = $__require('166').format,
        EventEmitter = $__require('55').EventEmitter,
        BSON = $__require('1b6').native().BSON,
        ReadPreference = $__require('1aa'),
        Logger = $__require('1a9'),
        debugOptions = $__require('1c1').debugOptions,
        Pool = $__require('1c3'),
        Query = $__require('1c2').Query,
        MongoError = $__require('1ab'),
        PreTwoSixWireProtocolSupport = $__require('1c6'),
        TwoSixWireProtocolSupport = $__require('1c8'),
        ThreeTwoWireProtocolSupport = $__require('1c9'),
        BasicCursor = $__require('1ad'),
        sdam = $__require('1af'),
        assign = $__require('1af').assign,
        createClientInfo = $__require('1af').createClientInfo;
    var debugFields = ['reconnect', 'reconnectTries', 'reconnectInterval', 'emitError', 'cursorFactory', 'host', 'port', 'size', 'keepAlive', 'keepAliveInitialDelay', 'noDelay', 'connectionTimeout', 'checkServerIdentity', 'socketTimeout', 'singleBufferSerializtion', 'ssl', 'ca', 'cert', 'key', 'rejectUnauthorized', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'servername'];
    var id = 0;
    var serverAccounting = false;
    var servers = {};
    var Server = function (options) {
      options = options || {};
      EventEmitter.call(this);
      this.id = id++;
      this.s = {
        options: options,
        logger: Logger('Server', options),
        Cursor: options.cursorFactory || BasicCursor,
        bson: options.bson || new BSON(),
        pool: null,
        disconnectHandler: options.disconnectHandler,
        monitoring: typeof options.monitoring == 'boolean' ? options.monitoring : true,
        inTopology: typeof options.inTopology == 'boolean' ? options.inTopology : false,
        monitoringInterval: typeof options.monitoringInterval == 'number' ? options.monitoringInterval : 5000,
        topologyId: -1
      };
      this.ismaster = null;
      this.lastIsMasterMS = -1;
      this.monitoringProcessId = null;
      this.initalConnect = true;
      this.wireProtocolHandler = new PreTwoSixWireProtocolSupport();
      this._type = 'server';
      this.clientInfo = createClientInfo(options);
      this.lastUpdateTime = 0;
      this.lastWriteDate = 0;
      this.staleness = 0;
    };
    inherits(Server, EventEmitter);
    Object.defineProperty(Server.prototype, 'type', {
      enumerable: true,
      get: function () {
        return this._type;
      }
    });
    Server.enableServerAccounting = function () {
      serverAccounting = true;
      servers = {};
    };
    Server.disableServerAccounting = function () {
      serverAccounting = false;
    };
    Server.servers = function () {
      return servers;
    };
    Object.defineProperty(Server.prototype, 'name', {
      enumerable: true,
      get: function () {
        return this.s.options.host + ":" + this.s.options.port;
      }
    });
    function configureWireProtocolHandler(self, ismaster) {
      if (ismaster.maxWireVersion >= 4) {
        return new ThreeTwoWireProtocolSupport(new TwoSixWireProtocolSupport());
      }
      if (ismaster.maxWireVersion >= 2) {
        return new TwoSixWireProtocolSupport();
      }
      return new PreTwoSixWireProtocolSupport();
    }
    function disconnectHandler(self, type, ns, cmd, options, callback) {
      if (!self.s.pool.isConnected() && self.s.disconnectHandler != null && !options.monitoring) {
        self.s.disconnectHandler.add(type, ns, cmd, options, callback);
        return true;
      }
      if (!self.s.pool.isConnected()) {
        callback(MongoError.create(f("no connection available to server %s", self.name)));
        return true;
      }
    }
    function monitoringProcess(self) {
      return function () {
        if (self.s.pool.isDestroyed()) return;
        self.emit('monitoring', self);
        var queryOptions = {
          numberToSkip: 0,
          numberToReturn: -1,
          checkKeys: false,
          slaveOk: true
        };
        var query = new Query(self.s.bson, 'admin.$cmd', { ismaster: true }, queryOptions);
        var start = new Date().getTime();
        self.s.pool.write(query, function (err, result) {
          self.lastIsMasterMS = new Date().getTime() - start;
          if (self.s.pool.isDestroyed()) return;
          if (result) {
            self.ismaster = result.result;
          }
          self.monitoringProcessId = setTimeout(monitoringProcess(self), self.s.monitoringInterval);
        });
      };
    }
    var eventHandler = function (self, event) {
      return function (err) {
        if (self.s.logger.isInfo()) {
          var object = err instanceof MongoError ? JSON.stringify(err) : {};
          self.s.logger.info(f('server %s fired event %s out with message %s', self.name, event, object));
        }
        if (event == 'connect') {
          var queryOptions = {
            numberToSkip: 0,
            numberToReturn: -1,
            checkKeys: false,
            slaveOk: true
          };
          var query = new Query(self.s.bson, 'admin.$cmd', {
            ismaster: true,
            client: self.clientInfo
          }, queryOptions);
          var start = new Date().getTime();
          self.s.pool.write(query, function (err, result) {
            self.lastIsMasterMS = new Date().getTime() - start;
            if (err) {
              self.destroy();
              if (self.listeners('error').length > 0) self.emit('error', err);
              return;
            }
            self.initalConnect = false;
            self.ismaster = result.result;
            if (self.ismaster.msg == 'isdbgrid') {
              self._type = 'mongos';
            }
            self.wireProtocolHandler = configureWireProtocolHandler(self, self.ismaster);
            if (self.s.monitoring) {
              self.monitoringProcessId = setTimeout(monitoringProcess(self), self.s.monitoringInterval);
            }
            sdam.emitServerDescriptionChanged(self, {
              address: self.name,
              arbiters: [],
              hosts: [],
              passives: [],
              type: !self.s.inTopology ? 'Standalone' : sdam.getTopologyType(self)
            });
            sdam.emitTopologyDescriptionChanged(self, {
              topologyType: 'Single',
              servers: [{
                address: self.name,
                arbiters: [],
                hosts: [],
                passives: [],
                type: 'Standalone'
              }]
            });
            if (self.s.logger.isInfo()) {
              self.s.logger.info(f('server %s connected with ismaster [%s]', self.name, JSON.stringify(self.ismaster)));
            }
            self.emit('connect', self);
          });
        } else if (event == 'error' || event == 'parseError' || event == 'close' || event == 'timeout' || event == 'reconnect' || event == 'attemptReconnect' || 'reconnectFailed') {
          if (serverAccounting && ['close', 'timeout', 'error', 'parseError', 'reconnectFailed'].indexOf(event) != -1) {
            if (!self.s.inTopology) {
              self.emit('topologyOpening', { topologyId: self.id });
            }
            delete servers[self.id];
          }
          if (event == 'reconnectFailed') {
            self.emit('reconnectFailed', err);
            if (self.listeners('error').length > 0) {
              self.emit('error', err);
            }
            return;
          }
          if (self.s.pool.state == 'disconnected' && self.initalConnect && ['close', 'timeout', 'error', 'parseError'].indexOf(event) != -1) {
            self.initalConnect = false;
            return self.emit('error', new MongoError(f('failed to connect to server [%s] on first connect', self.name)));
          }
          if (event == 'reconnect') {
            return self.emit(event, self);
          }
          self.emit(event, err);
        }
      };
    };
    Server.prototype.connect = function (options) {
      var self = this;
      options = options || {};
      if (serverAccounting) servers[this.id] = this;
      if (self.s.pool && !self.s.pool.isDisconnected() && !self.s.pool.isDestroyed()) {
        throw MongoError.create(f('server instance in invalid state %s', self.s.state));
      }
      self.s.pool = new Pool(assign(self.s.options, options, { bson: this.s.bson }));
      self.s.pool.on('close', eventHandler(self, 'close'));
      self.s.pool.on('error', eventHandler(self, 'error'));
      self.s.pool.on('timeout', eventHandler(self, 'timeout'));
      self.s.pool.on('parseError', eventHandler(self, 'parseError'));
      self.s.pool.on('connect', eventHandler(self, 'connect'));
      self.s.pool.on('reconnect', eventHandler(self, 'reconnect'));
      self.s.pool.on('reconnectFailed', eventHandler(self, 'reconnectFailed'));
      if (!self.s.inTopology) {
        this.emit('topologyOpening', { topologyId: self.id });
      }
      self.emit('serverOpening', {
        topologyId: self.s.topologyId != -1 ? self.s.topologyId : self.id,
        address: self.name
      });
      if (options.auth) {
        self.s.pool.connect.apply(self.s.pool, options.auth);
      } else {
        self.s.pool.connect();
      }
    };
    Server.prototype.getDescription = function () {
      var ismaster = this.ismaster || {};
      var description = {
        type: sdam.getTopologyType(this),
        address: this.name
      };
      if (ismaster.hosts) description.hosts = ismaster.hosts;
      if (ismaster.arbiters) description.arbiters = ismaster.arbiters;
      if (ismaster.passives) description.passives = ismaster.passives;
      if (ismaster.setName) description.setName = ismaster.setName;
      return description;
    };
    Server.prototype.lastIsMaster = function () {
      return this.ismaster;
    };
    Server.prototype.unref = function () {
      this.s.pool.unref();
    };
    Server.prototype.isConnected = function () {
      if (!this.s.pool) return false;
      return this.s.pool.isConnected();
    };
    Server.prototype.isDestroyed = function () {
      if (!this.s.pool) return false;
      return this.s.pool.isDestroyed();
    };
    function basicWriteValidations(self) {
      if (!self.s.pool) return MongoError.create('server instance is not connected');
      if (self.s.pool.isDestroyed()) return MongoError.create('server instance pool was destroyed');
    }
    function basicReadValidations(self, options) {
      basicWriteValidations(self, options);
      if (options.readPreference && !(options.readPreference instanceof ReadPreference)) {
        throw new Error("readPreference must be an instance of ReadPreference");
      }
    }
    Server.prototype.command = function (ns, cmd, options, callback) {
      var self = this;
      if (typeof options == 'function') callback = options, options = {}, options = options || {};
      var result = basicReadValidations(self, options);
      if (result) return callback(result);
      if (self.s.logger.isDebug()) self.s.logger.debug(f('executing command [%s] against %s', JSON.stringify({
        ns: ns,
        cmd: cmd,
        options: debugOptions(debugFields, options)
      }), self.name));
      if (disconnectHandler(self, 'command', ns, cmd, options, callback)) return;
      if (this.ismaster && this.ismaster.maxWireVersion < 5 && cmd.collation) {
        return callback(new MongoError(f('server %s does not support collation', this.name)));
      }
      var queryOptions = {
        numberToSkip: 0,
        numberToReturn: -1,
        checkKeys: typeof options.checkKeys == 'boolean' ? options.checkKeys : false,
        serializeFunctions: typeof options.serializeFunctions == 'boolean' ? options.serializeFunctions : false,
        ignoreUndefined: typeof options.ignoreUndefined == 'boolean' ? options.ignoreUndefined : false
      };
      var query = new Query(self.s.bson, ns, cmd, queryOptions);
      query.slaveOk = options.readPreference ? options.readPreference.slaveOk() : false;
      var writeOptions = {
        raw: typeof options.raw == 'boolean' ? options.raw : false,
        promoteLongs: typeof options.promoteLongs == 'boolean' ? options.promoteLongs : true,
        promoteValues: typeof options.promoteValues == 'boolean' ? options.promoteValues : true,
        promoteBuffers: typeof options.promoteBuffers == 'boolean' ? options.promoteBuffers : false,
        command: true,
        monitoring: typeof options.monitoring == 'boolean' ? options.monitoring : false,
        fullResult: typeof options.fullResult == 'boolean' ? options.fullResult : false,
        requestId: query.requestId,
        socketTimeout: typeof options.socketTimeout == 'number' ? options.socketTimeout : null
      };
      self.s.pool.write(query, writeOptions, callback);
    };
    Server.prototype.insert = function (ns, ops, options, callback) {
      var self = this;
      if (typeof options == 'function') callback = options, options = {}, options = options || {};
      var result = basicWriteValidations(self, options);
      if (result) return callback(result);
      if (disconnectHandler(self, 'insert', ns, ops, options, callback)) return;
      ops = Array.isArray(ops) ? ops : [ops];
      return self.wireProtocolHandler.insert(self.s.pool, self.ismaster, ns, self.s.bson, ops, options, callback);
    };
    Server.prototype.update = function (ns, ops, options, callback) {
      var self = this;
      if (typeof options == 'function') callback = options, options = {}, options = options || {};
      var result = basicWriteValidations(self, options);
      if (result) return callback(result);
      if (disconnectHandler(self, 'update', ns, ops, options, callback)) return;
      if (this.ismaster && this.ismaster.maxWireVersion < 5 && options.collation) {
        return callback(new MongoError(f('server %s does not support collation', this.name)));
      }
      ops = Array.isArray(ops) ? ops : [ops];
      return self.wireProtocolHandler.update(self.s.pool, self.ismaster, ns, self.s.bson, ops, options, callback);
    };
    Server.prototype.remove = function (ns, ops, options, callback) {
      var self = this;
      if (typeof options == 'function') callback = options, options = {}, options = options || {};
      var result = basicWriteValidations(self, options);
      if (result) return callback(result);
      if (disconnectHandler(self, 'remove', ns, ops, options, callback)) return;
      if (this.ismaster && this.ismaster.maxWireVersion < 5 && options.collation) {
        return callback(new MongoError(f('server %s does not support collation', this.name)));
      }
      ops = Array.isArray(ops) ? ops : [ops];
      return self.wireProtocolHandler.remove(self.s.pool, self.ismaster, ns, self.s.bson, ops, options, callback);
    };
    Server.prototype.cursor = function (ns, cmd, cursorOptions) {
      var s = this.s;
      cursorOptions = cursorOptions || {};
      var FinalCursor = cursorOptions.cursorFactory || s.Cursor;
      return new FinalCursor(s.bson, ns, cmd, cursorOptions, this, s.options);
    };
    Server.prototype.logout = function (dbName, callback) {
      this.s.pool.logout(dbName, callback);
    };
    Server.prototype.auth = function (mechanism, db) {
      var self = this;
      if (mechanism == 'default' && self.ismaster && self.ismaster.maxWireVersion >= 3) {
        mechanism = 'scram-sha-1';
      } else if (mechanism == 'default') {
        mechanism = 'mongocr';
      }
      var args = Array.prototype.slice.call(arguments, 0);
      args[0] = mechanism;
      var callback = args[args.length - 1];
      if (disconnectHandler(self, 'auth', db, args, {}, callback)) {
        return;
      }
      if (this.lastIsMaster() && this.lastIsMaster().arbiterOnly) {
        return callback(null, true);
      }
      self.s.pool.auth.apply(self.s.pool, args);
    };
    Server.prototype.equals = function (server) {
      if (typeof server == 'string') return this.name == server;
      if (server.name) return this.name == server.name;
      return false;
    };
    Server.prototype.connections = function () {
      return this.s.pool.allConnections();
    };
    Server.prototype.getServer = function () {
      return this;
    };
    Server.prototype.getConnection = function () {
      return this.s.pool.get();
    };
    var listeners = ['close', 'error', 'timeout', 'parseError', 'connect'];
    Server.prototype.destroy = function (options) {
      options = options || {};
      var self = this;
      if (serverAccounting) delete servers[this.id];
      if (this.monitoringProcessId) {
        clearTimeout(this.monitoringProcessId);
      }
      if (options.emitClose) {
        self.emit('close', self);
      }
      if (options.emitDestroy) {
        self.emit('destroy', self);
      }
      listeners.forEach(function (event) {
        self.s.pool.removeAllListeners(event);
      });
      if (self.listeners('serverClosed').length > 0) self.emit('serverClosed', {
        topologyId: self.s.topologyId != -1 ? self.s.topologyId : self.id,
        address: self.name
      });
      if (self.listeners('topologyClosed').length > 0 && !self.s.inTopology) {
        self.emit('topologyClosed', { topologyId: self.id });
      }
      if (self.s.logger.isDebug()) {
        self.s.logger.debug(f('destroy called on server %s', self.name));
      }
      this.s.pool.destroy(options.force);
    };
    module.exports = Server;
  })($__require('2a').Buffer, $__require('13'));
  return module.exports;
});
$__System.registerDynamic('1ca', [], true, function ($__require, exports, module) {
    var define,
        global = this || self,
        GLOBAL = global;
    /* */
    exports.endianness = function () {
        return 'LE';
    };

    exports.hostname = function () {
        if (typeof location !== 'undefined') {
            return location.hostname;
        } else return '';
    };

    exports.loadavg = function () {
        return [];
    };

    exports.uptime = function () {
        return 0;
    };

    exports.freemem = function () {
        return Number.MAX_VALUE;
    };

    exports.totalmem = function () {
        return Number.MAX_VALUE;
    };

    exports.cpus = function () {
        return [];
    };

    exports.type = function () {
        return 'Browser';
    };

    exports.release = function () {
        if (typeof navigator !== 'undefined') {
            return navigator.appVersion;
        }
        return '';
    };

    exports.networkInterfaces = exports.getNetworkInterfaces = function () {
        return {};
    };

    exports.arch = function () {
        return 'javascript';
    };

    exports.platform = function () {
        return 'browser';
    };

    exports.tmpdir = exports.tmpDir = function () {
        return '/tmp';
    };

    exports.EOL = '\n';
    return module.exports;
});
$__System.registerDynamic("1cb", ["1ca"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("1ca");
  return module.exports;
});
$__System.registerDynamic('1cc', ['1cb'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  module.exports = $__System._nodeRequire ? $__System._nodeRequire('os') : $__require('1cb');
  return module.exports;
});
$__System.registerDynamic("193", ["1cc"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("1cc");
  return module.exports;
});
$__System.registerDynamic('1af', ['193', '166', '2a', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  var __filename = 'jspm_packages/npm/mongodb-core@2.0.14/lib/topologies/shared.js',
      __dirname = 'jspm_packages/npm/mongodb-core@2.0.14/lib/topologies';
  /* */
  (function (Buffer, process) {
    "use strict";

    var os = $__require('193'),
        f = $__require('166').format;
    function emitSDAMEvent(self, event, description) {
      if (self.listeners(event).length > 0) {
        self.emit(event, description);
      }
    }
    var driverVersion = $__require(__dirname + '/../../package.json').version;
    var nodejsversion = f('Node.js %s, %s', process.version, os.endianness());
    var type = os.type();
    var name = process.platform;
    var architecture = process.arch;
    var release = os.release();
    function createClientInfo(options) {
      var clientInfo = options.clientInfo ? clone(options.clientInfo) : {
        driver: {
          name: "nodejs-core",
          version: driverVersion
        },
        os: {
          type: type,
          name: name,
          architecture: architecture,
          version: release
        }
      };
      if (clientInfo.platform && clientInfo.platform.indexOf('mongodb-core') == -1) {
        clientInfo.platform = f('%s, mongodb-core: %s', clientInfo.platform, driverVersion);
      } else if (!clientInfo.platform) {
        clientInfo.platform = nodejsversion;
      }
      if (options.appname) {
        var buffer = new Buffer(options.appname);
        var appname = buffer.length > 128 ? buffer.slice(0, 128).toString('utf8') : options.appname;
        clientInfo.application = { name: appname };
      }
      return clientInfo;
    }
    function clone(object) {
      return JSON.parse(JSON.stringify(object));
    }
    var getPreviousDescription = function (self) {
      if (!self.s.serverDescription) {
        self.s.serverDescription = {
          address: self.name,
          arbiters: [],
          hosts: [],
          passives: [],
          type: 'Unknown'
        };
      }
      return self.s.serverDescription;
    };
    var emitServerDescriptionChanged = function (self, description) {
      if (self.listeners('serverDescriptionChanged').length > 0) {
        self.emit('serverDescriptionChanged', {
          topologyId: self.s.topologyId != -1 ? self.s.topologyId : self.id,
          address: self.name,
          previousDescription: getPreviousDescription(self),
          newDescription: description
        });
        self.s.serverDescription = description;
      }
    };
    var getPreviousTopologyDescription = function (self) {
      if (!self.s.topologyDescription) {
        self.s.topologyDescription = {
          topologyType: 'Unknown',
          servers: [{
            address: self.name,
            arbiters: [],
            hosts: [],
            passives: [],
            type: 'Unknown'
          }]
        };
      }
      return self.s.topologyDescription;
    };
    var emitTopologyDescriptionChanged = function (self, description) {
      if (self.listeners('topologyDescriptionChanged').length > 0) {
        self.emit('topologyDescriptionChanged', {
          topologyId: self.s.topologyId != -1 ? self.s.topologyId : self.id,
          address: self.name,
          previousDescription: getPreviousTopologyDescription(self),
          newDescription: description
        });
        self.s.serverDescription = description;
      }
    };
    var changedIsMaster = function (self, currentIsmaster, ismaster) {
      var currentType = getTopologyType(self, currentIsmaster);
      var newType = getTopologyType(self, ismaster);
      if (newType != currentType) return true;
      return false;
    };
    var getTopologyType = function (self, ismaster) {
      if (!ismaster) {
        ismaster = self.ismaster;
      }
      if (!ismaster) return 'Unknown';
      if (ismaster.ismaster && !ismaster.hosts) return 'Standalone';
      if (ismaster.ismaster && ismaster.msg == 'isdbgrid') return 'Mongos';
      if (ismaster.ismaster) return 'RSPrimary';
      if (ismaster.secondary) return 'RSSecondary';
      if (ismaster.arbiterOnly) return 'RSArbiter';
      return 'Unknown';
    };
    var inquireServerState = function (self) {
      return function (callback) {
        if (self.s.state == 'destroyed') return;
        var start = new Date().getTime();
        emitSDAMEvent(self, 'serverHeartbeatStarted', { connectionId: self.name });
        self.command('admin.$cmd', { ismaster: true }, { monitoring: true }, function (err, r) {
          if (!err) {
            self.emit('ismaster', r, self);
            var latencyMS = new Date().getTime() - start;
            emitSDAMEvent(self, 'serverHeartbeatSucceeded', {
              durationMS: latencyMS,
              reply: r.result,
              connectionId: self.name
            });
            if (changedIsMaster(self, self.s.ismaster, r.result)) {
              emitServerDescriptionChanged(self, {
                address: self.name,
                arbiters: [],
                hosts: [],
                passives: [],
                type: !self.s.inTopology ? 'Standalone' : getTopologyType(self)
              });
            }
            self.s.ismaster = r.result;
            self.s.isMasterLatencyMS = latencyMS;
          } else {
            emitSDAMEvent(self, 'serverHeartbeatFailed', {
              durationMS: latencyMS,
              failure: err,
              connectionId: self.name
            });
          }
          if (typeof callback == 'function') {
            return callback(err, r);
          }
          self.s.inquireServerStateTimeout = setTimeout(inquireServerState(self), self.s.haInterval);
        });
      };
    };
    var assign = Object.assign ? Object.assign : function assign(target) {
      if (target === undefined || target === null) {
        throw new TypeError('Cannot convert first argument to object');
      }
      var to = Object(target);
      for (var i = 1; i < arguments.length; i++) {
        var nextSource = arguments[i];
        if (nextSource === undefined || nextSource === null) {
          continue;
        }
        var keysArray = Object.keys(Object(nextSource));
        for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
          var nextKey = keysArray[nextIndex];
          var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
          if (desc !== undefined && desc.enumerable) {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
      return to;
    };
    var cloneOptions = function (options) {
      var opts = {};
      for (var name in options) {
        opts[name] = options[name];
      }
      return opts;
    };
    module.exports.inquireServerState = inquireServerState;
    module.exports.getTopologyType = getTopologyType;
    module.exports.emitServerDescriptionChanged = emitServerDescriptionChanged;
    module.exports.emitTopologyDescriptionChanged = emitTopologyDescriptionChanged;
    module.exports.cloneOptions = cloneOptions;
    module.exports.assign = assign;
    module.exports.createClientInfo = createClientInfo;
    module.exports.clone = clone;
  })($__require('2a').Buffer, $__require('13'));
  return module.exports;
});
$__System.registerDynamic('1b4', ['166', '1cd', '1c2', '1ab', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    "use strict";

    var f = $__require('166').format,
        require_optional = $__require('1cd'),
        Query = $__require('1c2').Query,
        MongoError = $__require('1ab');
    var AuthSession = function (db, username, password, options) {
      this.db = db;
      this.username = username;
      this.password = password;
      this.options = options;
    };
    AuthSession.prototype.equal = function (session) {
      return session.db == this.db && session.username == this.username && session.password == this.password;
    };
    var Kerberos = null;
    var MongoAuthProcess = null;
    try {
      Kerberos = require_optional('kerberos').Kerberos;
      MongoAuthProcess = require_optional('kerberos').processes.MongoAuthProcess;
    } catch (err) {}
    var SSPI = function (bson) {
      this.bson = bson;
      this.authStore = [];
    };
    SSPI.prototype.auth = function (server, connections, db, username, password, options, callback) {
      var self = this;
      if (Kerberos == null) return callback(new Error("Kerberos library is not installed"));
      var gssapiServiceName = options['gssapiServiceName'] || 'mongodb';
      var count = connections.length;
      if (count == 0) return callback(null, null);
      var numberOfValidConnections = 0;
      var errorObject = null;
      while (connections.length > 0) {
        var execute = function (connection) {
          SSIPAuthenticate(self, username, password, gssapiServiceName, server, connection, options, function (err, r) {
            count = count - 1;
            if (err) {
              errorObject = err;
            } else if (r && typeof r == 'object' && r.result['$err']) {
              errorObject = r.result;
            } else if (r && typeof r == 'object' && r.result['errmsg']) {
              errorObject = r.result;
            } else {
              numberOfValidConnections = numberOfValidConnections + 1;
            }
            if (count == 0 && numberOfValidConnections > 0) {
              addAuthSession(self.authStore, new AuthSession(db, username, password, options));
              callback(null, true);
            } else if (count == 0) {
              if (errorObject == null) errorObject = new MongoError(f("failed to authenticate using mongocr"));
              callback(errorObject, false);
            }
          });
        };
        var _execute = function (_connection) {
          process.nextTick(function () {
            execute(_connection);
          });
        };
        _execute(connections.shift());
      }
    };
    var SSIPAuthenticate = function (self, username, password, gssapiServiceName, server, connection, options, callback) {
      var command = {
        saslStart: 1,
        mechanism: 'GSSAPI',
        payload: '',
        autoAuthorize: 1
      };
      var mongo_auth_process = new MongoAuthProcess(connection.host, connection.port, gssapiServiceName, options);
      server(connection, new Query(self.bson, "$external.$cmd", command, {
        numberToSkip: 0,
        numberToReturn: 1
      }), function (err, r) {
        if (err) return callback(err, false);
        var doc = r.result;
        mongo_auth_process.init(username, password, function (err) {
          if (err) return callback(err);
          mongo_auth_process.transition(doc.payload, function (err, payload) {
            if (err) return callback(err);
            var command = {
              saslContinue: 1,
              conversationId: doc.conversationId,
              payload: payload
            };
            server(connection, new Query(self.bson, "$external.$cmd", command, {
              numberToSkip: 0,
              numberToReturn: 1
            }), function (err, r) {
              if (err) return callback(err, false);
              var doc = r.result;
              mongo_auth_process.transition(doc.payload, function (err, payload) {
                if (err) return callback(err);
                var command = {
                  saslContinue: 1,
                  conversationId: doc.conversationId,
                  payload: payload
                };
                server(connection, new Query(self.bson, "$external.$cmd", command, {
                  numberToSkip: 0,
                  numberToReturn: 1
                }), function (err, r) {
                  if (err) return callback(err, false);
                  var doc = r.result;
                  mongo_auth_process.transition(doc.payload, function (err, payload) {
                    var command = {
                      saslContinue: 1,
                      conversationId: doc.conversationId,
                      payload: payload
                    };
                    server(connection, new Query(self.bson, "$external.$cmd", command, {
                      numberToSkip: 0,
                      numberToReturn: 1
                    }), function (err, r) {
                      if (err) return callback(err, false);
                      var doc = r.result;
                      if (doc.done) return callback(null, true);
                      callback(new Error("Authentication failed"), false);
                    });
                  });
                });
              });
            });
          });
        });
      });
    };
    var addAuthSession = function (authStore, session) {
      var found = false;
      for (var i = 0; i < authStore.length; i++) {
        if (authStore[i].equal(session)) {
          found = true;
          break;
        }
      }
      if (!found) authStore.push(session);
    };
    SSPI.prototype.logout = function (dbName) {
      this.authStore = this.authStore.filter(function (x) {
        return x.db != dbName;
      });
    };
    SSPI.prototype.reauthenticate = function (server, connections, callback) {
      var authStore = this.authStore.slice(0);
      var count = authStore.length;
      if (count == 0) return callback(null, null);
      for (var i = 0; i < authStore.length; i++) {
        this.auth(server, connections, authStore[i].db, authStore[i].username, authStore[i].password, authStore[i].options, function (err) {
          count = count - 1;
          if (count == 0) {
            callback(err, null);
          }
        });
      }
    };
    module.exports = SSPI;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('1ce', ['166', '55', '1b6', '1ad', '1a9', '1ab', '1ae', '1af', '1b0', '1b1', '1b2', '1b3', '1b4', '1b5', '2a', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer, process) {
    "use strict";

    var inherits = $__require('166').inherits,
        f = $__require('166').format,
        EventEmitter = $__require('55').EventEmitter,
        BSON = $__require('1b6').native().BSON,
        BasicCursor = $__require('1ad'),
        Logger = $__require('1a9'),
        MongoError = $__require('1ab'),
        Server = $__require('1ae'),
        assign = $__require('1af').assign,
        clone = $__require('1af').clone,
        createClientInfo = $__require('1af').createClientInfo;
    var MongoCR = $__require('1b0'),
        X509 = $__require('1b1'),
        Plain = $__require('1b2'),
        GSSAPI = $__require('1b3'),
        SSPI = $__require('1b4'),
        ScramSHA1 = $__require('1b5');
    var DISCONNECTED = 'disconnected';
    var CONNECTING = 'connecting';
    var CONNECTED = 'connected';
    var DESTROYED = 'destroyed';
    function stateTransition(self, newState) {
      var legalTransitions = {
        'disconnected': [CONNECTING, DESTROYED, DISCONNECTED],
        'connecting': [CONNECTING, DESTROYED, CONNECTED, DISCONNECTED],
        'connected': [CONNECTED, DISCONNECTED, DESTROYED],
        'destroyed': [DESTROYED]
      };
      var legalStates = legalTransitions[self.state];
      if (legalStates && legalStates.indexOf(newState) != -1) {
        self.state = newState;
      } else {
        self.logger.error(f('Pool with id [%s] failed attempted illegal state transition from [%s] to [%s] only following state allowed [%s]', self.id, self.state, newState, legalStates));
      }
    }
    var id = 1;
    var handlers = ['connect', 'close', 'error', 'timeout', 'parseError'];
    var Mongos = function (seedlist, options) {
      options = options || {};
      this.id = id++;
      this.s = {
        options: assign({}, options),
        bson: options.bson || new BSON(),
        Cursor: options.cursorFactory || BasicCursor,
        logger: Logger('Mongos', options),
        seedlist: seedlist,
        haInterval: options.haInterval ? options.haInterval : 10000,
        disconnectHandler: options.disconnectHandler,
        index: 0,
        connectOptions: {},
        debug: typeof options.debug == 'boolean' ? options.debug : false,
        localThresholdMS: options.localThresholdMS || 15,
        clientInfo: createClientInfo(options)
      };
      this.s.options.clientInfo = createClientInfo(options);
      if (this.s.logger.isWarn() && this.s.options.socketTimeout != 0 && this.s.options.socketTimeout < this.s.haInterval) {
        this.s.logger.warn(f('warning socketTimeout %s is less than haInterval %s. This might cause unnecessary server reconnections due to socket timeouts', this.s.options.socketTimeout, this.s.haInterval));
      }
      this.authProviders = options.authProviders || {
        'mongocr': new MongoCR(this.s.bson),
        'x509': new X509(this.s.bson),
        'plain': new Plain(this.s.bson),
        'gssapi': new GSSAPI(this.s.bson),
        'sspi': new SSPI(this.s.bson),
        'scram-sha-1': new ScramSHA1(this.s.bson)
      };
      this.state = DISCONNECTED;
      this.connectingProxies = [];
      this.connectedProxies = [];
      this.disconnectedProxies = [];
      this.authenticating = false;
      this.index = 0;
      this.haTimeoutId = null;
      this.ismaster = null;
      EventEmitter.call(this);
    };
    inherits(Mongos, EventEmitter);
    Object.defineProperty(Mongos.prototype, 'type', {
      enumerable: true,
      get: function () {
        return 'mongos';
      }
    });
    function emitSDAMEvent(self, event, description) {
      if (self.listeners(event).length > 0) {
        self.emit(event, description);
      }
    }
    Mongos.prototype.connect = function (options) {
      var self = this;
      this.s.connectOptions = options || {};
      stateTransition(this, CONNECTING);
      var servers = this.s.seedlist.map(function (x) {
        return new Server(assign({}, self.s.options, x, {
          authProviders: self.authProviders,
          reconnect: false,
          monitoring: false,
          inTopology: true
        }, { clientInfo: clone(self.s.clientInfo) }));
      });
      emitSDAMEvent(this, 'topologyOpening', { topologyId: this.id });
      connectProxies(self, servers);
    };
    function handleEvent(self) {
      return function () {
        if (self.state == DESTROYED) return;
        moveServerFrom(self.connectedProxies, self.disconnectedProxies, this);
        self.emit('left', 'mongos', this);
      };
    }
    function handleInitialConnectEvent(self, event) {
      return function () {
        if (self.state == DESTROYED) {
          moveServerFrom(self.connectingProxies, self.disconnectedProxies, this);
          return this.destroy();
        }
        if (event == 'connect') {
          self.ismaster = this.lastIsMaster();
          if (self.ismaster.msg == 'isdbgrid') {
            for (var i = 0; i < self.connectedProxies.length; i++) {
              if (self.connectedProxies[i].name == this.name) {
                moveServerFrom(self.connectingProxies, self.disconnectedProxies, this);
                this.destroy();
                return self.emit('failed', this);
              }
            }
            for (i = 0; i < handlers.length; i++) {
              this.removeAllListeners(handlers[i]);
            }
            this.on('error', handleEvent(self, 'error'));
            this.on('close', handleEvent(self, 'close'));
            this.on('timeout', handleEvent(self, 'timeout'));
            this.on('parseError', handleEvent(self, 'parseError'));
            moveServerFrom(self.connectingProxies, self.connectedProxies, this);
            self.emit('joined', 'mongos', this);
          } else {
            if (self.s.logger.isWarn()) {
              var message = 'expected mongos proxy, but found replicaset member mongod for server %s';
              if (!self.ismaster.hosts) {
                message = 'expected mongos proxy, but found standalone mongod for server %s';
              }
              self.s.logger.warn(f(message, this.name));
            }
            removeProxyFrom(self.connectingProxies, this);
            self.emit('left', 'server', this);
            self.emit('failed', this);
          }
        } else {
          moveServerFrom(self.connectingProxies, self.disconnectedProxies, this);
          self.emit('left', 'mongos', this);
          self.emit('failed', this);
        }
        if (self.connectingProxies.length == 0) {
          if (self.connectedProxies.length > 0) {
            stateTransition(self, CONNECTED);
            self.emit('connect', self);
            self.emit('fullsetup', self);
            self.emit('all', self);
          } else if (self.disconnectedProxies.length == 0) {
            if (self.s.logger.isWarn()) {
              self.s.logger.warn(f('no mongos proxies found in seed list, did you mean to connect to a replicaset'));
            }
            return self.emit('error', new MongoError('no mongos proxies found in seed list'));
          }
          topologyMonitor(self, { firstConnect: true });
        }
      };
    }
    function connectProxies(self, servers) {
      self.connectingProxies = self.connectingProxies.concat(servers);
      var timeoutInterval = 0;
      function connect(server, timeoutInterval) {
        setTimeout(function () {
          server.once('close', handleInitialConnectEvent(self, 'close'));
          server.once('timeout', handleInitialConnectEvent(self, 'timeout'));
          server.once('parseError', handleInitialConnectEvent(self, 'parseError'));
          server.once('error', handleInitialConnectEvent(self, 'error'));
          server.once('connect', handleInitialConnectEvent(self, 'connect'));
          server.on('serverOpening', function (e) {
            self.emit('serverOpening', e);
          });
          server.on('serverDescriptionChanged', function (e) {
            self.emit('serverDescriptionChanged', e);
          });
          server.on('serverClosed', function (e) {
            self.emit('serverClosed', e);
          });
          server.connect(self.s.connectOptions);
        }, timeoutInterval);
      }
      while (servers.length > 0) {
        connect(servers.shift(), timeoutInterval++);
      }
    }
    function pickProxy(self) {
      var connectedProxies = self.connectedProxies.slice(0);
      var lowerBoundLatency = Number.MAX_VALUE;
      for (var i = 0; i < connectedProxies.length; i++) {
        if (connectedProxies[i].lastIsMasterMS < lowerBoundLatency) {
          lowerBoundLatency = connectedProxies[i].lastIsMasterMS;
        }
      }
      connectedProxies = connectedProxies.filter(function (server) {
        if (server.lastIsMasterMS <= lowerBoundLatency + self.s.localThresholdMS && server.isConnected()) {
          return true;
        }
      });
      if (connectedProxies.length == 0) {
        return self.connectedProxies[0];
      }
      var proxy = connectedProxies[self.index % connectedProxies.length];
      self.index = (self.index + 1) % connectedProxies.length;
      return proxy;
    }
    function moveServerFrom(from, to, proxy) {
      for (var i = 0; i < from.length; i++) {
        if (from[i].name == proxy.name) {
          from.splice(i, 1);
        }
      }
      for (i = 0; i < to.length; i++) {
        if (to[i].name == proxy.name) {
          to.splice(i, 1);
        }
      }
      to.push(proxy);
    }
    function removeProxyFrom(from, proxy) {
      for (var i = 0; i < from.length; i++) {
        if (from[i].name == proxy.name) {
          from.splice(i, 1);
        }
      }
    }
    function reconnectProxies(self, proxies, callback) {
      var count = proxies.length;
      var _handleEvent = function (self, event) {
        return function () {
          var _self = this;
          count = count - 1;
          if (self.state == DESTROYED) {
            moveServerFrom(self.connectingProxies, self.disconnectedProxies, _self);
            return this.destroy();
          }
          if (event == 'connect' && !self.authenticating) {
            if (self.state == DESTROYED) {
              moveServerFrom(self.connectingProxies, self.disconnectedProxies, _self);
              return _self.destroy();
            }
            for (var i = 0; i < handlers.length; i++) {
              _self.removeAllListeners(handlers[i]);
            }
            _self.on('error', handleEvent(self, 'error'));
            _self.on('close', handleEvent(self, 'close'));
            _self.on('timeout', handleEvent(self, 'timeout'));
            _self.on('parseError', handleEvent(self, 'parseError'));
            moveServerFrom(self.disconnectedProxies, self.connectedProxies, _self);
            self.emit('joined', 'mongos', _self);
          } else if (event == 'connect' && self.authenticating) {
            moveServerFrom(self.connectingProxies, self.disconnectedProxies, _self);
            this.destroy();
          }
          if (count == 0) {
            callback();
          }
        };
      };
      if (count == 0) {
        return callback();
      }
      function execute(_server, i) {
        setTimeout(function () {
          if (self.state == DESTROYED) {
            return;
          }
          var server = new Server(assign({}, self.s.options, {
            host: _server.name.split(':')[0],
            port: parseInt(_server.name.split(':')[1], 10)
          }, {
            authProviders: self.authProviders,
            reconnect: false,
            monitoring: false,
            inTopology: true
          }, { clientInfo: clone(self.s.clientInfo) }));
          server.once('connect', _handleEvent(self, 'connect'));
          server.once('close', _handleEvent(self, 'close'));
          server.once('timeout', _handleEvent(self, 'timeout'));
          server.once('error', _handleEvent(self, 'error'));
          server.once('parseError', _handleEvent(self, 'parseError'));
          server.on('serverOpening', function (e) {
            self.emit('serverOpening', e);
          });
          server.on('serverDescriptionChanged', function (e) {
            self.emit('serverDescriptionChanged', e);
          });
          server.on('serverClosed', function (e) {
            self.emit('serverClosed', e);
          });
          server.connect(self.s.connectOptions);
        }, i);
      }
      for (var i = 0; i < proxies.length; i++) {
        execute(proxies[i], i);
      }
    }
    function topologyMonitor(self, options) {
      options = options || {};
      self.haTimeoutId = setTimeout(function () {
        if (self.state == DESTROYED) return;
        if (self.isConnected() && self.s.disconnectHandler) {
          self.s.disconnectHandler.execute();
        }
        var proxies = self.connectedProxies.slice(0);
        var count = proxies.length;
        function pingServer(_self, _server, cb) {
          var start = new Date().getTime();
          emitSDAMEvent(self, 'serverHeartbeatStarted', { connectionId: _server.name });
          _server.command('admin.$cmd', { ismaster: true }, {
            monitoring: true,
            socketTimeout: self.s.options.connectionTimeout || 2000
          }, function (err, r) {
            if (self.state == DESTROYED) {
              moveServerFrom(self.connectedProxies, self.disconnectedProxies, _server);
              _server.destroy();
              return cb(err, r);
            }
            var latencyMS = new Date().getTime() - start;
            if (err) {
              emitSDAMEvent(self, 'serverHeartbeatFailed', {
                durationMS: latencyMS,
                failure: err,
                connectionId: _server.name
              });
              moveServerFrom(self.connectedProxies, self.disconnectedProxies, _server);
            } else {
              _server.ismaster = r.result;
              _server.lastIsMasterMS = latencyMS;
              emitSDAMEvent(self, 'serverHeartbeatSucceeded', {
                durationMS: latencyMS,
                reply: r.result,
                connectionId: _server.name
              });
            }
            cb(err, r);
          });
        }
        if (proxies.length == 0) {
          if (self.listeners("close").length > 0 && self.state == CONNECTING) {
            self.emit('error', new MongoError('no mongos proxy available'));
          } else {
            self.emit('close', self);
          }
          return reconnectProxies(self, self.disconnectedProxies, function () {
            if (self.state == DESTROYED) return;
            if (self.state == CONNECTING && options.firstConnect) {
              self.emit('connect', self);
              self.emit('fullsetup', self);
              self.emit('all', self);
            } else if (self.isConnected()) {
              self.emit('reconnect', self);
            } else if (!self.isConnected() && self.listeners("close").length > 0) {
              self.emit('close', self);
            }
            topologyMonitor(self);
          });
        }
        for (var i = 0; i < proxies.length; i++) {
          pingServer(self, proxies[i], function () {
            count = count - 1;
            if (count == 0) {
              if (self.state == DESTROYED) return;
              reconnectProxies(self, self.disconnectedProxies, function () {
                if (self.state == DESTROYED) return;
                topologyMonitor(self);
              });
            }
          });
        }
      }, self.s.haInterval);
    }
    Mongos.prototype.lastIsMaster = function () {
      return this.ismaster;
    };
    Mongos.prototype.unref = function () {
      stateTransition(this, DISCONNECTED);
      var proxies = this.connectedProxies.concat(this.connectingProxies);
      proxies.forEach(function (x) {
        x.unref();
      });
      clearTimeout(this.haTimeoutId);
    };
    Mongos.prototype.destroy = function (options) {
      stateTransition(this, DESTROYED);
      var proxies = this.connectedProxies.concat(this.connectingProxies);
      if (this.haTimeoutId) clearTimeout(this.haTimeoutId);
      proxies.forEach(function (x) {
        x.destroy(options);
      });
      emitSDAMEvent(this, 'topologyClosed', { topologyId: this.id });
    };
    Mongos.prototype.isConnected = function () {
      return this.connectedProxies.length > 0;
    };
    Mongos.prototype.isDestroyed = function () {
      return this.state == DESTROYED;
    };
    var executeWriteOperation = function (self, op, ns, ops, options, callback) {
      if (typeof options == 'function') callback = options, options = {}, options = options || {};
      options = options || {};
      var server = pickProxy(self);
      if (!server) return callback(new MongoError('no mongos proxy available'));
      server[op](ns, ops, options, callback);
    };
    Mongos.prototype.insert = function (ns, ops, options, callback) {
      if (typeof options == 'function') callback = options, options = {}, options = options || {};
      if (this.state == DESTROYED) return callback(new MongoError(f('topology was destroyed')));
      if (!this.isConnected() && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add('insert', ns, ops, options, callback);
      }
      if (!this.isConnected()) {
        return callback(new MongoError('no mongos proxy available'));
      }
      executeWriteOperation(this, 'insert', ns, ops, options, callback);
    };
    Mongos.prototype.update = function (ns, ops, options, callback) {
      if (typeof options == 'function') callback = options, options = {}, options = options || {};
      if (this.state == DESTROYED) return callback(new MongoError(f('topology was destroyed')));
      if (!this.isConnected() && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add('update', ns, ops, options, callback);
      }
      if (!this.isConnected()) {
        return callback(new MongoError('no mongos proxy available'));
      }
      executeWriteOperation(this, 'update', ns, ops, options, callback);
    };
    Mongos.prototype.remove = function (ns, ops, options, callback) {
      if (typeof options == 'function') callback = options, options = {}, options = options || {};
      if (this.state == DESTROYED) return callback(new MongoError(f('topology was destroyed')));
      if (!this.isConnected() && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add('remove', ns, ops, options, callback);
      }
      if (!this.isConnected()) {
        return callback(new MongoError('no mongos proxy available'));
      }
      executeWriteOperation(this, 'remove', ns, ops, options, callback);
    };
    Mongos.prototype.command = function (ns, cmd, options, callback) {
      if (typeof options == 'function') callback = options, options = {}, options = options || {};
      if (this.state == DESTROYED) return callback(new MongoError(f('topology was destroyed')));
      var self = this;
      var server = pickProxy(self);
      if ((server == null || !server.isConnected()) && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add('command', ns, cmd, options, callback);
      }
      if (server == null) {
        return callback(new MongoError('no mongos proxy available'));
      }
      server.command(ns, cmd, options, callback);
    };
    Mongos.prototype.cursor = function (ns, cmd, cursorOptions) {
      cursorOptions = cursorOptions || {};
      var FinalCursor = cursorOptions.cursorFactory || this.s.Cursor;
      return new FinalCursor(this.s.bson, ns, cmd, cursorOptions, this, this.s.options);
    };
    Mongos.prototype.auth = function (mechanism, db) {
      var allArgs = Array.prototype.slice.call(arguments, 0).slice(0);
      var self = this;
      var args = Array.prototype.slice.call(arguments, 2);
      var callback = args.pop();
      if (this.authProviders[mechanism] == null && mechanism != 'default') {
        return callback(new MongoError(f("auth provider %s does not exist", mechanism)));
      }
      if (this.authenticating) {
        return callback(new MongoError('authentication or logout allready in process'));
      }
      if (!self.isConnected() && self.s.disconnectHandler != null) {
        return self.s.disconnectHandler.add('auth', db, allArgs, {}, callback);
      }
      this.authenticating = true;
      var errors = [];
      var servers = this.connectedProxies.slice(0);
      if (servers.length == 0) {
        this.authenticating = false;
        callback(null, true);
      }
      function auth(server) {
        var argsWithoutCallback = [mechanism, db].concat(args.slice(0));
        var finalArguments = argsWithoutCallback.concat([function (err) {
          count = count - 1;
          if (err) errors.push({
            name: server.name,
            err: err
          });
          if (count == 0) {
            self.authenticating = false;
            if (errors.length) return callback(MongoError.create({
              message: 'authentication fail',
              errors: errors
            }), false);
            callback(null, self);
          }
        }]);
        if (!server.lastIsMaster().arbiterOnly) {
          server.auth.apply(server, finalArguments);
        }
      }
      var count = servers.length;
      while (servers.length > 0) {
        auth(servers.shift());
      }
    };
    Mongos.prototype.logout = function (dbName, callback) {
      var self = this;
      if (this.authenticating) {
        throw new MongoError('authentication or logout allready in process');
      }
      this.authenticating = true;
      var providers = Object.keys(this.authProviders);
      for (var i = 0; i < providers.length; i++) {
        this.authProviders[providers[i]].logout(dbName);
      }
      var servers = this.connectedProxies.slice(0);
      var count = servers.length;
      if (count == 0) return callback();
      var errors = [];
      function logoutServer(_server, cb) {
        _server.logout(dbName, function (err) {
          if (err) errors.push({
            name: _server.name,
            err: err
          });
          cb();
        });
      }
      for (i = 0; i < servers.length; i++) {
        logoutServer(servers[i], function () {
          count = count - 1;
          if (count == 0) {
            self.authenticating = false;
            if (errors.length) return callback(MongoError.create({
              message: f('logout failed against db %s', dbName),
              errors: errors
            }), false);
            callback();
          }
        });
      }
    };
    Mongos.prototype.getServer = function () {
      var server = pickProxy(this);
      if (this.s.debug) this.emit('pickedServer', null, server);
      return server;
    };
    Mongos.prototype.connections = function () {
      var connections = [];
      for (var i = 0; i < this.connectedProxies.length; i++) {
        connections = connections.concat(this.connectedProxies[i].connections());
      }
      return connections;
    };
    module.exports = Mongos;
  })($__require('2a').Buffer, $__require('13'));
  return module.exports;
});
$__System.registerDynamic('1a9', ['166', '1ab', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    "use strict";

    var f = $__require('166').format,
        MongoError = $__require('1ab');
    var classFilters = {};
    var filteredClasses = {};
    var level = null;
    var pid = process.pid;
    var currentLogger = null;
    var Logger = function (className, options) {
      if (!(this instanceof Logger)) return new Logger(className, options);
      options = options || {};
      this.className = className;
      if (options.logger) {
        currentLogger = options.logger;
      } else if (currentLogger == null) {
        currentLogger = console.log;
      }
      if (options.loggerLevel) {
        level = options.loggerLevel || 'error';
      }
      if (filteredClasses[this.className] == null) classFilters[this.className] = true;
    };
    Logger.prototype.debug = function (message, object) {
      if (this.isDebug() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length == 0 && classFilters[this.className])) {
        var dateTime = new Date().getTime();
        var msg = f("[%s-%s:%s] %s %s", 'DEBUG', this.className, pid, dateTime, message);
        var state = {
          type: 'debug',
          message: message,
          className: this.className,
          pid: pid,
          date: dateTime
        };
        if (object) state.meta = object;
        currentLogger(msg, state);
      }
    };
    Logger.prototype.warn = function (message, object) {
      if (this.isWarn() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length == 0 && classFilters[this.className])) {
        var dateTime = new Date().getTime();
        var msg = f("[%s-%s:%s] %s %s", 'WARN', this.className, pid, dateTime, message);
        var state = {
          type: 'warn',
          message: message,
          className: this.className,
          pid: pid,
          date: dateTime
        };
        if (object) state.meta = object;
        currentLogger(msg, state);
      }
    }, Logger.prototype.info = function (message, object) {
      if (this.isInfo() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length == 0 && classFilters[this.className])) {
        var dateTime = new Date().getTime();
        var msg = f("[%s-%s:%s] %s %s", 'INFO', this.className, pid, dateTime, message);
        var state = {
          type: 'info',
          message: message,
          className: this.className,
          pid: pid,
          date: dateTime
        };
        if (object) state.meta = object;
        currentLogger(msg, state);
      }
    }, Logger.prototype.error = function (message, object) {
      if (this.isError() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length == 0 && classFilters[this.className])) {
        var dateTime = new Date().getTime();
        var msg = f("[%s-%s:%s] %s %s", 'ERROR', this.className, pid, dateTime, message);
        var state = {
          type: 'error',
          message: message,
          className: this.className,
          pid: pid,
          date: dateTime
        };
        if (object) state.meta = object;
        currentLogger(msg, state);
      }
    }, Logger.prototype.isInfo = function () {
      return level == 'info' || level == 'debug';
    }, Logger.prototype.isError = function () {
      return level == 'error' || level == 'info' || level == 'debug';
    }, Logger.prototype.isWarn = function () {
      return level == 'error' || level == 'warn' || level == 'info' || level == 'debug';
    }, Logger.prototype.isDebug = function () {
      return level == 'debug';
    };
    Logger.reset = function () {
      level = 'error';
      filteredClasses = {};
    };
    Logger.currentLogger = function () {
      return currentLogger;
    };
    Logger.setCurrentLogger = function (logger) {
      if (typeof logger != 'function') throw new MongoError("current logger must be a function");
      currentLogger = logger;
    };
    Logger.filter = function (type, values) {
      if (type == 'class' && Array.isArray(values)) {
        filteredClasses = {};
        values.forEach(function (x) {
          filteredClasses[x] = true;
        });
      }
    };
    Logger.setLevel = function (_level) {
      if (_level != 'info' && _level != 'error' && _level != 'debug' && _level != 'warn') {
        throw new Error(f("%s is an illegal logging level", _level));
      }
      level = _level;
    };
    module.exports = Logger;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('1ad', ['1b6', '1a9', '1ab', '166', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    "use strict";

    var Long = $__require('1b6').Long,
        Logger = $__require('1a9'),
        MongoError = $__require('1ab'),
        f = $__require('166').format;
    var Cursor = function (bson, ns, cmd, options, topology, topologyOptions) {
      options = options || {};
      this.pool = null;
      this.server = null;
      this.disconnectHandler = options.disconnectHandler;
      this.bson = bson;
      this.ns = ns;
      this.cmd = cmd;
      this.options = options;
      this.topology = topology;
      this.cursorState = {
        cursorId: null,
        cmd: cmd,
        documents: options.documents || [],
        cursorIndex: 0,
        dead: false,
        killed: false,
        init: false,
        notified: false,
        limit: options.limit || cmd.limit || 0,
        skip: options.skip || cmd.skip || 0,
        batchSize: options.batchSize || cmd.batchSize || 1000,
        currentLimit: 0,
        transforms: options.transforms
      };
      if (typeof topologyOptions.promoteLongs == 'boolean') {
        this.cursorState.promoteLongs = topologyOptions.promoteLongs;
      } else if (typeof options.promoteLongs == 'boolean') {
        this.cursorState.promoteLongs = options.promoteLongs;
      }
      if (typeof topologyOptions.promoteValues == 'boolean') {
        this.cursorState.promoteValues = topologyOptions.promoteValues;
      } else if (typeof options.promoteValues == 'boolean') {
        this.cursorState.promoteValues = options.promoteValues;
      }
      if (typeof topologyOptions.promoteBuffers == 'boolean') {
        this.cursorState.promoteBuffers = topologyOptions.promoteBuffers;
      } else if (typeof options.promoteBuffers == 'boolean') {
        this.cursorState.promoteBuffers = options.promoteBuffers;
      }
      this.logger = Logger('Cursor', topologyOptions);
      if (typeof cmd == 'number') {
        this.cursorState.cursorId = Long.fromNumber(cmd);
        this.cursorState.lastCursorId = this.cursorState.cursorId;
      } else if (cmd instanceof Long) {
        this.cursorState.cursorId = cmd;
        this.cursorState.lastCursorId = cmd;
      }
    };
    Cursor.prototype.setCursorBatchSize = function (value) {
      this.cursorState.batchSize = value;
    };
    Cursor.prototype.cursorBatchSize = function () {
      return this.cursorState.batchSize;
    };
    Cursor.prototype.setCursorLimit = function (value) {
      this.cursorState.limit = value;
    };
    Cursor.prototype.cursorLimit = function () {
      return this.cursorState.limit;
    };
    Cursor.prototype.setCursorSkip = function (value) {
      this.cursorState.skip = value;
    };
    Cursor.prototype.cursorSkip = function () {
      return this.cursorState.skip;
    };
    var handleCallback = function (callback, err, result) {
      try {
        callback(err, result);
      } catch (err) {
        process.nextTick(function () {
          throw err;
        });
      }
    };
    Cursor.prototype._find = function (callback) {
      var self = this;
      if (self.logger.isDebug()) {
        self.logger.debug(f('issue initial query [%s] with flags [%s]', JSON.stringify(self.cmd), JSON.stringify(self.query)));
      }
      var queryCallback = function (err, r) {
        if (err) return callback(err);
        var result = r.message;
        if (result.queryFailure) {
          return callback(MongoError.create(result.documents[0]), null);
        }
        if (Array.isArray(result.documents) && result.documents.length == 1 && (!self.cmd.find || self.cmd.find && self.cmd.virtual == false) && (result.documents[0].cursor != 'string' || result.documents[0]['$err'] || result.documents[0]['errmsg'] || Array.isArray(result.documents[0].result))) {
          if (result.documents[0]['$err'] || result.documents[0]['errmsg']) {
            return callback(MongoError.create(result.documents[0]), null);
          }
          if (result.documents[0].cursor != null && typeof result.documents[0].cursor != 'string') {
            var id = result.documents[0].cursor.id;
            if (result.documents[0].cursor.ns) {
              self.ns = result.documents[0].cursor.ns;
            }
            self.cursorState.cursorId = typeof id == 'number' ? Long.fromNumber(id) : id;
            self.cursorState.lastCursorId = self.cursorState.cursorId;
            if (Array.isArray(result.documents[0].cursor.firstBatch)) {
              self.cursorState.documents = result.documents[0].cursor.firstBatch;
            }
            return callback(null, null);
          }
          if (Array.isArray(result.documents[0].result)) {
            self.cursorState.documents = result.documents[0].result;
            self.cursorState.cursorId = Long.ZERO;
            return callback(null, null);
          }
        }
        self.cursorState.cursorId = result.cursorId;
        self.cursorState.documents = result.documents;
        self.cursorState.lastCursorId = result.cursorId;
        if (self.cursorState.transforms && typeof self.cursorState.transforms.query == 'function') {
          self.cursorState.documents = self.cursorState.transforms.query(result);
        }
        callback(null, null);
      };
      var queryOptions = {};
      if (self.options.raw || self.cmd.raw) {
        queryOptions.raw = self.options.raw || self.cmd.raw;
      }
      if (typeof self.query.documentsReturnedIn == 'string') {
        queryOptions.documentsReturnedIn = self.query.documentsReturnedIn;
      }
      if (typeof self.cursorState.promoteLongs == 'boolean') {
        queryOptions.promoteLongs = self.cursorState.promoteLongs;
      }
      if (typeof self.cursorState.promoteValues == 'boolean') {
        queryOptions.promoteValues = self.cursorState.promoteValues;
      }
      if (typeof self.cursorState.promoteBuffers == 'boolean') {
        queryOptions.promoteBuffers = self.cursorState.promoteBuffers;
      }
      self.server.s.pool.write(self.query, queryOptions, queryCallback);
    };
    Cursor.prototype._getmore = function (callback) {
      if (this.logger.isDebug()) this.logger.debug(f('schedule getMore call for query [%s]', JSON.stringify(this.query)));
      var raw = this.options.raw || this.cmd.raw;
      var batchSize = this.cursorState.batchSize;
      if (this.cursorState.limit > 0 && this.cursorState.currentLimit + batchSize > this.cursorState.limit) {
        batchSize = this.cursorState.limit - this.cursorState.currentLimit;
      }
      var pool = this.server.s.pool;
      this.server.wireProtocolHandler.getMore(this.bson, this.ns, this.cursorState, batchSize, raw, pool, this.options, callback);
    };
    Cursor.prototype._killcursor = function (callback) {
      this.cursorState.dead = true;
      this.cursorState.killed = true;
      this.cursorState.documents = [];
      if (this.cursorState.cursorId == null || this.cursorState.cursorId.isZero() || this.cursorState.init == false) {
        if (callback) callback(null, null);
        return;
      }
      var pool = this.server.s.pool;
      this.server.wireProtocolHandler.killCursor(this.bson, this.ns, this.cursorState.cursorId, pool, callback);
    };
    Cursor.prototype.clone = function () {
      return this.topology.cursor(this.ns, this.cmd, this.options);
    };
    Cursor.prototype.isDead = function () {
      return this.cursorState.dead == true;
    };
    Cursor.prototype.isKilled = function () {
      return this.cursorState.killed == true;
    };
    Cursor.prototype.isNotified = function () {
      return this.cursorState.notified == true;
    };
    Cursor.prototype.bufferedCount = function () {
      return this.cursorState.documents.length - this.cursorState.cursorIndex;
    };
    Cursor.prototype.readBufferedDocuments = function (number) {
      var unreadDocumentsLength = this.cursorState.documents.length - this.cursorState.cursorIndex;
      var length = number < unreadDocumentsLength ? number : unreadDocumentsLength;
      var elements = this.cursorState.documents.slice(this.cursorState.cursorIndex, this.cursorState.cursorIndex + length);
      if (this.cursorState.transforms && typeof this.cursorState.transforms.doc == 'function') {
        for (var i = 0; i < elements.length; i++) {
          elements[i] = this.cursorState.transforms.doc(elements[i]);
        }
      }
      if (this.cursorState.limit > 0 && this.cursorState.currentLimit + elements.length > this.cursorState.limit) {
        elements = elements.slice(0, this.cursorState.limit - this.cursorState.currentLimit);
        this.kill();
      }
      this.cursorState.currentLimit = this.cursorState.currentLimit + elements.length;
      this.cursorState.cursorIndex = this.cursorState.cursorIndex + elements.length;
      return elements;
    };
    Cursor.prototype.kill = function (callback) {
      this._killcursor(callback);
    };
    Cursor.prototype.rewind = function () {
      if (this.cursorState.init) {
        if (!this.cursorState.dead) {
          this.kill();
        }
        this.cursorState.currentLimit = 0;
        this.cursorState.init = false;
        this.cursorState.dead = false;
        this.cursorState.killed = false;
        this.cursorState.notified = false;
        this.cursorState.documents = [];
        this.cursorState.cursorId = null;
        this.cursorState.cursorIndex = 0;
      }
    };
    var isConnectionDead = function (self, callback) {
      if (self.pool && self.pool.isDestroyed()) {
        self.cursorState.notified = true;
        self.cursorState.killed = true;
        self.cursorState.documents = [];
        self.cursorState.cursorIndex = 0;
        callback(MongoError.create(f('connection to host %s:%s was destroyed', self.pool.host, self.pool.port)));
        return true;
      }
      return false;
    };
    var isCursorDeadButNotkilled = function (self, callback) {
      if (self.cursorState.dead && !self.cursorState.killed) {
        self.cursorState.notified = true;
        self.cursorState.killed = true;
        self.cursorState.documents = [];
        self.cursorState.cursorIndex = 0;
        handleCallback(callback, null, null);
        return true;
      }
      return false;
    };
    var isCursorDeadAndKilled = function (self, callback) {
      if (self.cursorState.dead && self.cursorState.killed) {
        handleCallback(callback, MongoError.create('cursor is dead'));
        return true;
      }
      return false;
    };
    var isCursorKilled = function (self, callback) {
      if (self.cursorState.killed) {
        self.cursorState.notified = true;
        self.cursorState.documents = [];
        self.cursorState.cursorIndex = 0;
        handleCallback(callback, null, null);
        return true;
      }
      return false;
    };
    var setCursorDeadAndNotified = function (self, callback) {
      self.cursorState.dead = true;
      self.cursorState.notified = true;
      self.cursorState.documents = [];
      self.cursorState.cursorIndex = 0;
      handleCallback(callback, null, null);
    };
    var setCursorNotified = function (self, callback) {
      self.cursorState.notified = true;
      self.cursorState.documents = [];
      self.cursorState.cursorIndex = 0;
      handleCallback(callback, null, null);
    };
    var nextFunction = function (self, callback) {
      if (self.cursorState.notified) {
        return callback(new Error('cursor is exhausted'));
      }
      if (isCursorKilled(self, callback)) return;
      if (isCursorDeadButNotkilled(self, callback)) return;
      if (isCursorDeadAndKilled(self, callback)) return;
      if (!self.cursorState.init) {
        if (!self.topology.isConnected(self.options) && self.disconnectHandler != null) {
          if (self.topology.isDestroyed()) {
            return callback(new MongoError('Topology was destroyed'));
          }
          return self.disconnectHandler.addObjectAndMethod('cursor', self, 'next', [callback], callback);
        }
        try {
          self.server = self.topology.getServer(self.options);
        } catch (err) {
          if (self.disconnectHandler != null) {
            return self.disconnectHandler.addObjectAndMethod('cursor', self, 'next', [callback], callback);
          }
          return callback(err);
        }
        self.cursorState.init = true;
        if (self.cmd && self.cmd.collation && self.server.ismaster.maxWireVersion < 5) {
          return callback(new MongoError(f('server %s does not support collation', self.server.name)));
        }
        try {
          self.query = self.server.wireProtocolHandler.command(self.bson, self.ns, self.cmd, self.cursorState, self.topology, self.options);
        } catch (err) {
          return callback(err);
        }
      }
      if (self.cursorState.cursorId == null) {
        if (isConnectionDead(self, callback)) return;
        if (self.topology.isDestroyed()) return callback(new MongoError('connection destroyed, not possible to instantiate cursor'));
        self._find(function (err) {
          if (err) return handleCallback(callback, err, null);
          if (self.cursorState.documents.length == 0 && self.cursorState.cursorId && self.cursorState.cursorId.isZero() && !self.cmd.tailable && !self.cmd.awaitData) {
            return setCursorNotified(self, callback);
          }
          nextFunction(self, callback);
        });
      } else if (self.cursorState.limit > 0 && self.cursorState.currentLimit >= self.cursorState.limit) {
        self.kill();
        return setCursorDeadAndNotified(self, callback);
      } else if (self.cursorState.cursorIndex == self.cursorState.documents.length && !Long.ZERO.equals(self.cursorState.cursorId)) {
        self.cursorState.documents = [];
        self.cursorState.cursorIndex = 0;
        if (self.topology.isDestroyed()) return callback(new MongoError('connection destroyed, not possible to instantiate cursor'));
        if (isConnectionDead(self, callback)) return;
        self._getmore(function (err, doc, connection) {
          if (err) return handleCallback(callback, err);
          self.connection = connection;
          if (self.cursorState.documents.length == 0 && self.cmd.tailable && Long.ZERO.equals(self.cursorState.cursorId)) {
            return handleCallback(callback, MongoError.create({
              message: 'No more documents in tailed cursor',
              tailable: self.cmd.tailable,
              awaitData: self.cmd.awaitData
            }));
          } else if (self.cursorState.documents.length == 0 && self.cmd.tailable && !Long.ZERO.equals(self.cursorState.cursorId)) {
            return nextFunction(self, callback);
          }
          if (self.cursorState.limit > 0 && self.cursorState.currentLimit >= self.cursorState.limit) {
            return setCursorDeadAndNotified(self, callback);
          }
          nextFunction(self, callback);
        });
      } else if (self.cursorState.documents.length == self.cursorState.cursorIndex && self.cmd.tailable && Long.ZERO.equals(self.cursorState.cursorId)) {
        return handleCallback(callback, MongoError.create({
          message: 'No more documents in tailed cursor',
          tailable: self.cmd.tailable,
          awaitData: self.cmd.awaitData
        }));
      } else if (self.cursorState.documents.length == self.cursorState.cursorIndex && Long.ZERO.equals(self.cursorState.cursorId)) {
        setCursorDeadAndNotified(self, callback);
      } else {
        if (self.cursorState.limit > 0 && self.cursorState.currentLimit >= self.cursorState.limit) {
          self.kill();
          return setCursorDeadAndNotified(self, callback);
        }
        self.cursorState.currentLimit += 1;
        var doc = self.cursorState.documents[self.cursorState.cursorIndex++];
        if (doc.$err) {
          self.kill();
          return setCursorDeadAndNotified(self, function () {
            handleCallback(callback, new MongoError(doc.$err));
          });
        }
        if (self.cursorState.transforms && typeof self.cursorState.transforms.doc == 'function') {
          doc = self.cursorState.transforms.doc(doc);
        }
        handleCallback(callback, null, doc);
      }
    };
    Cursor.prototype.next = function (callback) {
      nextFunction(this, callback);
    };
    module.exports = Cursor;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('1aa', [], true, function ($__require, exports, module) {
  /* */
  "use strict";

  var define,
      global = this || self,
      GLOBAL = global;
  var needSlaveOk = ['primaryPreferred', 'secondary', 'secondaryPreferred', 'nearest'];

  /**
   * @fileOverview The **ReadPreference** class is a class that represents a MongoDB ReadPreference and is
   * used to construct connections.
   *
   * @example
   * var ReplSet = require('mongodb-core').ReplSet
   *   , ReadPreference = require('mongodb-core').ReadPreference
   *   , assert = require('assert');
   *
   * var server = new ReplSet([{host: 'localhost', port: 30000}], {setName: 'rs'});
   * // Wait for the connection event
   * server.on('connect', function(server) {
   *   var cursor = server.cursor('db.test'
   *     , {find: 'db.test', query: {}}
   *     , {readPreference: new ReadPreference('secondary')});
   *   cursor.next(function(err, doc) {
   *     server.destroy();
   *   });
   * });
   *
   * // Start connecting
   * server.connect();
   */

  /**
   * Creates a new Pool instance
   * @class
   * @param {string} preference A string describing the preference (primary|primaryPreferred|secondary|secondaryPreferred|nearest)
   * @param {array} tags The tags object
   * @param {object} [options] Additional read preference options
   * @param {number} [options.maxStalenessSeconds] Max Secondary Read Stalleness in Seconds, Minimum value is 90 seconds.
   * @property {string} preference The preference string (primary|primaryPreferred|secondary|secondaryPreferred|nearest)
   * @property {array} tags The tags object
   * @property {object} options Additional read preference options
   * @property {number} maxStalenessSeconds MaxStalenessSeconds value for the read preference
   * @return {ReadPreference}
   */
  var ReadPreference = function (preference, tags, options) {
    this.preference = preference;
    this.tags = tags;
    this.options = options;

    // Add the maxStalenessSeconds value to the read Preference
    if (this.options && this.options.maxStalenessSeconds != null) {
      this.options = options;
      this.maxStalenessSeconds = this.options.maxStalenessSeconds >= 0 ? this.options.maxStalenessSeconds : null;
    } else if (tags && typeof tags == 'object') {
      this.options = tags, tags = null;
    }
  };

  /**
   * This needs slaveOk bit set
   * @method
   * @return {boolean}
   */
  ReadPreference.prototype.slaveOk = function () {
    return needSlaveOk.indexOf(this.preference) != -1;
  };

  /**
   * Are the two read preference equal
   * @method
   * @return {boolean}
   */
  ReadPreference.prototype.equals = function (readPreference) {
    return readPreference.preference == this.preference;
  };

  /**
   * Return JSON representation
   * @method
   * @return {Object}
   */
  ReadPreference.prototype.toJSON = function () {
    var readPreference = { mode: this.preference };
    if (Array.isArray(this.tags)) readPreference.tags = this.tags;
    if (this.maxStalenessSeconds) readPreference.maxStalenessSeconds = this.maxStalenessSeconds;
    return readPreference;
  };

  /**
   * Primary read preference
   * @method
   * @return {ReadPreference}
   */
  ReadPreference.primary = new ReadPreference('primary');
  /**
   * Primary Preferred read preference
   * @method
   * @return {ReadPreference}
   */
  ReadPreference.primaryPreferred = new ReadPreference('primaryPreferred');
  /**
   * Secondary read preference
   * @method
   * @return {ReadPreference}
   */
  ReadPreference.secondary = new ReadPreference('secondary');
  /**
   * Secondary Preferred read preference
   * @method
   * @return {ReadPreference}
   */
  ReadPreference.secondaryPreferred = new ReadPreference('secondaryPreferred');
  /**
   * Nearest read preference
   * @method
   * @return {ReadPreference}
   */
  ReadPreference.nearest = new ReadPreference('nearest');

  module.exports = ReadPreference;
  return module.exports;
});
$__System.registerDynamic('1b0', ['166', '38', '1c2', '1ab', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    "use strict";

    var f = $__require('166').format,
        crypto = $__require('38'),
        Query = $__require('1c2').Query,
        MongoError = $__require('1ab');
    var AuthSession = function (db, username, password) {
      this.db = db;
      this.username = username;
      this.password = password;
    };
    AuthSession.prototype.equal = function (session) {
      return session.db == this.db && session.username == this.username && session.password == this.password;
    };
    var MongoCR = function (bson) {
      this.bson = bson;
      this.authStore = [];
    };
    var addAuthSession = function (authStore, session) {
      var found = false;
      for (var i = 0; i < authStore.length; i++) {
        if (authStore[i].equal(session)) {
          found = true;
          break;
        }
      }
      if (!found) authStore.push(session);
    };
    MongoCR.prototype.auth = function (server, connections, db, username, password, callback) {
      var self = this;
      var count = connections.length;
      if (count == 0) return callback(null, null);
      var numberOfValidConnections = 0;
      var errorObject = null;
      while (connections.length > 0) {
        var executeMongoCR = function (connection) {
          server(connection, new Query(self.bson, f("%s.$cmd", db), { getnonce: 1 }, {
            numberToSkip: 0,
            numberToReturn: 1
          }), function (err, r) {
            var nonce = null;
            var key = null;
            if (err == null) {
              nonce = r.result.nonce;
              var md5 = crypto.createHash('md5');
              md5.update(username + ":mongo:" + password, 'utf8');
              var hash_password = md5.digest('hex');
              md5 = crypto.createHash('md5');
              md5.update(nonce + username + hash_password, 'utf8');
              key = md5.digest('hex');
            }
            server(connection, new Query(self.bson, f("%s.$cmd", db), {
              authenticate: 1,
              user: username,
              nonce: nonce,
              key: key
            }, {
              numberToSkip: 0,
              numberToReturn: 1
            }), function (err, r) {
              count = count - 1;
              if (err) {
                errorObject = err;
              } else if (r.result['$err']) {
                errorObject = r.result;
              } else if (r.result['errmsg']) {
                errorObject = r.result;
              } else {
                numberOfValidConnections = numberOfValidConnections + 1;
              }
              if (count == 0 && numberOfValidConnections > 0) {
                addAuthSession(self.authStore, new AuthSession(db, username, password));
                callback(null, true);
              } else if (count == 0) {
                if (errorObject == null) errorObject = new MongoError(f("failed to authenticate using mongocr"));
                callback(errorObject, false);
              }
            });
          });
        };
        var _execute = function (_connection) {
          process.nextTick(function () {
            executeMongoCR(_connection);
          });
        };
        _execute(connections.shift());
      }
    };
    MongoCR.prototype.logout = function (dbName) {
      this.authStore = this.authStore.filter(function (x) {
        return x.db != dbName;
      });
    };
    MongoCR.prototype.reauthenticate = function (server, connections, callback) {
      var authStore = this.authStore.slice(0);
      var count = authStore.length;
      if (count == 0) return callback(null, null);
      for (var i = 0; i < authStore.length; i++) {
        this.auth(server, connections, authStore[i].db, authStore[i].username, authStore[i].password, function (err) {
          count = count - 1;
          if (count == 0) {
            callback(err, null);
          }
        });
      }
    };
    module.exports = MongoCR;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('1b1', ['166', '1c2', '1ab', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    "use strict";

    var f = $__require('166').format,
        Query = $__require('1c2').Query,
        MongoError = $__require('1ab');
    var AuthSession = function (db, username, password) {
      this.db = db;
      this.username = username;
      this.password = password;
    };
    AuthSession.prototype.equal = function (session) {
      return session.db == this.db && session.username == this.username && session.password == this.password;
    };
    var X509 = function (bson) {
      this.bson = bson;
      this.authStore = [];
    };
    X509.prototype.auth = function (server, connections, db, username, password, callback) {
      var self = this;
      var count = connections.length;
      if (count == 0) return callback(null, null);
      var numberOfValidConnections = 0;
      var errorObject = null;
      while (connections.length > 0) {
        var execute = function (connection) {
          var command = {
            authenticate: 1,
            mechanism: 'MONGODB-X509'
          };
          if (username) {
            command.user = username;
          }
          server(connection, new Query(self.bson, "$external.$cmd", command, {
            numberToSkip: 0,
            numberToReturn: 1
          }), function (err, r) {
            count = count - 1;
            if (err) {
              errorObject = err;
            } else if (r.result['$err']) {
              errorObject = r.result;
            } else if (r.result['errmsg']) {
              errorObject = r.result;
            } else {
              numberOfValidConnections = numberOfValidConnections + 1;
            }
            if (count == 0 && numberOfValidConnections > 0) {
              addAuthSession(self.authStore, new AuthSession(db, username, password));
              callback(null, true);
            } else if (count == 0) {
              if (errorObject == null) errorObject = new MongoError(f("failed to authenticate using mongocr"));
              callback(errorObject, false);
            }
          });
        };
        var _execute = function (_connection) {
          process.nextTick(function () {
            execute(_connection);
          });
        };
        _execute(connections.shift());
      }
    };
    var addAuthSession = function (authStore, session) {
      var found = false;
      for (var i = 0; i < authStore.length; i++) {
        if (authStore[i].equal(session)) {
          found = true;
          break;
        }
      }
      if (!found) authStore.push(session);
    };
    X509.prototype.logout = function (dbName) {
      this.authStore = this.authStore.filter(function (x) {
        return x.db != dbName;
      });
    };
    X509.prototype.reauthenticate = function (server, connections, callback) {
      var authStore = this.authStore.slice(0);
      var count = authStore.length;
      if (count == 0) return callback(null, null);
      for (var i = 0; i < authStore.length; i++) {
        this.auth(server, connections, authStore[i].db, authStore[i].username, authStore[i].password, function (err) {
          count = count - 1;
          if (count == 0) {
            callback(err, null);
          }
        });
      }
    };
    module.exports = X509;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('1b2', ['166', '1b6', '1c2', '1ab', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    "use strict";

    var f = $__require('166').format,
        Binary = $__require('1b6').Binary,
        Query = $__require('1c2').Query,
        MongoError = $__require('1ab');
    var AuthSession = function (db, username, password) {
      this.db = db;
      this.username = username;
      this.password = password;
    };
    AuthSession.prototype.equal = function (session) {
      return session.db == this.db && session.username == this.username && session.password == this.password;
    };
    var Plain = function (bson) {
      this.bson = bson;
      this.authStore = [];
    };
    Plain.prototype.auth = function (server, connections, db, username, password, callback) {
      var self = this;
      var count = connections.length;
      if (count == 0) return callback(null, null);
      var numberOfValidConnections = 0;
      var errorObject = null;
      while (connections.length > 0) {
        var execute = function (connection) {
          var payload = new Binary(f("\x00%s\x00%s", username, password));
          var command = {
            saslStart: 1,
            mechanism: 'PLAIN',
            payload: payload,
            autoAuthorize: 1
          };
          server(connection, new Query(self.bson, "$external.$cmd", command, {
            numberToSkip: 0,
            numberToReturn: 1
          }), function (err, r) {
            count = count - 1;
            if (err) {
              errorObject = err;
            } else if (r.result['$err']) {
              errorObject = r.result;
            } else if (r.result['errmsg']) {
              errorObject = r.result;
            } else {
              numberOfValidConnections = numberOfValidConnections + 1;
            }
            if (count == 0 && numberOfValidConnections > 0) {
              addAuthSession(self.authStore, new AuthSession(db, username, password));
              callback(null, true);
            } else if (count == 0) {
              if (errorObject == null) errorObject = new MongoError(f("failed to authenticate using mongocr"));
              callback(errorObject, false);
            }
          });
        };
        var _execute = function (_connection) {
          process.nextTick(function () {
            execute(_connection);
          });
        };
        _execute(connections.shift());
      }
    };
    var addAuthSession = function (authStore, session) {
      var found = false;
      for (var i = 0; i < authStore.length; i++) {
        if (authStore[i].equal(session)) {
          found = true;
          break;
        }
      }
      if (!found) authStore.push(session);
    };
    Plain.prototype.logout = function (dbName) {
      this.authStore = this.authStore.filter(function (x) {
        return x.db != dbName;
      });
    };
    Plain.prototype.reauthenticate = function (server, connections, callback) {
      var authStore = this.authStore.slice(0);
      var count = authStore.length;
      if (count == 0) return callback(null, null);
      for (var i = 0; i < authStore.length; i++) {
        this.auth(server, connections, authStore[i].db, authStore[i].username, authStore[i].password, function (err) {
          count = count - 1;
          if (count == 0) {
            callback(err, null);
          }
        });
      }
    };
    module.exports = Plain;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('1cf', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  if ($__System._nodeRequire) {
    module.exports = $__System._nodeRequire('fs');
  } else {

    exports.readFileSync = function (address) {
      var output;
      var xhr = new XMLHttpRequest();
      xhr.open('GET', address, false);
      xhr.onreadystatechange = function (e) {
        if (xhr.readyState == 4) {
          var status = xhr.status;
          if (status > 399 && status < 600 || status == 400) {
            throw 'File read error on ' + address;
          } else output = xhr.responseText;
        }
      };
      xhr.send(null);
      return output;
    };
  }
  return module.exports;
});
$__System.registerDynamic("7", ["1cf"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("1cf");
  return module.exports;
});
$__System.registerDynamic('1d0', ['13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    function normalizeArray(parts, allowAboveRoot) {
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === '.') {
          parts.splice(i, 1);
        } else if (last === '..') {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }
      if (allowAboveRoot) {
        for (; up--; up) {
          parts.unshift('..');
        }
      }
      return parts;
    }
    var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
    var splitPath = function (filename) {
      return splitPathRe.exec(filename).slice(1);
    };
    exports.resolve = function () {
      var resolvedPath = '',
          resolvedAbsolute = false;
      for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path = i >= 0 ? arguments[i] : process.cwd();
        if (typeof path !== 'string') {
          throw new TypeError('Arguments to path.resolve must be strings');
        } else if (!path) {
          continue;
        }
        resolvedPath = path + '/' + resolvedPath;
        resolvedAbsolute = path.charAt(0) === '/';
      }
      resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function (p) {
        return !!p;
      }), !resolvedAbsolute).join('/');
      return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
    };
    exports.normalize = function (path) {
      var isAbsolute = exports.isAbsolute(path),
          trailingSlash = substr(path, -1) === '/';
      path = normalizeArray(filter(path.split('/'), function (p) {
        return !!p;
      }), !isAbsolute).join('/');
      if (!path && !isAbsolute) {
        path = '.';
      }
      if (path && trailingSlash) {
        path += '/';
      }
      return (isAbsolute ? '/' : '') + path;
    };
    exports.isAbsolute = function (path) {
      return path.charAt(0) === '/';
    };
    exports.join = function () {
      var paths = Array.prototype.slice.call(arguments, 0);
      return exports.normalize(filter(paths, function (p, index) {
        if (typeof p !== 'string') {
          throw new TypeError('Arguments to path.join must be strings');
        }
        return p;
      }).join('/'));
    };
    exports.relative = function (from, to) {
      from = exports.resolve(from).substr(1);
      to = exports.resolve(to).substr(1);
      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== '') break;
        }
        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== '') break;
        }
        if (start > end) return [];
        return arr.slice(start, end - start + 1);
      }
      var fromParts = trim(from.split('/'));
      var toParts = trim(to.split('/'));
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push('..');
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join('/');
    };
    exports.sep = '/';
    exports.delimiter = ':';
    exports.dirname = function (path) {
      var result = splitPath(path),
          root = result[0],
          dir = result[1];
      if (!root && !dir) {
        return '.';
      }
      if (dir) {
        dir = dir.substr(0, dir.length - 1);
      }
      return root + dir;
    };
    exports.basename = function (path, ext) {
      var f = splitPath(path)[2];
      if (ext && f.substr(-1 * ext.length) === ext) {
        f = f.substr(0, f.length - ext.length);
      }
      return f;
    };
    exports.extname = function (path) {
      return splitPath(path)[3];
    };
    function filter(xs, f) {
      if (xs.filter) return xs.filter(f);
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
      }
      return res;
    }
    var substr = 'ab'.substr(-1) === 'b' ? function (str, start, len) {
      return str.substr(start, len);
    } : function (str, start, len) {
      if (start < 0) start = str.length + start;
      return str.substr(start, len);
    };
    ;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic("1d1", ["1d0"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("1d0");
  return module.exports;
});
$__System.registerDynamic('1d2', ['1d1'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  module.exports = $__System._nodeRequire ? $__System._nodeRequire('path') : $__require('1d1');
  return module.exports;
});
$__System.registerDynamic("9", ["1d2"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("1d2");
  return module.exports;
});
$__System.registerDynamic('1d3', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__System._nodeRequire && $__System._nodeRequire('module');
  return module.exports;
});
$__System.registerDynamic("1d4", ["1d3"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("1d3");
  return module.exports;
});
$__System.registerDynamic('1d5', ['9', '1d4'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var path = $__require('9');
  var Module = $__require('1d4');
  module.exports = function (fromDir, moduleId) {
    if (typeof fromDir !== 'string' || typeof moduleId !== 'string') {
      throw new TypeError('Expected `fromDir` and `moduleId` to be a string');
    }
    fromDir = path.resolve(fromDir);
    var fromFile = path.join(fromDir, 'noop.js');
    try {
      return Module._resolveFilename(moduleId, {
        id: fromFile,
        filename: fromFile,
        paths: Module._nodeModulePaths(fromDir)
      });
    } catch (err) {
      return null;
    }
  };
  return module.exports;
});
$__System.registerDynamic("1d6", ["1d5"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("1d5");
  return module.exports;
});
$__System.registerDynamic('1d7', ['13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    exports = module.exports = SemVer;
    var debug;
    if (typeof process === 'object' && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) debug = function () {
      var args = Array.prototype.slice.call(arguments, 0);
      args.unshift('SEMVER');
      console.log.apply(console, args);
    };else debug = function () {};
    exports.SEMVER_SPEC_VERSION = '2.0.0';
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var re = exports.re = [];
    var src = exports.src = [];
    var R = 0;
    var NUMERICIDENTIFIER = R++;
    src[NUMERICIDENTIFIER] = '0|[1-9]\\d*';
    var NUMERICIDENTIFIERLOOSE = R++;
    src[NUMERICIDENTIFIERLOOSE] = '[0-9]+';
    var NONNUMERICIDENTIFIER = R++;
    src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*';
    var MAINVERSION = R++;
    src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' + '(' + src[NUMERICIDENTIFIER] + ')\\.' + '(' + src[NUMERICIDENTIFIER] + ')';
    var MAINVERSIONLOOSE = R++;
    src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[NUMERICIDENTIFIERLOOSE] + ')';
    var PRERELEASEIDENTIFIER = R++;
    src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] + '|' + src[NONNUMERICIDENTIFIER] + ')';
    var PRERELEASEIDENTIFIERLOOSE = R++;
    src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] + '|' + src[NONNUMERICIDENTIFIER] + ')';
    var PRERELEASE = R++;
    src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] + '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))';
    var PRERELEASELOOSE = R++;
    src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] + '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';
    var BUILDIDENTIFIER = R++;
    src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';
    var BUILD = R++;
    src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] + '(?:\\.' + src[BUILDIDENTIFIER] + ')*))';
    var FULL = R++;
    var FULLPLAIN = 'v?' + src[MAINVERSION] + src[PRERELEASE] + '?' + src[BUILD] + '?';
    src[FULL] = '^' + FULLPLAIN + '$';
    var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + '?' + src[BUILD] + '?';
    var LOOSE = R++;
    src[LOOSE] = '^' + LOOSEPLAIN + '$';
    var GTLT = R++;
    src[GTLT] = '((?:<|>)?=?)';
    var XRANGEIDENTIFIERLOOSE = R++;
    src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
    var XRANGEIDENTIFIER = R++;
    src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*';
    var XRANGEPLAIN = R++;
    src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' + '(?:' + src[PRERELEASE] + ')?' + src[BUILD] + '?' + ')?)?';
    var XRANGEPLAINLOOSE = R++;
    src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' + '(?:' + src[PRERELEASELOOSE] + ')?' + src[BUILD] + '?' + ')?)?';
    var XRANGE = R++;
    src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$';
    var XRANGELOOSE = R++;
    src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$';
    var LONETILDE = R++;
    src[LONETILDE] = '(?:~>?)';
    var TILDETRIM = R++;
    src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+';
    re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');
    var tildeTrimReplace = '$1~';
    var TILDE = R++;
    src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';
    var TILDELOOSE = R++;
    src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';
    var LONECARET = R++;
    src[LONECARET] = '(?:\\^)';
    var CARETTRIM = R++;
    src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+';
    re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');
    var caretTrimReplace = '$1^';
    var CARET = R++;
    src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';
    var CARETLOOSE = R++;
    src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';
    var COMPARATORLOOSE = R++;
    src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$';
    var COMPARATOR = R++;
    src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$';
    var COMPARATORTRIM = R++;
    src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] + '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';
    re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');
    var comparatorTrimReplace = '$1$2$3';
    var HYPHENRANGE = R++;
    src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' + '\\s+-\\s+' + '(' + src[XRANGEPLAIN] + ')' + '\\s*$';
    var HYPHENRANGELOOSE = R++;
    src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' + '\\s+-\\s+' + '(' + src[XRANGEPLAINLOOSE] + ')' + '\\s*$';
    var STAR = R++;
    src[STAR] = '(<|>)?=?\\s*\\*';
    for (var i = 0; i < R; i++) {
      debug(i, src[i]);
      if (!re[i]) re[i] = new RegExp(src[i]);
    }
    exports.parse = parse;
    function parse(version, loose) {
      if (version instanceof SemVer) return version;
      if (typeof version !== 'string') return null;
      if (version.length > MAX_LENGTH) return null;
      var r = loose ? re[LOOSE] : re[FULL];
      if (!r.test(version)) return null;
      try {
        return new SemVer(version, loose);
      } catch (er) {
        return null;
      }
    }
    exports.valid = valid;
    function valid(version, loose) {
      var v = parse(version, loose);
      return v ? v.version : null;
    }
    exports.clean = clean;
    function clean(version, loose) {
      var s = parse(version.trim().replace(/^[=v]+/, ''), loose);
      return s ? s.version : null;
    }
    exports.SemVer = SemVer;
    function SemVer(version, loose) {
      if (version instanceof SemVer) {
        if (version.loose === loose) return version;else version = version.version;
      } else if (typeof version !== 'string') {
        throw new TypeError('Invalid Version: ' + version);
      }
      if (version.length > MAX_LENGTH) throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters');
      if (!(this instanceof SemVer)) return new SemVer(version, loose);
      debug('SemVer', version, loose);
      this.loose = loose;
      var m = version.trim().match(loose ? re[LOOSE] : re[FULL]);
      if (!m) throw new TypeError('Invalid Version: ' + version);
      this.raw = version;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) throw new TypeError('Invalid major version');
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) throw new TypeError('Invalid minor version');
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) throw new TypeError('Invalid patch version');
      if (!m[4]) this.prerelease = [];else this.prerelease = m[4].split('.').map(function (id) {
        if (/^[0-9]+$/.test(id)) {
          var num = +id;
          if (num >= 0 && num < MAX_SAFE_INTEGER) return num;
        }
        return id;
      });
      this.build = m[5] ? m[5].split('.') : [];
      this.format();
    }
    SemVer.prototype.format = function () {
      this.version = this.major + '.' + this.minor + '.' + this.patch;
      if (this.prerelease.length) this.version += '-' + this.prerelease.join('.');
      return this.version;
    };
    SemVer.prototype.toString = function () {
      return this.version;
    };
    SemVer.prototype.compare = function (other) {
      debug('SemVer.compare', this.version, this.loose, other);
      if (!(other instanceof SemVer)) other = new SemVer(other, this.loose);
      return this.compareMain(other) || this.comparePre(other);
    };
    SemVer.prototype.compareMain = function (other) {
      if (!(other instanceof SemVer)) other = new SemVer(other, this.loose);
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };
    SemVer.prototype.comparePre = function (other) {
      if (!(other instanceof SemVer)) other = new SemVer(other, this.loose);
      if (this.prerelease.length && !other.prerelease.length) return -1;else if (!this.prerelease.length && other.prerelease.length) return 1;else if (!this.prerelease.length && !other.prerelease.length) return 0;
      var i = 0;
      do {
        var a = this.prerelease[i];
        var b = other.prerelease[i];
        debug('prerelease compare', i, a, b);
        if (a === undefined && b === undefined) return 0;else if (b === undefined) return 1;else if (a === undefined) return -1;else if (a === b) continue;else return compareIdentifiers(a, b);
      } while (++i);
    };
    SemVer.prototype.inc = function (release, identifier) {
      switch (release) {
        case 'premajor':
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc('pre', identifier);
          break;
        case 'preminor':
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc('pre', identifier);
          break;
        case 'prepatch':
          this.prerelease.length = 0;
          this.inc('patch', identifier);
          this.inc('pre', identifier);
          break;
        case 'prerelease':
          if (this.prerelease.length === 0) this.inc('patch', identifier);
          this.inc('pre', identifier);
          break;
        case 'major':
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) this.major++;
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case 'minor':
          if (this.patch !== 0 || this.prerelease.length === 0) this.minor++;
          this.patch = 0;
          this.prerelease = [];
          break;
        case 'patch':
          if (this.prerelease.length === 0) this.patch++;
          this.prerelease = [];
          break;
        case 'pre':
          if (this.prerelease.length === 0) this.prerelease = [0];else {
            var i = this.prerelease.length;
            while (--i >= 0) {
              if (typeof this.prerelease[i] === 'number') {
                this.prerelease[i]++;
                i = -2;
              }
            }
            if (i === -1) this.prerelease.push(0);
          }
          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) this.prerelease = [identifier, 0];
            } else this.prerelease = [identifier, 0];
          }
          break;
        default:
          throw new Error('invalid increment argument: ' + release);
      }
      this.format();
      this.raw = this.version;
      return this;
    };
    exports.inc = inc;
    function inc(version, release, loose, identifier) {
      if (typeof loose === 'string') {
        identifier = loose;
        loose = undefined;
      }
      try {
        return new SemVer(version, loose).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    }
    exports.diff = diff;
    function diff(version1, version2) {
      if (eq(version1, version2)) {
        return null;
      } else {
        var v1 = parse(version1);
        var v2 = parse(version2);
        if (v1.prerelease.length || v2.prerelease.length) {
          for (var key in v1) {
            if (key === 'major' || key === 'minor' || key === 'patch') {
              if (v1[key] !== v2[key]) {
                return 'pre' + key;
              }
            }
          }
          return 'prerelease';
        }
        for (var key in v1) {
          if (key === 'major' || key === 'minor' || key === 'patch') {
            if (v1[key] !== v2[key]) {
              return key;
            }
          }
        }
      }
    }
    exports.compareIdentifiers = compareIdentifiers;
    var numeric = /^[0-9]+$/;
    function compareIdentifiers(a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : a > b ? 1 : 0;
    }
    exports.rcompareIdentifiers = rcompareIdentifiers;
    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }
    exports.major = major;
    function major(a, loose) {
      return new SemVer(a, loose).major;
    }
    exports.minor = minor;
    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }
    exports.patch = patch;
    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }
    exports.compare = compare;
    function compare(a, b, loose) {
      return new SemVer(a, loose).compare(b);
    }
    exports.compareLoose = compareLoose;
    function compareLoose(a, b) {
      return compare(a, b, true);
    }
    exports.rcompare = rcompare;
    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }
    exports.sort = sort;
    function sort(list, loose) {
      return list.sort(function (a, b) {
        return exports.compare(a, b, loose);
      });
    }
    exports.rsort = rsort;
    function rsort(list, loose) {
      return list.sort(function (a, b) {
        return exports.rcompare(a, b, loose);
      });
    }
    exports.gt = gt;
    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }
    exports.lt = lt;
    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }
    exports.eq = eq;
    function eq(a, b, loose) {
      return compare(a, b, loose) === 0;
    }
    exports.neq = neq;
    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }
    exports.gte = gte;
    function gte(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }
    exports.lte = lte;
    function lte(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }
    exports.cmp = cmp;
    function cmp(a, op, b, loose) {
      var ret;
      switch (op) {
        case '===':
          if (typeof a === 'object') a = a.version;
          if (typeof b === 'object') b = b.version;
          ret = a === b;
          break;
        case '!==':
          if (typeof a === 'object') a = a.version;
          if (typeof b === 'object') b = b.version;
          ret = a !== b;
          break;
        case '':
        case '=':
        case '==':
          ret = eq(a, b, loose);
          break;
        case '!=':
          ret = neq(a, b, loose);
          break;
        case '>':
          ret = gt(a, b, loose);
          break;
        case '>=':
          ret = gte(a, b, loose);
          break;
        case '<':
          ret = lt(a, b, loose);
          break;
        case '<=':
          ret = lte(a, b, loose);
          break;
        default:
          throw new TypeError('Invalid operator: ' + op);
      }
      return ret;
    }
    exports.Comparator = Comparator;
    function Comparator(comp, loose) {
      if (comp instanceof Comparator) {
        if (comp.loose === loose) return comp;else comp = comp.value;
      }
      if (!(this instanceof Comparator)) return new Comparator(comp, loose);
      debug('comparator', comp, loose);
      this.loose = loose;
      this.parse(comp);
      if (this.semver === ANY) this.value = '';else this.value = this.operator + this.semver.version;
      debug('comp', this);
    }
    var ANY = {};
    Comparator.prototype.parse = function (comp) {
      var r = this.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
      var m = comp.match(r);
      if (!m) throw new TypeError('Invalid comparator: ' + comp);
      this.operator = m[1];
      if (this.operator === '=') this.operator = '';
      if (!m[2]) this.semver = ANY;else this.semver = new SemVer(m[2], this.loose);
    };
    Comparator.prototype.toString = function () {
      return this.value;
    };
    Comparator.prototype.test = function (version) {
      debug('Comparator.test', version, this.loose);
      if (this.semver === ANY) return true;
      if (typeof version === 'string') version = new SemVer(version, this.loose);
      return cmp(version, this.operator, this.semver, this.loose);
    };
    exports.Range = Range;
    function Range(range, loose) {
      if (range instanceof Range && range.loose === loose) return range;
      if (!(this instanceof Range)) return new Range(range, loose);
      this.loose = loose;
      this.raw = range;
      this.set = range.split(/\s*\|\|\s*/).map(function (range) {
        return this.parseRange(range.trim());
      }, this).filter(function (c) {
        return c.length;
      });
      if (!this.set.length) {
        throw new TypeError('Invalid SemVer Range: ' + range);
      }
      this.format();
    }
    Range.prototype.format = function () {
      this.range = this.set.map(function (comps) {
        return comps.join(' ').trim();
      }).join('||').trim();
      return this.range;
    };
    Range.prototype.toString = function () {
      return this.range;
    };
    Range.prototype.parseRange = function (range) {
      var loose = this.loose;
      range = range.trim();
      debug('range', range, loose);
      var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug('hyphen replace', range);
      range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
      debug('comparator trim', range, re[COMPARATORTRIM]);
      range = range.replace(re[TILDETRIM], tildeTrimReplace);
      range = range.replace(re[CARETTRIM], caretTrimReplace);
      range = range.split(/\s+/).join(' ');
      var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
      var set = range.split(' ').map(function (comp) {
        return parseComparator(comp, loose);
      }).join(' ').split(/\s+/);
      if (this.loose) {
        set = set.filter(function (comp) {
          return !!comp.match(compRe);
        });
      }
      set = set.map(function (comp) {
        return new Comparator(comp, loose);
      });
      return set;
    };
    exports.toComparators = toComparators;
    function toComparators(range, loose) {
      return new Range(range, loose).set.map(function (comp) {
        return comp.map(function (c) {
          return c.value;
        }).join(' ').trim().split(' ');
      });
    }
    function parseComparator(comp, loose) {
      debug('comp', comp);
      comp = replaceCarets(comp, loose);
      debug('caret', comp);
      comp = replaceTildes(comp, loose);
      debug('tildes', comp);
      comp = replaceXRanges(comp, loose);
      debug('xrange', comp);
      comp = replaceStars(comp, loose);
      debug('stars', comp);
      return comp;
    }
    function isX(id) {
      return !id || id.toLowerCase() === 'x' || id === '*';
    }
    function replaceTildes(comp, loose) {
      return comp.trim().split(/\s+/).map(function (comp) {
        return replaceTilde(comp, loose);
      }).join(' ');
    }
    function replaceTilde(comp, loose) {
      var r = loose ? re[TILDELOOSE] : re[TILDE];
      return comp.replace(r, function (_, M, m, p, pr) {
        debug('tilde', comp, _, M, m, p, pr);
        var ret;
        if (isX(M)) ret = '';else if (isX(m)) ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';else if (isX(p)) ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';else if (pr) {
          debug('replaceTilde pr', pr);
          if (pr.charAt(0) !== '-') pr = '-' + pr;
          ret = '>=' + M + '.' + m + '.' + p + pr + ' <' + M + '.' + (+m + 1) + '.0';
        } else ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
        debug('tilde return', ret);
        return ret;
      });
    }
    function replaceCarets(comp, loose) {
      return comp.trim().split(/\s+/).map(function (comp) {
        return replaceCaret(comp, loose);
      }).join(' ');
    }
    function replaceCaret(comp, loose) {
      debug('caret', comp, loose);
      var r = loose ? re[CARETLOOSE] : re[CARET];
      return comp.replace(r, function (_, M, m, p, pr) {
        debug('caret', comp, _, M, m, p, pr);
        var ret;
        if (isX(M)) ret = '';else if (isX(m)) ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';else if (isX(p)) {
          if (M === '0') ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';else ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
        } else if (pr) {
          debug('replaceCaret pr', pr);
          if (pr.charAt(0) !== '-') pr = '-' + pr;
          if (M === '0') {
            if (m === '0') ret = '>=' + M + '.' + m + '.' + p + pr + ' <' + M + '.' + m + '.' + (+p + 1);else ret = '>=' + M + '.' + m + '.' + p + pr + ' <' + M + '.' + (+m + 1) + '.0';
          } else ret = '>=' + M + '.' + m + '.' + p + pr + ' <' + (+M + 1) + '.0.0';
        } else {
          debug('no pr');
          if (M === '0') {
            if (m === '0') ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + m + '.' + (+p + 1);else ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
          } else ret = '>=' + M + '.' + m + '.' + p + ' <' + (+M + 1) + '.0.0';
        }
        debug('caret return', ret);
        return ret;
      });
    }
    function replaceXRanges(comp, loose) {
      debug('replaceXRanges', comp, loose);
      return comp.split(/\s+/).map(function (comp) {
        return replaceXRange(comp, loose);
      }).join(' ');
    }
    function replaceXRange(comp, loose) {
      comp = comp.trim();
      var r = loose ? re[XRANGELOOSE] : re[XRANGE];
      return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
        debug('xRange', comp, ret, gtlt, M, m, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m);
        var xp = xm || isX(p);
        var anyX = xp;
        if (gtlt === '=' && anyX) gtlt = '';
        if (xM) {
          if (gtlt === '>' || gtlt === '<') {
            ret = '<0.0.0';
          } else {
            ret = '*';
          }
        } else if (gtlt && anyX) {
          if (xm) m = 0;
          if (xp) p = 0;
          if (gtlt === '>') {
            gtlt = '>=';
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else if (xp) {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === '<=') {
            gtlt = '<';
            if (xm) M = +M + 1;else m = +m + 1;
          }
          ret = gtlt + M + '.' + m + '.' + p;
        } else if (xm) {
          ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
        } else if (xp) {
          ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
        }
        debug('xRange return', ret);
        return ret;
      });
    }
    function replaceStars(comp, loose) {
      debug('replaceStars', comp, loose);
      return comp.trim().replace(re[STAR], '');
    }
    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) from = '';else if (isX(fm)) from = '>=' + fM + '.0.0';else if (isX(fp)) from = '>=' + fM + '.' + fm + '.0';else from = '>=' + from;
      if (isX(tM)) to = '';else if (isX(tm)) to = '<' + (+tM + 1) + '.0.0';else if (isX(tp)) to = '<' + tM + '.' + (+tm + 1) + '.0';else if (tpr) to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;else to = '<=' + to;
      return (from + ' ' + to).trim();
    }
    Range.prototype.test = function (version) {
      if (!version) return false;
      if (typeof version === 'string') version = new SemVer(version, this.loose);
      for (var i = 0; i < this.set.length; i++) {
        if (testSet(this.set[i], version)) return true;
      }
      return false;
    };
    function testSet(set, version) {
      for (var i = 0; i < set.length; i++) {
        if (!set[i].test(version)) return false;
      }
      if (version.prerelease.length) {
        for (var i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === ANY) continue;
          if (set[i].semver.prerelease.length > 0) {
            var allowed = set[i].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) return true;
          }
        }
        return false;
      }
      return true;
    }
    exports.satisfies = satisfies;
    function satisfies(version, range, loose) {
      try {
        range = new Range(range, loose);
      } catch (er) {
        return false;
      }
      return range.test(version);
    }
    exports.maxSatisfying = maxSatisfying;
    function maxSatisfying(versions, range, loose) {
      return versions.filter(function (version) {
        return satisfies(version, range, loose);
      }).sort(function (a, b) {
        return rcompare(a, b, loose);
      })[0] || null;
    }
    exports.minSatisfying = minSatisfying;
    function minSatisfying(versions, range, loose) {
      return versions.filter(function (version) {
        return satisfies(version, range, loose);
      }).sort(function (a, b) {
        return compare(a, b, loose);
      })[0] || null;
    }
    exports.validRange = validRange;
    function validRange(range, loose) {
      try {
        return new Range(range, loose).range || '*';
      } catch (er) {
        return null;
      }
    }
    exports.ltr = ltr;
    function ltr(version, range, loose) {
      return outside(version, range, '<', loose);
    }
    exports.gtr = gtr;
    function gtr(version, range, loose) {
      return outside(version, range, '>', loose);
    }
    exports.outside = outside;
    function outside(version, range, hilo, loose) {
      version = new SemVer(version, loose);
      range = new Range(range, loose);
      var gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case '>':
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = '>';
          ecomp = '>=';
          break;
        case '<':
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = '<';
          ecomp = '<=';
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, loose)) {
        return false;
      }
      for (var i = 0; i < range.set.length; ++i) {
        var comparators = range.set[i];
        var high = null;
        var low = null;
        comparators.forEach(function (comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator('>=0.0.0');
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, loose)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, loose)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    }
    exports.prerelease = prerelease;
    function prerelease(version, loose) {
      var parsed = parse(version, loose);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic("1d8", ["1d7"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("1d7");
  return module.exports;
});
$__System.registerDynamic('1d9', ['9', '7', '166', '1d6', '1d8', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  var __filename = 'jspm_packages/npm/require_optional@1.0.0/index.js',
      __dirname = 'jspm_packages/npm/require_optional@1.0.0';
  /* */
  (function (process) {
    var path = $__require('9'),
        fs = $__require('7'),
        f = $__require('166').format,
        resolveFrom = $__require('1d6'),
        semver = $__require('1d8');
    var exists = fs.existsSync || path.existsSync;
    var find_package_json = function (location) {
      var found = false;
      while (!found) {
        if (exists(location + '/package.json')) {
          found = location;
        } else if (location !== '/') {
          location = path.dirname(location);
        } else {
          return false;
        }
      }
      return location;
    };
    var require_optional = function (name, options) {
      options = options || {};
      options.strict = typeof options.strict == 'boolean' ? options.strict : true;
      var location = __dirname;
      if (module.parent) {
        location = module.parent.filename;
      }
      var location = find_package_json(location);
      if (!location) {
        throw new Error('package.json can not be located');
      }
      var object = JSON.parse(fs.readFileSync(f('%s/package.json', location)));
      var parts = name.split(/\//);
      if (!object.peerOptionalDependencies) {
        throw new Error(f('no optional dependency [%s] defined in peerOptionalDependencies in package.json', parts[0]));
      } else if (object.peerOptionalDependencies && !object.peerOptionalDependencies[parts[0]]) {
        throw new Error(f('no optional dependency [%s] defined in peerOptionalDependencies in package.json', parts[0]));
      }
      var expectedVersions = object.peerOptionalDependencies[parts[0]];
      var moduleEntry = undefined;
      var moduleEntryFile = name;
      try {
        moduleEntry = $__require(moduleEntryFile);
      } catch (err) {
        try {
          moduleEntryFile = resolveFrom(process.cwd(), name);
          if (moduleEntryFile == null) return undefined;
          moduleEntry = $__require(moduleEntryFile);
        } catch (err) {
          if (err.code === 'MODULE_NOT_FOUND') return undefined;
        }
      }
      var location = find_package_json($__require.resolve(moduleEntryFile));
      if (!location) {
        throw new Error('package.json can not be located');
      }
      var dependentOnModule = JSON.parse(fs.readFileSync(f('%s/package.json', location)));
      var version = dependentOnModule.version;
      if (semver.satisfies(version, expectedVersions) == false && options.strict) {
        var error = new Error(f('optional dependency [%s] found but version [%s] did not satisfy constraint [%s]', parts[0], version, expectedVersions));
        error.code = 'OPTIONAL_MODULE_NOT_FOUND';
        throw error;
      }
      return moduleEntry;
    };
    require_optional.exists = function (name) {
      try {
        var m = require_optional(name);
        if (m === undefined) return false;
        return true;
      } catch (err) {
        return false;
      }
    };
    module.exports = require_optional;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic("1cd", ["1d9"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("1d9");
  return module.exports;
});
$__System.registerDynamic('1b3', ['166', '1cd', '1c2', '1ab', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    "use strict";

    var f = $__require('166').format,
        require_optional = $__require('1cd'),
        Query = $__require('1c2').Query,
        MongoError = $__require('1ab');
    var AuthSession = function (db, username, password, options) {
      this.db = db;
      this.username = username;
      this.password = password;
      this.options = options;
    };
    AuthSession.prototype.equal = function (session) {
      return session.db == this.db && session.username == this.username && session.password == this.password;
    };
    var Kerberos = null;
    var MongoAuthProcess = null;
    try {
      Kerberos = require_optional('kerberos').Kerberos;
      MongoAuthProcess = require_optional('kerberos').processes.MongoAuthProcess;
    } catch (err) {}
    var GSSAPI = function (bson) {
      this.bson = bson;
      this.authStore = [];
    };
    GSSAPI.prototype.auth = function (server, connections, db, username, password, options, callback) {
      var self = this;
      if (Kerberos == null) return callback(new Error("Kerberos library is not installed"));
      var gssapiServiceName = options['gssapiServiceName'] || 'mongodb';
      var count = connections.length;
      if (count == 0) return callback(null, null);
      var numberOfValidConnections = 0;
      var errorObject = null;
      while (connections.length > 0) {
        var execute = function (connection) {
          GSSAPIInitialize(self, db, username, password, db, gssapiServiceName, server, connection, options, function (err, r) {
            count = count - 1;
            if (err) {
              errorObject = err;
            } else if (r.result['$err']) {
              errorObject = r.result;
            } else if (r.result['errmsg']) {
              errorObject = r.result;
            } else {
              numberOfValidConnections = numberOfValidConnections + 1;
            }
            if (count == 0 && numberOfValidConnections > 0) {
              addAuthSession(self.authStore, new AuthSession(db, username, password, options));
              callback(null, true);
            } else if (count == 0) {
              if (errorObject == null) errorObject = new MongoError(f("failed to authenticate using mongocr"));
              callback(errorObject, false);
            }
          });
        };
        var _execute = function (_connection) {
          process.nextTick(function () {
            execute(_connection);
          });
        };
        _execute(connections.shift());
      }
    };
    var GSSAPIInitialize = function (self, db, username, password, authdb, gssapiServiceName, server, connection, options, callback) {
      var mongo_auth_process = new MongoAuthProcess(connection.host, connection.port, gssapiServiceName, options);
      mongo_auth_process.init(username, password, function (err) {
        if (err) return callback(err, false);
        mongo_auth_process.transition('', function (err, payload) {
          if (err) return callback(err, false);
          MongoDBGSSAPIFirstStep(self, mongo_auth_process, payload, db, username, password, authdb, server, connection, callback);
        });
      });
    };
    var MongoDBGSSAPIFirstStep = function (self, mongo_auth_process, payload, db, username, password, authdb, server, connection, callback) {
      var command = {
        saslStart: 1,
        mechanism: 'GSSAPI',
        payload: payload,
        autoAuthorize: 1
      };
      server(connection, new Query(self.bson, "$external.$cmd", command, {
        numberToSkip: 0,
        numberToReturn: 1
      }), function (err, r) {
        if (err) return callback(err, false);
        var doc = r.result;
        mongo_auth_process.transition(r.result.payload, function (err, payload) {
          if (err) return callback(err, false);
          MongoDBGSSAPISecondStep(self, mongo_auth_process, payload, doc, db, username, password, authdb, server, connection, callback);
        });
      });
    };
    var MongoDBGSSAPISecondStep = function (self, mongo_auth_process, payload, doc, db, username, password, authdb, server, connection, callback) {
      var command = {
        saslContinue: 1,
        conversationId: doc.conversationId,
        payload: payload
      };
      server(connection, new Query(self.bson, "$external.$cmd", command, {
        numberToSkip: 0,
        numberToReturn: 1
      }), function (err, r) {
        if (err) return callback(err, false);
        var doc = r.result;
        mongo_auth_process.transition(doc.payload, function (err, payload) {
          if (err) return callback(err, false);
          MongoDBGSSAPIThirdStep(self, mongo_auth_process, payload, doc, db, username, password, authdb, server, connection, callback);
        });
      });
    };
    var MongoDBGSSAPIThirdStep = function (self, mongo_auth_process, payload, doc, db, username, password, authdb, server, connection, callback) {
      var command = {
        saslContinue: 1,
        conversationId: doc.conversationId,
        payload: payload
      };
      server(connection, new Query(self.bson, "$external.$cmd", command, {
        numberToSkip: 0,
        numberToReturn: 1
      }), function (err, r) {
        if (err) return callback(err, false);
        mongo_auth_process.transition(null, function (err) {
          if (err) return callback(err, null);
          callback(null, r);
        });
      });
    };
    var addAuthSession = function (authStore, session) {
      var found = false;
      for (var i = 0; i < authStore.length; i++) {
        if (authStore[i].equal(session)) {
          found = true;
          break;
        }
      }
      if (!found) authStore.push(session);
    };
    GSSAPI.prototype.logout = function (dbName) {
      this.authStore = this.authStore.filter(function (x) {
        return x.db != dbName;
      });
    };
    GSSAPI.prototype.reauthenticate = function (server, connections, callback) {
      var authStore = this.authStore.slice(0);
      var count = authStore.length;
      if (count == 0) return callback(null, null);
      for (var i = 0; i < authStore.length; i++) {
        this.auth(server, connections, authStore[i].db, authStore[i].username, authStore[i].password, authStore[i].options, function (err) {
          count = count - 1;
          if (count == 0) {
            callback(err, null);
          }
        });
      }
    };
    module.exports = GSSAPI;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('1da', [], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  exports.readUInt32BE = function readUInt32BE(bytes, off) {
    var res = bytes[0 + off] << 24 | bytes[1 + off] << 16 | bytes[2 + off] << 8 | bytes[3 + off];
    return res >>> 0;
  };

  exports.writeUInt32BE = function writeUInt32BE(bytes, value, off) {
    bytes[0 + off] = value >>> 24;
    bytes[1 + off] = value >>> 16 & 0xff;
    bytes[2 + off] = value >>> 8 & 0xff;
    bytes[3 + off] = value & 0xff;
  };

  exports.ip = function ip(inL, inR, out, off) {
    var outL = 0;
    var outR = 0;

    for (var i = 6; i >= 0; i -= 2) {
      for (var j = 0; j <= 24; j += 8) {
        outL <<= 1;
        outL |= inR >>> j + i & 1;
      }
      for (var j = 0; j <= 24; j += 8) {
        outL <<= 1;
        outL |= inL >>> j + i & 1;
      }
    }

    for (var i = 6; i >= 0; i -= 2) {
      for (var j = 1; j <= 25; j += 8) {
        outR <<= 1;
        outR |= inR >>> j + i & 1;
      }
      for (var j = 1; j <= 25; j += 8) {
        outR <<= 1;
        outR |= inL >>> j + i & 1;
      }
    }

    out[off + 0] = outL >>> 0;
    out[off + 1] = outR >>> 0;
  };

  exports.rip = function rip(inL, inR, out, off) {
    var outL = 0;
    var outR = 0;

    for (var i = 0; i < 4; i++) {
      for (var j = 24; j >= 0; j -= 8) {
        outL <<= 1;
        outL |= inR >>> j + i & 1;
        outL <<= 1;
        outL |= inL >>> j + i & 1;
      }
    }
    for (var i = 4; i < 8; i++) {
      for (var j = 24; j >= 0; j -= 8) {
        outR <<= 1;
        outR |= inR >>> j + i & 1;
        outR <<= 1;
        outR |= inL >>> j + i & 1;
      }
    }

    out[off + 0] = outL >>> 0;
    out[off + 1] = outR >>> 0;
  };

  exports.pc1 = function pc1(inL, inR, out, off) {
    var outL = 0;
    var outR = 0;

    // 7, 15, 23, 31, 39, 47, 55, 63
    // 6, 14, 22, 30, 39, 47, 55, 63
    // 5, 13, 21, 29, 39, 47, 55, 63
    // 4, 12, 20, 28
    for (var i = 7; i >= 5; i--) {
      for (var j = 0; j <= 24; j += 8) {
        outL <<= 1;
        outL |= inR >> j + i & 1;
      }
      for (var j = 0; j <= 24; j += 8) {
        outL <<= 1;
        outL |= inL >> j + i & 1;
      }
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= inR >> j + i & 1;
    }

    // 1, 9, 17, 25, 33, 41, 49, 57
    // 2, 10, 18, 26, 34, 42, 50, 58
    // 3, 11, 19, 27, 35, 43, 51, 59
    // 36, 44, 52, 60
    for (var i = 1; i <= 3; i++) {
      for (var j = 0; j <= 24; j += 8) {
        outR <<= 1;
        outR |= inR >> j + i & 1;
      }
      for (var j = 0; j <= 24; j += 8) {
        outR <<= 1;
        outR |= inL >> j + i & 1;
      }
    }
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= inL >> j + i & 1;
    }

    out[off + 0] = outL >>> 0;
    out[off + 1] = outR >>> 0;
  };

  exports.r28shl = function r28shl(num, shift) {
    return num << shift & 0xfffffff | num >>> 28 - shift;
  };

  var pc2table = [
  // inL => outL
  14, 11, 17, 4, 27, 23, 25, 0, 13, 22, 7, 18, 5, 9, 16, 24, 2, 20, 12, 21, 1, 8, 15, 26,

  // inR => outR
  15, 4, 25, 19, 9, 1, 26, 16, 5, 11, 23, 8, 12, 7, 17, 0, 22, 3, 10, 14, 6, 20, 27, 24];

  exports.pc2 = function pc2(inL, inR, out, off) {
    var outL = 0;
    var outR = 0;

    var len = pc2table.length >>> 1;
    for (var i = 0; i < len; i++) {
      outL <<= 1;
      outL |= inL >>> pc2table[i] & 0x1;
    }
    for (var i = len; i < pc2table.length; i++) {
      outR <<= 1;
      outR |= inR >>> pc2table[i] & 0x1;
    }

    out[off + 0] = outL >>> 0;
    out[off + 1] = outR >>> 0;
  };

  exports.expand = function expand(r, out, off) {
    var outL = 0;
    var outR = 0;

    outL = (r & 1) << 5 | r >>> 27;
    for (var i = 23; i >= 15; i -= 4) {
      outL <<= 6;
      outL |= r >>> i & 0x3f;
    }
    for (var i = 11; i >= 3; i -= 4) {
      outR |= r >>> i & 0x3f;
      outR <<= 6;
    }
    outR |= (r & 0x1f) << 1 | r >>> 31;

    out[off + 0] = outL >>> 0;
    out[off + 1] = outR >>> 0;
  };

  var sTable = [14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12, 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14, 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11];

  exports.substitute = function substitute(inL, inR) {
    var out = 0;
    for (var i = 0; i < 4; i++) {
      var b = inL >>> 18 - i * 6 & 0x3f;
      var sb = sTable[i * 0x40 + b];

      out <<= 4;
      out |= sb;
    }
    for (var i = 0; i < 4; i++) {
      var b = inR >>> 18 - i * 6 & 0x3f;
      var sb = sTable[4 * 0x40 + i * 0x40 + b];

      out <<= 4;
      out |= sb;
    }
    return out >>> 0;
  };

  var permuteTable = [16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7];

  exports.permute = function permute(num) {
    var out = 0;
    for (var i = 0; i < permuteTable.length; i++) {
      out <<= 1;
      out |= num >>> permuteTable[i] & 0x1;
    }
    return out >>> 0;
  };

  exports.padSplit = function padSplit(num, size, group) {
    var str = num.toString(2);
    while (str.length < size) str = '0' + str;

    var out = [];
    for (var i = 0; i < size; i += group) out.push(str.slice(i, i + group));
    return out.join(' ');
  };
  return module.exports;
});
$__System.registerDynamic('1db', ['1dc', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    'use strict';

    var assert = $__require('1dc');
    function Cipher(options) {
      this.options = options;
      this.type = this.options.type;
      this.blockSize = 8;
      this._init();
      this.buffer = new Array(this.blockSize);
      this.bufferOff = 0;
    }
    module.exports = Cipher;
    Cipher.prototype._init = function _init() {};
    Cipher.prototype.update = function update(data) {
      if (data.length === 0) return [];
      if (this.type === 'decrypt') return this._updateDecrypt(data);else return this._updateEncrypt(data);
    };
    Cipher.prototype._buffer = function _buffer(data, off) {
      var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);
      for (var i = 0; i < min; i++) this.buffer[this.bufferOff + i] = data[off + i];
      this.bufferOff += min;
      return min;
    };
    Cipher.prototype._flushBuffer = function _flushBuffer(out, off) {
      this._update(this.buffer, 0, out, off);
      this.bufferOff = 0;
      return this.blockSize;
    };
    Cipher.prototype._updateEncrypt = function _updateEncrypt(data) {
      var inputOff = 0;
      var outputOff = 0;
      var count = (this.bufferOff + data.length) / this.blockSize | 0;
      var out = new Array(count * this.blockSize);
      if (this.bufferOff !== 0) {
        inputOff += this._buffer(data, inputOff);
        if (this.bufferOff === this.buffer.length) outputOff += this._flushBuffer(out, outputOff);
      }
      var max = data.length - (data.length - inputOff) % this.blockSize;
      for (; inputOff < max; inputOff += this.blockSize) {
        this._update(data, inputOff, out, outputOff);
        outputOff += this.blockSize;
      }
      for (; inputOff < data.length; inputOff++, this.bufferOff++) this.buffer[this.bufferOff] = data[inputOff];
      return out;
    };
    Cipher.prototype._updateDecrypt = function _updateDecrypt(data) {
      var inputOff = 0;
      var outputOff = 0;
      var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
      var out = new Array(count * this.blockSize);
      for (; count > 0; count--) {
        inputOff += this._buffer(data, inputOff);
        outputOff += this._flushBuffer(out, outputOff);
      }
      inputOff += this._buffer(data, inputOff);
      return out;
    };
    Cipher.prototype.final = function final(buffer) {
      var first;
      if (buffer) first = this.update(buffer);
      var last;
      if (this.type === 'encrypt') last = this._finalEncrypt();else last = this._finalDecrypt();
      if (first) return first.concat(last);else return last;
    };
    Cipher.prototype._pad = function _pad(buffer, off) {
      if (off === 0) return false;
      while (off < buffer.length) buffer[off++] = 0;
      return true;
    };
    Cipher.prototype._finalEncrypt = function _finalEncrypt() {
      if (!this._pad(this.buffer, this.bufferOff)) return [];
      var out = new Array(this.blockSize);
      this._update(this.buffer, 0, out, 0);
      return out;
    };
    Cipher.prototype._unpad = function _unpad(buffer) {
      return buffer;
    };
    Cipher.prototype._finalDecrypt = function _finalDecrypt() {
      assert.equal(this.bufferOff, this.blockSize, 'Not enough data to decrypt');
      var out = new Array(this.blockSize);
      this._flushBuffer(out, 0);
      return this._unpad(out);
    };
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic('1dd', ['1dc', '46', '1de'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var assert = $__require('1dc');
  var inherits = $__require('46');
  var des = $__require('1de');
  var utils = des.utils;
  var Cipher = des.Cipher;
  function DESState() {
    this.tmp = new Array(2);
    this.keys = null;
  }
  function DES(options) {
    Cipher.call(this, options);
    var state = new DESState();
    this._desState = state;
    this.deriveKeys(state, options.key);
  }
  inherits(DES, Cipher);
  module.exports = DES;
  DES.create = function create(options) {
    return new DES(options);
  };
  var shiftTable = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];
  DES.prototype.deriveKeys = function deriveKeys(state, key) {
    state.keys = new Array(16 * 2);
    assert.equal(key.length, this.blockSize, 'Invalid key length');
    var kL = utils.readUInt32BE(key, 0);
    var kR = utils.readUInt32BE(key, 4);
    utils.pc1(kL, kR, state.tmp, 0);
    kL = state.tmp[0];
    kR = state.tmp[1];
    for (var i = 0; i < state.keys.length; i += 2) {
      var shift = shiftTable[i >>> 1];
      kL = utils.r28shl(kL, shift);
      kR = utils.r28shl(kR, shift);
      utils.pc2(kL, kR, state.keys, i);
    }
  };
  DES.prototype._update = function _update(inp, inOff, out, outOff) {
    var state = this._desState;
    var l = utils.readUInt32BE(inp, inOff);
    var r = utils.readUInt32BE(inp, inOff + 4);
    utils.ip(l, r, state.tmp, 0);
    l = state.tmp[0];
    r = state.tmp[1];
    if (this.type === 'encrypt') this._encrypt(state, l, r, state.tmp, 0);else this._decrypt(state, l, r, state.tmp, 0);
    l = state.tmp[0];
    r = state.tmp[1];
    utils.writeUInt32BE(out, l, outOff);
    utils.writeUInt32BE(out, r, outOff + 4);
  };
  DES.prototype._pad = function _pad(buffer, off) {
    var value = buffer.length - off;
    for (var i = off; i < buffer.length; i++) buffer[i] = value;
    return true;
  };
  DES.prototype._unpad = function _unpad(buffer) {
    var pad = buffer[buffer.length - 1];
    for (var i = buffer.length - pad; i < buffer.length; i++) assert.equal(buffer[i], pad);
    return buffer.slice(0, buffer.length - pad);
  };
  DES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off) {
    var l = lStart;
    var r = rStart;
    for (var i = 0; i < state.keys.length; i += 2) {
      var keyL = state.keys[i];
      var keyR = state.keys[i + 1];
      utils.expand(r, state.tmp, 0);
      keyL ^= state.tmp[0];
      keyR ^= state.tmp[1];
      var s = utils.substitute(keyL, keyR);
      var f = utils.permute(s);
      var t = r;
      r = (l ^ f) >>> 0;
      l = t;
    }
    utils.rip(r, l, out, off);
  };
  DES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off) {
    var l = rStart;
    var r = lStart;
    for (var i = state.keys.length - 2; i >= 0; i -= 2) {
      var keyL = state.keys[i];
      var keyR = state.keys[i + 1];
      utils.expand(l, state.tmp, 0);
      keyL ^= state.tmp[0];
      keyR ^= state.tmp[1];
      var s = utils.substitute(keyL, keyR);
      var f = utils.permute(s);
      var t = l;
      l = (r ^ f) >>> 0;
      r = t;
    }
    utils.rip(l, r, out, off);
  };
  return module.exports;
});
$__System.registerDynamic('1df', ['1dc', '46'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var assert = $__require('1dc');
  var inherits = $__require('46');

  var proto = {};

  function CBCState(iv) {
    assert.equal(iv.length, 8, 'Invalid IV length');

    this.iv = new Array(8);
    for (var i = 0; i < this.iv.length; i++) this.iv[i] = iv[i];
  }

  function instantiate(Base) {
    function CBC(options) {
      Base.call(this, options);
      this._cbcInit();
    }
    inherits(CBC, Base);

    var keys = Object.keys(proto);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      CBC.prototype[key] = proto[key];
    }

    CBC.create = function create(options) {
      return new CBC(options);
    };

    return CBC;
  }

  exports.instantiate = instantiate;

  proto._cbcInit = function _cbcInit() {
    var state = new CBCState(this.options.iv);
    this._cbcState = state;
  };

  proto._update = function _update(inp, inOff, out, outOff) {
    var state = this._cbcState;
    var superProto = this.constructor.super_.prototype;

    var iv = state.iv;
    if (this.type === 'encrypt') {
      for (var i = 0; i < this.blockSize; i++) iv[i] ^= inp[inOff + i];

      superProto._update.call(this, iv, 0, out, outOff);

      for (var i = 0; i < this.blockSize; i++) iv[i] = out[outOff + i];
    } else {
      superProto._update.call(this, inp, inOff, out, outOff);

      for (var i = 0; i < this.blockSize; i++) out[outOff + i] ^= iv[i];

      for (var i = 0; i < this.blockSize; i++) iv[i] = inp[inOff + i];
    }
  };
  return module.exports;
});
$__System.registerDynamic('1e0', ['1dc', '46', '1de'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var assert = $__require('1dc');
  var inherits = $__require('46');
  var des = $__require('1de');
  var Cipher = des.Cipher;
  var DES = des.DES;
  function EDEState(type, key) {
    assert.equal(key.length, 24, 'Invalid key length');
    var k1 = key.slice(0, 8);
    var k2 = key.slice(8, 16);
    var k3 = key.slice(16, 24);
    if (type === 'encrypt') {
      this.ciphers = [DES.create({
        type: 'encrypt',
        key: k1
      }), DES.create({
        type: 'decrypt',
        key: k2
      }), DES.create({
        type: 'encrypt',
        key: k3
      })];
    } else {
      this.ciphers = [DES.create({
        type: 'decrypt',
        key: k3
      }), DES.create({
        type: 'encrypt',
        key: k2
      }), DES.create({
        type: 'decrypt',
        key: k1
      })];
    }
  }
  function EDE(options) {
    Cipher.call(this, options);
    var state = new EDEState(this.type, this.options.key);
    this._edeState = state;
  }
  inherits(EDE, Cipher);
  module.exports = EDE;
  EDE.create = function create(options) {
    return new EDE(options);
  };
  EDE.prototype._update = function _update(inp, inOff, out, outOff) {
    var state = this._edeState;
    state.ciphers[0]._update(inp, inOff, out, outOff);
    state.ciphers[1]._update(out, outOff, out, outOff);
    state.ciphers[2]._update(out, outOff, out, outOff);
  };
  EDE.prototype._pad = DES.prototype._pad;
  EDE.prototype._unpad = DES.prototype._unpad;
  return module.exports;
});
$__System.registerDynamic('1de', ['1da', '1db', '1dd', '1df', '1e0'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  exports.utils = $__require('1da');
  exports.Cipher = $__require('1db');
  exports.DES = $__require('1dd');
  exports.CBC = $__require('1df');
  exports.EDE = $__require('1e0');
  return module.exports;
});
$__System.registerDynamic("1e1", ["1de"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("1de");
  return module.exports;
});
$__System.registerDynamic('1e2', ['1e3', '1e1', '46', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    var CipherBase = $__require('1e3');
    var des = $__require('1e1');
    var inherits = $__require('46');
    var modes = {
      'des-ede3-cbc': des.CBC.instantiate(des.EDE),
      'des-ede3': des.EDE,
      'des-ede-cbc': des.CBC.instantiate(des.EDE),
      'des-ede': des.EDE,
      'des-cbc': des.CBC.instantiate(des.DES),
      'des-ecb': des.DES
    };
    modes.des = modes['des-cbc'];
    modes.des3 = modes['des-ede3-cbc'];
    module.exports = DES;
    inherits(DES, CipherBase);
    function DES(opts) {
      CipherBase.call(this);
      var modeName = opts.mode.toLowerCase();
      var mode = modes[modeName];
      var type;
      if (opts.decrypt) {
        type = 'decrypt';
      } else {
        type = 'encrypt';
      }
      var key = opts.key;
      if (modeName === 'des-ede' || modeName === 'des-ede-cbc') {
        key = Buffer.concat([key, key.slice(0, 8)]);
      }
      var iv = opts.iv;
      this._des = mode.create({
        key: key,
        iv: iv,
        type: type
      });
    }
    DES.prototype._update = function (data) {
      return new Buffer(this._des.update(data));
    };
    DES.prototype._final = function () {
      return new Buffer(this._des.final());
    };
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic("1e4", ["1e2"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("1e2");
  return module.exports;
});
$__System.registerDynamic('1e5', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  exports['des-ecb'] = {
    key: 8,
    iv: 0
  };
  exports['des-cbc'] = exports.des = {
    key: 8,
    iv: 8
  };
  exports['des-ede3-cbc'] = exports.des3 = {
    key: 24,
    iv: 8
  };
  exports['des-ede3'] = {
    key: 24,
    iv: 0
  };
  exports['des-ede-cbc'] = {
    key: 16,
    iv: 8
  };
  exports['des-ede'] = {
    key: 16,
    iv: 0
  };
  return module.exports;
});
$__System.registerDynamic('1e6', ['1e7', '1e8', '1e4', '1e5', '1e9'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var ebtk = $__require('1e7');
  var aes = $__require('1e8');
  var DES = $__require('1e4');
  var desModes = $__require('1e5');
  var aesModes = $__require('1e9');
  function createCipher(suite, password) {
    var keyLen, ivLen;
    suite = suite.toLowerCase();
    if (aesModes[suite]) {
      keyLen = aesModes[suite].key;
      ivLen = aesModes[suite].iv;
    } else if (desModes[suite]) {
      keyLen = desModes[suite].key * 8;
      ivLen = desModes[suite].iv;
    } else {
      throw new TypeError('invalid suite type');
    }
    var keys = ebtk(password, false, keyLen, ivLen);
    return createCipheriv(suite, keys.key, keys.iv);
  }
  function createDecipher(suite, password) {
    var keyLen, ivLen;
    suite = suite.toLowerCase();
    if (aesModes[suite]) {
      keyLen = aesModes[suite].key;
      ivLen = aesModes[suite].iv;
    } else if (desModes[suite]) {
      keyLen = desModes[suite].key * 8;
      ivLen = desModes[suite].iv;
    } else {
      throw new TypeError('invalid suite type');
    }
    var keys = ebtk(password, false, keyLen, ivLen);
    return createDecipheriv(suite, keys.key, keys.iv);
  }

  function createCipheriv(suite, key, iv) {
    suite = suite.toLowerCase();
    if (aesModes[suite]) {
      return aes.createCipheriv(suite, key, iv);
    } else if (desModes[suite]) {
      return new DES({
        key: key,
        iv: iv,
        mode: suite
      });
    } else {
      throw new TypeError('invalid suite type');
    }
  }
  function createDecipheriv(suite, key, iv) {
    suite = suite.toLowerCase();
    if (aesModes[suite]) {
      return aes.createDecipheriv(suite, key, iv);
    } else if (desModes[suite]) {
      return new DES({
        key: key,
        iv: iv,
        mode: suite,
        decrypt: true
      });
    } else {
      throw new TypeError('invalid suite type');
    }
  }
  exports.createCipher = exports.Cipher = createCipher;
  exports.createCipheriv = exports.Cipheriv = createCipheriv;
  exports.createDecipher = exports.Decipher = createDecipher;
  exports.createDecipheriv = exports.Decipheriv = createDecipheriv;
  function getCiphers() {
    return Object.keys(desModes).concat(aes.getCiphers());
  }
  exports.listCiphers = exports.getCiphers = getCiphers;
  return module.exports;
});
$__System.registerDynamic("1ea", ["1e6"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("1e6");
  return module.exports;
});
$__System.registerDynamic("1eb", [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = { "modp1": { "gen": "02", "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff" }, "modp2": { "gen": "02", "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff" }, "modp5": { "gen": "02", "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff" }, "modp14": { "gen": "02", "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff" }, "modp15": { "gen": "02", "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff" }, "modp16": { "gen": "02", "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff" }, "modp17": { "gen": "02", "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff" }, "modp18": { "gen": "02", "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff" } };
  return module.exports;
});
$__System.registerDynamic('1ec', ['1ee', '1ed'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var bn = $__require('1ee');
  var brorand = $__require('1ed');

  function MillerRabin(rand) {
    this.rand = rand || new brorand.Rand();
  }
  module.exports = MillerRabin;

  MillerRabin.create = function create(rand) {
    return new MillerRabin(rand);
  };

  MillerRabin.prototype._rand = function _rand(n) {
    var len = n.bitLength();
    var buf = this.rand.generate(Math.ceil(len / 8));

    // Set low bits
    buf[0] |= 3;

    // Mask high bits
    var mask = len & 0x7;
    if (mask !== 0) buf[buf.length - 1] >>= 7 - mask;

    return new bn(buf);
  };

  MillerRabin.prototype.test = function test(n, k, cb) {
    var len = n.bitLength();
    var red = bn.mont(n);
    var rone = new bn(1).toRed(red);

    if (!k) k = Math.max(1, len / 48 | 0);

    // Find d and s, (n - 1) = (2 ^ s) * d;
    var n1 = n.subn(1);
    var n2 = n1.subn(1);
    for (var s = 0; !n1.testn(s); s++) {}
    var d = n.shrn(s);

    var rn1 = n1.toRed(red);

    var prime = true;
    for (; k > 0; k--) {
      var a = this._rand(n2);
      if (cb) cb(a);

      var x = a.toRed(red).redPow(d);
      if (x.cmp(rone) === 0 || x.cmp(rn1) === 0) continue;

      for (var i = 1; i < s; i++) {
        x = x.redSqr();

        if (x.cmp(rone) === 0) return false;
        if (x.cmp(rn1) === 0) break;
      }

      if (i === s) return false;
    }

    return prime;
  };

  MillerRabin.prototype.getDivisor = function getDivisor(n, k) {
    var len = n.bitLength();
    var red = bn.mont(n);
    var rone = new bn(1).toRed(red);

    if (!k) k = Math.max(1, len / 48 | 0);

    // Find d and s, (n - 1) = (2 ^ s) * d;
    var n1 = n.subn(1);
    var n2 = n1.subn(1);
    for (var s = 0; !n1.testn(s); s++) {}
    var d = n.shrn(s);

    var rn1 = n1.toRed(red);

    for (; k > 0; k--) {
      var a = this._rand(n2);

      var g = n.gcd(a);
      if (g.cmpn(1) !== 0) return g;

      var x = a.toRed(red).redPow(d);
      if (x.cmp(rone) === 0 || x.cmp(rn1) === 0) continue;

      for (var i = 1; i < s; i++) {
        x = x.redSqr();

        if (x.cmp(rone) === 0) return x.fromRed().subn(1).gcd(n);
        if (x.cmp(rn1) === 0) break;
      }

      if (i === s) {
        x = x.redSqr();
        return x.fromRed().subn(1).gcd(n);
      }
    }

    return false;
  };
  return module.exports;
});
$__System.registerDynamic("1ef", ["1ec"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("1ec");
  return module.exports;
});
$__System.registerDynamic('1f0', ['1f1', '1ee', '1ef'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var randomBytes = $__require('1f1');
  module.exports = findPrime;
  findPrime.simpleSieve = simpleSieve;
  findPrime.fermatTest = fermatTest;
  var BN = $__require('1ee');
  var TWENTYFOUR = new BN(24);
  var MillerRabin = $__require('1ef');
  var millerRabin = new MillerRabin();
  var ONE = new BN(1);
  var TWO = new BN(2);
  var FIVE = new BN(5);
  var SIXTEEN = new BN(16);
  var EIGHT = new BN(8);
  var TEN = new BN(10);
  var THREE = new BN(3);
  var SEVEN = new BN(7);
  var ELEVEN = new BN(11);
  var FOUR = new BN(4);
  var TWELVE = new BN(12);
  var primes = null;

  function _getPrimes() {
    if (primes !== null) return primes;

    var limit = 0x100000;
    var res = [];
    res[0] = 2;
    for (var i = 1, k = 3; k < limit; k += 2) {
      var sqrt = Math.ceil(Math.sqrt(k));
      for (var j = 0; j < i && res[j] <= sqrt; j++) if (k % res[j] === 0) break;

      if (i !== j && res[j] <= sqrt) continue;

      res[i++] = k;
    }
    primes = res;
    return res;
  }

  function simpleSieve(p) {
    var primes = _getPrimes();

    for (var i = 0; i < primes.length; i++) if (p.modn(primes[i]) === 0) {
      if (p.cmpn(primes[i]) === 0) {
        return true;
      } else {
        return false;
      }
    }

    return true;
  }

  function fermatTest(p) {
    var red = BN.mont(p);
    return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;
  }

  function findPrime(bits, gen) {
    if (bits < 16) {
      // this is what openssl does
      if (gen === 2 || gen === 5) {
        return new BN([0x8c, 0x7b]);
      } else {
        return new BN([0x8c, 0x27]);
      }
    }
    gen = new BN(gen);

    var num, n2;

    while (true) {
      num = new BN(randomBytes(Math.ceil(bits / 8)));
      while (num.bitLength() > bits) {
        num.ishrn(1);
      }
      if (num.isEven()) {
        num.iadd(ONE);
      }
      if (!num.testn(1)) {
        num.iadd(TWO);
      }
      if (!gen.cmp(TWO)) {
        while (num.mod(TWENTYFOUR).cmp(ELEVEN)) {
          num.iadd(FOUR);
        }
      } else if (!gen.cmp(FIVE)) {
        while (num.mod(TEN).cmp(THREE)) {
          num.iadd(FOUR);
        }
      }
      n2 = num.shrn(1);
      if (simpleSieve(n2) && simpleSieve(num) && fermatTest(n2) && fermatTest(num) && millerRabin.test(n2) && millerRabin.test(num)) {
        return num;
      }
    }
  }
  return module.exports;
});
$__System.registerDynamic('1f2', ['1ee', '1ef', '1f0', '1f1', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    var BN = $__require('1ee');
    var MillerRabin = $__require('1ef');
    var millerRabin = new MillerRabin();
    var TWENTYFOUR = new BN(24);
    var ELEVEN = new BN(11);
    var TEN = new BN(10);
    var THREE = new BN(3);
    var SEVEN = new BN(7);
    var primes = $__require('1f0');
    var randomBytes = $__require('1f1');
    module.exports = DH;
    function setPublicKey(pub, enc) {
      enc = enc || 'utf8';
      if (!Buffer.isBuffer(pub)) {
        pub = new Buffer(pub, enc);
      }
      this._pub = new BN(pub);
      return this;
    }
    function setPrivateKey(priv, enc) {
      enc = enc || 'utf8';
      if (!Buffer.isBuffer(priv)) {
        priv = new Buffer(priv, enc);
      }
      this._priv = new BN(priv);
      return this;
    }
    var primeCache = {};
    function checkPrime(prime, generator) {
      var gen = generator.toString('hex');
      var hex = [gen, prime.toString(16)].join('_');
      if (hex in primeCache) {
        return primeCache[hex];
      }
      var error = 0;
      if (prime.isEven() || !primes.simpleSieve || !primes.fermatTest(prime) || !millerRabin.test(prime)) {
        error += 1;
        if (gen === '02' || gen === '05') {
          error += 8;
        } else {
          error += 4;
        }
        primeCache[hex] = error;
        return error;
      }
      if (!millerRabin.test(prime.shrn(1))) {
        error += 2;
      }
      var rem;
      switch (gen) {
        case '02':
          if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {
            error += 8;
          }
          break;
        case '05':
          rem = prime.mod(TEN);
          if (rem.cmp(THREE) && rem.cmp(SEVEN)) {
            error += 8;
          }
          break;
        default:
          error += 4;
      }
      primeCache[hex] = error;
      return error;
    }
    function DH(prime, generator, malleable) {
      this.setGenerator(generator);
      this.__prime = new BN(prime);
      this._prime = BN.mont(this.__prime);
      this._primeLen = prime.length;
      this._pub = undefined;
      this._priv = undefined;
      this._primeCode = undefined;
      if (malleable) {
        this.setPublicKey = setPublicKey;
        this.setPrivateKey = setPrivateKey;
      } else {
        this._primeCode = 8;
      }
    }
    Object.defineProperty(DH.prototype, 'verifyError', {
      enumerable: true,
      get: function () {
        if (typeof this._primeCode !== 'number') {
          this._primeCode = checkPrime(this.__prime, this.__gen);
        }
        return this._primeCode;
      }
    });
    DH.prototype.generateKeys = function () {
      if (!this._priv) {
        this._priv = new BN(randomBytes(this._primeLen));
      }
      this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
      return this.getPublicKey();
    };
    DH.prototype.computeSecret = function (other) {
      other = new BN(other);
      other = other.toRed(this._prime);
      var secret = other.redPow(this._priv).fromRed();
      var out = new Buffer(secret.toArray());
      var prime = this.getPrime();
      if (out.length < prime.length) {
        var front = new Buffer(prime.length - out.length);
        front.fill(0);
        out = Buffer.concat([front, out]);
      }
      return out;
    };
    DH.prototype.getPublicKey = function getPublicKey(enc) {
      return formatReturnValue(this._pub, enc);
    };
    DH.prototype.getPrivateKey = function getPrivateKey(enc) {
      return formatReturnValue(this._priv, enc);
    };
    DH.prototype.getPrime = function (enc) {
      return formatReturnValue(this.__prime, enc);
    };
    DH.prototype.getGenerator = function (enc) {
      return formatReturnValue(this._gen, enc);
    };
    DH.prototype.setGenerator = function (gen, enc) {
      enc = enc || 'utf8';
      if (!Buffer.isBuffer(gen)) {
        gen = new Buffer(gen, enc);
      }
      this.__gen = gen;
      this._gen = new BN(gen);
      return this;
    };
    function formatReturnValue(bn, enc) {
      var buf = new Buffer(bn.toArray());
      if (!enc) {
        return buf;
      } else {
        return buf.toString(enc);
      }
    }
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic('1f3', ['1f0', '1eb', '1f2', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    var generatePrime = $__require('1f0');
    var primes = $__require('1eb');
    var DH = $__require('1f2');
    function getDiffieHellman(mod) {
      var prime = new Buffer(primes[mod].prime, 'hex');
      var gen = new Buffer(primes[mod].gen, 'hex');
      return new DH(prime, gen);
    }
    var ENCODINGS = {
      'binary': true,
      'hex': true,
      'base64': true
    };
    function createDiffieHellman(prime, enc, generator, genc) {
      if (Buffer.isBuffer(enc) || ENCODINGS[enc] === undefined) {
        return createDiffieHellman(prime, 'binary', enc, generator);
      }
      enc = enc || 'binary';
      genc = genc || 'binary';
      generator = generator || new Buffer([2]);
      if (!Buffer.isBuffer(generator)) {
        generator = new Buffer(generator, genc);
      }
      if (typeof prime === 'number') {
        return new DH(generatePrime(prime, generator), generator, true);
      }
      if (!Buffer.isBuffer(prime)) {
        prime = new Buffer(prime, enc);
      }
      return new DH(prime, generator, true);
    }
    exports.DiffieHellmanGroup = exports.createDiffieHellmanGroup = exports.getDiffieHellman = getDiffieHellman;
    exports.createDiffieHellman = exports.DiffieHellman = createDiffieHellman;
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic("1f4", ["1f3"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("1f3");
  return module.exports;
});
$__System.registerDynamic('1f5', ['2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    'use strict';

    exports['RSA-SHA224'] = exports.sha224WithRSAEncryption = {
      sign: 'rsa',
      hash: 'sha224',
      id: new Buffer('302d300d06096086480165030402040500041c', 'hex')
    };
    exports['RSA-SHA256'] = exports.sha256WithRSAEncryption = {
      sign: 'rsa',
      hash: 'sha256',
      id: new Buffer('3031300d060960864801650304020105000420', 'hex')
    };
    exports['RSA-SHA384'] = exports.sha384WithRSAEncryption = {
      sign: 'rsa',
      hash: 'sha384',
      id: new Buffer('3041300d060960864801650304020205000430', 'hex')
    };
    exports['RSA-SHA512'] = exports.sha512WithRSAEncryption = {
      sign: 'rsa',
      hash: 'sha512',
      id: new Buffer('3051300d060960864801650304020305000440', 'hex')
    };
    exports['RSA-SHA1'] = {
      sign: 'rsa',
      hash: 'sha1',
      id: new Buffer('3021300906052b0e03021a05000414', 'hex')
    };
    exports['ecdsa-with-SHA1'] = {
      sign: 'ecdsa',
      hash: 'sha1',
      id: new Buffer('', 'hex')
    };
    exports.DSA = exports['DSA-SHA1'] = exports['DSA-SHA'] = {
      sign: 'dsa',
      hash: 'sha1',
      id: new Buffer('', 'hex')
    };
    exports['DSA-SHA224'] = exports['DSA-WITH-SHA224'] = {
      sign: 'dsa',
      hash: 'sha224',
      id: new Buffer('', 'hex')
    };
    exports['DSA-SHA256'] = exports['DSA-WITH-SHA256'] = {
      sign: 'dsa',
      hash: 'sha256',
      id: new Buffer('', 'hex')
    };
    exports['DSA-SHA384'] = exports['DSA-WITH-SHA384'] = {
      sign: 'dsa',
      hash: 'sha384',
      id: new Buffer('', 'hex')
    };
    exports['DSA-SHA512'] = exports['DSA-WITH-SHA512'] = {
      sign: 'dsa',
      hash: 'sha512',
      id: new Buffer('', 'hex')
    };
    exports['DSA-RIPEMD160'] = {
      sign: 'dsa',
      hash: 'rmd160',
      id: new Buffer('', 'hex')
    };
    exports['RSA-RIPEMD160'] = exports.ripemd160WithRSA = {
      sign: 'rsa',
      hash: 'rmd160',
      id: new Buffer('3021300906052b2403020105000414', 'hex')
    };
    exports['RSA-MD5'] = exports.md5WithRSAEncryption = {
      sign: 'rsa',
      hash: 'md5',
      id: new Buffer('3020300c06082a864886f70d020505000410', 'hex')
    };
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic('1f6', ['1f8', '1f9', '1f7', '1fa', '1fb', '1ee', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    var createHmac = $__require('1f8');
    var crt = $__require('1f9');
    var curves = $__require('1f7');
    var elliptic = $__require('1fa');
    var parseKeys = $__require('1fb');
    var BN = $__require('1ee');
    var EC = elliptic.ec;
    function sign(hash, key, hashType, signType) {
      var priv = parseKeys(key);
      if (priv.curve) {
        if (signType !== 'ecdsa') throw new Error('wrong private key type');
        return ecSign(hash, priv);
      } else if (priv.type === 'dsa') {
        if (signType !== 'dsa') {
          throw new Error('wrong private key type');
        }
        return dsaSign(hash, priv, hashType);
      } else {
        if (signType !== 'rsa') throw new Error('wrong private key type');
      }
      var len = priv.modulus.byteLength();
      var pad = [0, 1];
      while (hash.length + pad.length + 1 < len) {
        pad.push(0xff);
      }
      pad.push(0x00);
      var i = -1;
      while (++i < hash.length) {
        pad.push(hash[i]);
      }
      var out = crt(pad, priv);
      return out;
    }
    function ecSign(hash, priv) {
      var curveId = curves[priv.curve.join('.')];
      if (!curveId) throw new Error('unknown curve ' + priv.curve.join('.'));
      var curve = new EC(curveId);
      var key = curve.genKeyPair();
      key._importPrivate(priv.privateKey);
      var out = key.sign(hash);
      return new Buffer(out.toDER());
    }
    function dsaSign(hash, priv, algo) {
      var x = priv.params.priv_key;
      var p = priv.params.p;
      var q = priv.params.q;
      var g = priv.params.g;
      var r = new BN(0);
      var k;
      var H = bits2int(hash, q).mod(q);
      var s = false;
      var kv = getKey(x, q, hash, algo);
      while (s === false) {
        k = makeKey(q, kv, algo);
        r = makeR(g, k, p, q);
        s = k.invm(q).imul(H.add(x.mul(r))).mod(q);
        if (!s.cmpn(0)) {
          s = false;
          r = new BN(0);
        }
      }
      return toDER(r, s);
    }
    function toDER(r, s) {
      r = r.toArray();
      s = s.toArray();
      if (r[0] & 0x80) {
        r = [0].concat(r);
      }
      if (s[0] & 0x80) {
        s = [0].concat(s);
      }
      var total = r.length + s.length + 4;
      var res = [0x30, total, 0x02, r.length];
      res = res.concat(r, [0x02, s.length], s);
      return new Buffer(res);
    }
    function getKey(x, q, hash, algo) {
      x = new Buffer(x.toArray());
      if (x.length < q.byteLength()) {
        var zeros = new Buffer(q.byteLength() - x.length);
        zeros.fill(0);
        x = Buffer.concat([zeros, x]);
      }
      var hlen = hash.length;
      var hbits = bits2octets(hash, q);
      var v = new Buffer(hlen);
      v.fill(1);
      var k = new Buffer(hlen);
      k.fill(0);
      k = createHmac(algo, k).update(v).update(new Buffer([0])).update(x).update(hbits).digest();
      v = createHmac(algo, k).update(v).digest();
      k = createHmac(algo, k).update(v).update(new Buffer([1])).update(x).update(hbits).digest();
      v = createHmac(algo, k).update(v).digest();
      return {
        k: k,
        v: v
      };
    }
    function bits2int(obits, q) {
      var bits = new BN(obits);
      var shift = (obits.length << 3) - q.bitLength();
      if (shift > 0) {
        bits.ishrn(shift);
      }
      return bits;
    }
    function bits2octets(bits, q) {
      bits = bits2int(bits, q);
      bits = bits.mod(q);
      var out = new Buffer(bits.toArray());
      if (out.length < q.byteLength()) {
        var zeros = new Buffer(q.byteLength() - out.length);
        zeros.fill(0);
        out = Buffer.concat([zeros, out]);
      }
      return out;
    }
    function makeKey(q, kv, algo) {
      var t, k;
      do {
        t = new Buffer('');
        while (t.length * 8 < q.bitLength()) {
          kv.v = createHmac(algo, kv.k).update(kv.v).digest();
          t = Buffer.concat([t, kv.v]);
        }
        k = bits2int(t, q);
        kv.k = createHmac(algo, kv.k).update(kv.v).update(new Buffer([0])).digest();
        kv.v = createHmac(algo, kv.k).update(kv.v).digest();
      } while (k.cmp(q) !== -1);
      return k;
    }
    function makeR(g, k, p, q) {
      return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q);
    }
    module.exports = sign;
    module.exports.getKey = getKey;
    module.exports.makeKey = makeKey;
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic('1f7', [], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  exports['1.3.132.0.10'] = 'secp256k1';

  exports['1.3.132.0.33'] = 'p224';

  exports['1.2.840.10045.3.1.1'] = 'p192';

  exports['1.2.840.10045.3.1.7'] = 'p256';

  exports['1.3.132.0.34'] = 'p384';

  exports['1.3.132.0.35'] = 'p521';
  return module.exports;
});
$__System.registerDynamic('1fc', ['1f7', '1fa', '1fb', '1ee', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    var curves = $__require('1f7');
    var elliptic = $__require('1fa');
    var parseKeys = $__require('1fb');
    var BN = $__require('1ee');
    var EC = elliptic.ec;
    function verify(sig, hash, key, signType) {
      var pub = parseKeys(key);
      if (pub.type === 'ec') {
        if (signType !== 'ecdsa') {
          throw new Error('wrong public key type');
        }
        return ecVerify(sig, hash, pub);
      } else if (pub.type === 'dsa') {
        if (signType !== 'dsa') {
          throw new Error('wrong public key type');
        }
        return dsaVerify(sig, hash, pub);
      } else {
        if (signType !== 'rsa') {
          throw new Error('wrong public key type');
        }
      }
      var len = pub.modulus.byteLength();
      var pad = [1];
      var padNum = 0;
      while (hash.length + pad.length + 2 < len) {
        pad.push(0xff);
        padNum++;
      }
      pad.push(0x00);
      var i = -1;
      while (++i < hash.length) {
        pad.push(hash[i]);
      }
      pad = new Buffer(pad);
      var red = BN.mont(pub.modulus);
      sig = new BN(sig).toRed(red);
      sig = sig.redPow(new BN(pub.publicExponent));
      sig = new Buffer(sig.fromRed().toArray());
      var out = 0;
      if (padNum < 8) {
        out = 1;
      }
      len = Math.min(sig.length, pad.length);
      if (sig.length !== pad.length) {
        out = 1;
      }
      i = -1;
      while (++i < len) {
        out |= sig[i] ^ pad[i];
      }
      return out === 0;
    }
    function ecVerify(sig, hash, pub) {
      var curveId = curves[pub.data.algorithm.curve.join('.')];
      if (!curveId) throw new Error('unknown curve ' + pub.data.algorithm.curve.join('.'));
      var curve = new EC(curveId);
      var pubkey = pub.data.subjectPrivateKey.data;
      return curve.verify(hash, sig, pubkey);
    }
    function dsaVerify(sig, hash, pub) {
      var p = pub.data.p;
      var q = pub.data.q;
      var g = pub.data.g;
      var y = pub.data.pub_key;
      var unpacked = parseKeys.signature.decode(sig, 'der');
      var s = unpacked.s;
      var r = unpacked.r;
      checkValue(s, q);
      checkValue(r, q);
      var montp = BN.mont(p);
      var w = s.invm(q);
      var v = g.toRed(montp).redPow(new BN(hash).mul(w).mod(q)).fromRed().mul(y.toRed(montp).redPow(r.mul(w).mod(q)).fromRed()).mod(p).mod(q);
      return !v.cmp(r);
    }
    function checkValue(b, q) {
      if (b.cmpn(0) <= 0) {
        throw new Error('invalid sig');
      }
      if (b.cmp(q) >= q) {
        throw new Error('invalid sig');
      }
    }
    module.exports = verify;
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic('1fd', ['1f5', '1fe', '46', '1f6', '49', '1fc', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    var _algos = $__require('1f5');
    var createHash = $__require('1fe');
    var inherits = $__require('46');
    var sign = $__require('1f6');
    var stream = $__require('49');
    var verify = $__require('1fc');
    var algos = {};
    Object.keys(_algos).forEach(function (key) {
      algos[key] = algos[key.toLowerCase()] = _algos[key];
    });
    function Sign(algorithm) {
      stream.Writable.call(this);
      var data = algos[algorithm];
      if (!data) {
        throw new Error('Unknown message digest');
      }
      this._hashType = data.hash;
      this._hash = createHash(data.hash);
      this._tag = data.id;
      this._signType = data.sign;
    }
    inherits(Sign, stream.Writable);
    Sign.prototype._write = function _write(data, _, done) {
      this._hash.update(data);
      done();
    };
    Sign.prototype.update = function update(data, enc) {
      if (typeof data === 'string') {
        data = new Buffer(data, enc);
      }
      this._hash.update(data);
      return this;
    };
    Sign.prototype.sign = function signMethod(key, enc) {
      this.end();
      var hash = this._hash.digest();
      var sig = sign(Buffer.concat([this._tag, hash]), key, this._hashType, this._signType);
      return enc ? sig.toString(enc) : sig;
    };
    function Verify(algorithm) {
      stream.Writable.call(this);
      var data = algos[algorithm];
      if (!data) {
        throw new Error('Unknown message digest');
      }
      this._hash = createHash(data.hash);
      this._tag = data.id;
      this._signType = data.sign;
    }
    inherits(Verify, stream.Writable);
    Verify.prototype._write = function _write(data, _, done) {
      this._hash.update(data);
      done();
    };
    Verify.prototype.update = function update(data, enc) {
      if (typeof data === 'string') {
        data = new Buffer(data, enc);
      }
      this._hash.update(data);
      return this;
    };
    Verify.prototype.verify = function verifyMethod(key, sig, enc) {
      if (typeof sig === 'string') {
        sig = new Buffer(sig, enc);
      }
      this.end();
      var hash = this._hash.digest();
      return verify(sig, Buffer.concat([this._tag, hash]), key, this._signType);
    };
    function createSign(algorithm) {
      return new Sign(algorithm);
    }
    function createVerify(algorithm) {
      return new Verify(algorithm);
    }
    module.exports = {
      Sign: createSign,
      Verify: createVerify,
      createSign: createSign,
      createVerify: createVerify
    };
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic("1ff", ["1fd"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("1fd");
  return module.exports;
});
$__System.registerDynamic("200", [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = { "name": "elliptic", "version": "6.3.2", "description": "EC cryptography", "main": "lib/elliptic.js", "files": ["lib"], "scripts": { "jscs": "jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js", "jshint": "jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js", "lint": "npm run jscs && npm run jshint", "unit": "istanbul test _mocha --reporter=spec test/index.js", "test": "npm run lint && npm run unit", "version": "grunt dist && git add dist/" }, "repository": { "type": "git", "url": "git@github.com:indutny/elliptic" }, "keywords": ["EC", "Elliptic", "curve", "Cryptography"], "author": "Fedor Indutny <fedor@indutny.com>", "license": "MIT", "bugs": { "url": "https://github.com/indutny/elliptic/issues" }, "homepage": "https://github.com/indutny/elliptic", "devDependencies": { "brfs": "^1.4.3", "coveralls": "^2.11.3", "grunt": "^0.4.5", "grunt-browserify": "^5.0.0", "grunt-contrib-connect": "^1.0.0", "grunt-contrib-copy": "^1.0.0", "grunt-contrib-uglify": "^1.0.1", "grunt-mocha-istanbul": "^3.0.1", "grunt-saucelabs": "^8.6.2", "istanbul": "^0.4.2", "jscs": "^2.9.0", "jshint": "^2.6.0", "mocha": "^2.1.0" }, "dependencies": { "bn.js": "^4.4.0", "brorand": "^1.0.1", "hash.js": "^1.0.0", "inherits": "^2.0.1" } };
  return module.exports;
});
$__System.registerDynamic('201', ['1ee'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var utils = exports;
  var BN = $__require('1ee');

  utils.assert = function assert(val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  };

  function toArray(msg, enc) {
    if (Array.isArray(msg)) return msg.slice();
    if (!msg) return [];
    var res = [];
    if (typeof msg !== 'string') {
      for (var i = 0; i < msg.length; i++) res[i] = msg[i] | 0;
      return res;
    }
    if (!enc) {
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        var hi = c >> 8;
        var lo = c & 0xff;
        if (hi) res.push(hi, lo);else res.push(lo);
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0) msg = '0' + msg;
      for (var i = 0; i < msg.length; i += 2) res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
    return res;
  }
  utils.toArray = toArray;

  function zero2(word) {
    if (word.length === 1) return '0' + word;else return word;
  }
  utils.zero2 = zero2;

  function toHex(msg) {
    var res = '';
    for (var i = 0; i < msg.length; i++) res += zero2(msg[i].toString(16));
    return res;
  }
  utils.toHex = toHex;

  utils.encode = function encode(arr, enc) {
    if (enc === 'hex') return toHex(arr);else return arr;
  };

  // Represent num in a w-NAF form
  function getNAF(num, w) {
    var naf = [];
    var ws = 1 << w + 1;
    var k = num.clone();
    while (k.cmpn(1) >= 0) {
      var z;
      if (k.isOdd()) {
        var mod = k.andln(ws - 1);
        if (mod > (ws >> 1) - 1) z = (ws >> 1) - mod;else z = mod;
        k.isubn(z);
      } else {
        z = 0;
      }
      naf.push(z);

      // Optimization, shift by word if possible
      var shift = k.cmpn(0) !== 0 && k.andln(ws - 1) === 0 ? w + 1 : 1;
      for (var i = 1; i < shift; i++) naf.push(0);
      k.iushrn(shift);
    }

    return naf;
  }
  utils.getNAF = getNAF;

  // Represent k1, k2 in a Joint Sparse Form
  function getJSF(k1, k2) {
    var jsf = [[], []];

    k1 = k1.clone();
    k2 = k2.clone();
    var d1 = 0;
    var d2 = 0;
    while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {

      // First phase
      var m14 = k1.andln(3) + d1 & 3;
      var m24 = k2.andln(3) + d2 & 3;
      if (m14 === 3) m14 = -1;
      if (m24 === 3) m24 = -1;
      var u1;
      if ((m14 & 1) === 0) {
        u1 = 0;
      } else {
        var m8 = k1.andln(7) + d1 & 7;
        if ((m8 === 3 || m8 === 5) && m24 === 2) u1 = -m14;else u1 = m14;
      }
      jsf[0].push(u1);

      var u2;
      if ((m24 & 1) === 0) {
        u2 = 0;
      } else {
        var m8 = k2.andln(7) + d2 & 7;
        if ((m8 === 3 || m8 === 5) && m14 === 2) u2 = -m24;else u2 = m24;
      }
      jsf[1].push(u2);

      // Second phase
      if (2 * d1 === u1 + 1) d1 = 1 - d1;
      if (2 * d2 === u2 + 1) d2 = 1 - d2;
      k1.iushrn(1);
      k2.iushrn(1);
    }

    return jsf;
  }
  utils.getJSF = getJSF;

  function cachedProperty(obj, name, computer) {
    var key = '_' + name;
    obj.prototype[name] = function cachedProperty() {
      return this[key] !== undefined ? this[key] : this[key] = computer.call(this);
    };
  }
  utils.cachedProperty = cachedProperty;

  function parseBytes(bytes) {
    return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') : bytes;
  }
  utils.parseBytes = parseBytes;

  function intFromLE(bytes) {
    return new BN(bytes, 'hex', 'le');
  }
  utils.intFromLE = intFromLE;
  return module.exports;
});
$__System.registerDynamic('202', ['@empty'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var r;
  module.exports = function rand(len) {
    if (!r) r = new Rand(null);
    return r.generate(len);
  };
  function Rand(rand) {
    this.rand = rand;
  }
  module.exports.Rand = Rand;
  Rand.prototype.generate = function generate(len) {
    return this._rand(len);
  };
  if (typeof window === 'object') {
    if (window.crypto && window.crypto.getRandomValues) {
      Rand.prototype._rand = function _rand(n) {
        var arr = new Uint8Array(n);
        window.crypto.getRandomValues(arr);
        return arr;
      };
    } else if (window.msCrypto && window.msCrypto.getRandomValues) {
      Rand.prototype._rand = function _rand(n) {
        var arr = new Uint8Array(n);
        window.msCrypto.getRandomValues(arr);
        return arr;
      };
    } else {
      Rand.prototype._rand = function () {
        throw new Error('Not implemented yet');
      };
    }
  } else {
    try {
      var crypto = $__require('@empty');
      Rand.prototype._rand = function _rand(n) {
        return crypto.randomBytes(n);
      };
    } catch (e) {
      Rand.prototype._rand = function _rand(n) {
        var res = new Uint8Array(n);
        for (var i = 0; i < res.length; i++) res[i] = this.rand.getByte();
        return res;
      };
    }
  }
  return module.exports;
});
$__System.registerDynamic("1ed", ["202"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("202");
  return module.exports;
});
$__System.registerDynamic('203', ['205', '204'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var hash = $__require('205');
  var elliptic = $__require('204');
  var utils = elliptic.utils;
  var assert = utils.assert;
  function HmacDRBG(options) {
    if (!(this instanceof HmacDRBG)) return new HmacDRBG(options);
    this.hash = options.hash;
    this.predResist = !!options.predResist;
    this.outLen = this.hash.outSize;
    this.minEntropy = options.minEntropy || this.hash.hmacStrength;
    this.reseed = null;
    this.reseedInterval = null;
    this.K = null;
    this.V = null;
    var entropy = utils.toArray(options.entropy, options.entropyEnc);
    var nonce = utils.toArray(options.nonce, options.nonceEnc);
    var pers = utils.toArray(options.pers, options.persEnc);
    assert(entropy.length >= this.minEntropy / 8, 'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
    this._init(entropy, nonce, pers);
  }
  module.exports = HmacDRBG;
  HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
    var seed = entropy.concat(nonce).concat(pers);
    this.K = new Array(this.outLen / 8);
    this.V = new Array(this.outLen / 8);
    for (var i = 0; i < this.V.length; i++) {
      this.K[i] = 0x00;
      this.V[i] = 0x01;
    }
    this._update(seed);
    this.reseed = 1;
    this.reseedInterval = 0x1000000000000;
  };
  HmacDRBG.prototype._hmac = function hmac() {
    return new hash.hmac(this.hash, this.K);
  };
  HmacDRBG.prototype._update = function update(seed) {
    var kmac = this._hmac().update(this.V).update([0x00]);
    if (seed) kmac = kmac.update(seed);
    this.K = kmac.digest();
    this.V = this._hmac().update(this.V).digest();
    if (!seed) return;
    this.K = this._hmac().update(this.V).update([0x01]).update(seed).digest();
    this.V = this._hmac().update(this.V).digest();
  };
  HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
    if (typeof entropyEnc !== 'string') {
      addEnc = add;
      add = entropyEnc;
      entropyEnc = null;
    }
    entropy = utils.toBuffer(entropy, entropyEnc);
    add = utils.toBuffer(add, addEnc);
    assert(entropy.length >= this.minEntropy / 8, 'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
    this._update(entropy.concat(add || []));
    this.reseed = 1;
  };
  HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
    if (this.reseed > this.reseedInterval) throw new Error('Reseed is required');
    if (typeof enc !== 'string') {
      addEnc = add;
      add = enc;
      enc = null;
    }
    if (add) {
      add = utils.toArray(add, addEnc);
      this._update(add);
    }
    var temp = [];
    while (temp.length < len) {
      this.V = this._hmac().update(this.V).digest();
      temp = temp.concat(this.V);
    }
    var res = temp.slice(0, len);
    this._update(add);
    this.reseed++;
    return utils.encode(res, enc);
  };
  return module.exports;
});
$__System.registerDynamic('206', ['1ee', '204'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var BN = $__require('1ee');
  var elliptic = $__require('204');
  var utils = elliptic.utils;
  var getNAF = utils.getNAF;
  var getJSF = utils.getJSF;
  var assert = utils.assert;
  function BaseCurve(type, conf) {
    this.type = type;
    this.p = new BN(conf.p, 16);
    this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
    this.zero = new BN(0).toRed(this.red);
    this.one = new BN(1).toRed(this.red);
    this.two = new BN(2).toRed(this.red);
    this.n = conf.n && new BN(conf.n, 16);
    this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
    this._wnafT1 = new Array(4);
    this._wnafT2 = new Array(4);
    this._wnafT3 = new Array(4);
    this._wnafT4 = new Array(4);
    var adjustCount = this.n && this.p.div(this.n);
    if (!adjustCount || adjustCount.cmpn(100) > 0) {
      this.redN = null;
    } else {
      this._maxwellTrick = true;
      this.redN = this.n.toRed(this.red);
    }
  }
  module.exports = BaseCurve;
  BaseCurve.prototype.point = function point() {
    throw new Error('Not implemented');
  };
  BaseCurve.prototype.validate = function validate() {
    throw new Error('Not implemented');
  };
  BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
    assert(p.precomputed);
    var doubles = p._getDoubles();
    var naf = getNAF(k, 1);
    var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
    I /= 3;
    var repr = [];
    for (var j = 0; j < naf.length; j += doubles.step) {
      var nafW = 0;
      for (var k = j + doubles.step - 1; k >= j; k--) nafW = (nafW << 1) + naf[k];
      repr.push(nafW);
    }
    var a = this.jpoint(null, null, null);
    var b = this.jpoint(null, null, null);
    for (var i = I; i > 0; i--) {
      for (var j = 0; j < repr.length; j++) {
        var nafW = repr[j];
        if (nafW === i) b = b.mixedAdd(doubles.points[j]);else if (nafW === -i) b = b.mixedAdd(doubles.points[j].neg());
      }
      a = a.add(b);
    }
    return a.toP();
  };
  BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
    var w = 4;
    var nafPoints = p._getNAFPoints(w);
    w = nafPoints.wnd;
    var wnd = nafPoints.points;
    var naf = getNAF(k, w);
    var acc = this.jpoint(null, null, null);
    for (var i = naf.length - 1; i >= 0; i--) {
      for (var k = 0; i >= 0 && naf[i] === 0; i--) k++;
      if (i >= 0) k++;
      acc = acc.dblp(k);
      if (i < 0) break;
      var z = naf[i];
      assert(z !== 0);
      if (p.type === 'affine') {
        if (z > 0) acc = acc.mixedAdd(wnd[z - 1 >> 1]);else acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
      } else {
        if (z > 0) acc = acc.add(wnd[z - 1 >> 1]);else acc = acc.add(wnd[-z - 1 >> 1].neg());
      }
    }
    return p.type === 'affine' ? acc.toP() : acc;
  };
  BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
    var wndWidth = this._wnafT1;
    var wnd = this._wnafT2;
    var naf = this._wnafT3;
    var max = 0;
    for (var i = 0; i < len; i++) {
      var p = points[i];
      var nafPoints = p._getNAFPoints(defW);
      wndWidth[i] = nafPoints.wnd;
      wnd[i] = nafPoints.points;
    }
    for (var i = len - 1; i >= 1; i -= 2) {
      var a = i - 1;
      var b = i;
      if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
        naf[a] = getNAF(coeffs[a], wndWidth[a]);
        naf[b] = getNAF(coeffs[b], wndWidth[b]);
        max = Math.max(naf[a].length, max);
        max = Math.max(naf[b].length, max);
        continue;
      }
      var comb = [points[a], null, null, points[b]];
      if (points[a].y.cmp(points[b].y) === 0) {
        comb[1] = points[a].add(points[b]);
        comb[2] = points[a].toJ().mixedAdd(points[b].neg());
      } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
        comb[1] = points[a].toJ().mixedAdd(points[b]);
        comb[2] = points[a].add(points[b].neg());
      } else {
        comb[1] = points[a].toJ().mixedAdd(points[b]);
        comb[2] = points[a].toJ().mixedAdd(points[b].neg());
      }
      var index = [-3, -1, -5, -7, 0, 7, 5, 1, 3];
      var jsf = getJSF(coeffs[a], coeffs[b]);
      max = Math.max(jsf[0].length, max);
      naf[a] = new Array(max);
      naf[b] = new Array(max);
      for (var j = 0; j < max; j++) {
        var ja = jsf[0][j] | 0;
        var jb = jsf[1][j] | 0;
        naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
        naf[b][j] = 0;
        wnd[a] = comb;
      }
    }
    var acc = this.jpoint(null, null, null);
    var tmp = this._wnafT4;
    for (var i = max; i >= 0; i--) {
      var k = 0;
      while (i >= 0) {
        var zero = true;
        for (var j = 0; j < len; j++) {
          tmp[j] = naf[j][i] | 0;
          if (tmp[j] !== 0) zero = false;
        }
        if (!zero) break;
        k++;
        i--;
      }
      if (i >= 0) k++;
      acc = acc.dblp(k);
      if (i < 0) break;
      for (var j = 0; j < len; j++) {
        var z = tmp[j];
        var p;
        if (z === 0) continue;else if (z > 0) p = wnd[j][z - 1 >> 1];else if (z < 0) p = wnd[j][-z - 1 >> 1].neg();
        if (p.type === 'affine') acc = acc.mixedAdd(p);else acc = acc.add(p);
      }
    }
    for (var i = 0; i < len; i++) wnd[i] = null;
    if (jacobianResult) return acc;else return acc.toP();
  };
  function BasePoint(curve, type) {
    this.curve = curve;
    this.type = type;
    this.precomputed = null;
  }
  BaseCurve.BasePoint = BasePoint;
  BasePoint.prototype.eq = function eq() {
    throw new Error('Not implemented');
  };
  BasePoint.prototype.validate = function validate() {
    return this.curve.validate(this);
  };
  BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
    bytes = utils.toArray(bytes, enc);
    var len = this.p.byteLength();
    if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) && bytes.length - 1 === 2 * len) {
      if (bytes[0] === 0x06) assert(bytes[bytes.length - 1] % 2 === 0);else if (bytes[0] === 0x07) assert(bytes[bytes.length - 1] % 2 === 1);
      var res = this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));
      return res;
    } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) && bytes.length - 1 === len) {
      return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
    }
    throw new Error('Unknown point format');
  };
  BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
    return this.encode(enc, true);
  };
  BasePoint.prototype._encode = function _encode(compact) {
    var len = this.curve.p.byteLength();
    var x = this.getX().toArray('be', len);
    if (compact) return [this.getY().isEven() ? 0x02 : 0x03].concat(x);
    return [0x04].concat(x, this.getY().toArray('be', len));
  };
  BasePoint.prototype.encode = function encode(enc, compact) {
    return utils.encode(this._encode(compact), enc);
  };
  BasePoint.prototype.precompute = function precompute(power) {
    if (this.precomputed) return this;
    var precomputed = {
      doubles: null,
      naf: null,
      beta: null
    };
    precomputed.naf = this._getNAFPoints(8);
    precomputed.doubles = this._getDoubles(4, power);
    precomputed.beta = this._getBeta();
    this.precomputed = precomputed;
    return this;
  };
  BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
    if (!this.precomputed) return false;
    var doubles = this.precomputed.doubles;
    if (!doubles) return false;
    return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
  };
  BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
    if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
    var doubles = [this];
    var acc = this;
    for (var i = 0; i < power; i += step) {
      for (var j = 0; j < step; j++) acc = acc.dbl();
      doubles.push(acc);
    }
    return {
      step: step,
      points: doubles
    };
  };
  BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
    if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
    var res = [this];
    var max = (1 << wnd) - 1;
    var dbl = max === 1 ? null : this.dbl();
    for (var i = 1; i < max; i++) res[i] = res[i - 1].add(dbl);
    return {
      wnd: wnd,
      points: res
    };
  };
  BasePoint.prototype._getBeta = function _getBeta() {
    return null;
  };
  BasePoint.prototype.dblp = function dblp(k) {
    var r = this;
    for (var i = 0; i < k; i++) r = r.dbl();
    return r;
  };
  return module.exports;
});
$__System.registerDynamic('207', ['208', '204', '1ee', '46'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var curve = $__require('208');
  var elliptic = $__require('204');
  var BN = $__require('1ee');
  var inherits = $__require('46');
  var Base = curve.base;
  var assert = elliptic.utils.assert;
  function ShortCurve(conf) {
    Base.call(this, 'short', conf);
    this.a = new BN(conf.a, 16).toRed(this.red);
    this.b = new BN(conf.b, 16).toRed(this.red);
    this.tinv = this.two.redInvm();
    this.zeroA = this.a.fromRed().cmpn(0) === 0;
    this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
    this.endo = this._getEndomorphism(conf);
    this._endoWnafT1 = new Array(4);
    this._endoWnafT2 = new Array(4);
  }
  inherits(ShortCurve, Base);
  module.exports = ShortCurve;
  ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
    if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1) return;
    var beta;
    var lambda;
    if (conf.beta) {
      beta = new BN(conf.beta, 16).toRed(this.red);
    } else {
      var betas = this._getEndoRoots(this.p);
      beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
      beta = beta.toRed(this.red);
    }
    if (conf.lambda) {
      lambda = new BN(conf.lambda, 16);
    } else {
      var lambdas = this._getEndoRoots(this.n);
      if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
        lambda = lambdas[0];
      } else {
        lambda = lambdas[1];
        assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
      }
    }
    var basis;
    if (conf.basis) {
      basis = conf.basis.map(function (vec) {
        return {
          a: new BN(vec.a, 16),
          b: new BN(vec.b, 16)
        };
      });
    } else {
      basis = this._getEndoBasis(lambda);
    }
    return {
      beta: beta,
      lambda: lambda,
      basis: basis
    };
  };
  ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
    var red = num === this.p ? this.red : BN.mont(num);
    var tinv = new BN(2).toRed(red).redInvm();
    var ntinv = tinv.redNeg();
    var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);
    var l1 = ntinv.redAdd(s).fromRed();
    var l2 = ntinv.redSub(s).fromRed();
    return [l1, l2];
  };
  ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
    var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
    var u = lambda;
    var v = this.n.clone();
    var x1 = new BN(1);
    var y1 = new BN(0);
    var x2 = new BN(0);
    var y2 = new BN(1);
    var a0;
    var b0;
    var a1;
    var b1;
    var a2;
    var b2;
    var prevR;
    var i = 0;
    var r;
    var x;
    while (u.cmpn(0) !== 0) {
      var q = v.div(u);
      r = v.sub(q.mul(u));
      x = x2.sub(q.mul(x1));
      var y = y2.sub(q.mul(y1));
      if (!a1 && r.cmp(aprxSqrt) < 0) {
        a0 = prevR.neg();
        b0 = x1;
        a1 = r.neg();
        b1 = x;
      } else if (a1 && ++i === 2) {
        break;
      }
      prevR = r;
      v = u;
      u = r;
      x2 = x1;
      x1 = x;
      y2 = y1;
      y1 = y;
    }
    a2 = r.neg();
    b2 = x;
    var len1 = a1.sqr().add(b1.sqr());
    var len2 = a2.sqr().add(b2.sqr());
    if (len2.cmp(len1) >= 0) {
      a2 = a0;
      b2 = b0;
    }
    if (a1.negative) {
      a1 = a1.neg();
      b1 = b1.neg();
    }
    if (a2.negative) {
      a2 = a2.neg();
      b2 = b2.neg();
    }
    return [{
      a: a1,
      b: b1
    }, {
      a: a2,
      b: b2
    }];
  };
  ShortCurve.prototype._endoSplit = function _endoSplit(k) {
    var basis = this.endo.basis;
    var v1 = basis[0];
    var v2 = basis[1];
    var c1 = v2.b.mul(k).divRound(this.n);
    var c2 = v1.b.neg().mul(k).divRound(this.n);
    var p1 = c1.mul(v1.a);
    var p2 = c2.mul(v2.a);
    var q1 = c1.mul(v1.b);
    var q2 = c2.mul(v2.b);
    var k1 = k.sub(p1).sub(p2);
    var k2 = q1.add(q2).neg();
    return {
      k1: k1,
      k2: k2
    };
  };
  ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
    x = new BN(x, 16);
    if (!x.red) x = x.toRed(this.red);
    var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
    var y = y2.redSqrt();
    if (y.redSqr().redSub(y2).cmp(this.zero) !== 0) throw new Error('invalid point');
    var isOdd = y.fromRed().isOdd();
    if (odd && !isOdd || !odd && isOdd) y = y.redNeg();
    return this.point(x, y);
  };
  ShortCurve.prototype.validate = function validate(point) {
    if (point.inf) return true;
    var x = point.x;
    var y = point.y;
    var ax = this.a.redMul(x);
    var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
    return y.redSqr().redISub(rhs).cmpn(0) === 0;
  };
  ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
    var npoints = this._endoWnafT1;
    var ncoeffs = this._endoWnafT2;
    for (var i = 0; i < points.length; i++) {
      var split = this._endoSplit(coeffs[i]);
      var p = points[i];
      var beta = p._getBeta();
      if (split.k1.negative) {
        split.k1.ineg();
        p = p.neg(true);
      }
      if (split.k2.negative) {
        split.k2.ineg();
        beta = beta.neg(true);
      }
      npoints[i * 2] = p;
      npoints[i * 2 + 1] = beta;
      ncoeffs[i * 2] = split.k1;
      ncoeffs[i * 2 + 1] = split.k2;
    }
    var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
    for (var j = 0; j < i * 2; j++) {
      npoints[j] = null;
      ncoeffs[j] = null;
    }
    return res;
  };
  function Point(curve, x, y, isRed) {
    Base.BasePoint.call(this, curve, 'affine');
    if (x === null && y === null) {
      this.x = null;
      this.y = null;
      this.inf = true;
    } else {
      this.x = new BN(x, 16);
      this.y = new BN(y, 16);
      if (isRed) {
        this.x.forceRed(this.curve.red);
        this.y.forceRed(this.curve.red);
      }
      if (!this.x.red) this.x = this.x.toRed(this.curve.red);
      if (!this.y.red) this.y = this.y.toRed(this.curve.red);
      this.inf = false;
    }
  }
  inherits(Point, Base.BasePoint);
  ShortCurve.prototype.point = function point(x, y, isRed) {
    return new Point(this, x, y, isRed);
  };
  ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
    return Point.fromJSON(this, obj, red);
  };
  Point.prototype._getBeta = function _getBeta() {
    if (!this.curve.endo) return;
    var pre = this.precomputed;
    if (pre && pre.beta) return pre.beta;
    var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (pre) {
      var curve = this.curve;
      var endoMul = function (p) {
        return curve.point(p.x.redMul(curve.endo.beta), p.y);
      };
      pre.beta = beta;
      beta.precomputed = {
        beta: null,
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: pre.naf.points.map(endoMul)
        },
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: pre.doubles.points.map(endoMul)
        }
      };
    }
    return beta;
  };
  Point.prototype.toJSON = function toJSON() {
    if (!this.precomputed) return [this.x, this.y];
    return [this.x, this.y, this.precomputed && {
      doubles: this.precomputed.doubles && {
        step: this.precomputed.doubles.step,
        points: this.precomputed.doubles.points.slice(1)
      },
      naf: this.precomputed.naf && {
        wnd: this.precomputed.naf.wnd,
        points: this.precomputed.naf.points.slice(1)
      }
    }];
  };
  Point.fromJSON = function fromJSON(curve, obj, red) {
    if (typeof obj === 'string') obj = JSON.parse(obj);
    var res = curve.point(obj[0], obj[1], red);
    if (!obj[2]) return res;
    function obj2point(obj) {
      return curve.point(obj[0], obj[1], red);
    }
    var pre = obj[2];
    res.precomputed = {
      beta: null,
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: [res].concat(pre.doubles.points.map(obj2point))
      },
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: [res].concat(pre.naf.points.map(obj2point))
      }
    };
    return res;
  };
  Point.prototype.inspect = function inspect() {
    if (this.isInfinity()) return '<EC Point Infinity>';
    return '<EC Point x: ' + this.x.fromRed().toString(16, 2) + ' y: ' + this.y.fromRed().toString(16, 2) + '>';
  };
  Point.prototype.isInfinity = function isInfinity() {
    return this.inf;
  };
  Point.prototype.add = function add(p) {
    if (this.inf) return p;
    if (p.inf) return this;
    if (this.eq(p)) return this.dbl();
    if (this.neg().eq(p)) return this.curve.point(null, null);
    if (this.x.cmp(p.x) === 0) return this.curve.point(null, null);
    var c = this.y.redSub(p.y);
    if (c.cmpn(0) !== 0) c = c.redMul(this.x.redSub(p.x).redInvm());
    var nx = c.redSqr().redISub(this.x).redISub(p.x);
    var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
    return this.curve.point(nx, ny);
  };
  Point.prototype.dbl = function dbl() {
    if (this.inf) return this;
    var ys1 = this.y.redAdd(this.y);
    if (ys1.cmpn(0) === 0) return this.curve.point(null, null);
    var a = this.curve.a;
    var x2 = this.x.redSqr();
    var dyinv = ys1.redInvm();
    var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
    var nx = c.redSqr().redISub(this.x.redAdd(this.x));
    var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
    return this.curve.point(nx, ny);
  };
  Point.prototype.getX = function getX() {
    return this.x.fromRed();
  };
  Point.prototype.getY = function getY() {
    return this.y.fromRed();
  };
  Point.prototype.mul = function mul(k) {
    k = new BN(k, 16);
    if (this._hasDoubles(k)) return this.curve._fixedNafMul(this, k);else if (this.curve.endo) return this.curve._endoWnafMulAdd([this], [k]);else return this.curve._wnafMul(this, k);
  };
  Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
    var points = [this, p2];
    var coeffs = [k1, k2];
    if (this.curve.endo) return this.curve._endoWnafMulAdd(points, coeffs);else return this.curve._wnafMulAdd(1, points, coeffs, 2);
  };
  Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
    var points = [this, p2];
    var coeffs = [k1, k2];
    if (this.curve.endo) return this.curve._endoWnafMulAdd(points, coeffs, true);else return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
  };
  Point.prototype.eq = function eq(p) {
    return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
  };
  Point.prototype.neg = function neg(_precompute) {
    if (this.inf) return this;
    var res = this.curve.point(this.x, this.y.redNeg());
    if (_precompute && this.precomputed) {
      var pre = this.precomputed;
      var negate = function (p) {
        return p.neg();
      };
      res.precomputed = {
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: pre.naf.points.map(negate)
        },
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: pre.doubles.points.map(negate)
        }
      };
    }
    return res;
  };
  Point.prototype.toJ = function toJ() {
    if (this.inf) return this.curve.jpoint(null, null, null);
    var res = this.curve.jpoint(this.x, this.y, this.curve.one);
    return res;
  };
  function JPoint(curve, x, y, z) {
    Base.BasePoint.call(this, curve, 'jacobian');
    if (x === null && y === null && z === null) {
      this.x = this.curve.one;
      this.y = this.curve.one;
      this.z = new BN(0);
    } else {
      this.x = new BN(x, 16);
      this.y = new BN(y, 16);
      this.z = new BN(z, 16);
    }
    if (!this.x.red) this.x = this.x.toRed(this.curve.red);
    if (!this.y.red) this.y = this.y.toRed(this.curve.red);
    if (!this.z.red) this.z = this.z.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;
  }
  inherits(JPoint, Base.BasePoint);
  ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
    return new JPoint(this, x, y, z);
  };
  JPoint.prototype.toP = function toP() {
    if (this.isInfinity()) return this.curve.point(null, null);
    var zinv = this.z.redInvm();
    var zinv2 = zinv.redSqr();
    var ax = this.x.redMul(zinv2);
    var ay = this.y.redMul(zinv2).redMul(zinv);
    return this.curve.point(ax, ay);
  };
  JPoint.prototype.neg = function neg() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  };
  JPoint.prototype.add = function add(p) {
    if (this.isInfinity()) return p;
    if (p.isInfinity()) return this;
    var pz2 = p.z.redSqr();
    var z2 = this.z.redSqr();
    var u1 = this.x.redMul(pz2);
    var u2 = p.x.redMul(z2);
    var s1 = this.y.redMul(pz2.redMul(p.z));
    var s2 = p.y.redMul(z2.redMul(this.z));
    var h = u1.redSub(u2);
    var r = s1.redSub(s2);
    if (h.cmpn(0) === 0) {
      if (r.cmpn(0) !== 0) return this.curve.jpoint(null, null, null);else return this.dbl();
    }
    var h2 = h.redSqr();
    var h3 = h2.redMul(h);
    var v = u1.redMul(h2);
    var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
    var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
    var nz = this.z.redMul(p.z).redMul(h);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype.mixedAdd = function mixedAdd(p) {
    if (this.isInfinity()) return p.toJ();
    if (p.isInfinity()) return this;
    var z2 = this.z.redSqr();
    var u1 = this.x;
    var u2 = p.x.redMul(z2);
    var s1 = this.y;
    var s2 = p.y.redMul(z2).redMul(this.z);
    var h = u1.redSub(u2);
    var r = s1.redSub(s2);
    if (h.cmpn(0) === 0) {
      if (r.cmpn(0) !== 0) return this.curve.jpoint(null, null, null);else return this.dbl();
    }
    var h2 = h.redSqr();
    var h3 = h2.redMul(h);
    var v = u1.redMul(h2);
    var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
    var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
    var nz = this.z.redMul(h);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype.dblp = function dblp(pow) {
    if (pow === 0) return this;
    if (this.isInfinity()) return this;
    if (!pow) return this.dbl();
    if (this.curve.zeroA || this.curve.threeA) {
      var r = this;
      for (var i = 0; i < pow; i++) r = r.dbl();
      return r;
    }
    var a = this.curve.a;
    var tinv = this.curve.tinv;
    var jx = this.x;
    var jy = this.y;
    var jz = this.z;
    var jz4 = jz.redSqr().redSqr();
    var jyd = jy.redAdd(jy);
    for (var i = 0; i < pow; i++) {
      var jx2 = jx.redSqr();
      var jyd2 = jyd.redSqr();
      var jyd4 = jyd2.redSqr();
      var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
      var t1 = jx.redMul(jyd2);
      var nx = c.redSqr().redISub(t1.redAdd(t1));
      var t2 = t1.redISub(nx);
      var dny = c.redMul(t2);
      dny = dny.redIAdd(dny).redISub(jyd4);
      var nz = jyd.redMul(jz);
      if (i + 1 < pow) jz4 = jz4.redMul(jyd4);
      jx = nx;
      jz = nz;
      jyd = dny;
    }
    return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
  };
  JPoint.prototype.dbl = function dbl() {
    if (this.isInfinity()) return this;
    if (this.curve.zeroA) return this._zeroDbl();else if (this.curve.threeA) return this._threeDbl();else return this._dbl();
  };
  JPoint.prototype._zeroDbl = function _zeroDbl() {
    var nx;
    var ny;
    var nz;
    if (this.zOne) {
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var yyyy = yy.redSqr();
      var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      s = s.redIAdd(s);
      var m = xx.redAdd(xx).redIAdd(xx);
      var t = m.redSqr().redISub(s).redISub(s);
      var yyyy8 = yyyy.redIAdd(yyyy);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      nx = t;
      ny = m.redMul(s.redISub(t)).redISub(yyyy8);
      nz = this.y.redAdd(this.y);
    } else {
      var a = this.x.redSqr();
      var b = this.y.redSqr();
      var c = b.redSqr();
      var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
      d = d.redIAdd(d);
      var e = a.redAdd(a).redIAdd(a);
      var f = e.redSqr();
      var c8 = c.redIAdd(c);
      c8 = c8.redIAdd(c8);
      c8 = c8.redIAdd(c8);
      nx = f.redISub(d).redISub(d);
      ny = e.redMul(d.redISub(nx)).redISub(c8);
      nz = this.y.redMul(this.z);
      nz = nz.redIAdd(nz);
    }
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype._threeDbl = function _threeDbl() {
    var nx;
    var ny;
    var nz;
    if (this.zOne) {
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var yyyy = yy.redSqr();
      var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      s = s.redIAdd(s);
      var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
      var t = m.redSqr().redISub(s).redISub(s);
      nx = t;
      var yyyy8 = yyyy.redIAdd(yyyy);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      ny = m.redMul(s.redISub(t)).redISub(yyyy8);
      nz = this.y.redAdd(this.y);
    } else {
      var delta = this.z.redSqr();
      var gamma = this.y.redSqr();
      var beta = this.x.redMul(gamma);
      var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
      alpha = alpha.redAdd(alpha).redIAdd(alpha);
      var beta4 = beta.redIAdd(beta);
      beta4 = beta4.redIAdd(beta4);
      var beta8 = beta4.redAdd(beta4);
      nx = alpha.redSqr().redISub(beta8);
      nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
      var ggamma8 = gamma.redSqr();
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
    }
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype._dbl = function _dbl() {
    var a = this.curve.a;
    var jx = this.x;
    var jy = this.y;
    var jz = this.z;
    var jz4 = jz.redSqr().redSqr();
    var jx2 = jx.redSqr();
    var jy2 = jy.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
    var jxd4 = jx.redAdd(jx);
    jxd4 = jxd4.redIAdd(jxd4);
    var t1 = jxd4.redMul(jy2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var jyd8 = jy2.redSqr();
    jyd8 = jyd8.redIAdd(jyd8);
    jyd8 = jyd8.redIAdd(jyd8);
    jyd8 = jyd8.redIAdd(jyd8);
    var ny = c.redMul(t2).redISub(jyd8);
    var nz = jy.redAdd(jy).redMul(jz);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype.trpl = function trpl() {
    if (!this.curve.zeroA) return this.dbl().add(this);
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var zz = this.z.redSqr();
    var yyyy = yy.redSqr();
    var m = xx.redAdd(xx).redIAdd(xx);
    var mm = m.redSqr();
    var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    e = e.redIAdd(e);
    e = e.redAdd(e).redIAdd(e);
    e = e.redISub(mm);
    var ee = e.redSqr();
    var t = yyyy.redIAdd(yyyy);
    t = t.redIAdd(t);
    t = t.redIAdd(t);
    t = t.redIAdd(t);
    var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
    var yyu4 = yy.redMul(u);
    yyu4 = yyu4.redIAdd(yyu4);
    yyu4 = yyu4.redIAdd(yyu4);
    var nx = this.x.redMul(ee).redISub(yyu4);
    nx = nx.redIAdd(nx);
    nx = nx.redIAdd(nx);
    var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
    ny = ny.redIAdd(ny);
    ny = ny.redIAdd(ny);
    ny = ny.redIAdd(ny);
    var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype.mul = function mul(k, kbase) {
    k = new BN(k, kbase);
    return this.curve._wnafMul(this, k);
  };
  JPoint.prototype.eq = function eq(p) {
    if (p.type === 'affine') return this.eq(p.toJ());
    if (this === p) return true;
    var z2 = this.z.redSqr();
    var pz2 = p.z.redSqr();
    if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0) return false;
    var z3 = z2.redMul(this.z);
    var pz3 = pz2.redMul(p.z);
    return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
  };
  JPoint.prototype.eqXToP = function eqXToP(x) {
    var zs = this.z.redSqr();
    var rx = x.toRed(this.curve.red).redMul(zs);
    if (this.x.cmp(rx) === 0) return true;
    var xc = x.clone();
    var t = this.curve.redN.redMul(zs);
    for (;;) {
      xc.iadd(this.curve.n);
      if (xc.cmp(this.curve.p) >= 0) return false;
      rx.redIAdd(t);
      if (this.x.cmp(rx) === 0) return true;
    }
    return false;
  };
  JPoint.prototype.inspect = function inspect() {
    if (this.isInfinity()) return '<EC JPoint Infinity>';
    return '<EC JPoint x: ' + this.x.toString(16, 2) + ' y: ' + this.y.toString(16, 2) + ' z: ' + this.z.toString(16, 2) + '>';
  };
  JPoint.prototype.isInfinity = function isInfinity() {
    return this.z.cmpn(0) === 0;
  };
  return module.exports;
});
$__System.registerDynamic('209', ['208', '1ee', '46', '204'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var curve = $__require('208');
  var BN = $__require('1ee');
  var inherits = $__require('46');
  var Base = curve.base;
  var elliptic = $__require('204');
  var utils = elliptic.utils;
  function MontCurve(conf) {
    Base.call(this, 'mont', conf);
    this.a = new BN(conf.a, 16).toRed(this.red);
    this.b = new BN(conf.b, 16).toRed(this.red);
    this.i4 = new BN(4).toRed(this.red).redInvm();
    this.two = new BN(2).toRed(this.red);
    this.a24 = this.i4.redMul(this.a.redAdd(this.two));
  }
  inherits(MontCurve, Base);
  module.exports = MontCurve;
  MontCurve.prototype.validate = function validate(point) {
    var x = point.normalize().x;
    var x2 = x.redSqr();
    var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
    var y = rhs.redSqrt();
    return y.redSqr().cmp(rhs) === 0;
  };
  function Point(curve, x, z) {
    Base.BasePoint.call(this, curve, 'projective');
    if (x === null && z === null) {
      this.x = this.curve.one;
      this.z = this.curve.zero;
    } else {
      this.x = new BN(x, 16);
      this.z = new BN(z, 16);
      if (!this.x.red) this.x = this.x.toRed(this.curve.red);
      if (!this.z.red) this.z = this.z.toRed(this.curve.red);
    }
  }
  inherits(Point, Base.BasePoint);
  MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
    return this.point(utils.toArray(bytes, enc), 1);
  };
  MontCurve.prototype.point = function point(x, z) {
    return new Point(this, x, z);
  };
  MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
    return Point.fromJSON(this, obj);
  };
  Point.prototype.precompute = function precompute() {};
  Point.prototype._encode = function _encode() {
    return this.getX().toArray('be', this.curve.p.byteLength());
  };
  Point.fromJSON = function fromJSON(curve, obj) {
    return new Point(curve, obj[0], obj[1] || curve.one);
  };
  Point.prototype.inspect = function inspect() {
    if (this.isInfinity()) return '<EC Point Infinity>';
    return '<EC Point x: ' + this.x.fromRed().toString(16, 2) + ' z: ' + this.z.fromRed().toString(16, 2) + '>';
  };
  Point.prototype.isInfinity = function isInfinity() {
    return this.z.cmpn(0) === 0;
  };
  Point.prototype.dbl = function dbl() {
    var a = this.x.redAdd(this.z);
    var aa = a.redSqr();
    var b = this.x.redSub(this.z);
    var bb = b.redSqr();
    var c = aa.redSub(bb);
    var nx = aa.redMul(bb);
    var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
    return this.curve.point(nx, nz);
  };
  Point.prototype.add = function add() {
    throw new Error('Not supported on Montgomery curve');
  };
  Point.prototype.diffAdd = function diffAdd(p, diff) {
    var a = this.x.redAdd(this.z);
    var b = this.x.redSub(this.z);
    var c = p.x.redAdd(p.z);
    var d = p.x.redSub(p.z);
    var da = d.redMul(a);
    var cb = c.redMul(b);
    var nx = diff.z.redMul(da.redAdd(cb).redSqr());
    var nz = diff.x.redMul(da.redISub(cb).redSqr());
    return this.curve.point(nx, nz);
  };
  Point.prototype.mul = function mul(k) {
    var t = k.clone();
    var a = this;
    var b = this.curve.point(null, null);
    var c = this;
    for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1)) bits.push(t.andln(1));
    for (var i = bits.length - 1; i >= 0; i--) {
      if (bits[i] === 0) {
        a = a.diffAdd(b, c);
        b = b.dbl();
      } else {
        b = a.diffAdd(b, c);
        a = a.dbl();
      }
    }
    return b;
  };
  Point.prototype.mulAdd = function mulAdd() {
    throw new Error('Not supported on Montgomery curve');
  };
  Point.prototype.jumlAdd = function jumlAdd() {
    throw new Error('Not supported on Montgomery curve');
  };
  Point.prototype.eq = function eq(other) {
    return this.getX().cmp(other.getX()) === 0;
  };
  Point.prototype.normalize = function normalize() {
    this.x = this.x.redMul(this.z.redInvm());
    this.z = this.curve.one;
    return this;
  };
  Point.prototype.getX = function getX() {
    this.normalize();
    return this.x.fromRed();
  };
  return module.exports;
});
$__System.registerDynamic('20a', ['208', '204', '1ee', '46'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var curve = $__require('208');
  var elliptic = $__require('204');
  var BN = $__require('1ee');
  var inherits = $__require('46');
  var Base = curve.base;
  var assert = elliptic.utils.assert;
  function EdwardsCurve(conf) {
    this.twisted = (conf.a | 0) !== 1;
    this.mOneA = this.twisted && (conf.a | 0) === -1;
    this.extended = this.mOneA;
    Base.call(this, 'edwards', conf);
    this.a = new BN(conf.a, 16).umod(this.red.m);
    this.a = this.a.toRed(this.red);
    this.c = new BN(conf.c, 16).toRed(this.red);
    this.c2 = this.c.redSqr();
    this.d = new BN(conf.d, 16).toRed(this.red);
    this.dd = this.d.redAdd(this.d);
    assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
    this.oneC = (conf.c | 0) === 1;
  }
  inherits(EdwardsCurve, Base);
  module.exports = EdwardsCurve;
  EdwardsCurve.prototype._mulA = function _mulA(num) {
    if (this.mOneA) return num.redNeg();else return this.a.redMul(num);
  };
  EdwardsCurve.prototype._mulC = function _mulC(num) {
    if (this.oneC) return num;else return this.c.redMul(num);
  };
  EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
    return this.point(x, y, z, t);
  };
  EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
    x = new BN(x, 16);
    if (!x.red) x = x.toRed(this.red);
    var x2 = x.redSqr();
    var rhs = this.c2.redSub(this.a.redMul(x2));
    var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
    var y2 = rhs.redMul(lhs.redInvm());
    var y = y2.redSqrt();
    if (y.redSqr().redSub(y2).cmp(this.zero) !== 0) throw new Error('invalid point');
    var isOdd = y.fromRed().isOdd();
    if (odd && !isOdd || !odd && isOdd) y = y.redNeg();
    return this.point(x, y);
  };
  EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
    y = new BN(y, 16);
    if (!y.red) y = y.toRed(this.red);
    var y2 = y.redSqr();
    var lhs = y2.redSub(this.one);
    var rhs = y2.redMul(this.d).redAdd(this.one);
    var x2 = lhs.redMul(rhs.redInvm());
    if (x2.cmp(this.zero) === 0) {
      if (odd) throw new Error('invalid point');else return this.point(this.zero, y);
    }
    var x = x2.redSqrt();
    if (x.redSqr().redSub(x2).cmp(this.zero) !== 0) throw new Error('invalid point');
    if (x.isOdd() !== odd) x = x.redNeg();
    return this.point(x, y);
  };
  EdwardsCurve.prototype.validate = function validate(point) {
    if (point.isInfinity()) return true;
    point.normalize();
    var x2 = point.x.redSqr();
    var y2 = point.y.redSqr();
    var lhs = x2.redMul(this.a).redAdd(y2);
    var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
    return lhs.cmp(rhs) === 0;
  };
  function Point(curve, x, y, z, t) {
    Base.BasePoint.call(this, curve, 'projective');
    if (x === null && y === null && z === null) {
      this.x = this.curve.zero;
      this.y = this.curve.one;
      this.z = this.curve.one;
      this.t = this.curve.zero;
      this.zOne = true;
    } else {
      this.x = new BN(x, 16);
      this.y = new BN(y, 16);
      this.z = z ? new BN(z, 16) : this.curve.one;
      this.t = t && new BN(t, 16);
      if (!this.x.red) this.x = this.x.toRed(this.curve.red);
      if (!this.y.red) this.y = this.y.toRed(this.curve.red);
      if (!this.z.red) this.z = this.z.toRed(this.curve.red);
      if (this.t && !this.t.red) this.t = this.t.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;
      if (this.curve.extended && !this.t) {
        this.t = this.x.redMul(this.y);
        if (!this.zOne) this.t = this.t.redMul(this.z.redInvm());
      }
    }
  }
  inherits(Point, Base.BasePoint);
  EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
    return Point.fromJSON(this, obj);
  };
  EdwardsCurve.prototype.point = function point(x, y, z, t) {
    return new Point(this, x, y, z, t);
  };
  Point.fromJSON = function fromJSON(curve, obj) {
    return new Point(curve, obj[0], obj[1], obj[2]);
  };
  Point.prototype.inspect = function inspect() {
    if (this.isInfinity()) return '<EC Point Infinity>';
    return '<EC Point x: ' + this.x.fromRed().toString(16, 2) + ' y: ' + this.y.fromRed().toString(16, 2) + ' z: ' + this.z.fromRed().toString(16, 2) + '>';
  };
  Point.prototype.isInfinity = function isInfinity() {
    return this.x.cmpn(0) === 0 && this.y.cmp(this.z) === 0;
  };
  Point.prototype._extDbl = function _extDbl() {
    var a = this.x.redSqr();
    var b = this.y.redSqr();
    var c = this.z.redSqr();
    c = c.redIAdd(c);
    var d = this.curve._mulA(a);
    var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
    var g = d.redAdd(b);
    var f = g.redSub(c);
    var h = d.redSub(b);
    var nx = e.redMul(f);
    var ny = g.redMul(h);
    var nt = e.redMul(h);
    var nz = f.redMul(g);
    return this.curve.point(nx, ny, nz, nt);
  };
  Point.prototype._projDbl = function _projDbl() {
    var b = this.x.redAdd(this.y).redSqr();
    var c = this.x.redSqr();
    var d = this.y.redSqr();
    var nx;
    var ny;
    var nz;
    if (this.curve.twisted) {
      var e = this.curve._mulA(c);
      var f = e.redAdd(d);
      if (this.zOne) {
        nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
        ny = f.redMul(e.redSub(d));
        nz = f.redSqr().redSub(f).redSub(f);
      } else {
        var h = this.z.redSqr();
        var j = f.redSub(h).redISub(h);
        nx = b.redSub(c).redISub(d).redMul(j);
        ny = f.redMul(e.redSub(d));
        nz = f.redMul(j);
      }
    } else {
      var e = c.redAdd(d);
      var h = this.curve._mulC(this.c.redMul(this.z)).redSqr();
      var j = e.redSub(h).redSub(h);
      nx = this.curve._mulC(b.redISub(e)).redMul(j);
      ny = this.curve._mulC(e).redMul(c.redISub(d));
      nz = e.redMul(j);
    }
    return this.curve.point(nx, ny, nz);
  };
  Point.prototype.dbl = function dbl() {
    if (this.isInfinity()) return this;
    if (this.curve.extended) return this._extDbl();else return this._projDbl();
  };
  Point.prototype._extAdd = function _extAdd(p) {
    var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
    var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
    var c = this.t.redMul(this.curve.dd).redMul(p.t);
    var d = this.z.redMul(p.z.redAdd(p.z));
    var e = b.redSub(a);
    var f = d.redSub(c);
    var g = d.redAdd(c);
    var h = b.redAdd(a);
    var nx = e.redMul(f);
    var ny = g.redMul(h);
    var nt = e.redMul(h);
    var nz = f.redMul(g);
    return this.curve.point(nx, ny, nz, nt);
  };
  Point.prototype._projAdd = function _projAdd(p) {
    var a = this.z.redMul(p.z);
    var b = a.redSqr();
    var c = this.x.redMul(p.x);
    var d = this.y.redMul(p.y);
    var e = this.curve.d.redMul(c).redMul(d);
    var f = b.redSub(e);
    var g = b.redAdd(e);
    var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
    var nx = a.redMul(f).redMul(tmp);
    var ny;
    var nz;
    if (this.curve.twisted) {
      ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
      nz = f.redMul(g);
    } else {
      ny = a.redMul(g).redMul(d.redSub(c));
      nz = this.curve._mulC(f).redMul(g);
    }
    return this.curve.point(nx, ny, nz);
  };
  Point.prototype.add = function add(p) {
    if (this.isInfinity()) return p;
    if (p.isInfinity()) return this;
    if (this.curve.extended) return this._extAdd(p);else return this._projAdd(p);
  };
  Point.prototype.mul = function mul(k) {
    if (this._hasDoubles(k)) return this.curve._fixedNafMul(this, k);else return this.curve._wnafMul(this, k);
  };
  Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
    return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, false);
  };
  Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
    return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, true);
  };
  Point.prototype.normalize = function normalize() {
    if (this.zOne) return this;
    var zi = this.z.redInvm();
    this.x = this.x.redMul(zi);
    this.y = this.y.redMul(zi);
    if (this.t) this.t = this.t.redMul(zi);
    this.z = this.curve.one;
    this.zOne = true;
    return this;
  };
  Point.prototype.neg = function neg() {
    return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
  };
  Point.prototype.getX = function getX() {
    this.normalize();
    return this.x.fromRed();
  };
  Point.prototype.getY = function getY() {
    this.normalize();
    return this.y.fromRed();
  };
  Point.prototype.eq = function eq(other) {
    return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
  };
  Point.prototype.eqXToP = function eqXToP(x) {
    var rx = x.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(rx) === 0) return true;
    var xc = x.clone();
    var t = this.curve.redN.redMul(this.z);
    for (;;) {
      xc.iadd(this.curve.n);
      if (xc.cmp(this.curve.p) >= 0) return false;
      rx.redIAdd(t);
      if (this.x.cmp(rx) === 0) return true;
    }
    return false;
  };
  Point.prototype.toP = Point.prototype.normalize;
  Point.prototype.mixedAdd = Point.prototype.add;
  return module.exports;
});
$__System.registerDynamic('208', ['206', '207', '209', '20a'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var curve = exports;
  curve.base = $__require('206');
  curve.short = $__require('207');
  curve.mont = $__require('209');
  curve.edwards = $__require('20a');
  return module.exports;
});
$__System.registerDynamic('20b', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  module.exports = {
    doubles: {
      step: 4,
      points: [['e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a', 'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821'], ['8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508', '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf'], ['175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739', 'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695'], ['363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640', '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9'], ['8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c', '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36'], ['723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda', '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f'], ['eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa', '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999'], ['100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0', 'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09'], ['e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d', '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d'], ['feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d', 'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088'], ['da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1', '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d'], ['53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0', '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8'], ['8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047', '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a'], ['385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862', '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453'], ['6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7', '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160'], ['3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd', '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0'], ['85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83', '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6'], ['948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a', '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589'], ['6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8', 'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17'], ['e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d', '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda'], ['e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725', '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd'], ['213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754', '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2'], ['4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c', '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6'], ['fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6', '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f'], ['76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39', 'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01'], ['c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891', '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3'], ['d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b', 'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f'], ['b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03', '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7'], ['e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d', 'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78'], ['a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070', '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1'], ['90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4', 'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150'], ['8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da', '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82'], ['e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11', '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc'], ['8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e', 'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b'], ['e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41', '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51'], ['b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef', '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45'], ['d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8', 'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120'], ['324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d', '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84'], ['4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96', '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d'], ['9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd', 'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d'], ['6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5', '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8'], ['a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266', '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8'], ['7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71', '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac'], ['928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac', 'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f'], ['85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751', '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962'], ['ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e', '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907'], ['827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241', 'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec'], ['eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3', 'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d'], ['e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f', '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414'], ['1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19', 'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd'], ['146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be', 'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0'], ['fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9', '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811'], ['da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2', '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1'], ['a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13', '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c'], ['174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c', 'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73'], ['959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba', '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd'], ['d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151', 'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405'], ['64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073', 'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589'], ['8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458', '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e'], ['13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b', '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27'], ['bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366', 'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1'], ['8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa', '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482'], ['8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0', '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945'], ['dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787', '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573'], ['f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e', 'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82']]
    },
    naf: {
      wnd: 7,
      points: [['f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9', '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672'], ['2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4', 'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6'], ['5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc', '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da'], ['acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe', 'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37'], ['774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb', 'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b'], ['f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8', 'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81'], ['d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e', '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58'], ['defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34', '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77'], ['2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c', '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a'], ['352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5', '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c'], ['2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f', '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67'], ['9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714', '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402'], ['daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729', 'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55'], ['c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db', '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482'], ['6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4', 'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82'], ['1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5', 'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396'], ['605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479', '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49'], ['62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d', '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf'], ['80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f', '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a'], ['7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb', 'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7'], ['d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9', 'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933'], ['49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963', '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a'], ['77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74', '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6'], ['f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530', 'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37'], ['463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b', '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e'], ['f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247', 'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6'], ['caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1', 'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476'], ['2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120', '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40'], ['7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435', '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61'], ['754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18', '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683'], ['e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8', '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5'], ['186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb', '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b'], ['df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f', '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417'], ['5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143', 'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868'], ['290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba', 'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a'], ['af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45', 'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6'], ['766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a', '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996'], ['59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e', 'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e'], ['f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8', 'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d'], ['7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c', '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2'], ['948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519', 'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e'], ['7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab', '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437'], ['3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca', 'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311'], ['d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf', '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4'], ['1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610', '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575'], ['733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4', 'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d'], ['15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c', 'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d'], ['a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940', 'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629'], ['e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980', 'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06'], ['311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3', '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374'], ['34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf', '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee'], ['f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63', '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1'], ['d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448', 'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b'], ['32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf', '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661'], ['7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5', '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6'], ['ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6', '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e'], ['16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5', '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d'], ['eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99', 'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc'], ['78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51', 'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4'], ['494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5', '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c'], ['a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5', '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b'], ['c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997', '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913'], ['841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881', '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154'], ['5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5', '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865'], ['36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66', 'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc'], ['336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726', 'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224'], ['8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede', '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e'], ['1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94', '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6'], ['85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31', '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511'], ['29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51', 'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b'], ['a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252', 'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2'], ['4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5', 'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c'], ['d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b', '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3'], ['ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4', '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d'], ['af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f', '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700'], ['e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889', '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4'], ['591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246', 'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196'], ['11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984', '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4'], ['3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a', 'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257'], ['cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030', 'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13'], ['c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197', '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096'], ['c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593', 'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38'], ['a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef', '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f'], ['347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38', '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448'], ['da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a', '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a'], ['c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111', '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4'], ['4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502', '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437'], ['3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea', 'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7'], ['cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26', '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d'], ['b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986', '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a'], ['d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e', '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54'], ['48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4', '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77'], ['dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda', 'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517'], ['6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859', 'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10'], ['e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f', 'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125'], ['eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c', '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e'], ['13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942', 'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1'], ['ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a', '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2'], ['b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80', '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423'], ['ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d', '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8'], ['8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1', 'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758'], ['52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63', 'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375'], ['e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352', '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d'], ['7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193', 'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec'], ['5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00', '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0'], ['32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58', 'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c'], ['e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7', 'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4'], ['8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8', 'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f'], ['4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e', '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649'], ['3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d', 'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826'], ['674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b', '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5'], ['d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f', 'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87'], ['30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6', '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b'], ['be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297', '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc'], ['93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a', '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c'], ['b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c', 'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f'], ['d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52', '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a'], ['d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb', 'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46'], ['463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065', 'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f'], ['7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917', '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03'], ['74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9', 'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08'], ['30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3', '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8'], ['9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57', '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373'], ['176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66', 'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3'], ['75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8', '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8'], ['809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721', '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1'], ['1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180', '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9']]
    }
  };
  return module.exports;
});
$__System.registerDynamic('20c', ['205', '204', '20b'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var curves = exports;
  var hash = $__require('205');
  var elliptic = $__require('204');
  var assert = elliptic.utils.assert;
  function PresetCurve(options) {
    if (options.type === 'short') this.curve = new elliptic.curve.short(options);else if (options.type === 'edwards') this.curve = new elliptic.curve.edwards(options);else this.curve = new elliptic.curve.mont(options);
    this.g = this.curve.g;
    this.n = this.curve.n;
    this.hash = options.hash;
    assert(this.g.validate(), 'Invalid curve');
    assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
  }
  curves.PresetCurve = PresetCurve;
  function defineCurve(name, options) {
    Object.defineProperty(curves, name, {
      configurable: true,
      enumerable: true,
      get: function () {
        var curve = new PresetCurve(options);
        Object.defineProperty(curves, name, {
          configurable: true,
          enumerable: true,
          value: curve
        });
        return curve;
      }
    });
  }
  defineCurve('p192', {
    type: 'short',
    prime: 'p192',
    p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
    a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
    b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
    n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
    hash: hash.sha256,
    gRed: false,
    g: ['188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012', '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811']
  });
  defineCurve('p224', {
    type: 'short',
    prime: 'p224',
    p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
    a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
    b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
    n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
    hash: hash.sha256,
    gRed: false,
    g: ['b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21', 'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34']
  });
  defineCurve('p256', {
    type: 'short',
    prime: null,
    p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
    a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
    b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
    n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
    hash: hash.sha256,
    gRed: false,
    g: ['6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296', '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5']
  });
  defineCurve('p384', {
    type: 'short',
    prime: null,
    p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'fffffffe ffffffff 00000000 00000000 ffffffff',
    a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'fffffffe ffffffff 00000000 00000000 fffffffc',
    b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' + '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
    n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' + 'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
    hash: hash.sha384,
    gRed: false,
    g: ['aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' + '5502f25d bf55296c 3a545e38 72760ab7', '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' + '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f']
  });
  defineCurve('p521', {
    type: 'short',
    prime: null,
    p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'ffffffff ffffffff ffffffff ffffffff ffffffff',
    a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'ffffffff ffffffff ffffffff ffffffff fffffffc',
    b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' + '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' + '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
    n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' + 'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
    hash: hash.sha512,
    gRed: false,
    g: ['000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' + '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' + 'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66', '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' + '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' + '3fad0761 353c7086 a272c240 88be9476 9fd16650']
  });
  defineCurve('curve25519', {
    type: 'mont',
    prime: 'p25519',
    p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
    a: '76d06',
    b: '0',
    n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
    hash: hash.sha256,
    gRed: false,
    g: ['9']
  });
  defineCurve('ed25519', {
    type: 'edwards',
    prime: 'p25519',
    p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
    a: '-1',
    c: '1',
    d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
    n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
    hash: hash.sha256,
    gRed: false,
    g: ['216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a', '6666666666666666666666666666666666666666666666666666666666666658']
  });
  var pre;
  try {
    pre = $__require('20b');
  } catch (e) {
    pre = undefined;
  }
  defineCurve('secp256k1', {
    type: 'short',
    prime: 'k256',
    p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
    a: '0',
    b: '7',
    n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
    h: '1',
    hash: hash.sha256,
    beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
    lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
    basis: [{
      a: '3086d221a7d46bcde86c90e49284eb15',
      b: '-e4437ed6010e88286f547fa90abfe4c3'
    }, {
      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
      b: '3086d221a7d46bcde86c90e49284eb15'
    }],
    gRed: false,
    g: ['79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798', '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8', pre]
  });
  return module.exports;
});
$__System.registerDynamic('20d', ['1ee'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var BN = $__require('1ee');

  function KeyPair(ec, options) {
    this.ec = ec;
    this.priv = null;
    this.pub = null;

    // KeyPair(ec, { priv: ..., pub: ... })
    if (options.priv) this._importPrivate(options.priv, options.privEnc);
    if (options.pub) this._importPublic(options.pub, options.pubEnc);
  }
  module.exports = KeyPair;

  KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
    if (pub instanceof KeyPair) return pub;

    return new KeyPair(ec, {
      pub: pub,
      pubEnc: enc
    });
  };

  KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
    if (priv instanceof KeyPair) return priv;

    return new KeyPair(ec, {
      priv: priv,
      privEnc: enc
    });
  };

  KeyPair.prototype.validate = function validate() {
    var pub = this.getPublic();

    if (pub.isInfinity()) return { result: false, reason: 'Invalid public key' };
    if (!pub.validate()) return { result: false, reason: 'Public key is not a point' };
    if (!pub.mul(this.ec.curve.n).isInfinity()) return { result: false, reason: 'Public key * N != O' };

    return { result: true, reason: null };
  };

  KeyPair.prototype.getPublic = function getPublic(compact, enc) {
    // compact is optional argument
    if (typeof compact === 'string') {
      enc = compact;
      compact = null;
    }

    if (!this.pub) this.pub = this.ec.g.mul(this.priv);

    if (!enc) return this.pub;

    return this.pub.encode(enc, compact);
  };

  KeyPair.prototype.getPrivate = function getPrivate(enc) {
    if (enc === 'hex') return this.priv.toString(16, 2);else return this.priv;
  };

  KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
    this.priv = new BN(key, enc || 16);

    // Ensure that the priv won't be bigger than n, otherwise we may fail
    // in fixed multiplication method
    this.priv = this.priv.umod(this.ec.curve.n);
  };

  KeyPair.prototype._importPublic = function _importPublic(key, enc) {
    if (key.x || key.y) {
      this.pub = this.ec.curve.point(key.x, key.y);
      return;
    }
    this.pub = this.ec.curve.decodePoint(key, enc);
  };

  // ECDH
  KeyPair.prototype.derive = function derive(pub) {
    return pub.mul(this.priv).getX();
  };

  // ECDSA
  KeyPair.prototype.sign = function sign(msg, enc, options) {
    return this.ec.sign(msg, this, enc, options);
  };

  KeyPair.prototype.verify = function verify(msg, signature) {
    return this.ec.verify(msg, signature, this);
  };

  KeyPair.prototype.inspect = function inspect() {
    return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) + ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
  };
  return module.exports;
});
$__System.registerDynamic('20e', ['1ee', '204'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var BN = $__require('1ee');
  var elliptic = $__require('204');
  var utils = elliptic.utils;
  var assert = utils.assert;
  function Signature(options, enc) {
    if (options instanceof Signature) return options;
    if (this._importDER(options, enc)) return;
    assert(options.r && options.s, 'Signature without r or s');
    this.r = new BN(options.r, 16);
    this.s = new BN(options.s, 16);
    if (options.recoveryParam === undefined) this.recoveryParam = null;else this.recoveryParam = options.recoveryParam;
  }
  module.exports = Signature;
  function Position() {
    this.place = 0;
  }
  function getLength(buf, p) {
    var initial = buf[p.place++];
    if (!(initial & 0x80)) {
      return initial;
    }
    var octetLen = initial & 0xf;
    var val = 0;
    for (var i = 0, off = p.place; i < octetLen; i++, off++) {
      val <<= 8;
      val |= buf[off];
    }
    p.place = off;
    return val;
  }
  function rmPadding(buf) {
    var i = 0;
    var len = buf.length - 1;
    while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
      i++;
    }
    if (i === 0) {
      return buf;
    }
    return buf.slice(i);
  }
  Signature.prototype._importDER = function _importDER(data, enc) {
    data = utils.toArray(data, enc);
    var p = new Position();
    if (data[p.place++] !== 0x30) {
      return false;
    }
    var len = getLength(data, p);
    if (len + p.place !== data.length) {
      return false;
    }
    if (data[p.place++] !== 0x02) {
      return false;
    }
    var rlen = getLength(data, p);
    var r = data.slice(p.place, rlen + p.place);
    p.place += rlen;
    if (data[p.place++] !== 0x02) {
      return false;
    }
    var slen = getLength(data, p);
    if (data.length !== slen + p.place) {
      return false;
    }
    var s = data.slice(p.place, slen + p.place);
    if (r[0] === 0 && r[1] & 0x80) {
      r = r.slice(1);
    }
    if (s[0] === 0 && s[1] & 0x80) {
      s = s.slice(1);
    }
    this.r = new BN(r);
    this.s = new BN(s);
    this.recoveryParam = null;
    return true;
  };
  function constructLength(arr, len) {
    if (len < 0x80) {
      arr.push(len);
      return;
    }
    var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
    arr.push(octets | 0x80);
    while (--octets) {
      arr.push(len >>> (octets << 3) & 0xff);
    }
    arr.push(len);
  }
  Signature.prototype.toDER = function toDER(enc) {
    var r = this.r.toArray();
    var s = this.s.toArray();
    if (r[0] & 0x80) r = [0].concat(r);
    if (s[0] & 0x80) s = [0].concat(s);
    r = rmPadding(r);
    s = rmPadding(s);
    while (!s[0] && !(s[1] & 0x80)) {
      s = s.slice(1);
    }
    var arr = [0x02];
    constructLength(arr, r.length);
    arr = arr.concat(r);
    arr.push(0x02);
    constructLength(arr, s.length);
    var backHalf = arr.concat(s);
    var res = [0x30];
    constructLength(res, backHalf.length);
    res = res.concat(backHalf);
    return utils.encode(res, enc);
  };
  return module.exports;
});
$__System.registerDynamic('20f', ['1ee', '204', '20d', '20e'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var BN = $__require('1ee');
  var elliptic = $__require('204');
  var utils = elliptic.utils;
  var assert = utils.assert;
  var KeyPair = $__require('20d');
  var Signature = $__require('20e');
  function EC(options) {
    if (!(this instanceof EC)) return new EC(options);
    if (typeof options === 'string') {
      assert(elliptic.curves.hasOwnProperty(options), 'Unknown curve ' + options);
      options = elliptic.curves[options];
    }
    if (options instanceof elliptic.curves.PresetCurve) options = { curve: options };
    this.curve = options.curve.curve;
    this.n = this.curve.n;
    this.nh = this.n.ushrn(1);
    this.g = this.curve.g;
    this.g = options.curve.g;
    this.g.precompute(options.curve.n.bitLength() + 1);
    this.hash = options.hash || options.curve.hash;
  }
  module.exports = EC;
  EC.prototype.keyPair = function keyPair(options) {
    return new KeyPair(this, options);
  };
  EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
    return KeyPair.fromPrivate(this, priv, enc);
  };
  EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
    return KeyPair.fromPublic(this, pub, enc);
  };
  EC.prototype.genKeyPair = function genKeyPair(options) {
    if (!options) options = {};
    var drbg = new elliptic.hmacDRBG({
      hash: this.hash,
      pers: options.pers,
      entropy: options.entropy || elliptic.rand(this.hash.hmacStrength),
      nonce: this.n.toArray()
    });
    var bytes = this.n.byteLength();
    var ns2 = this.n.sub(new BN(2));
    do {
      var priv = new BN(drbg.generate(bytes));
      if (priv.cmp(ns2) > 0) continue;
      priv.iaddn(1);
      return this.keyFromPrivate(priv);
    } while (true);
  };
  EC.prototype._truncateToN = function truncateToN(msg, truncOnly) {
    var delta = msg.byteLength() * 8 - this.n.bitLength();
    if (delta > 0) msg = msg.ushrn(delta);
    if (!truncOnly && msg.cmp(this.n) >= 0) return msg.sub(this.n);else return msg;
  };
  EC.prototype.sign = function sign(msg, key, enc, options) {
    if (typeof enc === 'object') {
      options = enc;
      enc = null;
    }
    if (!options) options = {};
    key = this.keyFromPrivate(key, enc);
    msg = this._truncateToN(new BN(msg, 16));
    var bytes = this.n.byteLength();
    var bkey = key.getPrivate().toArray('be', bytes);
    var nonce = msg.toArray('be', bytes);
    var drbg = new elliptic.hmacDRBG({
      hash: this.hash,
      entropy: bkey,
      nonce: nonce,
      pers: options.pers,
      persEnc: options.persEnc
    });
    var ns1 = this.n.sub(new BN(1));
    for (var iter = 0; true; iter++) {
      var k = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
      k = this._truncateToN(k, true);
      if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0) continue;
      var kp = this.g.mul(k);
      if (kp.isInfinity()) continue;
      var kpX = kp.getX();
      var r = kpX.umod(this.n);
      if (r.cmpn(0) === 0) continue;
      var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
      s = s.umod(this.n);
      if (s.cmpn(0) === 0) continue;
      var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
      if (options.canonical && s.cmp(this.nh) > 0) {
        s = this.n.sub(s);
        recoveryParam ^= 1;
      }
      return new Signature({
        r: r,
        s: s,
        recoveryParam: recoveryParam
      });
    }
  };
  EC.prototype.verify = function verify(msg, signature, key, enc) {
    msg = this._truncateToN(new BN(msg, 16));
    key = this.keyFromPublic(key, enc);
    signature = new Signature(signature, 'hex');
    var r = signature.r;
    var s = signature.s;
    if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0) return false;
    if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0) return false;
    var sinv = s.invm(this.n);
    var u1 = sinv.mul(msg).umod(this.n);
    var u2 = sinv.mul(r).umod(this.n);
    if (!this.curve._maxwellTrick) {
      var p = this.g.mulAdd(u1, key.getPublic(), u2);
      if (p.isInfinity()) return false;
      return p.getX().umod(this.n).cmp(r) === 0;
    }
    var p = this.g.jmulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity()) return false;
    return p.eqXToP(r);
  };
  EC.prototype.recoverPubKey = function (msg, signature, j, enc) {
    assert((3 & j) === j, 'The recovery param is more than two bits');
    signature = new Signature(signature, enc);
    var n = this.n;
    var e = new BN(msg);
    var r = signature.r;
    var s = signature.s;
    var isYOdd = j & 1;
    var isSecondKey = j >> 1;
    if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey) throw new Error('Unable to find sencond key candinate');
    if (isSecondKey) r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);else r = this.curve.pointFromX(r, isYOdd);
    var rInv = signature.r.invm(n);
    var s1 = n.sub(e).mul(rInv).umod(n);
    var s2 = s.mul(rInv).umod(n);
    return this.g.mulAdd(s1, r, s2);
  };
  EC.prototype.getKeyRecoveryParam = function (e, signature, Q, enc) {
    signature = new Signature(signature, enc);
    if (signature.recoveryParam !== null) return signature.recoveryParam;
    for (var i = 0; i < 4; i++) {
      var Qprime;
      try {
        Qprime = this.recoverPubKey(e, signature, i);
      } catch (e) {
        continue;
      }
      if (Qprime.eq(Q)) return i;
    }
    throw new Error('Unable to find valid recovery factor');
  };
  return module.exports;
});
$__System.registerDynamic('210', ['46'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var utils = exports;
  var inherits = $__require('46');

  function toArray(msg, enc) {
    if (Array.isArray(msg)) return msg.slice();
    if (!msg) return [];
    var res = [];
    if (typeof msg === 'string') {
      if (!enc) {
        for (var i = 0; i < msg.length; i++) {
          var c = msg.charCodeAt(i);
          var hi = c >> 8;
          var lo = c & 0xff;
          if (hi) res.push(hi, lo);else res.push(lo);
        }
      } else if (enc === 'hex') {
        msg = msg.replace(/[^a-z0-9]+/ig, '');
        if (msg.length % 2 !== 0) msg = '0' + msg;
        for (var i = 0; i < msg.length; i += 2) res.push(parseInt(msg[i] + msg[i + 1], 16));
      }
    } else {
      for (var i = 0; i < msg.length; i++) res[i] = msg[i] | 0;
    }
    return res;
  }
  utils.toArray = toArray;

  function toHex(msg) {
    var res = '';
    for (var i = 0; i < msg.length; i++) res += zero2(msg[i].toString(16));
    return res;
  }
  utils.toHex = toHex;

  function htonl(w) {
    var res = w >>> 24 | w >>> 8 & 0xff00 | w << 8 & 0xff0000 | (w & 0xff) << 24;
    return res >>> 0;
  }
  utils.htonl = htonl;

  function toHex32(msg, endian) {
    var res = '';
    for (var i = 0; i < msg.length; i++) {
      var w = msg[i];
      if (endian === 'little') w = htonl(w);
      res += zero8(w.toString(16));
    }
    return res;
  }
  utils.toHex32 = toHex32;

  function zero2(word) {
    if (word.length === 1) return '0' + word;else return word;
  }
  utils.zero2 = zero2;

  function zero8(word) {
    if (word.length === 7) return '0' + word;else if (word.length === 6) return '00' + word;else if (word.length === 5) return '000' + word;else if (word.length === 4) return '0000' + word;else if (word.length === 3) return '00000' + word;else if (word.length === 2) return '000000' + word;else if (word.length === 1) return '0000000' + word;else return word;
  }
  utils.zero8 = zero8;

  function join32(msg, start, end, endian) {
    var len = end - start;
    assert(len % 4 === 0);
    var res = new Array(len / 4);
    for (var i = 0, k = start; i < res.length; i++, k += 4) {
      var w;
      if (endian === 'big') w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];else w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
      res[i] = w >>> 0;
    }
    return res;
  }
  utils.join32 = join32;

  function split32(msg, endian) {
    var res = new Array(msg.length * 4);
    for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
      var m = msg[i];
      if (endian === 'big') {
        res[k] = m >>> 24;
        res[k + 1] = m >>> 16 & 0xff;
        res[k + 2] = m >>> 8 & 0xff;
        res[k + 3] = m & 0xff;
      } else {
        res[k + 3] = m >>> 24;
        res[k + 2] = m >>> 16 & 0xff;
        res[k + 1] = m >>> 8 & 0xff;
        res[k] = m & 0xff;
      }
    }
    return res;
  }
  utils.split32 = split32;

  function rotr32(w, b) {
    return w >>> b | w << 32 - b;
  }
  utils.rotr32 = rotr32;

  function rotl32(w, b) {
    return w << b | w >>> 32 - b;
  }
  utils.rotl32 = rotl32;

  function sum32(a, b) {
    return a + b >>> 0;
  }
  utils.sum32 = sum32;

  function sum32_3(a, b, c) {
    return a + b + c >>> 0;
  }
  utils.sum32_3 = sum32_3;

  function sum32_4(a, b, c, d) {
    return a + b + c + d >>> 0;
  }
  utils.sum32_4 = sum32_4;

  function sum32_5(a, b, c, d, e) {
    return a + b + c + d + e >>> 0;
  }
  utils.sum32_5 = sum32_5;

  function assert(cond, msg) {
    if (!cond) throw new Error(msg || 'Assertion failed');
  }
  utils.assert = assert;

  utils.inherits = inherits;

  function sum64(buf, pos, ah, al) {
    var bh = buf[pos];
    var bl = buf[pos + 1];

    var lo = al + bl >>> 0;
    var hi = (lo < al ? 1 : 0) + ah + bh;
    buf[pos] = hi >>> 0;
    buf[pos + 1] = lo;
  }
  exports.sum64 = sum64;

  function sum64_hi(ah, al, bh, bl) {
    var lo = al + bl >>> 0;
    var hi = (lo < al ? 1 : 0) + ah + bh;
    return hi >>> 0;
  };
  exports.sum64_hi = sum64_hi;

  function sum64_lo(ah, al, bh, bl) {
    var lo = al + bl;
    return lo >>> 0;
  };
  exports.sum64_lo = sum64_lo;

  function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
    var carry = 0;
    var lo = al;
    lo = lo + bl >>> 0;
    carry += lo < al ? 1 : 0;
    lo = lo + cl >>> 0;
    carry += lo < cl ? 1 : 0;
    lo = lo + dl >>> 0;
    carry += lo < dl ? 1 : 0;

    var hi = ah + bh + ch + dh + carry;
    return hi >>> 0;
  };
  exports.sum64_4_hi = sum64_4_hi;

  function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
    var lo = al + bl + cl + dl;
    return lo >>> 0;
  };
  exports.sum64_4_lo = sum64_4_lo;

  function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
    var carry = 0;
    var lo = al;
    lo = lo + bl >>> 0;
    carry += lo < al ? 1 : 0;
    lo = lo + cl >>> 0;
    carry += lo < cl ? 1 : 0;
    lo = lo + dl >>> 0;
    carry += lo < dl ? 1 : 0;
    lo = lo + el >>> 0;
    carry += lo < el ? 1 : 0;

    var hi = ah + bh + ch + dh + eh + carry;
    return hi >>> 0;
  };
  exports.sum64_5_hi = sum64_5_hi;

  function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
    var lo = al + bl + cl + dl + el;

    return lo >>> 0;
  };
  exports.sum64_5_lo = sum64_5_lo;

  function rotr64_hi(ah, al, num) {
    var r = al << 32 - num | ah >>> num;
    return r >>> 0;
  };
  exports.rotr64_hi = rotr64_hi;

  function rotr64_lo(ah, al, num) {
    var r = ah << 32 - num | al >>> num;
    return r >>> 0;
  };
  exports.rotr64_lo = rotr64_lo;

  function shr64_hi(ah, al, num) {
    return ah >>> num;
  };
  exports.shr64_hi = shr64_hi;

  function shr64_lo(ah, al, num) {
    var r = ah << 32 - num | al >>> num;
    return r >>> 0;
  };
  exports.shr64_lo = shr64_lo;
  return module.exports;
});
$__System.registerDynamic('211', ['212'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var hash = $__require('212');
  var utils = hash.utils;
  var assert = utils.assert;
  function BlockHash() {
    this.pending = null;
    this.pendingTotal = 0;
    this.blockSize = this.constructor.blockSize;
    this.outSize = this.constructor.outSize;
    this.hmacStrength = this.constructor.hmacStrength;
    this.padLength = this.constructor.padLength / 8;
    this.endian = 'big';
    this._delta8 = this.blockSize / 8;
    this._delta32 = this.blockSize / 32;
  }
  exports.BlockHash = BlockHash;
  BlockHash.prototype.update = function update(msg, enc) {
    msg = utils.toArray(msg, enc);
    if (!this.pending) this.pending = msg;else this.pending = this.pending.concat(msg);
    this.pendingTotal += msg.length;
    if (this.pending.length >= this._delta8) {
      msg = this.pending;
      var r = msg.length % this._delta8;
      this.pending = msg.slice(msg.length - r, msg.length);
      if (this.pending.length === 0) this.pending = null;
      msg = utils.join32(msg, 0, msg.length - r, this.endian);
      for (var i = 0; i < msg.length; i += this._delta32) this._update(msg, i, i + this._delta32);
    }
    return this;
  };
  BlockHash.prototype.digest = function digest(enc) {
    this.update(this._pad());
    assert(this.pending === null);
    return this._digest(enc);
  };
  BlockHash.prototype._pad = function pad() {
    var len = this.pendingTotal;
    var bytes = this._delta8;
    var k = bytes - (len + this.padLength) % bytes;
    var res = new Array(k + this.padLength);
    res[0] = 0x80;
    for (var i = 1; i < k; i++) res[i] = 0;
    len <<= 3;
    if (this.endian === 'big') {
      for (var t = 8; t < this.padLength; t++) res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = len >>> 24 & 0xff;
      res[i++] = len >>> 16 & 0xff;
      res[i++] = len >>> 8 & 0xff;
      res[i++] = len & 0xff;
    } else {
      res[i++] = len & 0xff;
      res[i++] = len >>> 8 & 0xff;
      res[i++] = len >>> 16 & 0xff;
      res[i++] = len >>> 24 & 0xff;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      for (var t = 8; t < this.padLength; t++) res[i++] = 0;
    }
    return res;
  };
  return module.exports;
});
$__System.registerDynamic('213', ['212'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var hash = $__require('212');
  var utils = hash.utils;
  var assert = utils.assert;
  var rotr32 = utils.rotr32;
  var rotl32 = utils.rotl32;
  var sum32 = utils.sum32;
  var sum32_4 = utils.sum32_4;
  var sum32_5 = utils.sum32_5;
  var rotr64_hi = utils.rotr64_hi;
  var rotr64_lo = utils.rotr64_lo;
  var shr64_hi = utils.shr64_hi;
  var shr64_lo = utils.shr64_lo;
  var sum64 = utils.sum64;
  var sum64_hi = utils.sum64_hi;
  var sum64_lo = utils.sum64_lo;
  var sum64_4_hi = utils.sum64_4_hi;
  var sum64_4_lo = utils.sum64_4_lo;
  var sum64_5_hi = utils.sum64_5_hi;
  var sum64_5_lo = utils.sum64_5_lo;
  var BlockHash = hash.common.BlockHash;
  var sha256_K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];
  var sha512_K = [0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc, 0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118, 0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2, 0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694, 0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3, 0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65, 0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5, 0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4, 0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70, 0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df, 0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b, 0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30, 0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8, 0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8, 0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3, 0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec, 0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b, 0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178, 0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b, 0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c, 0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817];
  var sha1_K = [0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xCA62C1D6];
  function SHA256() {
    if (!(this instanceof SHA256)) return new SHA256();
    BlockHash.call(this);
    this.h = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];
    this.k = sha256_K;
    this.W = new Array(64);
  }
  utils.inherits(SHA256, BlockHash);
  exports.sha256 = SHA256;
  SHA256.blockSize = 512;
  SHA256.outSize = 256;
  SHA256.hmacStrength = 192;
  SHA256.padLength = 64;
  SHA256.prototype._update = function _update(msg, start) {
    var W = this.W;
    for (var i = 0; i < 16; i++) W[i] = msg[start + i];
    for (; i < W.length; i++) W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
    var a = this.h[0];
    var b = this.h[1];
    var c = this.h[2];
    var d = this.h[3];
    var e = this.h[4];
    var f = this.h[5];
    var g = this.h[6];
    var h = this.h[7];
    assert(this.k.length === W.length);
    for (var i = 0; i < W.length; i++) {
      var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
      var T2 = sum32(s0_256(a), maj32(a, b, c));
      h = g;
      g = f;
      f = e;
      e = sum32(d, T1);
      d = c;
      c = b;
      b = a;
      a = sum32(T1, T2);
    }
    this.h[0] = sum32(this.h[0], a);
    this.h[1] = sum32(this.h[1], b);
    this.h[2] = sum32(this.h[2], c);
    this.h[3] = sum32(this.h[3], d);
    this.h[4] = sum32(this.h[4], e);
    this.h[5] = sum32(this.h[5], f);
    this.h[6] = sum32(this.h[6], g);
    this.h[7] = sum32(this.h[7], h);
  };
  SHA256.prototype._digest = function digest(enc) {
    if (enc === 'hex') return utils.toHex32(this.h, 'big');else return utils.split32(this.h, 'big');
  };
  function SHA224() {
    if (!(this instanceof SHA224)) return new SHA224();
    SHA256.call(this);
    this.h = [0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4];
  }
  utils.inherits(SHA224, SHA256);
  exports.sha224 = SHA224;
  SHA224.blockSize = 512;
  SHA224.outSize = 224;
  SHA224.hmacStrength = 192;
  SHA224.padLength = 64;
  SHA224.prototype._digest = function digest(enc) {
    if (enc === 'hex') return utils.toHex32(this.h.slice(0, 7), 'big');else return utils.split32(this.h.slice(0, 7), 'big');
  };
  function SHA512() {
    if (!(this instanceof SHA512)) return new SHA512();
    BlockHash.call(this);
    this.h = [0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1, 0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179];
    this.k = sha512_K;
    this.W = new Array(160);
  }
  utils.inherits(SHA512, BlockHash);
  exports.sha512 = SHA512;
  SHA512.blockSize = 1024;
  SHA512.outSize = 512;
  SHA512.hmacStrength = 192;
  SHA512.padLength = 128;
  SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
    var W = this.W;
    for (var i = 0; i < 32; i++) W[i] = msg[start + i];
    for (; i < W.length; i += 2) {
      var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);
      var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
      var c1_hi = W[i - 14];
      var c1_lo = W[i - 13];
      var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);
      var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
      var c3_hi = W[i - 32];
      var c3_lo = W[i - 31];
      W[i] = sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
      W[i + 1] = sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
    }
  };
  SHA512.prototype._update = function _update(msg, start) {
    this._prepareBlock(msg, start);
    var W = this.W;
    var ah = this.h[0];
    var al = this.h[1];
    var bh = this.h[2];
    var bl = this.h[3];
    var ch = this.h[4];
    var cl = this.h[5];
    var dh = this.h[6];
    var dl = this.h[7];
    var eh = this.h[8];
    var el = this.h[9];
    var fh = this.h[10];
    var fl = this.h[11];
    var gh = this.h[12];
    var gl = this.h[13];
    var hh = this.h[14];
    var hl = this.h[15];
    assert(this.k.length === W.length);
    for (var i = 0; i < W.length; i += 2) {
      var c0_hi = hh;
      var c0_lo = hl;
      var c1_hi = s1_512_hi(eh, el);
      var c1_lo = s1_512_lo(eh, el);
      var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
      var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
      var c3_hi = this.k[i];
      var c3_lo = this.k[i + 1];
      var c4_hi = W[i];
      var c4_lo = W[i + 1];
      var T1_hi = sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
      var T1_lo = sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
      var c0_hi = s0_512_hi(ah, al);
      var c0_lo = s0_512_lo(ah, al);
      var c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
      var c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
      var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
      var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
      hh = gh;
      hl = gl;
      gh = fh;
      gl = fl;
      fh = eh;
      fl = el;
      eh = sum64_hi(dh, dl, T1_hi, T1_lo);
      el = sum64_lo(dl, dl, T1_hi, T1_lo);
      dh = ch;
      dl = cl;
      ch = bh;
      cl = bl;
      bh = ah;
      bl = al;
      ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
      al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
    }
    sum64(this.h, 0, ah, al);
    sum64(this.h, 2, bh, bl);
    sum64(this.h, 4, ch, cl);
    sum64(this.h, 6, dh, dl);
    sum64(this.h, 8, eh, el);
    sum64(this.h, 10, fh, fl);
    sum64(this.h, 12, gh, gl);
    sum64(this.h, 14, hh, hl);
  };
  SHA512.prototype._digest = function digest(enc) {
    if (enc === 'hex') return utils.toHex32(this.h, 'big');else return utils.split32(this.h, 'big');
  };
  function SHA384() {
    if (!(this instanceof SHA384)) return new SHA384();
    SHA512.call(this);
    this.h = [0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939, 0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4];
  }
  utils.inherits(SHA384, SHA512);
  exports.sha384 = SHA384;
  SHA384.blockSize = 1024;
  SHA384.outSize = 384;
  SHA384.hmacStrength = 192;
  SHA384.padLength = 128;
  SHA384.prototype._digest = function digest(enc) {
    if (enc === 'hex') return utils.toHex32(this.h.slice(0, 12), 'big');else return utils.split32(this.h.slice(0, 12), 'big');
  };
  function SHA1() {
    if (!(this instanceof SHA1)) return new SHA1();
    BlockHash.call(this);
    this.h = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
    this.W = new Array(80);
  }
  utils.inherits(SHA1, BlockHash);
  exports.sha1 = SHA1;
  SHA1.blockSize = 512;
  SHA1.outSize = 160;
  SHA1.hmacStrength = 80;
  SHA1.padLength = 64;
  SHA1.prototype._update = function _update(msg, start) {
    var W = this.W;
    for (var i = 0; i < 16; i++) W[i] = msg[start + i];
    for (; i < W.length; i++) W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
    var a = this.h[0];
    var b = this.h[1];
    var c = this.h[2];
    var d = this.h[3];
    var e = this.h[4];
    for (var i = 0; i < W.length; i++) {
      var s = ~~(i / 20);
      var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
      e = d;
      d = c;
      c = rotl32(b, 30);
      b = a;
      a = t;
    }
    this.h[0] = sum32(this.h[0], a);
    this.h[1] = sum32(this.h[1], b);
    this.h[2] = sum32(this.h[2], c);
    this.h[3] = sum32(this.h[3], d);
    this.h[4] = sum32(this.h[4], e);
  };
  SHA1.prototype._digest = function digest(enc) {
    if (enc === 'hex') return utils.toHex32(this.h, 'big');else return utils.split32(this.h, 'big');
  };
  function ch32(x, y, z) {
    return x & y ^ ~x & z;
  }
  function maj32(x, y, z) {
    return x & y ^ x & z ^ y & z;
  }
  function p32(x, y, z) {
    return x ^ y ^ z;
  }
  function s0_256(x) {
    return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
  }
  function s1_256(x) {
    return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
  }
  function g0_256(x) {
    return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
  }
  function g1_256(x) {
    return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
  }
  function ft_1(s, x, y, z) {
    if (s === 0) return ch32(x, y, z);
    if (s === 1 || s === 3) return p32(x, y, z);
    if (s === 2) return maj32(x, y, z);
  }
  function ch64_hi(xh, xl, yh, yl, zh, zl) {
    var r = xh & yh ^ ~xh & zh;
    if (r < 0) r += 0x100000000;
    return r;
  }
  function ch64_lo(xh, xl, yh, yl, zh, zl) {
    var r = xl & yl ^ ~xl & zl;
    if (r < 0) r += 0x100000000;
    return r;
  }
  function maj64_hi(xh, xl, yh, yl, zh, zl) {
    var r = xh & yh ^ xh & zh ^ yh & zh;
    if (r < 0) r += 0x100000000;
    return r;
  }
  function maj64_lo(xh, xl, yh, yl, zh, zl) {
    var r = xl & yl ^ xl & zl ^ yl & zl;
    if (r < 0) r += 0x100000000;
    return r;
  }
  function s0_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 28);
    var c1_hi = rotr64_hi(xl, xh, 2);
    var c2_hi = rotr64_hi(xl, xh, 7);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0) r += 0x100000000;
    return r;
  }
  function s0_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 28);
    var c1_lo = rotr64_lo(xl, xh, 2);
    var c2_lo = rotr64_lo(xl, xh, 7);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0) r += 0x100000000;
    return r;
  }
  function s1_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 14);
    var c1_hi = rotr64_hi(xh, xl, 18);
    var c2_hi = rotr64_hi(xl, xh, 9);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0) r += 0x100000000;
    return r;
  }
  function s1_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 14);
    var c1_lo = rotr64_lo(xh, xl, 18);
    var c2_lo = rotr64_lo(xl, xh, 9);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0) r += 0x100000000;
    return r;
  }
  function g0_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 1);
    var c1_hi = rotr64_hi(xh, xl, 8);
    var c2_hi = shr64_hi(xh, xl, 7);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0) r += 0x100000000;
    return r;
  }
  function g0_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 1);
    var c1_lo = rotr64_lo(xh, xl, 8);
    var c2_lo = shr64_lo(xh, xl, 7);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0) r += 0x100000000;
    return r;
  }
  function g1_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 19);
    var c1_hi = rotr64_hi(xl, xh, 29);
    var c2_hi = shr64_hi(xh, xl, 6);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0) r += 0x100000000;
    return r;
  }
  function g1_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 19);
    var c1_lo = rotr64_lo(xl, xh, 29);
    var c2_lo = shr64_lo(xh, xl, 6);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0) r += 0x100000000;
    return r;
  }
  return module.exports;
});
$__System.registerDynamic('214', ['212'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var hash = $__require('212');
  var utils = hash.utils;
  var rotl32 = utils.rotl32;
  var sum32 = utils.sum32;
  var sum32_3 = utils.sum32_3;
  var sum32_4 = utils.sum32_4;
  var BlockHash = hash.common.BlockHash;
  function RIPEMD160() {
    if (!(this instanceof RIPEMD160)) return new RIPEMD160();
    BlockHash.call(this);
    this.h = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
    this.endian = 'little';
  }
  utils.inherits(RIPEMD160, BlockHash);
  exports.ripemd160 = RIPEMD160;
  RIPEMD160.blockSize = 512;
  RIPEMD160.outSize = 160;
  RIPEMD160.hmacStrength = 192;
  RIPEMD160.padLength = 64;
  RIPEMD160.prototype._update = function update(msg, start) {
    var A = this.h[0];
    var B = this.h[1];
    var C = this.h[2];
    var D = this.h[3];
    var E = this.h[4];
    var Ah = A;
    var Bh = B;
    var Ch = C;
    var Dh = D;
    var Eh = E;
    for (var j = 0; j < 80; j++) {
      var T = sum32(rotl32(sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)), s[j]), E);
      A = E;
      E = D;
      D = rotl32(C, 10);
      C = B;
      B = T;
      T = sum32(rotl32(sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)), sh[j]), Eh);
      Ah = Eh;
      Eh = Dh;
      Dh = rotl32(Ch, 10);
      Ch = Bh;
      Bh = T;
    }
    T = sum32_3(this.h[1], C, Dh);
    this.h[1] = sum32_3(this.h[2], D, Eh);
    this.h[2] = sum32_3(this.h[3], E, Ah);
    this.h[3] = sum32_3(this.h[4], A, Bh);
    this.h[4] = sum32_3(this.h[0], B, Ch);
    this.h[0] = T;
  };
  RIPEMD160.prototype._digest = function digest(enc) {
    if (enc === 'hex') return utils.toHex32(this.h, 'little');else return utils.split32(this.h, 'little');
  };
  function f(j, x, y, z) {
    if (j <= 15) return x ^ y ^ z;else if (j <= 31) return x & y | ~x & z;else if (j <= 47) return (x | ~y) ^ z;else if (j <= 63) return x & z | y & ~z;else return x ^ (y | ~z);
  }
  function K(j) {
    if (j <= 15) return 0x00000000;else if (j <= 31) return 0x5a827999;else if (j <= 47) return 0x6ed9eba1;else if (j <= 63) return 0x8f1bbcdc;else return 0xa953fd4e;
  }
  function Kh(j) {
    if (j <= 15) return 0x50a28be6;else if (j <= 31) return 0x5c4dd124;else if (j <= 47) return 0x6d703ef3;else if (j <= 63) return 0x7a6d76e9;else return 0x00000000;
  }
  var r = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
  var rh = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];
  var s = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
  var sh = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
  return module.exports;
});
$__System.registerDynamic('215', ['212'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var hmac = exports;
  var hash = $__require('212');
  var utils = hash.utils;
  var assert = utils.assert;
  function Hmac(hash, key, enc) {
    if (!(this instanceof Hmac)) return new Hmac(hash, key, enc);
    this.Hash = hash;
    this.blockSize = hash.blockSize / 8;
    this.outSize = hash.outSize / 8;
    this.inner = null;
    this.outer = null;
    this._init(utils.toArray(key, enc));
  }
  module.exports = Hmac;
  Hmac.prototype._init = function init(key) {
    if (key.length > this.blockSize) key = new this.Hash().update(key).digest();
    assert(key.length <= this.blockSize);
    for (var i = key.length; i < this.blockSize; i++) key.push(0);
    for (var i = 0; i < key.length; i++) key[i] ^= 0x36;
    this.inner = new this.Hash().update(key);
    for (var i = 0; i < key.length; i++) key[i] ^= 0x6a;
    this.outer = new this.Hash().update(key);
  };
  Hmac.prototype.update = function update(msg, enc) {
    this.inner.update(msg, enc);
    return this;
  };
  Hmac.prototype.digest = function digest(enc) {
    this.outer.update(this.inner.digest());
    return this.outer.digest(enc);
  };
  return module.exports;
});
$__System.registerDynamic('212', ['210', '211', '213', '214', '215'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var hash = exports;
  hash.utils = $__require('210');
  hash.common = $__require('211');
  hash.sha = $__require('213');
  hash.ripemd = $__require('214');
  hash.hmac = $__require('215');
  hash.sha1 = hash.sha.sha1;
  hash.sha256 = hash.sha.sha256;
  hash.sha224 = hash.sha.sha224;
  hash.sha384 = hash.sha.sha384;
  hash.sha512 = hash.sha.sha512;
  hash.ripemd160 = hash.ripemd.ripemd160;
  return module.exports;
});
$__System.registerDynamic("205", ["212"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("212");
  return module.exports;
});
$__System.registerDynamic('216', ['204'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var elliptic = $__require('204');
  var utils = elliptic.utils;
  var assert = utils.assert;
  var parseBytes = utils.parseBytes;
  var cachedProperty = utils.cachedProperty;
  function KeyPair(eddsa, params) {
    this.eddsa = eddsa;
    this._secret = parseBytes(params.secret);
    if (eddsa.isPoint(params.pub)) this._pub = params.pub;else this._pubBytes = parseBytes(params.pub);
  }
  KeyPair.fromPublic = function fromPublic(eddsa, pub) {
    if (pub instanceof KeyPair) return pub;
    return new KeyPair(eddsa, { pub: pub });
  };
  KeyPair.fromSecret = function fromSecret(eddsa, secret) {
    if (secret instanceof KeyPair) return secret;
    return new KeyPair(eddsa, { secret: secret });
  };
  KeyPair.prototype.secret = function secret() {
    return this._secret;
  };
  cachedProperty(KeyPair, 'pubBytes', function pubBytes() {
    return this.eddsa.encodePoint(this.pub());
  });
  cachedProperty(KeyPair, 'pub', function pub() {
    if (this._pubBytes) return this.eddsa.decodePoint(this._pubBytes);
    return this.eddsa.g.mul(this.priv());
  });
  cachedProperty(KeyPair, 'privBytes', function privBytes() {
    var eddsa = this.eddsa;
    var hash = this.hash();
    var lastIx = eddsa.encodingLength - 1;
    var a = hash.slice(0, eddsa.encodingLength);
    a[0] &= 248;
    a[lastIx] &= 127;
    a[lastIx] |= 64;
    return a;
  });
  cachedProperty(KeyPair, 'priv', function priv() {
    return this.eddsa.decodeInt(this.privBytes());
  });
  cachedProperty(KeyPair, 'hash', function hash() {
    return this.eddsa.hash().update(this.secret()).digest();
  });
  cachedProperty(KeyPair, 'messagePrefix', function messagePrefix() {
    return this.hash().slice(this.eddsa.encodingLength);
  });
  KeyPair.prototype.sign = function sign(message) {
    assert(this._secret, 'KeyPair can only verify');
    return this.eddsa.sign(message, this);
  };
  KeyPair.prototype.verify = function verify(message, sig) {
    return this.eddsa.verify(message, sig, this);
  };
  KeyPair.prototype.getSecret = function getSecret(enc) {
    assert(this._secret, 'KeyPair is public only');
    return utils.encode(this.secret(), enc);
  };
  KeyPair.prototype.getPublic = function getPublic(enc) {
    return utils.encode(this.pubBytes(), enc);
  };
  module.exports = KeyPair;
  return module.exports;
});
$__System.registerDynamic('217', ['1ee', '204'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var BN = $__require('1ee');
  var elliptic = $__require('204');
  var utils = elliptic.utils;
  var assert = utils.assert;
  var cachedProperty = utils.cachedProperty;
  var parseBytes = utils.parseBytes;
  function Signature(eddsa, sig) {
    this.eddsa = eddsa;
    if (typeof sig !== 'object') sig = parseBytes(sig);
    if (Array.isArray(sig)) {
      sig = {
        R: sig.slice(0, eddsa.encodingLength),
        S: sig.slice(eddsa.encodingLength)
      };
    }
    assert(sig.R && sig.S, 'Signature without R or S');
    if (eddsa.isPoint(sig.R)) this._R = sig.R;
    if (sig.S instanceof BN) this._S = sig.S;
    this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
    this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
  }
  cachedProperty(Signature, 'S', function S() {
    return this.eddsa.decodeInt(this.Sencoded());
  });
  cachedProperty(Signature, 'R', function R() {
    return this.eddsa.decodePoint(this.Rencoded());
  });
  cachedProperty(Signature, 'Rencoded', function Rencoded() {
    return this.eddsa.encodePoint(this.R());
  });
  cachedProperty(Signature, 'Sencoded', function Sencoded() {
    return this.eddsa.encodeInt(this.S());
  });
  Signature.prototype.toBytes = function toBytes() {
    return this.Rencoded().concat(this.Sencoded());
  };
  Signature.prototype.toHex = function toHex() {
    return utils.encode(this.toBytes(), 'hex').toUpperCase();
  };
  module.exports = Signature;
  return module.exports;
});
$__System.registerDynamic('218', ['205', '204', '216', '217'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var hash = $__require('205');
  var elliptic = $__require('204');
  var utils = elliptic.utils;
  var assert = utils.assert;
  var parseBytes = utils.parseBytes;
  var KeyPair = $__require('216');
  var Signature = $__require('217');
  function EDDSA(curve) {
    assert(curve === 'ed25519', 'only tested with ed25519 so far');
    if (!(this instanceof EDDSA)) return new EDDSA(curve);
    var curve = elliptic.curves[curve].curve;
    this.curve = curve;
    this.g = curve.g;
    this.g.precompute(curve.n.bitLength() + 1);
    this.pointClass = curve.point().constructor;
    this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
    this.hash = hash.sha512;
  }
  module.exports = EDDSA;
  EDDSA.prototype.sign = function sign(message, secret) {
    message = parseBytes(message);
    var key = this.keyFromSecret(secret);
    var r = this.hashInt(key.messagePrefix(), message);
    var R = this.g.mul(r);
    var Rencoded = this.encodePoint(R);
    var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
    var S = r.add(s_).umod(this.curve.n);
    return this.makeSignature({
      R: R,
      S: S,
      Rencoded: Rencoded
    });
  };
  EDDSA.prototype.verify = function verify(message, sig, pub) {
    message = parseBytes(message);
    sig = this.makeSignature(sig);
    var key = this.keyFromPublic(pub);
    var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
    var SG = this.g.mul(sig.S());
    var RplusAh = sig.R().add(key.pub().mul(h));
    return RplusAh.eq(SG);
  };
  EDDSA.prototype.hashInt = function hashInt() {
    var hash = this.hash();
    for (var i = 0; i < arguments.length; i++) hash.update(arguments[i]);
    return utils.intFromLE(hash.digest()).umod(this.curve.n);
  };
  EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
    return KeyPair.fromPublic(this, pub);
  };
  EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
    return KeyPair.fromSecret(this, secret);
  };
  EDDSA.prototype.makeSignature = function makeSignature(sig) {
    if (sig instanceof Signature) return sig;
    return new Signature(this, sig);
  };
  EDDSA.prototype.encodePoint = function encodePoint(point) {
    var enc = point.getY().toArray('le', this.encodingLength);
    enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
    return enc;
  };
  EDDSA.prototype.decodePoint = function decodePoint(bytes) {
    bytes = utils.parseBytes(bytes);
    var lastIx = bytes.length - 1;
    var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
    var xIsOdd = (bytes[lastIx] & 0x80) !== 0;
    var y = utils.intFromLE(normed);
    return this.curve.pointFromY(y, xIsOdd);
  };
  EDDSA.prototype.encodeInt = function encodeInt(num) {
    return num.toArray('le', this.encodingLength);
  };
  EDDSA.prototype.decodeInt = function decodeInt(bytes) {
    return utils.intFromLE(bytes);
  };
  EDDSA.prototype.isPoint = function isPoint(val) {
    return val instanceof this.pointClass;
  };
  return module.exports;
});
$__System.registerDynamic('204', ['200', '201', '1ed', '203', '208', '20c', '20f', '218'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var elliptic = exports;
  elliptic.version = $__require('200').version;
  elliptic.utils = $__require('201');
  elliptic.rand = $__require('1ed');
  elliptic.hmacDRBG = $__require('203');
  elliptic.curve = $__require('208');
  elliptic.curves = $__require('20c');
  elliptic.ec = $__require('20f');
  elliptic.eddsa = $__require('218');
  return module.exports;
});
$__System.registerDynamic("1fa", ["204"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("204");
  return module.exports;
});
$__System.registerDynamic('219', ['1fa', '1ee', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    var elliptic = $__require('1fa');
    var BN = $__require('1ee');
    module.exports = function createECDH(curve) {
      return new ECDH(curve);
    };
    var aliases = {
      secp256k1: {
        name: 'secp256k1',
        byteLength: 32
      },
      secp224r1: {
        name: 'p224',
        byteLength: 28
      },
      prime256v1: {
        name: 'p256',
        byteLength: 32
      },
      prime192v1: {
        name: 'p192',
        byteLength: 24
      },
      ed25519: {
        name: 'ed25519',
        byteLength: 32
      },
      secp384r1: {
        name: 'p384',
        byteLength: 48
      },
      secp521r1: {
        name: 'p521',
        byteLength: 66
      }
    };
    aliases.p224 = aliases.secp224r1;
    aliases.p256 = aliases.secp256r1 = aliases.prime256v1;
    aliases.p192 = aliases.secp192r1 = aliases.prime192v1;
    aliases.p384 = aliases.secp384r1;
    aliases.p521 = aliases.secp521r1;
    function ECDH(curve) {
      this.curveType = aliases[curve];
      if (!this.curveType) {
        this.curveType = { name: curve };
      }
      this.curve = new elliptic.ec(this.curveType.name);
      this.keys = void 0;
    }
    ECDH.prototype.generateKeys = function (enc, format) {
      this.keys = this.curve.genKeyPair();
      return this.getPublicKey(enc, format);
    };
    ECDH.prototype.computeSecret = function (other, inenc, enc) {
      inenc = inenc || 'utf8';
      if (!Buffer.isBuffer(other)) {
        other = new Buffer(other, inenc);
      }
      var otherPub = this.curve.keyFromPublic(other).getPublic();
      var out = otherPub.mul(this.keys.getPrivate()).getX();
      return formatReturnValue(out, enc, this.curveType.byteLength);
    };
    ECDH.prototype.getPublicKey = function (enc, format) {
      var key = this.keys.getPublic(format === 'compressed', true);
      if (format === 'hybrid') {
        if (key[key.length - 1] % 2) {
          key[0] = 7;
        } else {
          key[0] = 6;
        }
      }
      return formatReturnValue(key, enc);
    };
    ECDH.prototype.getPrivateKey = function (enc) {
      return formatReturnValue(this.keys.getPrivate(), enc);
    };
    ECDH.prototype.setPublicKey = function (pub, enc) {
      enc = enc || 'utf8';
      if (!Buffer.isBuffer(pub)) {
        pub = new Buffer(pub, enc);
      }
      this.keys._importPublic(pub);
      return this;
    };
    ECDH.prototype.setPrivateKey = function (priv, enc) {
      enc = enc || 'utf8';
      if (!Buffer.isBuffer(priv)) {
        priv = new Buffer(priv, enc);
      }
      var _priv = new BN(priv);
      _priv = _priv.toString(16);
      this.keys._importPrivate(_priv);
      return this;
    };
    function formatReturnValue(bn, enc, len) {
      if (!Array.isArray(bn)) {
        bn = bn.toArray();
      }
      var buf = new Buffer(bn);
      if (len && buf.length < len) {
        var zeros = new Buffer(len - buf.length);
        zeros.fill(0);
        buf = Buffer.concat([zeros, buf]);
      }
      if (!enc) {
        return buf;
      } else {
        return buf.toString(enc);
      }
    }
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic("21a", ["219"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("219");
  return module.exports;
});
$__System.registerDynamic('21b', ['1fb', '1f1', '1fe', '21c', '21d', '1ee', '21e', '1f9', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    var parseKeys = $__require('1fb');
    var randomBytes = $__require('1f1');
    var createHash = $__require('1fe');
    var mgf = $__require('21c');
    var xor = $__require('21d');
    var bn = $__require('1ee');
    var withPublic = $__require('21e');
    var crt = $__require('1f9');
    var constants = {
      RSA_PKCS1_OAEP_PADDING: 4,
      RSA_PKCS1_PADDIN: 1,
      RSA_NO_PADDING: 3
    };
    module.exports = function publicEncrypt(public_key, msg, reverse) {
      var padding;
      if (public_key.padding) {
        padding = public_key.padding;
      } else if (reverse) {
        padding = 1;
      } else {
        padding = 4;
      }
      var key = parseKeys(public_key);
      var paddedMsg;
      if (padding === 4) {
        paddedMsg = oaep(key, msg);
      } else if (padding === 1) {
        paddedMsg = pkcs1(key, msg, reverse);
      } else if (padding === 3) {
        paddedMsg = new bn(msg);
        if (paddedMsg.cmp(key.modulus) >= 0) {
          throw new Error('data too long for modulus');
        }
      } else {
        throw new Error('unknown padding');
      }
      if (reverse) {
        return crt(paddedMsg, key);
      } else {
        return withPublic(paddedMsg, key);
      }
    };
    function oaep(key, msg) {
      var k = key.modulus.byteLength();
      var mLen = msg.length;
      var iHash = createHash('sha1').update(new Buffer('')).digest();
      var hLen = iHash.length;
      var hLen2 = 2 * hLen;
      if (mLen > k - hLen2 - 2) {
        throw new Error('message too long');
      }
      var ps = new Buffer(k - mLen - hLen2 - 2);
      ps.fill(0);
      var dblen = k - hLen - 1;
      var seed = randomBytes(hLen);
      var maskedDb = xor(Buffer.concat([iHash, ps, new Buffer([1]), msg], dblen), mgf(seed, dblen));
      var maskedSeed = xor(seed, mgf(maskedDb, hLen));
      return new bn(Buffer.concat([new Buffer([0]), maskedSeed, maskedDb], k));
    }
    function pkcs1(key, msg, reverse) {
      var mLen = msg.length;
      var k = key.modulus.byteLength();
      if (mLen > k - 11) {
        throw new Error('message too long');
      }
      var ps;
      if (reverse) {
        ps = new Buffer(k - mLen - 3);
        ps.fill(0xff);
      } else {
        ps = nonZero(k - mLen - 3);
      }
      return new bn(Buffer.concat([new Buffer([0, reverse ? 1 : 2]), ps, new Buffer([0]), msg], k));
    }
    function nonZero(len, crypto) {
      var out = new Buffer(len);
      var i = 0;
      var cache = randomBytes(len * 2);
      var cur = 0;
      var num;
      while (i < len) {
        if (cur === cache.length) {
          cache = randomBytes(len * 2);
          cur = 0;
        }
        num = cache[cur++];
        if (num) {
          out[i++] = num;
        }
      }
      return out;
    }
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic("21f", [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */

  var indexOf = [].indexOf;

  module.exports = function (arr, obj) {
    if (indexOf) return arr.indexOf(obj);
    for (var i = 0; i < arr.length; ++i) {
      if (arr[i] === obj) return i;
    }
    return -1;
  };
  return module.exports;
});
$__System.registerDynamic("220", ["21f"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("21f");
  return module.exports;
});
$__System.registerDynamic('221', ['220'], true, function ($__require, exports, module) {
    var define,
        global = this || self,
        GLOBAL = global;
    /* */
    var indexOf = $__require('220');

    var Object_keys = function (obj) {
        if (Object.keys) return Object.keys(obj);else {
            var res = [];
            for (var key in obj) res.push(key);
            return res;
        }
    };

    var forEach = function (xs, fn) {
        if (xs.forEach) return xs.forEach(fn);else for (var i = 0; i < xs.length; i++) {
            fn(xs[i], i, xs);
        }
    };

    var defineProp = function () {
        try {
            Object.defineProperty({}, '_', {});
            return function (obj, name, value) {
                Object.defineProperty(obj, name, {
                    writable: true,
                    enumerable: false,
                    configurable: true,
                    value: value
                });
            };
        } catch (e) {
            return function (obj, name, value) {
                obj[name] = value;
            };
        }
    }();

    var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function', 'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError', 'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError', 'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape', 'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];

    function Context() {}
    Context.prototype = {};

    var Script = exports.Script = function NodeScript(code) {
        if (!(this instanceof Script)) return new Script(code);
        this.code = code;
    };

    Script.prototype.runInContext = function (context) {
        if (!(context instanceof Context)) {
            throw new TypeError("needs a 'context' argument.");
        }

        var iframe = document.createElement('iframe');
        if (!iframe.style) iframe.style = {};
        iframe.style.display = 'none';

        document.body.appendChild(iframe);

        var win = iframe.contentWindow;
        var wEval = win.eval,
            wExecScript = win.execScript;

        if (!wEval && wExecScript) {
            // win.eval() magically appears when this is called in IE:
            wExecScript.call(win, 'null');
            wEval = win.eval;
        }

        forEach(Object_keys(context), function (key) {
            win[key] = context[key];
        });
        forEach(globals, function (key) {
            if (context[key]) {
                win[key] = context[key];
            }
        });

        var winKeys = Object_keys(win);

        var res = wEval.call(win, this.code);

        forEach(Object_keys(win), function (key) {
            // Avoid copying circular objects like `top` and `window` by only
            // updating existing context properties or new properties in the `win`
            // that was only introduced after the eval.
            if (key in context || indexOf(winKeys, key) === -1) {
                context[key] = win[key];
            }
        });

        forEach(globals, function (key) {
            if (!(key in context)) {
                defineProp(context, key, win[key]);
            }
        });

        document.body.removeChild(iframe);

        return res;
    };

    Script.prototype.runInThisContext = function () {
        return eval(this.code); // maybe...
    };

    Script.prototype.runInNewContext = function (context) {
        var ctx = Script.createContext(context);
        var res = this.runInContext(ctx);

        forEach(Object_keys(ctx), function (key) {
            context[key] = ctx[key];
        });

        return res;
    };

    forEach(Object_keys(Script.prototype), function (name) {
        exports[name] = Script[name] = function (code) {
            var s = Script(code);
            return s[name].apply(s, [].slice.call(arguments, 1));
        };
    });

    exports.createScript = function (code) {
        return exports.Script(code);
    };

    exports.createContext = Script.createContext = function (context) {
        var copy = new Context();
        if (typeof context === 'object') {
            forEach(Object_keys(context), function (key) {
                copy[key] = context[key];
            });
        }
        return copy;
    };
    return module.exports;
});
$__System.registerDynamic("222", ["221"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("221");
  return module.exports;
});
$__System.registerDynamic('223', ['222'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  module.exports = $__System._nodeRequire ? $__System._nodeRequire('vm') : $__require('222');
  return module.exports;
});
$__System.registerDynamic("224", ["223"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("223");
  return module.exports;
});
$__System.registerDynamic('225', ['226', '46', '224'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var asn1 = $__require('226');
  var inherits = $__require('46');
  var api = exports;
  api.define = function define(name, body) {
    return new Entity(name, body);
  };
  function Entity(name, body) {
    this.name = name;
    this.body = body;
    this.decoders = {};
    this.encoders = {};
  }
  ;
  Entity.prototype._createNamed = function createNamed(base) {
    var named;
    try {
      named = $__require('224').runInThisContext('(function ' + this.name + '(entity) {\n' + '  this._initNamed(entity);\n' + '})');
    } catch (e) {
      named = function (entity) {
        this._initNamed(entity);
      };
    }
    inherits(named, base);
    named.prototype._initNamed = function initnamed(entity) {
      base.call(this, entity);
    };
    return new named(this);
  };
  Entity.prototype._getDecoder = function _getDecoder(enc) {
    enc = enc || 'der';
    if (!this.decoders.hasOwnProperty(enc)) this.decoders[enc] = this._createNamed(asn1.decoders[enc]);
    return this.decoders[enc];
  };
  Entity.prototype.decode = function decode(data, enc, options) {
    return this._getDecoder(enc).decode(data, options);
  };
  Entity.prototype._getEncoder = function _getEncoder(enc) {
    enc = enc || 'der';
    if (!this.encoders.hasOwnProperty(enc)) this.encoders[enc] = this._createNamed(asn1.encoders[enc]);
    return this.encoders[enc];
  };
  Entity.prototype.encode = function encode(data, enc, reporter) {
    return this._getEncoder(enc).encode(data, reporter);
  };
  return module.exports;
});
$__System.registerDynamic('227', ['46'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var inherits = $__require('46');

  function Reporter(options) {
    this._reporterState = {
      obj: null,
      path: [],
      options: options || {},
      errors: []
    };
  }
  exports.Reporter = Reporter;

  Reporter.prototype.isError = function isError(obj) {
    return obj instanceof ReporterError;
  };

  Reporter.prototype.save = function save() {
    var state = this._reporterState;

    return { obj: state.obj, pathLen: state.path.length };
  };

  Reporter.prototype.restore = function restore(data) {
    var state = this._reporterState;

    state.obj = data.obj;
    state.path = state.path.slice(0, data.pathLen);
  };

  Reporter.prototype.enterKey = function enterKey(key) {
    return this._reporterState.path.push(key);
  };

  Reporter.prototype.exitKey = function exitKey(index) {
    var state = this._reporterState;

    state.path = state.path.slice(0, index - 1);
  };

  Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
    var state = this._reporterState;

    this.exitKey(index);
    if (state.obj !== null) state.obj[key] = value;
  };

  Reporter.prototype.path = function path() {
    return this._reporterState.path.join('/');
  };

  Reporter.prototype.enterObject = function enterObject() {
    var state = this._reporterState;

    var prev = state.obj;
    state.obj = {};
    return prev;
  };

  Reporter.prototype.leaveObject = function leaveObject(prev) {
    var state = this._reporterState;

    var now = state.obj;
    state.obj = prev;
    return now;
  };

  Reporter.prototype.error = function error(msg) {
    var err;
    var state = this._reporterState;

    var inherited = msg instanceof ReporterError;
    if (inherited) {
      err = msg;
    } else {
      err = new ReporterError(state.path.map(function (elem) {
        return '[' + JSON.stringify(elem) + ']';
      }).join(''), msg.message || msg, msg.stack);
    }

    if (!state.options.partial) throw err;

    if (!inherited) state.errors.push(err);

    return err;
  };

  Reporter.prototype.wrapResult = function wrapResult(result) {
    var state = this._reporterState;
    if (!state.options.partial) return result;

    return {
      result: this.isError(result) ? null : result,
      errors: state.errors
    };
  };

  function ReporterError(path, msg) {
    this.path = path;
    this.rethrow(msg);
  };
  inherits(ReporterError, Error);

  ReporterError.prototype.rethrow = function rethrow(msg) {
    this.message = msg + ' at: ' + (this.path || '(shallow)');
    if (Error.captureStackTrace) Error.captureStackTrace(this, ReporterError);

    if (!this.stack) {
      try {
        // IE only adds stack when thrown
        throw new Error(this.message);
      } catch (e) {
        this.stack = e.stack;
      }
    }
    return this;
  };
  return module.exports;
});
$__System.registerDynamic('228', ['46', '229', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    var inherits = $__require('46');
    var Reporter = $__require('229').Reporter;
    var Buffer = $__require('2a').Buffer;
    function DecoderBuffer(base, options) {
      Reporter.call(this, options);
      if (!Buffer.isBuffer(base)) {
        this.error('Input not Buffer');
        return;
      }
      this.base = base;
      this.offset = 0;
      this.length = base.length;
    }
    inherits(DecoderBuffer, Reporter);
    exports.DecoderBuffer = DecoderBuffer;
    DecoderBuffer.prototype.save = function save() {
      return {
        offset: this.offset,
        reporter: Reporter.prototype.save.call(this)
      };
    };
    DecoderBuffer.prototype.restore = function restore(save) {
      var res = new DecoderBuffer(this.base);
      res.offset = save.offset;
      res.length = this.offset;
      this.offset = save.offset;
      Reporter.prototype.restore.call(this, save.reporter);
      return res;
    };
    DecoderBuffer.prototype.isEmpty = function isEmpty() {
      return this.offset === this.length;
    };
    DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
      if (this.offset + 1 <= this.length) return this.base.readUInt8(this.offset++, true);else return this.error(fail || 'DecoderBuffer overrun');
    };
    DecoderBuffer.prototype.skip = function skip(bytes, fail) {
      if (!(this.offset + bytes <= this.length)) return this.error(fail || 'DecoderBuffer overrun');
      var res = new DecoderBuffer(this.base);
      res._reporterState = this._reporterState;
      res.offset = this.offset;
      res.length = this.offset + bytes;
      this.offset += bytes;
      return res;
    };
    DecoderBuffer.prototype.raw = function raw(save) {
      return this.base.slice(save ? save.offset : this.offset, this.length);
    };
    function EncoderBuffer(value, reporter) {
      if (Array.isArray(value)) {
        this.length = 0;
        this.value = value.map(function (item) {
          if (!(item instanceof EncoderBuffer)) item = new EncoderBuffer(item, reporter);
          this.length += item.length;
          return item;
        }, this);
      } else if (typeof value === 'number') {
        if (!(0 <= value && value <= 0xff)) return reporter.error('non-byte EncoderBuffer value');
        this.value = value;
        this.length = 1;
      } else if (typeof value === 'string') {
        this.value = value;
        this.length = Buffer.byteLength(value);
      } else if (Buffer.isBuffer(value)) {
        this.value = value;
        this.length = value.length;
      } else {
        return reporter.error('Unsupported type: ' + typeof value);
      }
    }
    exports.EncoderBuffer = EncoderBuffer;
    EncoderBuffer.prototype.join = function join(out, offset) {
      if (!out) out = new Buffer(this.length);
      if (!offset) offset = 0;
      if (this.length === 0) return out;
      if (Array.isArray(this.value)) {
        this.value.forEach(function (item) {
          item.join(out, offset);
          offset += item.length;
        });
      } else {
        if (typeof this.value === 'number') out[offset] = this.value;else if (typeof this.value === 'string') out.write(this.value, offset);else if (Buffer.isBuffer(this.value)) this.value.copy(out, offset);
        offset += this.length;
      }
      return out;
    };
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic('22a', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  module.exports = assert;

  function assert(val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  assert.equal = function assertEqual(l, r, msg) {
    if (l != r) throw new Error(msg || 'Assertion failed: ' + l + ' != ' + r);
  };
  return module.exports;
});
$__System.registerDynamic("1dc", ["22a"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("22a");
  return module.exports;
});
$__System.registerDynamic('22b', ['229', '1dc'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var Reporter = $__require('229').Reporter;
  var EncoderBuffer = $__require('229').EncoderBuffer;
  var DecoderBuffer = $__require('229').DecoderBuffer;
  var assert = $__require('1dc');
  var tags = ['seq', 'seqof', 'set', 'setof', 'objid', 'bool', 'gentime', 'utctime', 'null_', 'enum', 'int', 'objDesc', 'bitstr', 'bmpstr', 'charstr', 'genstr', 'graphstr', 'ia5str', 'iso646str', 'numstr', 'octstr', 'printstr', 't61str', 'unistr', 'utf8str', 'videostr'];
  var methods = ['key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice', 'any', 'contains'].concat(tags);
  var overrided = ['_peekTag', '_decodeTag', '_use', '_decodeStr', '_decodeObjid', '_decodeTime', '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList', '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime', '_encodeNull', '_encodeInt', '_encodeBool'];
  function Node(enc, parent) {
    var state = {};
    this._baseState = state;
    state.enc = enc;
    state.parent = parent || null;
    state.children = null;
    state.tag = null;
    state.args = null;
    state.reverseArgs = null;
    state.choice = null;
    state.optional = false;
    state.any = false;
    state.obj = false;
    state.use = null;
    state.useDecoder = null;
    state.key = null;
    state['default'] = null;
    state.explicit = null;
    state.implicit = null;
    state.contains = null;
    if (!state.parent) {
      state.children = [];
      this._wrap();
    }
  }
  module.exports = Node;
  var stateProps = ['enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice', 'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit', 'implicit', 'contains'];
  Node.prototype.clone = function clone() {
    var state = this._baseState;
    var cstate = {};
    stateProps.forEach(function (prop) {
      cstate[prop] = state[prop];
    });
    var res = new this.constructor(cstate.parent);
    res._baseState = cstate;
    return res;
  };
  Node.prototype._wrap = function wrap() {
    var state = this._baseState;
    methods.forEach(function (method) {
      this[method] = function _wrappedMethod() {
        var clone = new this.constructor(this);
        state.children.push(clone);
        return clone[method].apply(clone, arguments);
      };
    }, this);
  };
  Node.prototype._init = function init(body) {
    var state = this._baseState;
    assert(state.parent === null);
    body.call(this);
    state.children = state.children.filter(function (child) {
      return child._baseState.parent === this;
    }, this);
    assert.equal(state.children.length, 1, 'Root node can have only one child');
  };
  Node.prototype._useArgs = function useArgs(args) {
    var state = this._baseState;
    var children = args.filter(function (arg) {
      return arg instanceof this.constructor;
    }, this);
    args = args.filter(function (arg) {
      return !(arg instanceof this.constructor);
    }, this);
    if (children.length !== 0) {
      assert(state.children === null);
      state.children = children;
      children.forEach(function (child) {
        child._baseState.parent = this;
      }, this);
    }
    if (args.length !== 0) {
      assert(state.args === null);
      state.args = args;
      state.reverseArgs = args.map(function (arg) {
        if (typeof arg !== 'object' || arg.constructor !== Object) return arg;
        var res = {};
        Object.keys(arg).forEach(function (key) {
          if (key == (key | 0)) key |= 0;
          var value = arg[key];
          res[value] = key;
        });
        return res;
      });
    }
  };
  overrided.forEach(function (method) {
    Node.prototype[method] = function _overrided() {
      var state = this._baseState;
      throw new Error(method + ' not implemented for encoding: ' + state.enc);
    };
  });
  tags.forEach(function (tag) {
    Node.prototype[tag] = function _tagMethod() {
      var state = this._baseState;
      var args = Array.prototype.slice.call(arguments);
      assert(state.tag === null);
      state.tag = tag;
      this._useArgs(args);
      return this;
    };
  });
  Node.prototype.use = function use(item) {
    assert(item);
    var state = this._baseState;
    assert(state.use === null);
    state.use = item;
    return this;
  };
  Node.prototype.optional = function optional() {
    var state = this._baseState;
    state.optional = true;
    return this;
  };
  Node.prototype.def = function def(val) {
    var state = this._baseState;
    assert(state['default'] === null);
    state['default'] = val;
    state.optional = true;
    return this;
  };
  Node.prototype.explicit = function explicit(num) {
    var state = this._baseState;
    assert(state.explicit === null && state.implicit === null);
    state.explicit = num;
    return this;
  };
  Node.prototype.implicit = function implicit(num) {
    var state = this._baseState;
    assert(state.explicit === null && state.implicit === null);
    state.implicit = num;
    return this;
  };
  Node.prototype.obj = function obj() {
    var state = this._baseState;
    var args = Array.prototype.slice.call(arguments);
    state.obj = true;
    if (args.length !== 0) this._useArgs(args);
    return this;
  };
  Node.prototype.key = function key(newKey) {
    var state = this._baseState;
    assert(state.key === null);
    state.key = newKey;
    return this;
  };
  Node.prototype.any = function any() {
    var state = this._baseState;
    state.any = true;
    return this;
  };
  Node.prototype.choice = function choice(obj) {
    var state = this._baseState;
    assert(state.choice === null);
    state.choice = obj;
    this._useArgs(Object.keys(obj).map(function (key) {
      return obj[key];
    }));
    return this;
  };
  Node.prototype.contains = function contains(item) {
    var state = this._baseState;
    assert(state.use === null);
    state.contains = item;
    return this;
  };
  Node.prototype._decode = function decode(input, options) {
    var state = this._baseState;
    if (state.parent === null) return input.wrapResult(state.children[0]._decode(input, options));
    var result = state['default'];
    var present = true;
    var prevKey = null;
    if (state.key !== null) prevKey = input.enterKey(state.key);
    if (state.optional) {
      var tag = null;
      if (state.explicit !== null) tag = state.explicit;else if (state.implicit !== null) tag = state.implicit;else if (state.tag !== null) tag = state.tag;
      if (tag === null && !state.any) {
        var save = input.save();
        try {
          if (state.choice === null) this._decodeGeneric(state.tag, input, options);else this._decodeChoice(input, options);
          present = true;
        } catch (e) {
          present = false;
        }
        input.restore(save);
      } else {
        present = this._peekTag(input, tag, state.any);
        if (input.isError(present)) return present;
      }
    }
    var prevObj;
    if (state.obj && present) prevObj = input.enterObject();
    if (present) {
      if (state.explicit !== null) {
        var explicit = this._decodeTag(input, state.explicit);
        if (input.isError(explicit)) return explicit;
        input = explicit;
      }
      var start = input.offset;
      if (state.use === null && state.choice === null) {
        if (state.any) var save = input.save();
        var body = this._decodeTag(input, state.implicit !== null ? state.implicit : state.tag, state.any);
        if (input.isError(body)) return body;
        if (state.any) result = input.raw(save);else input = body;
      }
      if (options && options.track && state.tag !== null) options.track(input.path(), start, input.length, 'tagged');
      if (options && options.track && state.tag !== null) options.track(input.path(), input.offset, input.length, 'content');
      if (state.any) result = result;else if (state.choice === null) result = this._decodeGeneric(state.tag, input, options);else result = this._decodeChoice(input, options);
      if (input.isError(result)) return result;
      if (!state.any && state.choice === null && state.children !== null) {
        state.children.forEach(function decodeChildren(child) {
          child._decode(input, options);
        });
      }
      if (state.contains && (state.tag === 'octstr' || state.tag === 'bitstr')) {
        var data = new DecoderBuffer(result);
        result = this._getUse(state.contains, input._reporterState.obj)._decode(data, options);
      }
    }
    if (state.obj && present) result = input.leaveObject(prevObj);
    if (state.key !== null && (result !== null || present === true)) input.leaveKey(prevKey, state.key, result);else if (prevKey !== null) input.exitKey(prevKey);
    return result;
  };
  Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
    var state = this._baseState;
    if (tag === 'seq' || tag === 'set') return null;
    if (tag === 'seqof' || tag === 'setof') return this._decodeList(input, tag, state.args[0], options);else if (/str$/.test(tag)) return this._decodeStr(input, tag, options);else if (tag === 'objid' && state.args) return this._decodeObjid(input, state.args[0], state.args[1], options);else if (tag === 'objid') return this._decodeObjid(input, null, null, options);else if (tag === 'gentime' || tag === 'utctime') return this._decodeTime(input, tag, options);else if (tag === 'null_') return this._decodeNull(input, options);else if (tag === 'bool') return this._decodeBool(input, options);else if (tag === 'objDesc') return this._decodeStr(input, tag, options);else if (tag === 'int' || tag === 'enum') return this._decodeInt(input, state.args && state.args[0], options);
    if (state.use !== null) {
      return this._getUse(state.use, input._reporterState.obj)._decode(input, options);
    } else {
      return input.error('unknown tag: ' + tag);
    }
  };
  Node.prototype._getUse = function _getUse(entity, obj) {
    var state = this._baseState;
    state.useDecoder = this._use(entity, obj);
    assert(state.useDecoder._baseState.parent === null);
    state.useDecoder = state.useDecoder._baseState.children[0];
    if (state.implicit !== state.useDecoder._baseState.implicit) {
      state.useDecoder = state.useDecoder.clone();
      state.useDecoder._baseState.implicit = state.implicit;
    }
    return state.useDecoder;
  };
  Node.prototype._decodeChoice = function decodeChoice(input, options) {
    var state = this._baseState;
    var result = null;
    var match = false;
    Object.keys(state.choice).some(function (key) {
      var save = input.save();
      var node = state.choice[key];
      try {
        var value = node._decode(input, options);
        if (input.isError(value)) return false;
        result = {
          type: key,
          value: value
        };
        match = true;
      } catch (e) {
        input.restore(save);
        return false;
      }
      return true;
    }, this);
    if (!match) return input.error('Choice not matched');
    return result;
  };
  Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
    return new EncoderBuffer(data, this.reporter);
  };
  Node.prototype._encode = function encode(data, reporter, parent) {
    var state = this._baseState;
    if (state['default'] !== null && state['default'] === data) return;
    var result = this._encodeValue(data, reporter, parent);
    if (result === undefined) return;
    if (this._skipDefault(result, reporter, parent)) return;
    return result;
  };
  Node.prototype._encodeValue = function encode(data, reporter, parent) {
    var state = this._baseState;
    if (state.parent === null) return state.children[0]._encode(data, reporter || new Reporter());
    var result = null;
    this.reporter = reporter;
    if (state.optional && data === undefined) {
      if (state['default'] !== null) data = state['default'];else return;
    }
    var content = null;
    var primitive = false;
    if (state.any) {
      result = this._createEncoderBuffer(data);
    } else if (state.choice) {
      result = this._encodeChoice(data, reporter);
    } else if (state.contains) {
      content = this._getUse(state.contains, parent)._encode(data, reporter);
      primitive = true;
    } else if (state.children) {
      content = state.children.map(function (child) {
        if (child._baseState.tag === 'null_') return child._encode(null, reporter, data);
        if (child._baseState.key === null) return reporter.error('Child should have a key');
        var prevKey = reporter.enterKey(child._baseState.key);
        if (typeof data !== 'object') return reporter.error('Child expected, but input is not object');
        var res = child._encode(data[child._baseState.key], reporter, data);
        reporter.leaveKey(prevKey);
        return res;
      }, this).filter(function (child) {
        return child;
      });
      content = this._createEncoderBuffer(content);
    } else {
      if (state.tag === 'seqof' || state.tag === 'setof') {
        if (!(state.args && state.args.length === 1)) return reporter.error('Too many args for : ' + state.tag);
        if (!Array.isArray(data)) return reporter.error('seqof/setof, but data is not Array');
        var child = this.clone();
        child._baseState.implicit = null;
        content = this._createEncoderBuffer(data.map(function (item) {
          var state = this._baseState;
          return this._getUse(state.args[0], data)._encode(item, reporter);
        }, child));
      } else if (state.use !== null) {
        result = this._getUse(state.use, parent)._encode(data, reporter);
      } else {
        content = this._encodePrimitive(state.tag, data);
        primitive = true;
      }
    }
    var result;
    if (!state.any && state.choice === null) {
      var tag = state.implicit !== null ? state.implicit : state.tag;
      var cls = state.implicit === null ? 'universal' : 'context';
      if (tag === null) {
        if (state.use === null) reporter.error('Tag could be ommited only for .use()');
      } else {
        if (state.use === null) result = this._encodeComposite(tag, primitive, cls, content);
      }
    }
    if (state.explicit !== null) result = this._encodeComposite(state.explicit, false, 'context', result);
    return result;
  };
  Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
    var state = this._baseState;
    var node = state.choice[data.type];
    if (!node) {
      assert(false, data.type + ' not found in ' + JSON.stringify(Object.keys(state.choice)));
    }
    return node._encode(data.value, reporter);
  };
  Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
    var state = this._baseState;
    if (/str$/.test(tag)) return this._encodeStr(data, tag);else if (tag === 'objid' && state.args) return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);else if (tag === 'objid') return this._encodeObjid(data, null, null);else if (tag === 'gentime' || tag === 'utctime') return this._encodeTime(data, tag);else if (tag === 'null_') return this._encodeNull();else if (tag === 'int' || tag === 'enum') return this._encodeInt(data, state.args && state.reverseArgs[0]);else if (tag === 'bool') return this._encodeBool(data);else if (tag === 'objDesc') return this._encodeStr(data, tag);else throw new Error('Unsupported tag: ' + tag);
  };
  Node.prototype._isNumstr = function isNumstr(str) {
    return (/^[0-9 ]*$/.test(str)
    );
  };
  Node.prototype._isPrintstr = function isPrintstr(str) {
    return (/^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(str)
    );
  };
  return module.exports;
});
$__System.registerDynamic('229', ['227', '228', '22b'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var base = exports;
  base.Reporter = $__require('227').Reporter;
  base.DecoderBuffer = $__require('228').DecoderBuffer;
  base.EncoderBuffer = $__require('228').EncoderBuffer;
  base.Node = $__require('22b');
  return module.exports;
});
$__System.registerDynamic('22c', ['22d'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var constants = $__require('22d');
  exports.tagClass = {
    0: 'universal',
    1: 'application',
    2: 'context',
    3: 'private'
  };
  exports.tagClassByName = constants._reverse(exports.tagClass);
  exports.tag = {
    0x00: 'end',
    0x01: 'bool',
    0x02: 'int',
    0x03: 'bitstr',
    0x04: 'octstr',
    0x05: 'null_',
    0x06: 'objid',
    0x07: 'objDesc',
    0x08: 'external',
    0x09: 'real',
    0x0a: 'enum',
    0x0b: 'embed',
    0x0c: 'utf8str',
    0x0d: 'relativeOid',
    0x10: 'seq',
    0x11: 'set',
    0x12: 'numstr',
    0x13: 'printstr',
    0x14: 't61str',
    0x15: 'videostr',
    0x16: 'ia5str',
    0x17: 'utctime',
    0x18: 'gentime',
    0x19: 'graphstr',
    0x1a: 'iso646str',
    0x1b: 'genstr',
    0x1c: 'unistr',
    0x1d: 'charstr',
    0x1e: 'bmpstr'
  };
  exports.tagByName = constants._reverse(exports.tag);
  return module.exports;
});
$__System.registerDynamic('22d', ['22c'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var constants = exports;
  constants._reverse = function reverse(map) {
    var res = {};
    Object.keys(map).forEach(function (key) {
      if ((key | 0) == key) key = key | 0;
      var value = map[key];
      res[value] = key;
    });
    return res;
  };
  constants.der = $__require('22c');
  return module.exports;
});
$__System.registerDynamic('22e', ['46', '226'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var inherits = $__require('46');
  var asn1 = $__require('226');
  var base = asn1.base;
  var bignum = asn1.bignum;
  var der = asn1.constants.der;
  function DERDecoder(entity) {
    this.enc = 'der';
    this.name = entity.name;
    this.entity = entity;
    this.tree = new DERNode();
    this.tree._init(entity.body);
  }
  ;
  module.exports = DERDecoder;
  DERDecoder.prototype.decode = function decode(data, options) {
    if (!(data instanceof base.DecoderBuffer)) data = new base.DecoderBuffer(data, options);
    return this.tree._decode(data, options);
  };
  function DERNode(parent) {
    base.Node.call(this, 'der', parent);
  }
  inherits(DERNode, base.Node);
  DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
    if (buffer.isEmpty()) return false;
    var state = buffer.save();
    var decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
    if (buffer.isError(decodedTag)) return decodedTag;
    buffer.restore(state);
    return decodedTag.tag === tag || decodedTag.tagStr === tag || decodedTag.tagStr + 'of' === tag || any;
  };
  DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
    var decodedTag = derDecodeTag(buffer, 'Failed to decode tag of "' + tag + '"');
    if (buffer.isError(decodedTag)) return decodedTag;
    var len = derDecodeLen(buffer, decodedTag.primitive, 'Failed to get length of "' + tag + '"');
    if (buffer.isError(len)) return len;
    if (!any && decodedTag.tag !== tag && decodedTag.tagStr !== tag && decodedTag.tagStr + 'of' !== tag) {
      return buffer.error('Failed to match tag: "' + tag + '"');
    }
    if (decodedTag.primitive || len !== null) return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
    var state = buffer.save();
    var res = this._skipUntilEnd(buffer, 'Failed to skip indefinite length body: "' + this.tag + '"');
    if (buffer.isError(res)) return res;
    len = buffer.offset - state.offset;
    buffer.restore(state);
    return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
  };
  DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
    while (true) {
      var tag = derDecodeTag(buffer, fail);
      if (buffer.isError(tag)) return tag;
      var len = derDecodeLen(buffer, tag.primitive, fail);
      if (buffer.isError(len)) return len;
      var res;
      if (tag.primitive || len !== null) res = buffer.skip(len);else res = this._skipUntilEnd(buffer, fail);
      if (buffer.isError(res)) return res;
      if (tag.tagStr === 'end') break;
    }
  };
  DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder, options) {
    var result = [];
    while (!buffer.isEmpty()) {
      var possibleEnd = this._peekTag(buffer, 'end');
      if (buffer.isError(possibleEnd)) return possibleEnd;
      var res = decoder.decode(buffer, 'der', options);
      if (buffer.isError(res) && possibleEnd) break;
      result.push(res);
    }
    return result;
  };
  DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
    if (tag === 'bitstr') {
      var unused = buffer.readUInt8();
      if (buffer.isError(unused)) return unused;
      return {
        unused: unused,
        data: buffer.raw()
      };
    } else if (tag === 'bmpstr') {
      var raw = buffer.raw();
      if (raw.length % 2 === 1) return buffer.error('Decoding of string type: bmpstr length mismatch');
      var str = '';
      for (var i = 0; i < raw.length / 2; i++) {
        str += String.fromCharCode(raw.readUInt16BE(i * 2));
      }
      return str;
    } else if (tag === 'numstr') {
      var numstr = buffer.raw().toString('ascii');
      if (!this._isNumstr(numstr)) {
        return buffer.error('Decoding of string type: ' + 'numstr unsupported characters');
      }
      return numstr;
    } else if (tag === 'octstr') {
      return buffer.raw();
    } else if (tag === 'objDesc') {
      return buffer.raw();
    } else if (tag === 'printstr') {
      var printstr = buffer.raw().toString('ascii');
      if (!this._isPrintstr(printstr)) {
        return buffer.error('Decoding of string type: ' + 'printstr unsupported characters');
      }
      return printstr;
    } else if (/str$/.test(tag)) {
      return buffer.raw().toString();
    } else {
      return buffer.error('Decoding of string type: ' + tag + ' unsupported');
    }
  };
  DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
    var result;
    var identifiers = [];
    var ident = 0;
    while (!buffer.isEmpty()) {
      var subident = buffer.readUInt8();
      ident <<= 7;
      ident |= subident & 0x7f;
      if ((subident & 0x80) === 0) {
        identifiers.push(ident);
        ident = 0;
      }
    }
    if (subident & 0x80) identifiers.push(ident);
    var first = identifiers[0] / 40 | 0;
    var second = identifiers[0] % 40;
    if (relative) result = identifiers;else result = [first, second].concat(identifiers.slice(1));
    if (values) {
      var tmp = values[result.join(' ')];
      if (tmp === undefined) tmp = values[result.join('.')];
      if (tmp !== undefined) result = tmp;
    }
    return result;
  };
  DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
    var str = buffer.raw().toString();
    if (tag === 'gentime') {
      var year = str.slice(0, 4) | 0;
      var mon = str.slice(4, 6) | 0;
      var day = str.slice(6, 8) | 0;
      var hour = str.slice(8, 10) | 0;
      var min = str.slice(10, 12) | 0;
      var sec = str.slice(12, 14) | 0;
    } else if (tag === 'utctime') {
      var year = str.slice(0, 2) | 0;
      var mon = str.slice(2, 4) | 0;
      var day = str.slice(4, 6) | 0;
      var hour = str.slice(6, 8) | 0;
      var min = str.slice(8, 10) | 0;
      var sec = str.slice(10, 12) | 0;
      if (year < 70) year = 2000 + year;else year = 1900 + year;
    } else {
      return buffer.error('Decoding ' + tag + ' time is not supported yet');
    }
    return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
  };
  DERNode.prototype._decodeNull = function decodeNull(buffer) {
    return null;
  };
  DERNode.prototype._decodeBool = function decodeBool(buffer) {
    var res = buffer.readUInt8();
    if (buffer.isError(res)) return res;else return res !== 0;
  };
  DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
    var raw = buffer.raw();
    var res = new bignum(raw);
    if (values) res = values[res.toString(10)] || res;
    return res;
  };
  DERNode.prototype._use = function use(entity, obj) {
    if (typeof entity === 'function') entity = entity(obj);
    return entity._getDecoder('der').tree;
  };
  function derDecodeTag(buf, fail) {
    var tag = buf.readUInt8(fail);
    if (buf.isError(tag)) return tag;
    var cls = der.tagClass[tag >> 6];
    var primitive = (tag & 0x20) === 0;
    if ((tag & 0x1f) === 0x1f) {
      var oct = tag;
      tag = 0;
      while ((oct & 0x80) === 0x80) {
        oct = buf.readUInt8(fail);
        if (buf.isError(oct)) return oct;
        tag <<= 7;
        tag |= oct & 0x7f;
      }
    } else {
      tag &= 0x1f;
    }
    var tagStr = der.tag[tag];
    return {
      cls: cls,
      primitive: primitive,
      tag: tag,
      tagStr: tagStr
    };
  }
  function derDecodeLen(buf, primitive, fail) {
    var len = buf.readUInt8(fail);
    if (buf.isError(len)) return len;
    if (!primitive && len === 0x80) return null;
    if ((len & 0x80) === 0) {
      return len;
    }
    var num = len & 0x7f;
    if (num >= 4) return buf.error('length octect is too long');
    len = 0;
    for (var i = 0; i < num; i++) {
      len <<= 8;
      var j = buf.readUInt8(fail);
      if (buf.isError(j)) return j;
      len |= j;
    }
    return len;
  }
  return module.exports;
});
$__System.registerDynamic('22f', ['46', '2a', '22e'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    var inherits = $__require('46');
    var Buffer = $__require('2a').Buffer;
    var DERDecoder = $__require('22e');
    function PEMDecoder(entity) {
      DERDecoder.call(this, entity);
      this.enc = 'pem';
    }
    ;
    inherits(PEMDecoder, DERDecoder);
    module.exports = PEMDecoder;
    PEMDecoder.prototype.decode = function decode(data, options) {
      var lines = data.toString().split(/[\r\n]+/g);
      var label = options.label.toUpperCase();
      var re = /^-----(BEGIN|END) ([^-]+)-----$/;
      var start = -1;
      var end = -1;
      for (var i = 0; i < lines.length; i++) {
        var match = lines[i].match(re);
        if (match === null) continue;
        if (match[2] !== label) continue;
        if (start === -1) {
          if (match[1] !== 'BEGIN') break;
          start = i;
        } else {
          if (match[1] !== 'END') break;
          end = i;
          break;
        }
      }
      if (start === -1 || end === -1) throw new Error('PEM section not found for: ' + label);
      var base64 = lines.slice(start + 1, end).join('');
      base64.replace(/[^a-z0-9\+\/=]+/gi, '');
      var input = new Buffer(base64, 'base64');
      return DERDecoder.prototype.decode.call(this, input, options);
    };
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic('230', ['22e', '22f'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var decoders = exports;
  decoders.der = $__require('22e');
  decoders.pem = $__require('22f');
  return module.exports;
});
$__System.registerDynamic('231', ['46', '2a', '226'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    var inherits = $__require('46');
    var Buffer = $__require('2a').Buffer;
    var asn1 = $__require('226');
    var base = asn1.base;
    var der = asn1.constants.der;
    function DEREncoder(entity) {
      this.enc = 'der';
      this.name = entity.name;
      this.entity = entity;
      this.tree = new DERNode();
      this.tree._init(entity.body);
    }
    ;
    module.exports = DEREncoder;
    DEREncoder.prototype.encode = function encode(data, reporter) {
      return this.tree._encode(data, reporter).join();
    };
    function DERNode(parent) {
      base.Node.call(this, 'der', parent);
    }
    inherits(DERNode, base.Node);
    DERNode.prototype._encodeComposite = function encodeComposite(tag, primitive, cls, content) {
      var encodedTag = encodeTag(tag, primitive, cls, this.reporter);
      if (content.length < 0x80) {
        var header = new Buffer(2);
        header[0] = encodedTag;
        header[1] = content.length;
        return this._createEncoderBuffer([header, content]);
      }
      var lenOctets = 1;
      for (var i = content.length; i >= 0x100; i >>= 8) lenOctets++;
      var header = new Buffer(1 + 1 + lenOctets);
      header[0] = encodedTag;
      header[1] = 0x80 | lenOctets;
      for (var i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8) header[i] = j & 0xff;
      return this._createEncoderBuffer([header, content]);
    };
    DERNode.prototype._encodeStr = function encodeStr(str, tag) {
      if (tag === 'bitstr') {
        return this._createEncoderBuffer([str.unused | 0, str.data]);
      } else if (tag === 'bmpstr') {
        var buf = new Buffer(str.length * 2);
        for (var i = 0; i < str.length; i++) {
          buf.writeUInt16BE(str.charCodeAt(i), i * 2);
        }
        return this._createEncoderBuffer(buf);
      } else if (tag === 'numstr') {
        if (!this._isNumstr(str)) {
          return this.reporter.error('Encoding of string type: numstr supports ' + 'only digits and space');
        }
        return this._createEncoderBuffer(str);
      } else if (tag === 'printstr') {
        if (!this._isPrintstr(str)) {
          return this.reporter.error('Encoding of string type: printstr supports ' + 'only latin upper and lower case letters, ' + 'digits, space, apostrophe, left and rigth ' + 'parenthesis, plus sign, comma, hyphen, ' + 'dot, slash, colon, equal sign, ' + 'question mark');
        }
        return this._createEncoderBuffer(str);
      } else if (/str$/.test(tag)) {
        return this._createEncoderBuffer(str);
      } else if (tag === 'objDesc') {
        return this._createEncoderBuffer(str);
      } else {
        return this.reporter.error('Encoding of string type: ' + tag + ' unsupported');
      }
    };
    DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
      if (typeof id === 'string') {
        if (!values) return this.reporter.error('string objid given, but no values map found');
        if (!values.hasOwnProperty(id)) return this.reporter.error('objid not found in values map');
        id = values[id].split(/[\s\.]+/g);
        for (var i = 0; i < id.length; i++) id[i] |= 0;
      } else if (Array.isArray(id)) {
        id = id.slice();
        for (var i = 0; i < id.length; i++) id[i] |= 0;
      }
      if (!Array.isArray(id)) {
        return this.reporter.error('objid() should be either array or string, ' + 'got: ' + JSON.stringify(id));
      }
      if (!relative) {
        if (id[1] >= 40) return this.reporter.error('Second objid identifier OOB');
        id.splice(0, 2, id[0] * 40 + id[1]);
      }
      var size = 0;
      for (var i = 0; i < id.length; i++) {
        var ident = id[i];
        for (size++; ident >= 0x80; ident >>= 7) size++;
      }
      var objid = new Buffer(size);
      var offset = objid.length - 1;
      for (var i = id.length - 1; i >= 0; i--) {
        var ident = id[i];
        objid[offset--] = ident & 0x7f;
        while ((ident >>= 7) > 0) objid[offset--] = 0x80 | ident & 0x7f;
      }
      return this._createEncoderBuffer(objid);
    };
    function two(num) {
      if (num < 10) return '0' + num;else return num;
    }
    DERNode.prototype._encodeTime = function encodeTime(time, tag) {
      var str;
      var date = new Date(time);
      if (tag === 'gentime') {
        str = [two(date.getFullYear()), two(date.getUTCMonth() + 1), two(date.getUTCDate()), two(date.getUTCHours()), two(date.getUTCMinutes()), two(date.getUTCSeconds()), 'Z'].join('');
      } else if (tag === 'utctime') {
        str = [two(date.getFullYear() % 100), two(date.getUTCMonth() + 1), two(date.getUTCDate()), two(date.getUTCHours()), two(date.getUTCMinutes()), two(date.getUTCSeconds()), 'Z'].join('');
      } else {
        this.reporter.error('Encoding ' + tag + ' time is not supported yet');
      }
      return this._encodeStr(str, 'octstr');
    };
    DERNode.prototype._encodeNull = function encodeNull() {
      return this._createEncoderBuffer('');
    };
    DERNode.prototype._encodeInt = function encodeInt(num, values) {
      if (typeof num === 'string') {
        if (!values) return this.reporter.error('String int or enum given, but no values map');
        if (!values.hasOwnProperty(num)) {
          return this.reporter.error('Values map doesn\'t contain: ' + JSON.stringify(num));
        }
        num = values[num];
      }
      if (typeof num !== 'number' && !Buffer.isBuffer(num)) {
        var numArray = num.toArray();
        if (!num.sign && numArray[0] & 0x80) {
          numArray.unshift(0);
        }
        num = new Buffer(numArray);
      }
      if (Buffer.isBuffer(num)) {
        var size = num.length;
        if (num.length === 0) size++;
        var out = new Buffer(size);
        num.copy(out);
        if (num.length === 0) out[0] = 0;
        return this._createEncoderBuffer(out);
      }
      if (num < 0x80) return this._createEncoderBuffer(num);
      if (num < 0x100) return this._createEncoderBuffer([0, num]);
      var size = 1;
      for (var i = num; i >= 0x100; i >>= 8) size++;
      var out = new Array(size);
      for (var i = out.length - 1; i >= 0; i--) {
        out[i] = num & 0xff;
        num >>= 8;
      }
      if (out[0] & 0x80) {
        out.unshift(0);
      }
      return this._createEncoderBuffer(new Buffer(out));
    };
    DERNode.prototype._encodeBool = function encodeBool(value) {
      return this._createEncoderBuffer(value ? 0xff : 0);
    };
    DERNode.prototype._use = function use(entity, obj) {
      if (typeof entity === 'function') entity = entity(obj);
      return entity._getEncoder('der').tree;
    };
    DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
      var state = this._baseState;
      var i;
      if (state['default'] === null) return false;
      var data = dataBuffer.join();
      if (state.defaultBuffer === undefined) state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join();
      if (data.length !== state.defaultBuffer.length) return false;
      for (i = 0; i < data.length; i++) if (data[i] !== state.defaultBuffer[i]) return false;
      return true;
    };
    function encodeTag(tag, primitive, cls, reporter) {
      var res;
      if (tag === 'seqof') tag = 'seq';else if (tag === 'setof') tag = 'set';
      if (der.tagByName.hasOwnProperty(tag)) res = der.tagByName[tag];else if (typeof tag === 'number' && (tag | 0) === tag) res = tag;else return reporter.error('Unknown tag: ' + tag);
      if (res >= 0x1f) return reporter.error('Multi-octet tag encoding unsupported');
      if (!primitive) res |= 0x20;
      res |= der.tagClassByName[cls || 'universal'] << 6;
      return res;
    }
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic('232', ['46', '231'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var inherits = $__require('46');
  var DEREncoder = $__require('231');
  function PEMEncoder(entity) {
    DEREncoder.call(this, entity);
    this.enc = 'pem';
  }
  ;
  inherits(PEMEncoder, DEREncoder);
  module.exports = PEMEncoder;
  PEMEncoder.prototype.encode = function encode(data, options) {
    var buf = DEREncoder.prototype.encode.call(this, data);
    var p = buf.toString('base64');
    var out = ['-----BEGIN ' + options.label + '-----'];
    for (var i = 0; i < p.length; i += 64) out.push(p.slice(i, i + 64));
    out.push('-----END ' + options.label + '-----');
    return out.join('\n');
  };
  return module.exports;
});
$__System.registerDynamic('233', ['231', '232'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var encoders = exports;
  encoders.der = $__require('231');
  encoders.pem = $__require('232');
  return module.exports;
});
$__System.registerDynamic('226', ['1ee', '225', '229', '22d', '230', '233'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var asn1 = exports;
  asn1.bignum = $__require('1ee');
  asn1.define = $__require('225').define;
  asn1.base = $__require('229');
  asn1.constants = $__require('22d');
  asn1.decoders = $__require('230');
  asn1.encoders = $__require('233');
  return module.exports;
});
$__System.registerDynamic("234", ["226"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("226");
  return module.exports;
});
$__System.registerDynamic('235', ['234'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  // from https://github.com/indutny/self-signed/blob/gh-pages/lib/asn1.js
  // Fedor, you are amazing.

  var asn1 = $__require('234');

  var RSAPrivateKey = asn1.define('RSAPrivateKey', function () {
    this.seq().obj(this.key('version').int(), this.key('modulus').int(), this.key('publicExponent').int(), this.key('privateExponent').int(), this.key('prime1').int(), this.key('prime2').int(), this.key('exponent1').int(), this.key('exponent2').int(), this.key('coefficient').int());
  });
  exports.RSAPrivateKey = RSAPrivateKey;

  var RSAPublicKey = asn1.define('RSAPublicKey', function () {
    this.seq().obj(this.key('modulus').int(), this.key('publicExponent').int());
  });
  exports.RSAPublicKey = RSAPublicKey;

  var PublicKey = asn1.define('SubjectPublicKeyInfo', function () {
    this.seq().obj(this.key('algorithm').use(AlgorithmIdentifier), this.key('subjectPublicKey').bitstr());
  });
  exports.PublicKey = PublicKey;

  var AlgorithmIdentifier = asn1.define('AlgorithmIdentifier', function () {
    this.seq().obj(this.key('algorithm').objid(), this.key('none').null_().optional(), this.key('curve').objid().optional(), this.key('params').seq().obj(this.key('p').int(), this.key('q').int(), this.key('g').int()).optional());
  });

  var PrivateKeyInfo = asn1.define('PrivateKeyInfo', function () {
    this.seq().obj(this.key('version').int(), this.key('algorithm').use(AlgorithmIdentifier), this.key('subjectPrivateKey').octstr());
  });
  exports.PrivateKey = PrivateKeyInfo;
  var EncryptedPrivateKeyInfo = asn1.define('EncryptedPrivateKeyInfo', function () {
    this.seq().obj(this.key('algorithm').seq().obj(this.key('id').objid(), this.key('decrypt').seq().obj(this.key('kde').seq().obj(this.key('id').objid(), this.key('kdeparams').seq().obj(this.key('salt').octstr(), this.key('iters').int())), this.key('cipher').seq().obj(this.key('algo').objid(), this.key('iv').octstr()))), this.key('subjectPrivateKey').octstr());
  });

  exports.EncryptedPrivateKey = EncryptedPrivateKeyInfo;

  var DSAPrivateKey = asn1.define('DSAPrivateKey', function () {
    this.seq().obj(this.key('version').int(), this.key('p').int(), this.key('q').int(), this.key('g').int(), this.key('pub_key').int(), this.key('priv_key').int());
  });
  exports.DSAPrivateKey = DSAPrivateKey;

  exports.DSAparam = asn1.define('DSAparam', function () {
    this.int();
  });
  var ECPrivateKey = asn1.define('ECPrivateKey', function () {
    this.seq().obj(this.key('version').int(), this.key('privateKey').octstr(), this.key('parameters').optional().explicit(0).use(ECParameters), this.key('publicKey').optional().explicit(1).bitstr());
  });
  exports.ECPrivateKey = ECPrivateKey;
  var ECParameters = asn1.define('ECParameters', function () {
    this.choice({
      namedCurve: this.objid()
    });
  });

  exports.signature = asn1.define('signature', function () {
    this.seq().obj(this.key('r').int(), this.key('s').int());
  });
  return module.exports;
});
$__System.registerDynamic("236", [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = { "2.16.840.1.101.3.4.1.1": "aes-128-ecb", "2.16.840.1.101.3.4.1.2": "aes-128-cbc", "2.16.840.1.101.3.4.1.3": "aes-128-ofb", "2.16.840.1.101.3.4.1.4": "aes-128-cfb", "2.16.840.1.101.3.4.1.21": "aes-192-ecb", "2.16.840.1.101.3.4.1.22": "aes-192-cbc", "2.16.840.1.101.3.4.1.23": "aes-192-ofb", "2.16.840.1.101.3.4.1.24": "aes-192-cfb", "2.16.840.1.101.3.4.1.41": "aes-256-ecb", "2.16.840.1.101.3.4.1.42": "aes-256-cbc", "2.16.840.1.101.3.4.1.43": "aes-256-ofb", "2.16.840.1.101.3.4.1.44": "aes-256-cfb" };
  return module.exports;
});
$__System.registerDynamic('237', ['1e7', '238', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    var findProc = /Proc-Type: 4,ENCRYPTED\r?\nDEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)\r?\n\r?\n([0-9A-z\n\r\+\/\=]+)\r?\n/m;
    var startRegex = /^-----BEGIN (.*) KEY-----\r?\n/m;
    var fullRegex = /^-----BEGIN (.*) KEY-----\r?\n([0-9A-z\n\r\+\/\=]+)\r?\n-----END \1 KEY-----$/m;
    var evp = $__require('1e7');
    var ciphers = $__require('238');
    module.exports = function (okey, password) {
      var key = okey.toString();
      var match = key.match(findProc);
      var decrypted;
      if (!match) {
        var match2 = key.match(fullRegex);
        decrypted = new Buffer(match2[2].replace(/\r?\n/g, ''), 'base64');
      } else {
        var suite = 'aes' + match[1];
        var iv = new Buffer(match[2], 'hex');
        var cipherText = new Buffer(match[3].replace(/\r?\n/g, ''), 'base64');
        var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key;
        var out = [];
        var cipher = ciphers.createDecipheriv(suite, cipherKey, iv);
        out.push(cipher.update(cipherText));
        out.push(cipher.final());
        decrypted = Buffer.concat(out);
      }
      var tag = key.match(startRegex)[1] + ' KEY';
      return {
        tag: tag,
        data: decrypted
      };
    };
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic('239', ['23a', '1e3', '46', '1e9', '1e7', '23b', '23c', '23d', '23e', '23f', '240', '241', '242', '243', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    var aes = $__require('23a');
    var Transform = $__require('1e3');
    var inherits = $__require('46');
    var modes = $__require('1e9');
    var ebtk = $__require('1e7');
    var StreamCipher = $__require('23b');
    var AuthCipher = $__require('23c');
    inherits(Cipher, Transform);
    function Cipher(mode, key, iv) {
      if (!(this instanceof Cipher)) {
        return new Cipher(mode, key, iv);
      }
      Transform.call(this);
      this._cache = new Splitter();
      this._cipher = new aes.AES(key);
      this._prev = new Buffer(iv.length);
      iv.copy(this._prev);
      this._mode = mode;
      this._autopadding = true;
    }
    Cipher.prototype._update = function (data) {
      this._cache.add(data);
      var chunk;
      var thing;
      var out = [];
      while (chunk = this._cache.get()) {
        thing = this._mode.encrypt(this, chunk);
        out.push(thing);
      }
      return Buffer.concat(out);
    };
    Cipher.prototype._final = function () {
      var chunk = this._cache.flush();
      if (this._autopadding) {
        chunk = this._mode.encrypt(this, chunk);
        this._cipher.scrub();
        return chunk;
      } else if (chunk.toString('hex') !== '10101010101010101010101010101010') {
        this._cipher.scrub();
        throw new Error('data not multiple of block length');
      }
    };
    Cipher.prototype.setAutoPadding = function (setTo) {
      this._autopadding = !!setTo;
      return this;
    };
    function Splitter() {
      if (!(this instanceof Splitter)) {
        return new Splitter();
      }
      this.cache = new Buffer('');
    }
    Splitter.prototype.add = function (data) {
      this.cache = Buffer.concat([this.cache, data]);
    };
    Splitter.prototype.get = function () {
      if (this.cache.length > 15) {
        var out = this.cache.slice(0, 16);
        this.cache = this.cache.slice(16);
        return out;
      }
      return null;
    };
    Splitter.prototype.flush = function () {
      var len = 16 - this.cache.length;
      var padBuff = new Buffer(len);
      var i = -1;
      while (++i < len) {
        padBuff.writeUInt8(len, i);
      }
      var out = Buffer.concat([this.cache, padBuff]);
      return out;
    };
    var modelist = {
      ECB: $__require('23d'),
      CBC: $__require('23e'),
      CFB: $__require('23f'),
      CFB8: $__require('240'),
      CFB1: $__require('241'),
      OFB: $__require('242'),
      CTR: $__require('243'),
      GCM: $__require('243')
    };
    function createCipheriv(suite, password, iv) {
      var config = modes[suite.toLowerCase()];
      if (!config) {
        throw new TypeError('invalid suite type');
      }
      if (typeof iv === 'string') {
        iv = new Buffer(iv);
      }
      if (typeof password === 'string') {
        password = new Buffer(password);
      }
      if (password.length !== config.key / 8) {
        throw new TypeError('invalid key length ' + password.length);
      }
      if (iv.length !== config.iv) {
        throw new TypeError('invalid iv length ' + iv.length);
      }
      if (config.type === 'stream') {
        return new StreamCipher(modelist[config.mode], password, iv);
      } else if (config.type === 'auth') {
        return new AuthCipher(modelist[config.mode], password, iv);
      }
      return new Cipher(modelist[config.mode], password, iv);
    }
    function createCipher(suite, password) {
      var config = modes[suite.toLowerCase()];
      if (!config) {
        throw new TypeError('invalid suite type');
      }
      var keys = ebtk(password, false, config.key, config.iv);
      return createCipheriv(suite, keys.key, keys.iv);
    }
    exports.createCipheriv = createCipheriv;
    exports.createCipher = createCipher;
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic('23b', ['23a', '1e3', '46', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    var aes = $__require('23a');
    var Transform = $__require('1e3');
    var inherits = $__require('46');
    inherits(StreamCipher, Transform);
    module.exports = StreamCipher;
    function StreamCipher(mode, key, iv, decrypt) {
      if (!(this instanceof StreamCipher)) {
        return new StreamCipher(mode, key, iv);
      }
      Transform.call(this);
      this._cipher = new aes.AES(key);
      this._prev = new Buffer(iv.length);
      this._cache = new Buffer('');
      this._secCache = new Buffer('');
      this._decrypt = decrypt;
      iv.copy(this._prev);
      this._mode = mode;
    }
    StreamCipher.prototype._update = function (chunk) {
      return this._mode.encrypt(this, chunk, this._decrypt);
    };
    StreamCipher.prototype._final = function () {
      this._cipher.scrub();
    };
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic('23a', ['2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    var uint_max = Math.pow(2, 32);
    function fixup_uint32(x) {
      var ret, x_pos;
      ret = x > uint_max || x < 0 ? (x_pos = Math.abs(x) % uint_max, x < 0 ? uint_max - x_pos : x_pos) : x;
      return ret;
    }
    function scrub_vec(v) {
      for (var i = 0; i < v.length; v++) {
        v[i] = 0;
      }
      return false;
    }
    function Global() {
      this.SBOX = [];
      this.INV_SBOX = [];
      this.SUB_MIX = [[], [], [], []];
      this.INV_SUB_MIX = [[], [], [], []];
      this.init();
      this.RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];
    }
    Global.prototype.init = function () {
      var d, i, sx, t, x, x2, x4, x8, xi, _i;
      d = function () {
        var _i, _results;
        _results = [];
        for (i = _i = 0; _i < 256; i = ++_i) {
          if (i < 128) {
            _results.push(i << 1);
          } else {
            _results.push(i << 1 ^ 0x11b);
          }
        }
        return _results;
      }();
      x = 0;
      xi = 0;
      for (i = _i = 0; _i < 256; i = ++_i) {
        sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
        sx = sx >>> 8 ^ sx & 0xff ^ 0x63;
        this.SBOX[x] = sx;
        this.INV_SBOX[sx] = x;
        x2 = d[x];
        x4 = d[x2];
        x8 = d[x4];
        t = d[sx] * 0x101 ^ sx * 0x1010100;
        this.SUB_MIX[0][x] = t << 24 | t >>> 8;
        this.SUB_MIX[1][x] = t << 16 | t >>> 16;
        this.SUB_MIX[2][x] = t << 8 | t >>> 24;
        this.SUB_MIX[3][x] = t;
        t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;
        this.INV_SUB_MIX[0][sx] = t << 24 | t >>> 8;
        this.INV_SUB_MIX[1][sx] = t << 16 | t >>> 16;
        this.INV_SUB_MIX[2][sx] = t << 8 | t >>> 24;
        this.INV_SUB_MIX[3][sx] = t;
        if (x === 0) {
          x = xi = 1;
        } else {
          x = x2 ^ d[d[d[x8 ^ x2]]];
          xi ^= d[d[xi]];
        }
      }
      return true;
    };
    var G = new Global();
    AES.blockSize = 4 * 4;
    AES.prototype.blockSize = AES.blockSize;
    AES.keySize = 256 / 8;
    AES.prototype.keySize = AES.keySize;
    function bufferToArray(buf) {
      var len = buf.length / 4;
      var out = new Array(len);
      var i = -1;
      while (++i < len) {
        out[i] = buf.readUInt32BE(i * 4);
      }
      return out;
    }
    function AES(key) {
      this._key = bufferToArray(key);
      this._doReset();
    }
    AES.prototype._doReset = function () {
      var invKsRow, keySize, keyWords, ksRow, ksRows, t;
      keyWords = this._key;
      keySize = keyWords.length;
      this._nRounds = keySize + 6;
      ksRows = (this._nRounds + 1) * 4;
      this._keySchedule = [];
      for (ksRow = 0; ksRow < ksRows; ksRow++) {
        this._keySchedule[ksRow] = ksRow < keySize ? keyWords[ksRow] : (t = this._keySchedule[ksRow - 1], ksRow % keySize === 0 ? (t = t << 8 | t >>> 24, t = G.SBOX[t >>> 24] << 24 | G.SBOX[t >>> 16 & 0xff] << 16 | G.SBOX[t >>> 8 & 0xff] << 8 | G.SBOX[t & 0xff], t ^= G.RCON[ksRow / keySize | 0] << 24) : keySize > 6 && ksRow % keySize === 4 ? t = G.SBOX[t >>> 24] << 24 | G.SBOX[t >>> 16 & 0xff] << 16 | G.SBOX[t >>> 8 & 0xff] << 8 | G.SBOX[t & 0xff] : void 0, this._keySchedule[ksRow - keySize] ^ t);
      }
      this._invKeySchedule = [];
      for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {
        ksRow = ksRows - invKsRow;
        t = this._keySchedule[ksRow - (invKsRow % 4 ? 0 : 4)];
        this._invKeySchedule[invKsRow] = invKsRow < 4 || ksRow <= 4 ? t : G.INV_SUB_MIX[0][G.SBOX[t >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[t >>> 16 & 0xff]] ^ G.INV_SUB_MIX[2][G.SBOX[t >>> 8 & 0xff]] ^ G.INV_SUB_MIX[3][G.SBOX[t & 0xff]];
      }
      return true;
    };
    AES.prototype.encryptBlock = function (M) {
      M = bufferToArray(new Buffer(M));
      var out = this._doCryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX);
      var buf = new Buffer(16);
      buf.writeUInt32BE(out[0], 0);
      buf.writeUInt32BE(out[1], 4);
      buf.writeUInt32BE(out[2], 8);
      buf.writeUInt32BE(out[3], 12);
      return buf;
    };
    AES.prototype.decryptBlock = function (M) {
      M = bufferToArray(new Buffer(M));
      var temp = [M[3], M[1]];
      M[1] = temp[0];
      M[3] = temp[1];
      var out = this._doCryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX);
      var buf = new Buffer(16);
      buf.writeUInt32BE(out[0], 0);
      buf.writeUInt32BE(out[3], 4);
      buf.writeUInt32BE(out[2], 8);
      buf.writeUInt32BE(out[1], 12);
      return buf;
    };
    AES.prototype.scrub = function () {
      scrub_vec(this._keySchedule);
      scrub_vec(this._invKeySchedule);
      scrub_vec(this._key);
    };
    AES.prototype._doCryptBlock = function (M, keySchedule, SUB_MIX, SBOX) {
      var ksRow, s0, s1, s2, s3, t0, t1, t2, t3;
      s0 = M[0] ^ keySchedule[0];
      s1 = M[1] ^ keySchedule[1];
      s2 = M[2] ^ keySchedule[2];
      s3 = M[3] ^ keySchedule[3];
      ksRow = 4;
      for (var round = 1; round < this._nRounds; round++) {
        t0 = SUB_MIX[0][s0 >>> 24] ^ SUB_MIX[1][s1 >>> 16 & 0xff] ^ SUB_MIX[2][s2 >>> 8 & 0xff] ^ SUB_MIX[3][s3 & 0xff] ^ keySchedule[ksRow++];
        t1 = SUB_MIX[0][s1 >>> 24] ^ SUB_MIX[1][s2 >>> 16 & 0xff] ^ SUB_MIX[2][s3 >>> 8 & 0xff] ^ SUB_MIX[3][s0 & 0xff] ^ keySchedule[ksRow++];
        t2 = SUB_MIX[0][s2 >>> 24] ^ SUB_MIX[1][s3 >>> 16 & 0xff] ^ SUB_MIX[2][s0 >>> 8 & 0xff] ^ SUB_MIX[3][s1 & 0xff] ^ keySchedule[ksRow++];
        t3 = SUB_MIX[0][s3 >>> 24] ^ SUB_MIX[1][s0 >>> 16 & 0xff] ^ SUB_MIX[2][s1 >>> 8 & 0xff] ^ SUB_MIX[3][s2 & 0xff] ^ keySchedule[ksRow++];
        s0 = t0;
        s1 = t1;
        s2 = t2;
        s3 = t3;
      }
      t0 = (SBOX[s0 >>> 24] << 24 | SBOX[s1 >>> 16 & 0xff] << 16 | SBOX[s2 >>> 8 & 0xff] << 8 | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
      t1 = (SBOX[s1 >>> 24] << 24 | SBOX[s2 >>> 16 & 0xff] << 16 | SBOX[s3 >>> 8 & 0xff] << 8 | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
      t2 = (SBOX[s2 >>> 24] << 24 | SBOX[s3 >>> 16 & 0xff] << 16 | SBOX[s0 >>> 8 & 0xff] << 8 | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
      t3 = (SBOX[s3 >>> 24] << 24 | SBOX[s0 >>> 16 & 0xff] << 16 | SBOX[s1 >>> 8 & 0xff] << 8 | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];
      return [fixup_uint32(t0), fixup_uint32(t1), fixup_uint32(t2), fixup_uint32(t3)];
    };
    exports.AES = AES;
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic('244', ['2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    var zeros = new Buffer(16);
    zeros.fill(0);
    module.exports = GHASH;
    function GHASH(key) {
      this.h = key;
      this.state = new Buffer(16);
      this.state.fill(0);
      this.cache = new Buffer('');
    }
    GHASH.prototype.ghash = function (block) {
      var i = -1;
      while (++i < block.length) {
        this.state[i] ^= block[i];
      }
      this._multiply();
    };
    GHASH.prototype._multiply = function () {
      var Vi = toArray(this.h);
      var Zi = [0, 0, 0, 0];
      var j, xi, lsb_Vi;
      var i = -1;
      while (++i < 128) {
        xi = (this.state[~~(i / 8)] & 1 << 7 - i % 8) !== 0;
        if (xi) {
          Zi = xor(Zi, Vi);
        }
        lsb_Vi = (Vi[3] & 1) !== 0;
        for (j = 3; j > 0; j--) {
          Vi[j] = Vi[j] >>> 1 | (Vi[j - 1] & 1) << 31;
        }
        Vi[0] = Vi[0] >>> 1;
        if (lsb_Vi) {
          Vi[0] = Vi[0] ^ 0xe1 << 24;
        }
      }
      this.state = fromArray(Zi);
    };
    GHASH.prototype.update = function (buf) {
      this.cache = Buffer.concat([this.cache, buf]);
      var chunk;
      while (this.cache.length >= 16) {
        chunk = this.cache.slice(0, 16);
        this.cache = this.cache.slice(16);
        this.ghash(chunk);
      }
    };
    GHASH.prototype.final = function (abl, bl) {
      if (this.cache.length) {
        this.ghash(Buffer.concat([this.cache, zeros], 16));
      }
      this.ghash(fromArray([0, abl, 0, bl]));
      return this.state;
    };
    function toArray(buf) {
      return [buf.readUInt32BE(0), buf.readUInt32BE(4), buf.readUInt32BE(8), buf.readUInt32BE(12)];
    }
    function fromArray(out) {
      out = out.map(fixup_uint32);
      var buf = new Buffer(16);
      buf.writeUInt32BE(out[0], 0);
      buf.writeUInt32BE(out[1], 4);
      buf.writeUInt32BE(out[2], 8);
      buf.writeUInt32BE(out[3], 12);
      return buf;
    }
    var uint_max = Math.pow(2, 32);
    function fixup_uint32(x) {
      var ret, x_pos;
      ret = x > uint_max || x < 0 ? (x_pos = Math.abs(x) % uint_max, x < 0 ? uint_max - x_pos : x_pos) : x;
      return ret;
    }
    function xor(a, b) {
      return [a[0] ^ b[0], a[1] ^ b[1], a[2] ^ b[2], a[3] ^ b[3]];
    }
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic('23c', ['23a', '1e3', '46', '244', '245', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    var aes = $__require('23a');
    var Transform = $__require('1e3');
    var inherits = $__require('46');
    var GHASH = $__require('244');
    var xor = $__require('245');
    inherits(StreamCipher, Transform);
    module.exports = StreamCipher;
    function StreamCipher(mode, key, iv, decrypt) {
      if (!(this instanceof StreamCipher)) {
        return new StreamCipher(mode, key, iv);
      }
      Transform.call(this);
      this._finID = Buffer.concat([iv, new Buffer([0, 0, 0, 1])]);
      iv = Buffer.concat([iv, new Buffer([0, 0, 0, 2])]);
      this._cipher = new aes.AES(key);
      this._prev = new Buffer(iv.length);
      this._cache = new Buffer('');
      this._secCache = new Buffer('');
      this._decrypt = decrypt;
      this._alen = 0;
      this._len = 0;
      iv.copy(this._prev);
      this._mode = mode;
      var h = new Buffer(4);
      h.fill(0);
      this._ghash = new GHASH(this._cipher.encryptBlock(h));
      this._authTag = null;
      this._called = false;
    }
    StreamCipher.prototype._update = function (chunk) {
      if (!this._called && this._alen) {
        var rump = 16 - this._alen % 16;
        if (rump < 16) {
          rump = new Buffer(rump);
          rump.fill(0);
          this._ghash.update(rump);
        }
      }
      this._called = true;
      var out = this._mode.encrypt(this, chunk);
      if (this._decrypt) {
        this._ghash.update(chunk);
      } else {
        this._ghash.update(out);
      }
      this._len += chunk.length;
      return out;
    };
    StreamCipher.prototype._final = function () {
      if (this._decrypt && !this._authTag) {
        throw new Error('Unsupported state or unable to authenticate data');
      }
      var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
      if (this._decrypt) {
        if (xorTest(tag, this._authTag)) {
          throw new Error('Unsupported state or unable to authenticate data');
        }
      } else {
        this._authTag = tag;
      }
      this._cipher.scrub();
    };
    StreamCipher.prototype.getAuthTag = function getAuthTag() {
      if (!this._decrypt && Buffer.isBuffer(this._authTag)) {
        return this._authTag;
      } else {
        throw new Error('Attempting to get auth tag in unsupported state');
      }
    };
    StreamCipher.prototype.setAuthTag = function setAuthTag(tag) {
      if (this._decrypt) {
        this._authTag = tag;
      } else {
        throw new Error('Attempting to set auth tag in unsupported state');
      }
    };
    StreamCipher.prototype.setAAD = function setAAD(buf) {
      if (!this._called) {
        this._ghash.update(buf);
        this._alen += buf.length;
      } else {
        throw new Error('Attempting to set AAD in unsupported state');
      }
    };
    function xorTest(a, b) {
      var out = 0;
      if (a.length !== b.length) {
        out++;
      }
      var len = Math.min(a.length, b.length);
      var i = -1;
      while (++i < len) {
        out += a[i] ^ b[i];
      }
      return out;
    }
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic('246', ['247', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    var md5 = $__require('247');
    module.exports = EVP_BytesToKey;
    function EVP_BytesToKey(password, salt, keyLen, ivLen) {
      if (!Buffer.isBuffer(password)) {
        password = new Buffer(password, 'binary');
      }
      if (salt && !Buffer.isBuffer(salt)) {
        salt = new Buffer(salt, 'binary');
      }
      keyLen = keyLen / 8;
      ivLen = ivLen || 0;
      var ki = 0;
      var ii = 0;
      var key = new Buffer(keyLen);
      var iv = new Buffer(ivLen);
      var addmd = 0;
      var md_buf;
      var i;
      var bufs = [];
      while (true) {
        if (addmd++ > 0) {
          bufs.push(md_buf);
        }
        bufs.push(password);
        if (salt) {
          bufs.push(salt);
        }
        md_buf = md5(Buffer.concat(bufs));
        bufs = [];
        i = 0;
        if (keyLen > 0) {
          while (true) {
            if (keyLen === 0) {
              break;
            }
            if (i === md_buf.length) {
              break;
            }
            key[ki++] = md_buf[i];
            keyLen--;
            i++;
          }
        }
        if (ivLen > 0 && i !== md_buf.length) {
          while (true) {
            if (ivLen === 0) {
              break;
            }
            if (i === md_buf.length) {
              break;
            }
            iv[ii++] = md_buf[i];
            ivLen--;
            i++;
          }
        }
        if (keyLen === 0 && ivLen === 0) {
          break;
        }
      }
      for (i = 0; i < md_buf.length; i++) {
        md_buf[i] = 0;
      }
      return {
        key: key,
        iv: iv
      };
    }
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic("1e7", ["246"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("246");
  return module.exports;
});
$__System.registerDynamic("23d", [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  exports.encrypt = function (self, block) {
    return self._cipher.encryptBlock(block);
  };
  exports.decrypt = function (self, block) {
    return self._cipher.decryptBlock(block);
  };
  return module.exports;
});
$__System.registerDynamic('23e', ['245'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var xor = $__require('245');

  exports.encrypt = function (self, block) {
    var data = xor(block, self._prev);

    self._prev = self._cipher.encryptBlock(data);
    return self._prev;
  };

  exports.decrypt = function (self, block) {
    var pad = self._prev;

    self._prev = block;
    var out = self._cipher.decryptBlock(block);

    return xor(out, pad);
  };
  return module.exports;
});
$__System.registerDynamic('23f', ['245', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    var xor = $__require('245');
    exports.encrypt = function (self, data, decrypt) {
      var out = new Buffer('');
      var len;
      while (data.length) {
        if (self._cache.length === 0) {
          self._cache = self._cipher.encryptBlock(self._prev);
          self._prev = new Buffer('');
        }
        if (self._cache.length <= data.length) {
          len = self._cache.length;
          out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)]);
          data = data.slice(len);
        } else {
          out = Buffer.concat([out, encryptStart(self, data, decrypt)]);
          break;
        }
      }
      return out;
    };
    function encryptStart(self, data, decrypt) {
      var len = data.length;
      var out = xor(data, self._cache);
      self._cache = self._cache.slice(len);
      self._prev = Buffer.concat([self._prev, decrypt ? data : out]);
      return out;
    }
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic('240', ['2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    function encryptByte(self, byteParam, decrypt) {
      var pad = self._cipher.encryptBlock(self._prev);
      var out = pad[0] ^ byteParam;
      self._prev = Buffer.concat([self._prev.slice(1), new Buffer([decrypt ? byteParam : out])]);
      return out;
    }
    exports.encrypt = function (self, chunk, decrypt) {
      var len = chunk.length;
      var out = new Buffer(len);
      var i = -1;
      while (++i < len) {
        out[i] = encryptByte(self, chunk[i], decrypt);
      }
      return out;
    };
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic('241', ['2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    function encryptByte(self, byteParam, decrypt) {
      var pad;
      var i = -1;
      var len = 8;
      var out = 0;
      var bit, value;
      while (++i < len) {
        pad = self._cipher.encryptBlock(self._prev);
        bit = byteParam & 1 << 7 - i ? 0x80 : 0;
        value = pad[0] ^ bit;
        out += (value & 0x80) >> i % 8;
        self._prev = shiftIn(self._prev, decrypt ? bit : value);
      }
      return out;
    }
    exports.encrypt = function (self, chunk, decrypt) {
      var len = chunk.length;
      var out = new Buffer(len);
      var i = -1;
      while (++i < len) {
        out[i] = encryptByte(self, chunk[i], decrypt);
      }
      return out;
    };
    function shiftIn(buffer, value) {
      var len = buffer.length;
      var i = -1;
      var out = new Buffer(buffer.length);
      buffer = Buffer.concat([buffer, new Buffer([value])]);
      while (++i < len) {
        out[i] = buffer[i] << 1 | buffer[i + 1] >> 7;
      }
      return out;
    }
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic('242', ['245', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    var xor = $__require('245');
    function getBlock(self) {
      self._prev = self._cipher.encryptBlock(self._prev);
      return self._prev;
    }
    exports.encrypt = function (self, chunk) {
      while (self._cache.length < chunk.length) {
        self._cache = Buffer.concat([self._cache, getBlock(self)]);
      }
      var pad = self._cache.slice(0, chunk.length);
      self._cache = self._cache.slice(chunk.length);
      return xor(chunk, pad);
    };
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic('248', ['2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    module.exports = function xor(a, b) {
      var length = Math.min(a.length, b.length);
      var buffer = new Buffer(length);
      for (var i = 0; i < length; ++i) {
        buffer[i] = a[i] ^ b[i];
      }
      return buffer;
    };
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic("245", ["248"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("248");
  return module.exports;
});
$__System.registerDynamic('243', ['245', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    var xor = $__require('245');
    function incr32(iv) {
      var len = iv.length;
      var item;
      while (len--) {
        item = iv.readUInt8(len);
        if (item === 255) {
          iv.writeUInt8(0, len);
        } else {
          item++;
          iv.writeUInt8(item, len);
          break;
        }
      }
    }
    function getBlock(self) {
      var out = self._cipher.encryptBlock(self._prev);
      incr32(self._prev);
      return out;
    }
    exports.encrypt = function (self, chunk) {
      while (self._cache.length < chunk.length) {
        self._cache = Buffer.concat([self._cache, getBlock(self)]);
      }
      var pad = self._cache.slice(0, chunk.length);
      self._cache = self._cache.slice(chunk.length);
      return xor(chunk, pad);
    };
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic('249', ['23a', '1e3', '46', '1e9', '23b', '23c', '1e7', '23d', '23e', '23f', '240', '241', '242', '243', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    var aes = $__require('23a');
    var Transform = $__require('1e3');
    var inherits = $__require('46');
    var modes = $__require('1e9');
    var StreamCipher = $__require('23b');
    var AuthCipher = $__require('23c');
    var ebtk = $__require('1e7');
    inherits(Decipher, Transform);
    function Decipher(mode, key, iv) {
      if (!(this instanceof Decipher)) {
        return new Decipher(mode, key, iv);
      }
      Transform.call(this);
      this._cache = new Splitter();
      this._last = void 0;
      this._cipher = new aes.AES(key);
      this._prev = new Buffer(iv.length);
      iv.copy(this._prev);
      this._mode = mode;
      this._autopadding = true;
    }
    Decipher.prototype._update = function (data) {
      this._cache.add(data);
      var chunk;
      var thing;
      var out = [];
      while (chunk = this._cache.get(this._autopadding)) {
        thing = this._mode.decrypt(this, chunk);
        out.push(thing);
      }
      return Buffer.concat(out);
    };
    Decipher.prototype._final = function () {
      var chunk = this._cache.flush();
      if (this._autopadding) {
        return unpad(this._mode.decrypt(this, chunk));
      } else if (chunk) {
        throw new Error('data not multiple of block length');
      }
    };
    Decipher.prototype.setAutoPadding = function (setTo) {
      this._autopadding = !!setTo;
      return this;
    };
    function Splitter() {
      if (!(this instanceof Splitter)) {
        return new Splitter();
      }
      this.cache = new Buffer('');
    }
    Splitter.prototype.add = function (data) {
      this.cache = Buffer.concat([this.cache, data]);
    };
    Splitter.prototype.get = function (autoPadding) {
      var out;
      if (autoPadding) {
        if (this.cache.length > 16) {
          out = this.cache.slice(0, 16);
          this.cache = this.cache.slice(16);
          return out;
        }
      } else {
        if (this.cache.length >= 16) {
          out = this.cache.slice(0, 16);
          this.cache = this.cache.slice(16);
          return out;
        }
      }
      return null;
    };
    Splitter.prototype.flush = function () {
      if (this.cache.length) {
        return this.cache;
      }
    };
    function unpad(last) {
      var padded = last[15];
      var i = -1;
      while (++i < padded) {
        if (last[i + (16 - padded)] !== padded) {
          throw new Error('unable to decrypt data');
        }
      }
      if (padded === 16) {
        return;
      }
      return last.slice(0, 16 - padded);
    }
    var modelist = {
      ECB: $__require('23d'),
      CBC: $__require('23e'),
      CFB: $__require('23f'),
      CFB8: $__require('240'),
      CFB1: $__require('241'),
      OFB: $__require('242'),
      CTR: $__require('243'),
      GCM: $__require('243')
    };
    function createDecipheriv(suite, password, iv) {
      var config = modes[suite.toLowerCase()];
      if (!config) {
        throw new TypeError('invalid suite type');
      }
      if (typeof iv === 'string') {
        iv = new Buffer(iv);
      }
      if (typeof password === 'string') {
        password = new Buffer(password);
      }
      if (password.length !== config.key / 8) {
        throw new TypeError('invalid key length ' + password.length);
      }
      if (iv.length !== config.iv) {
        throw new TypeError('invalid iv length ' + iv.length);
      }
      if (config.type === 'stream') {
        return new StreamCipher(modelist[config.mode], password, iv, true);
      } else if (config.type === 'auth') {
        return new AuthCipher(modelist[config.mode], password, iv, true);
      }
      return new Decipher(modelist[config.mode], password, iv);
    }
    function createDecipher(suite, password) {
      var config = modes[suite.toLowerCase()];
      if (!config) {
        throw new TypeError('invalid suite type');
      }
      var keys = ebtk(password, false, config.key, config.iv);
      return createDecipheriv(suite, keys.key, keys.iv);
    }
    exports.createDecipher = createDecipher;
    exports.createDecipheriv = createDecipheriv;
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic('1e9', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  exports['aes-128-ecb'] = {
    cipher: 'AES',
    key: 128,
    iv: 0,
    mode: 'ECB',
    type: 'block'
  };
  exports['aes-192-ecb'] = {
    cipher: 'AES',
    key: 192,
    iv: 0,
    mode: 'ECB',
    type: 'block'
  };
  exports['aes-256-ecb'] = {
    cipher: 'AES',
    key: 256,
    iv: 0,
    mode: 'ECB',
    type: 'block'
  };
  exports['aes-128-cbc'] = {
    cipher: 'AES',
    key: 128,
    iv: 16,
    mode: 'CBC',
    type: 'block'
  };
  exports['aes-192-cbc'] = {
    cipher: 'AES',
    key: 192,
    iv: 16,
    mode: 'CBC',
    type: 'block'
  };
  exports['aes-256-cbc'] = {
    cipher: 'AES',
    key: 256,
    iv: 16,
    mode: 'CBC',
    type: 'block'
  };
  exports['aes128'] = exports['aes-128-cbc'];
  exports['aes192'] = exports['aes-192-cbc'];
  exports['aes256'] = exports['aes-256-cbc'];
  exports['aes-128-cfb'] = {
    cipher: 'AES',
    key: 128,
    iv: 16,
    mode: 'CFB',
    type: 'stream'
  };
  exports['aes-192-cfb'] = {
    cipher: 'AES',
    key: 192,
    iv: 16,
    mode: 'CFB',
    type: 'stream'
  };
  exports['aes-256-cfb'] = {
    cipher: 'AES',
    key: 256,
    iv: 16,
    mode: 'CFB',
    type: 'stream'
  };
  exports['aes-128-cfb8'] = {
    cipher: 'AES',
    key: 128,
    iv: 16,
    mode: 'CFB8',
    type: 'stream'
  };
  exports['aes-192-cfb8'] = {
    cipher: 'AES',
    key: 192,
    iv: 16,
    mode: 'CFB8',
    type: 'stream'
  };
  exports['aes-256-cfb8'] = {
    cipher: 'AES',
    key: 256,
    iv: 16,
    mode: 'CFB8',
    type: 'stream'
  };
  exports['aes-128-cfb1'] = {
    cipher: 'AES',
    key: 128,
    iv: 16,
    mode: 'CFB1',
    type: 'stream'
  };
  exports['aes-192-cfb1'] = {
    cipher: 'AES',
    key: 192,
    iv: 16,
    mode: 'CFB1',
    type: 'stream'
  };
  exports['aes-256-cfb1'] = {
    cipher: 'AES',
    key: 256,
    iv: 16,
    mode: 'CFB1',
    type: 'stream'
  };
  exports['aes-128-ofb'] = {
    cipher: 'AES',
    key: 128,
    iv: 16,
    mode: 'OFB',
    type: 'stream'
  };
  exports['aes-192-ofb'] = {
    cipher: 'AES',
    key: 192,
    iv: 16,
    mode: 'OFB',
    type: 'stream'
  };
  exports['aes-256-ofb'] = {
    cipher: 'AES',
    key: 256,
    iv: 16,
    mode: 'OFB',
    type: 'stream'
  };
  exports['aes-128-ctr'] = {
    cipher: 'AES',
    key: 128,
    iv: 16,
    mode: 'CTR',
    type: 'stream'
  };
  exports['aes-192-ctr'] = {
    cipher: 'AES',
    key: 192,
    iv: 16,
    mode: 'CTR',
    type: 'stream'
  };
  exports['aes-256-ctr'] = {
    cipher: 'AES',
    key: 256,
    iv: 16,
    mode: 'CTR',
    type: 'stream'
  };
  exports['aes-128-gcm'] = {
    cipher: 'AES',
    key: 128,
    iv: 12,
    mode: 'GCM',
    type: 'auth'
  };
  exports['aes-192-gcm'] = {
    cipher: 'AES',
    key: 192,
    iv: 12,
    mode: 'GCM',
    type: 'auth'
  };
  exports['aes-256-gcm'] = {
    cipher: 'AES',
    key: 256,
    iv: 12,
    mode: 'GCM',
    type: 'auth'
  };
  return module.exports;
});
$__System.registerDynamic('1e8', ['239', '249', '1e9'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var ciphers = $__require('239');
  exports.createCipher = exports.Cipher = ciphers.createCipher;
  exports.createCipheriv = exports.Cipheriv = ciphers.createCipheriv;
  var deciphers = $__require('249');
  exports.createDecipher = exports.Decipher = deciphers.createDecipher;
  exports.createDecipheriv = exports.Decipheriv = deciphers.createDecipheriv;
  var modes = $__require('1e9');
  function getCiphers() {
    return Object.keys(modes);
  }
  exports.listCiphers = exports.getCiphers = getCiphers;
  return module.exports;
});
$__System.registerDynamic("238", ["1e8"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("1e8");
  return module.exports;
});
$__System.registerDynamic('24a', ['24b', '46', '49', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    'use strict';

    var createHash = $__require('24b');
    var inherits = $__require('46');
    var Transform = $__require('49').Transform;
    var ZEROS = new Buffer(128);
    ZEROS.fill(0);
    function Hmac(alg, key) {
      Transform.call(this);
      alg = alg.toLowerCase();
      if (typeof key === 'string') {
        key = new Buffer(key);
      }
      var blocksize = alg === 'sha512' || alg === 'sha384' ? 128 : 64;
      this._alg = alg;
      this._key = key;
      if (key.length > blocksize) {
        key = createHash(alg).update(key).digest();
      } else if (key.length < blocksize) {
        key = Buffer.concat([key, ZEROS], blocksize);
      }
      var ipad = this._ipad = new Buffer(blocksize);
      var opad = this._opad = new Buffer(blocksize);
      for (var i = 0; i < blocksize; i++) {
        ipad[i] = key[i] ^ 0x36;
        opad[i] = key[i] ^ 0x5C;
      }
      this._hash = createHash(alg).update(ipad);
    }
    inherits(Hmac, Transform);
    Hmac.prototype.update = function (data, enc) {
      this._hash.update(data, enc);
      return this;
    };
    Hmac.prototype._transform = function (data, _, next) {
      this._hash.update(data);
      next();
    };
    Hmac.prototype._flush = function (next) {
      this.push(this.digest());
      next();
    };
    Hmac.prototype.digest = function (enc) {
      var h = this._hash.digest();
      return createHash(this._alg).update(this._opad).update(h).digest(enc);
    };
    module.exports = function createHmac(alg, key) {
      return new Hmac(alg, key);
    };
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic("1f8", ["24a"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("24a");
  return module.exports;
});
$__System.registerDynamic('24c', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var MAX_ALLOC = Math.pow(2, 30) - 1; // default in iojs
  module.exports = function (iterations, keylen) {
    if (typeof iterations !== 'number') {
      throw new TypeError('Iterations not a number');
    }

    if (iterations < 0) {
      throw new TypeError('Bad iterations');
    }

    if (typeof keylen !== 'number') {
      throw new TypeError('Key length not a number');
    }

    if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) {
      /* eslint no-self-compare: 0 */
      throw new TypeError('Bad key length');
    }
  };
  return module.exports;
});
$__System.registerDynamic('24d', ['1f8', '24c', '2a', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer, process) {
    var createHmac = $__require('1f8');
    var checkParameters = $__require('24c');
    exports.pbkdf2 = function (password, salt, iterations, keylen, digest, callback) {
      if (typeof digest === 'function') {
        callback = digest;
        digest = undefined;
      }
      checkParameters(iterations, keylen);
      if (typeof callback !== 'function') throw new Error('No callback provided to pbkdf2');
      setTimeout(function () {
        callback(null, exports.pbkdf2Sync(password, salt, iterations, keylen, digest));
      });
    };
    var defaultEncoding;
    if (process.browser) {
      defaultEncoding = 'utf-8';
    } else {
      var pVersionMajor = parseInt(process.version.split('.')[0].slice(1), 10);
      defaultEncoding = pVersionMajor >= 6 ? 'utf-8' : 'binary';
    }
    exports.pbkdf2Sync = function (password, salt, iterations, keylen, digest) {
      if (!Buffer.isBuffer(password)) password = new Buffer(password, defaultEncoding);
      if (!Buffer.isBuffer(salt)) salt = new Buffer(salt, defaultEncoding);
      checkParameters(iterations, keylen);
      digest = digest || 'sha1';
      var hLen;
      var l = 1;
      var DK = new Buffer(keylen);
      var block1 = new Buffer(salt.length + 4);
      salt.copy(block1, 0, 0, salt.length);
      var r;
      var T;
      for (var i = 1; i <= l; i++) {
        block1.writeUInt32BE(i, salt.length);
        var U = createHmac(digest, password).update(block1).digest();
        if (!hLen) {
          hLen = U.length;
          T = new Buffer(hLen);
          l = Math.ceil(keylen / hLen);
          r = keylen - (l - 1) * hLen;
        }
        U.copy(T, 0, 0, hLen);
        for (var j = 1; j < iterations; j++) {
          U = createHmac(digest, password).update(U).digest();
          for (var k = 0; k < hLen; k++) T[k] ^= U[k];
        }
        var destPos = (i - 1) * hLen;
        var len = i === l ? r : hLen;
        T.copy(DK, destPos, 0, len);
      }
      return DK;
    };
  })($__require('2a').Buffer, $__require('13'));
  return module.exports;
});
$__System.registerDynamic("24e", ["24d"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("24d");
  return module.exports;
});
$__System.registerDynamic('24f', ['235', '236', '237', '238', '24e', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    var asn1 = $__require('235');
    var aesid = $__require('236');
    var fixProc = $__require('237');
    var ciphers = $__require('238');
    var compat = $__require('24e');
    module.exports = parseKeys;
    function parseKeys(buffer) {
      var password;
      if (typeof buffer === 'object' && !Buffer.isBuffer(buffer)) {
        password = buffer.passphrase;
        buffer = buffer.key;
      }
      if (typeof buffer === 'string') {
        buffer = new Buffer(buffer);
      }
      var stripped = fixProc(buffer, password);
      var type = stripped.tag;
      var data = stripped.data;
      var subtype, ndata;
      switch (type) {
        case 'PUBLIC KEY':
          ndata = asn1.PublicKey.decode(data, 'der');
          subtype = ndata.algorithm.algorithm.join('.');
          switch (subtype) {
            case '1.2.840.113549.1.1.1':
              return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, 'der');
            case '1.2.840.10045.2.1':
              ndata.subjectPrivateKey = ndata.subjectPublicKey;
              return {
                type: 'ec',
                data: ndata
              };
            case '1.2.840.10040.4.1':
              ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, 'der');
              return {
                type: 'dsa',
                data: ndata.algorithm.params
              };
            default:
              throw new Error('unknown key id ' + subtype);
          }
          throw new Error('unknown key type ' + type);
        case 'ENCRYPTED PRIVATE KEY':
          data = asn1.EncryptedPrivateKey.decode(data, 'der');
          data = decrypt(data, password);
        case 'PRIVATE KEY':
          ndata = asn1.PrivateKey.decode(data, 'der');
          subtype = ndata.algorithm.algorithm.join('.');
          switch (subtype) {
            case '1.2.840.113549.1.1.1':
              return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, 'der');
            case '1.2.840.10045.2.1':
              return {
                curve: ndata.algorithm.curve,
                privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, 'der').privateKey
              };
            case '1.2.840.10040.4.1':
              ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, 'der');
              return {
                type: 'dsa',
                params: ndata.algorithm.params
              };
            default:
              throw new Error('unknown key id ' + subtype);
          }
          throw new Error('unknown key type ' + type);
        case 'RSA PUBLIC KEY':
          return asn1.RSAPublicKey.decode(data, 'der');
        case 'RSA PRIVATE KEY':
          return asn1.RSAPrivateKey.decode(data, 'der');
        case 'DSA PRIVATE KEY':
          return {
            type: 'dsa',
            params: asn1.DSAPrivateKey.decode(data, 'der')
          };
        case 'EC PRIVATE KEY':
          data = asn1.ECPrivateKey.decode(data, 'der');
          return {
            curve: data.parameters.value,
            privateKey: data.privateKey
          };
        default:
          throw new Error('unknown key type ' + type);
      }
    }
    parseKeys.signature = asn1.signature;
    function decrypt(data, password) {
      var salt = data.algorithm.decrypt.kde.kdeparams.salt;
      var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10);
      var algo = aesid[data.algorithm.decrypt.cipher.algo.join('.')];
      var iv = data.algorithm.decrypt.cipher.iv;
      var cipherText = data.subjectPrivateKey;
      var keylen = parseInt(algo.split('-')[1], 10) / 8;
      var key = compat.pbkdf2Sync(password, salt, iters, keylen);
      var cipher = ciphers.createDecipheriv(algo, key, iv);
      var out = [];
      out.push(cipher.update(cipherText));
      out.push(cipher.final());
      return Buffer.concat(out);
    }
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic("1fb", ["24f"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("24f");
  return module.exports;
});
$__System.registerDynamic('21c', ['1fe', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    var createHash = $__require('1fe');
    module.exports = function (seed, len) {
      var t = new Buffer('');
      var i = 0,
          c;
      while (t.length < len) {
        c = i2ops(i++);
        t = Buffer.concat([t, createHash('sha1').update(seed).update(c).digest()]);
      }
      return t.slice(0, len);
    };
    function i2ops(c) {
      var out = new Buffer(4);
      out.writeUInt32BE(c, 0);
      return out;
    }
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic("21d", [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function xor(a, b) {
    var len = a.length;
    var i = -1;
    while (++i < len) {
      a[i] ^= b[i];
    }
    return a;
  };
  return module.exports;
});
$__System.registerDynamic('250', ['2a', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer, process) {
    'use strict';

    function oldBrowser() {
      throw new Error('secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11');
    }
    var crypto = global.crypto || global.msCrypto;
    if (crypto && crypto.getRandomValues) {
      module.exports = randomBytes;
    } else {
      module.exports = oldBrowser;
    }
    function randomBytes(size, cb) {
      if (size > 65536) throw new Error('requested too many random bytes');
      var rawBytes = new global.Uint8Array(size);
      if (size > 0) {
        crypto.getRandomValues(rawBytes);
      }
      var bytes = new Buffer(rawBytes.buffer);
      if (typeof cb === 'function') {
        return process.nextTick(function () {
          cb(null, bytes);
        });
      }
      return bytes;
    }
  })($__require('2a').Buffer, $__require('13'));
  return module.exports;
});
$__System.registerDynamic("1f1", ["250"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("250");
  return module.exports;
});
$__System.registerDynamic('251', ['1ee', '1f1', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    var bn = $__require('1ee');
    var randomBytes = $__require('1f1');
    module.exports = crt;
    function blind(priv) {
      var r = getr(priv);
      var blinder = r.toRed(bn.mont(priv.modulus)).redPow(new bn(priv.publicExponent)).fromRed();
      return {
        blinder: blinder,
        unblinder: r.invm(priv.modulus)
      };
    }
    function crt(msg, priv) {
      var blinds = blind(priv);
      var len = priv.modulus.byteLength();
      var mod = bn.mont(priv.modulus);
      var blinded = new bn(msg).mul(blinds.blinder).umod(priv.modulus);
      var c1 = blinded.toRed(bn.mont(priv.prime1));
      var c2 = blinded.toRed(bn.mont(priv.prime2));
      var qinv = priv.coefficient;
      var p = priv.prime1;
      var q = priv.prime2;
      var m1 = c1.redPow(priv.exponent1);
      var m2 = c2.redPow(priv.exponent2);
      m1 = m1.fromRed();
      m2 = m2.fromRed();
      var h = m1.isub(m2).imul(qinv).umod(p);
      h.imul(q);
      m2.iadd(h);
      return new Buffer(m2.imul(blinds.unblinder).umod(priv.modulus).toArray(false, len));
    }
    crt.getr = getr;
    function getr(priv) {
      var len = priv.modulus.byteLength();
      var r = new bn(randomBytes(len));
      while (r.cmp(priv.modulus) >= 0 || !r.umod(priv.prime1) || !r.umod(priv.prime2)) {
        r = new bn(randomBytes(len));
      }
      return r;
    }
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic("1f9", ["251"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("251");
  return module.exports;
});
$__System.registerDynamic('252', ['2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    'use strict';

    var intSize = 4;
    var zeroBuffer = new Buffer(intSize);
    zeroBuffer.fill(0);
    var chrsz = 8;
    function toArray(buf, bigEndian) {
      if (buf.length % intSize !== 0) {
        var len = buf.length + (intSize - buf.length % intSize);
        buf = Buffer.concat([buf, zeroBuffer], len);
      }
      var arr = [];
      var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
      for (var i = 0; i < buf.length; i += intSize) {
        arr.push(fn.call(buf, i));
      }
      return arr;
    }
    function toBuffer(arr, size, bigEndian) {
      var buf = new Buffer(size);
      var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
      for (var i = 0; i < arr.length; i++) {
        fn.call(buf, arr[i], i * 4, true);
      }
      return buf;
    }
    function hash(buf, fn, hashSize, bigEndian) {
      if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);
      var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
      return toBuffer(arr, hashSize, bigEndian);
    }
    exports.hash = hash;
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic('247', ['252'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var helpers = $__require('252');
  function core_md5(x, len) {
    x[len >> 5] |= 0x80 << len % 32;
    x[(len + 64 >>> 9 << 4) + 14] = len;
    var a = 1732584193;
    var b = -271733879;
    var c = -1732584194;
    var d = 271733878;
    for (var i = 0; i < x.length; i += 16) {
      var olda = a;
      var oldb = b;
      var oldc = c;
      var oldd = d;
      a = md5_ff(a, b, c, d, x[i + 0], 7, -680876936);
      d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586);
      c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819);
      b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330);
      a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897);
      d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426);
      c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341);
      b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983);
      a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416);
      d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417);
      c = md5_ff(c, d, a, b, x[i + 10], 17, -42063);
      b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);
      a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682);
      d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101);
      c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);
      b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329);
      a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510);
      d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632);
      c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713);
      b = md5_gg(b, c, d, a, x[i + 0], 20, -373897302);
      a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691);
      d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083);
      c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335);
      b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848);
      a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438);
      d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690);
      c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961);
      b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501);
      a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467);
      d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784);
      c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473);
      b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);
      a = md5_hh(a, b, c, d, x[i + 5], 4, -378558);
      d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463);
      c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562);
      b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556);
      a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060);
      d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353);
      c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632);
      b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);
      a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174);
      d = md5_hh(d, a, b, c, x[i + 0], 11, -358537222);
      c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979);
      b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189);
      a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487);
      d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835);
      c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520);
      b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651);
      a = md5_ii(a, b, c, d, x[i + 0], 6, -198630844);
      d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415);
      c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);
      b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055);
      a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571);
      d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606);
      c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523);
      b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799);
      a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359);
      d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744);
      c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380);
      b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649);
      a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070);
      d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);
      c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259);
      b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551);
      a = safe_add(a, olda);
      b = safe_add(b, oldb);
      c = safe_add(c, oldc);
      d = safe_add(d, oldd);
    }
    return Array(a, b, c, d);
  }
  function md5_cmn(q, a, b, x, s, t) {
    return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b);
  }
  function md5_ff(a, b, c, d, x, s, t) {
    return md5_cmn(b & c | ~b & d, a, b, x, s, t);
  }
  function md5_gg(a, b, c, d, x, s, t) {
    return md5_cmn(b & d | c & ~d, a, b, x, s, t);
  }
  function md5_hh(a, b, c, d, x, s, t) {
    return md5_cmn(b ^ c ^ d, a, b, x, s, t);
  }
  function md5_ii(a, b, c, d, x, s, t) {
    return md5_cmn(c ^ (b | ~d), a, b, x, s, t);
  }
  function safe_add(x, y) {
    var lsw = (x & 0xFFFF) + (y & 0xFFFF);
    var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
    return msw << 16 | lsw & 0xFFFF;
  }
  function bit_rol(num, cnt) {
    return num << cnt | num >>> 32 - cnt;
  }
  module.exports = function md5(buf) {
    return helpers.hash(buf, core_md5, 16);
  };
  return module.exports;
});
$__System.registerDynamic('253', ['2a', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer, process) {
    var zl = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
    var zr = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];
    var sl = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
    var sr = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
    var hl = [0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E];
    var hr = [0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000];
    function bytesToWords(bytes) {
      var words = [];
      for (var i = 0, b = 0; i < bytes.length; i++, b += 8) {
        words[b >>> 5] |= bytes[i] << 24 - b % 32;
      }
      return words;
    }
    function wordsToBytes(words) {
      var bytes = [];
      for (var b = 0; b < words.length * 32; b += 8) {
        bytes.push(words[b >>> 5] >>> 24 - b % 32 & 0xFF);
      }
      return bytes;
    }
    function processBlock(H, M, offset) {
      for (var i = 0; i < 16; i++) {
        var offset_i = offset + i;
        var M_offset_i = M[offset_i];
        M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 0x00ff00ff | (M_offset_i << 24 | M_offset_i >>> 8) & 0xff00ff00;
      }
      var al, bl, cl, dl, el;
      var ar, br, cr, dr, er;
      ar = al = H[0];
      br = bl = H[1];
      cr = cl = H[2];
      dr = dl = H[3];
      er = el = H[4];
      var t;
      for (i = 0; i < 80; i += 1) {
        t = al + M[offset + zl[i]] | 0;
        if (i < 16) {
          t += f1(bl, cl, dl) + hl[0];
        } else if (i < 32) {
          t += f2(bl, cl, dl) + hl[1];
        } else if (i < 48) {
          t += f3(bl, cl, dl) + hl[2];
        } else if (i < 64) {
          t += f4(bl, cl, dl) + hl[3];
        } else {
          t += f5(bl, cl, dl) + hl[4];
        }
        t = t | 0;
        t = rotl(t, sl[i]);
        t = t + el | 0;
        al = el;
        el = dl;
        dl = rotl(cl, 10);
        cl = bl;
        bl = t;
        t = ar + M[offset + zr[i]] | 0;
        if (i < 16) {
          t += f5(br, cr, dr) + hr[0];
        } else if (i < 32) {
          t += f4(br, cr, dr) + hr[1];
        } else if (i < 48) {
          t += f3(br, cr, dr) + hr[2];
        } else if (i < 64) {
          t += f2(br, cr, dr) + hr[3];
        } else {
          t += f1(br, cr, dr) + hr[4];
        }
        t = t | 0;
        t = rotl(t, sr[i]);
        t = t + er | 0;
        ar = er;
        er = dr;
        dr = rotl(cr, 10);
        cr = br;
        br = t;
      }
      t = H[1] + cl + dr | 0;
      H[1] = H[2] + dl + er | 0;
      H[2] = H[3] + el + ar | 0;
      H[3] = H[4] + al + br | 0;
      H[4] = H[0] + bl + cr | 0;
      H[0] = t;
    }
    function f1(x, y, z) {
      return x ^ y ^ z;
    }
    function f2(x, y, z) {
      return x & y | ~x & z;
    }
    function f3(x, y, z) {
      return (x | ~y) ^ z;
    }
    function f4(x, y, z) {
      return x & z | y & ~z;
    }
    function f5(x, y, z) {
      return x ^ (y | ~z);
    }
    function rotl(x, n) {
      return x << n | x >>> 32 - n;
    }
    function ripemd160(message) {
      var H = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0];
      if (typeof message === 'string') {
        message = new Buffer(message, 'utf8');
      }
      var m = bytesToWords(message);
      var nBitsLeft = message.length * 8;
      var nBitsTotal = message.length * 8;
      m[nBitsLeft >>> 5] |= 0x80 << 24 - nBitsLeft % 32;
      m[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotal << 8 | nBitsTotal >>> 24) & 0x00ff00ff | (nBitsTotal << 24 | nBitsTotal >>> 8) & 0xff00ff00;
      for (var i = 0; i < m.length; i += 16) {
        processBlock(H, m, i);
      }
      for (i = 0; i < 5; i++) {
        var H_i = H[i];
        H[i] = (H_i << 8 | H_i >>> 24) & 0x00ff00ff | (H_i << 24 | H_i >>> 8) & 0xff00ff00;
      }
      var digestbytes = wordsToBytes(H);
      return new Buffer(digestbytes);
    }
    module.exports = ripemd160;
  })($__require('2a').Buffer, $__require('13'));
  return module.exports;
});
$__System.registerDynamic("254", ["253"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("253");
  return module.exports;
});
$__System.registerDynamic('255', ['46', '256', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    var inherits = $__require('46');
    var Hash = $__require('256');
    var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0];
    var W = new Array(80);
    function Sha() {
      this.init();
      this._w = W;
      Hash.call(this, 64, 56);
    }
    inherits(Sha, Hash);
    Sha.prototype.init = function () {
      this._a = 0x67452301;
      this._b = 0xefcdab89;
      this._c = 0x98badcfe;
      this._d = 0x10325476;
      this._e = 0xc3d2e1f0;
      return this;
    };
    function rotl5(num) {
      return num << 5 | num >>> 27;
    }
    function rotl30(num) {
      return num << 30 | num >>> 2;
    }
    function ft(s, b, c, d) {
      if (s === 0) return b & c | ~b & d;
      if (s === 2) return b & c | b & d | c & d;
      return b ^ c ^ d;
    }
    Sha.prototype._update = function (M) {
      var W = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);
      for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
      for (var j = 0; j < 80; ++j) {
        var s = ~~(j / 20);
        var t = rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s] | 0;
        e = d;
        d = c;
        c = rotl30(b);
        b = a;
        a = t;
      }
      this._a = a + this._a | 0;
      this._b = b + this._b | 0;
      this._c = c + this._c | 0;
      this._d = d + this._d | 0;
      this._e = e + this._e | 0;
    };
    Sha.prototype._hash = function () {
      var H = new Buffer(20);
      H.writeInt32BE(this._a | 0, 0);
      H.writeInt32BE(this._b | 0, 4);
      H.writeInt32BE(this._c | 0, 8);
      H.writeInt32BE(this._d | 0, 12);
      H.writeInt32BE(this._e | 0, 16);
      return H;
    };
    module.exports = Sha;
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic('257', ['46', '256', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    var inherits = $__require('46');
    var Hash = $__require('256');
    var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0];
    var W = new Array(80);
    function Sha1() {
      this.init();
      this._w = W;
      Hash.call(this, 64, 56);
    }
    inherits(Sha1, Hash);
    Sha1.prototype.init = function () {
      this._a = 0x67452301;
      this._b = 0xefcdab89;
      this._c = 0x98badcfe;
      this._d = 0x10325476;
      this._e = 0xc3d2e1f0;
      return this;
    };
    function rotl1(num) {
      return num << 1 | num >>> 31;
    }
    function rotl5(num) {
      return num << 5 | num >>> 27;
    }
    function rotl30(num) {
      return num << 30 | num >>> 2;
    }
    function ft(s, b, c, d) {
      if (s === 0) return b & c | ~b & d;
      if (s === 2) return b & c | b & d | c & d;
      return b ^ c ^ d;
    }
    Sha1.prototype._update = function (M) {
      var W = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);
      for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]);
      for (var j = 0; j < 80; ++j) {
        var s = ~~(j / 20);
        var t = rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s] | 0;
        e = d;
        d = c;
        c = rotl30(b);
        b = a;
        a = t;
      }
      this._a = a + this._a | 0;
      this._b = b + this._b | 0;
      this._c = c + this._c | 0;
      this._d = d + this._d | 0;
      this._e = e + this._e | 0;
    };
    Sha1.prototype._hash = function () {
      var H = new Buffer(20);
      H.writeInt32BE(this._a | 0, 0);
      H.writeInt32BE(this._b | 0, 4);
      H.writeInt32BE(this._c | 0, 8);
      H.writeInt32BE(this._d | 0, 12);
      H.writeInt32BE(this._e | 0, 16);
      return H;
    };
    module.exports = Sha1;
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic('258', ['46', '259', '256', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    var inherits = $__require('46');
    var Sha256 = $__require('259');
    var Hash = $__require('256');
    var W = new Array(64);
    function Sha224() {
      this.init();
      this._w = W;
      Hash.call(this, 64, 56);
    }
    inherits(Sha224, Sha256);
    Sha224.prototype.init = function () {
      this._a = 0xc1059ed8;
      this._b = 0x367cd507;
      this._c = 0x3070dd17;
      this._d = 0xf70e5939;
      this._e = 0xffc00b31;
      this._f = 0x68581511;
      this._g = 0x64f98fa7;
      this._h = 0xbefa4fa4;
      return this;
    };
    Sha224.prototype._hash = function () {
      var H = new Buffer(28);
      H.writeInt32BE(this._a, 0);
      H.writeInt32BE(this._b, 4);
      H.writeInt32BE(this._c, 8);
      H.writeInt32BE(this._d, 12);
      H.writeInt32BE(this._e, 16);
      H.writeInt32BE(this._f, 20);
      H.writeInt32BE(this._g, 24);
      return H;
    };
    module.exports = Sha224;
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic('259', ['46', '256', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    var inherits = $__require('46');
    var Hash = $__require('256');
    var K = [0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5, 0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5, 0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3, 0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174, 0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC, 0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA, 0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7, 0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967, 0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13, 0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85, 0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3, 0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070, 0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5, 0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3, 0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208, 0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2];
    var W = new Array(64);
    function Sha256() {
      this.init();
      this._w = W;
      Hash.call(this, 64, 56);
    }
    inherits(Sha256, Hash);
    Sha256.prototype.init = function () {
      this._a = 0x6a09e667;
      this._b = 0xbb67ae85;
      this._c = 0x3c6ef372;
      this._d = 0xa54ff53a;
      this._e = 0x510e527f;
      this._f = 0x9b05688c;
      this._g = 0x1f83d9ab;
      this._h = 0x5be0cd19;
      return this;
    };
    function ch(x, y, z) {
      return z ^ x & (y ^ z);
    }
    function maj(x, y, z) {
      return x & y | z & (x | y);
    }
    function sigma0(x) {
      return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
    }
    function sigma1(x) {
      return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
    }
    function gamma0(x) {
      return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
    }
    function gamma1(x) {
      return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
    }
    Sha256.prototype._update = function (M) {
      var W = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      var f = this._f | 0;
      var g = this._g | 0;
      var h = this._h | 0;
      for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);
      for (; i < 64; ++i) W[i] = gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16] | 0;
      for (var j = 0; j < 64; ++j) {
        var T1 = h + sigma1(e) + ch(e, f, g) + K[j] + W[j] | 0;
        var T2 = sigma0(a) + maj(a, b, c) | 0;
        h = g;
        g = f;
        f = e;
        e = d + T1 | 0;
        d = c;
        c = b;
        b = a;
        a = T1 + T2 | 0;
      }
      this._a = a + this._a | 0;
      this._b = b + this._b | 0;
      this._c = c + this._c | 0;
      this._d = d + this._d | 0;
      this._e = e + this._e | 0;
      this._f = f + this._f | 0;
      this._g = g + this._g | 0;
      this._h = h + this._h | 0;
    };
    Sha256.prototype._hash = function () {
      var H = new Buffer(32);
      H.writeInt32BE(this._a, 0);
      H.writeInt32BE(this._b, 4);
      H.writeInt32BE(this._c, 8);
      H.writeInt32BE(this._d, 12);
      H.writeInt32BE(this._e, 16);
      H.writeInt32BE(this._f, 20);
      H.writeInt32BE(this._g, 24);
      H.writeInt32BE(this._h, 28);
      return H;
    };
    module.exports = Sha256;
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic('25a', ['46', '25b', '256', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    var inherits = $__require('46');
    var SHA512 = $__require('25b');
    var Hash = $__require('256');
    var W = new Array(160);
    function Sha384() {
      this.init();
      this._w = W;
      Hash.call(this, 128, 112);
    }
    inherits(Sha384, SHA512);
    Sha384.prototype.init = function () {
      this._ah = 0xcbbb9d5d;
      this._bh = 0x629a292a;
      this._ch = 0x9159015a;
      this._dh = 0x152fecd8;
      this._eh = 0x67332667;
      this._fh = 0x8eb44a87;
      this._gh = 0xdb0c2e0d;
      this._hh = 0x47b5481d;
      this._al = 0xc1059ed8;
      this._bl = 0x367cd507;
      this._cl = 0x3070dd17;
      this._dl = 0xf70e5939;
      this._el = 0xffc00b31;
      this._fl = 0x68581511;
      this._gl = 0x64f98fa7;
      this._hl = 0xbefa4fa4;
      return this;
    };
    Sha384.prototype._hash = function () {
      var H = new Buffer(48);
      function writeInt64BE(h, l, offset) {
        H.writeInt32BE(h, offset);
        H.writeInt32BE(l, offset + 4);
      }
      writeInt64BE(this._ah, this._al, 0);
      writeInt64BE(this._bh, this._bl, 8);
      writeInt64BE(this._ch, this._cl, 16);
      writeInt64BE(this._dh, this._dl, 24);
      writeInt64BE(this._eh, this._el, 32);
      writeInt64BE(this._fh, this._fl, 40);
      return H;
    };
    module.exports = Sha384;
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic('256', ['2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    function Hash(blockSize, finalSize) {
      this._block = new Buffer(blockSize);
      this._finalSize = finalSize;
      this._blockSize = blockSize;
      this._len = 0;
      this._s = 0;
    }
    Hash.prototype.update = function (data, enc) {
      if (typeof data === 'string') {
        enc = enc || 'utf8';
        data = new Buffer(data, enc);
      }
      var l = this._len += data.length;
      var s = this._s || 0;
      var f = 0;
      var buffer = this._block;
      while (s < l) {
        var t = Math.min(data.length, f + this._blockSize - s % this._blockSize);
        var ch = t - f;
        for (var i = 0; i < ch; i++) {
          buffer[s % this._blockSize + i] = data[i + f];
        }
        s += ch;
        f += ch;
        if (s % this._blockSize === 0) {
          this._update(buffer);
        }
      }
      this._s = s;
      return this;
    };
    Hash.prototype.digest = function (enc) {
      var l = this._len * 8;
      this._block[this._len % this._blockSize] = 0x80;
      this._block.fill(0, this._len % this._blockSize + 1);
      if (l % (this._blockSize * 8) >= this._finalSize * 8) {
        this._update(this._block);
        this._block.fill(0);
      }
      this._block.writeInt32BE(l, this._blockSize - 4);
      var hash = this._update(this._block) || this._hash();
      return enc ? hash.toString(enc) : hash;
    };
    Hash.prototype._update = function () {
      throw new Error('_update must be implemented by subclass');
    };
    module.exports = Hash;
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic('25b', ['46', '256', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    var inherits = $__require('46');
    var Hash = $__require('256');
    var K = [0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc, 0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118, 0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2, 0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694, 0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3, 0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65, 0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5, 0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4, 0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70, 0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df, 0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b, 0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30, 0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8, 0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8, 0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3, 0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec, 0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b, 0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178, 0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b, 0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c, 0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817];
    var W = new Array(160);
    function Sha512() {
      this.init();
      this._w = W;
      Hash.call(this, 128, 112);
    }
    inherits(Sha512, Hash);
    Sha512.prototype.init = function () {
      this._ah = 0x6a09e667;
      this._bh = 0xbb67ae85;
      this._ch = 0x3c6ef372;
      this._dh = 0xa54ff53a;
      this._eh = 0x510e527f;
      this._fh = 0x9b05688c;
      this._gh = 0x1f83d9ab;
      this._hh = 0x5be0cd19;
      this._al = 0xf3bcc908;
      this._bl = 0x84caa73b;
      this._cl = 0xfe94f82b;
      this._dl = 0x5f1d36f1;
      this._el = 0xade682d1;
      this._fl = 0x2b3e6c1f;
      this._gl = 0xfb41bd6b;
      this._hl = 0x137e2179;
      return this;
    };
    function Ch(x, y, z) {
      return z ^ x & (y ^ z);
    }
    function maj(x, y, z) {
      return x & y | z & (x | y);
    }
    function sigma0(x, xl) {
      return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25);
    }
    function sigma1(x, xl) {
      return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23);
    }
    function Gamma0(x, xl) {
      return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ x >>> 7;
    }
    function Gamma0l(x, xl) {
      return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25);
    }
    function Gamma1(x, xl) {
      return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ x >>> 6;
    }
    function Gamma1l(x, xl) {
      return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26);
    }
    function getCarry(a, b) {
      return a >>> 0 < b >>> 0 ? 1 : 0;
    }
    Sha512.prototype._update = function (M) {
      var W = this._w;
      var ah = this._ah | 0;
      var bh = this._bh | 0;
      var ch = this._ch | 0;
      var dh = this._dh | 0;
      var eh = this._eh | 0;
      var fh = this._fh | 0;
      var gh = this._gh | 0;
      var hh = this._hh | 0;
      var al = this._al | 0;
      var bl = this._bl | 0;
      var cl = this._cl | 0;
      var dl = this._dl | 0;
      var el = this._el | 0;
      var fl = this._fl | 0;
      var gl = this._gl | 0;
      var hl = this._hl | 0;
      for (var i = 0; i < 32; i += 2) {
        W[i] = M.readInt32BE(i * 4);
        W[i + 1] = M.readInt32BE(i * 4 + 4);
      }
      for (; i < 160; i += 2) {
        var xh = W[i - 15 * 2];
        var xl = W[i - 15 * 2 + 1];
        var gamma0 = Gamma0(xh, xl);
        var gamma0l = Gamma0l(xl, xh);
        xh = W[i - 2 * 2];
        xl = W[i - 2 * 2 + 1];
        var gamma1 = Gamma1(xh, xl);
        var gamma1l = Gamma1l(xl, xh);
        var Wi7h = W[i - 7 * 2];
        var Wi7l = W[i - 7 * 2 + 1];
        var Wi16h = W[i - 16 * 2];
        var Wi16l = W[i - 16 * 2 + 1];
        var Wil = gamma0l + Wi7l | 0;
        var Wih = gamma0 + Wi7h + getCarry(Wil, gamma0l) | 0;
        Wil = Wil + gamma1l | 0;
        Wih = Wih + gamma1 + getCarry(Wil, gamma1l) | 0;
        Wil = Wil + Wi16l | 0;
        Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
        W[i] = Wih;
        W[i + 1] = Wil;
      }
      for (var j = 0; j < 160; j += 2) {
        Wih = W[j];
        Wil = W[j + 1];
        var majh = maj(ah, bh, ch);
        var majl = maj(al, bl, cl);
        var sigma0h = sigma0(ah, al);
        var sigma0l = sigma0(al, ah);
        var sigma1h = sigma1(eh, el);
        var sigma1l = sigma1(el, eh);
        var Kih = K[j];
        var Kil = K[j + 1];
        var chh = Ch(eh, fh, gh);
        var chl = Ch(el, fl, gl);
        var t1l = hl + sigma1l | 0;
        var t1h = hh + sigma1h + getCarry(t1l, hl) | 0;
        t1l = t1l + chl | 0;
        t1h = t1h + chh + getCarry(t1l, chl) | 0;
        t1l = t1l + Kil | 0;
        t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
        t1l = t1l + Wil | 0;
        t1h = t1h + Wih + getCarry(t1l, Wil) | 0;
        var t2l = sigma0l + majl | 0;
        var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        el = dl + t1l | 0;
        eh = dh + t1h + getCarry(el, dl) | 0;
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        al = t1l + t2l | 0;
        ah = t1h + t2h + getCarry(al, t1l) | 0;
      }
      this._al = this._al + al | 0;
      this._bl = this._bl + bl | 0;
      this._cl = this._cl + cl | 0;
      this._dl = this._dl + dl | 0;
      this._el = this._el + el | 0;
      this._fl = this._fl + fl | 0;
      this._gl = this._gl + gl | 0;
      this._hl = this._hl + hl | 0;
      this._ah = this._ah + ah + getCarry(this._al, al) | 0;
      this._bh = this._bh + bh + getCarry(this._bl, bl) | 0;
      this._ch = this._ch + ch + getCarry(this._cl, cl) | 0;
      this._dh = this._dh + dh + getCarry(this._dl, dl) | 0;
      this._eh = this._eh + eh + getCarry(this._el, el) | 0;
      this._fh = this._fh + fh + getCarry(this._fl, fl) | 0;
      this._gh = this._gh + gh + getCarry(this._gl, gl) | 0;
      this._hh = this._hh + hh + getCarry(this._hl, hl) | 0;
    };
    Sha512.prototype._hash = function () {
      var H = new Buffer(64);
      function writeInt64BE(h, l, offset) {
        H.writeInt32BE(h, offset);
        H.writeInt32BE(l, offset + 4);
      }
      writeInt64BE(this._ah, this._al, 0);
      writeInt64BE(this._bh, this._bl, 8);
      writeInt64BE(this._ch, this._cl, 16);
      writeInt64BE(this._dh, this._dl, 24);
      writeInt64BE(this._eh, this._el, 32);
      writeInt64BE(this._fh, this._fl, 40);
      writeInt64BE(this._gh, this._gl, 48);
      writeInt64BE(this._hh, this._hl, 56);
      return H;
    };
    module.exports = Sha512;
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic('25c', ['255', '257', '258', '259', '25a', '25b'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var exports = module.exports = function SHA(algorithm) {
    algorithm = algorithm.toLowerCase();
    var Algorithm = exports[algorithm];
    if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)');
    return new Algorithm();
  };
  exports.sha = $__require('255');
  exports.sha1 = $__require('257');
  exports.sha224 = $__require('258');
  exports.sha256 = $__require('259');
  exports.sha384 = $__require('25a');
  exports.sha512 = $__require('25b');
  return module.exports;
});
$__System.registerDynamic("25d", ["25c"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("25c");
  return module.exports;
});
$__System.registerDynamic('25e', ['19e'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  module.exports = $__System._nodeRequire ? $__System._nodeRequire('string_decoder') : $__require('19e');
  return module.exports;
});
$__System.registerDynamic("140", ["25e"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("25e");
  return module.exports;
});
$__System.registerDynamic('25f', ['49', '46', '140', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    var Transform = $__require('49').Transform;
    var inherits = $__require('46');
    var StringDecoder = $__require('140').StringDecoder;
    module.exports = CipherBase;
    inherits(CipherBase, Transform);
    function CipherBase(hashMode) {
      Transform.call(this);
      this.hashMode = typeof hashMode === 'string';
      if (this.hashMode) {
        this[hashMode] = this._finalOrDigest;
      } else {
        this.final = this._finalOrDigest;
      }
      this._decoder = null;
      this._encoding = null;
    }
    CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
      if (typeof data === 'string') {
        data = new Buffer(data, inputEnc);
      }
      var outData = this._update(data);
      if (this.hashMode) {
        return this;
      }
      if (outputEnc) {
        outData = this._toString(outData, outputEnc);
      }
      return outData;
    };
    CipherBase.prototype.setAutoPadding = function () {};
    CipherBase.prototype.getAuthTag = function () {
      throw new Error('trying to get auth tag in unsupported state');
    };
    CipherBase.prototype.setAuthTag = function () {
      throw new Error('trying to set auth tag in unsupported state');
    };
    CipherBase.prototype.setAAD = function () {
      throw new Error('trying to set aad in unsupported state');
    };
    CipherBase.prototype._transform = function (data, _, next) {
      var err;
      try {
        if (this.hashMode) {
          this._update(data);
        } else {
          this.push(this._update(data));
        }
      } catch (e) {
        err = e;
      } finally {
        next(err);
      }
    };
    CipherBase.prototype._flush = function (done) {
      var err;
      try {
        this.push(this._final());
      } catch (e) {
        err = e;
      } finally {
        done(err);
      }
    };
    CipherBase.prototype._finalOrDigest = function (outputEnc) {
      var outData = this._final() || new Buffer('');
      if (outputEnc) {
        outData = this._toString(outData, outputEnc, true);
      }
      return outData;
    };
    CipherBase.prototype._toString = function (value, enc, fin) {
      if (!this._decoder) {
        this._decoder = new StringDecoder(enc);
        this._encoding = enc;
      }
      if (this._encoding !== enc) {
        throw new Error('can\'t switch encodings');
      }
      var out = this._decoder.write(value);
      if (fin) {
        out += this._decoder.end();
      }
      return out;
    };
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic("1e3", ["25f"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("25f");
  return module.exports;
});
$__System.registerDynamic('24b', ['46', '247', '254', '25d', '1e3', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    'use strict';

    var inherits = $__require('46');
    var md5 = $__require('247');
    var rmd160 = $__require('254');
    var sha = $__require('25d');
    var Base = $__require('1e3');
    function HashNoConstructor(hash) {
      Base.call(this, 'digest');
      this._hash = hash;
      this.buffers = [];
    }
    inherits(HashNoConstructor, Base);
    HashNoConstructor.prototype._update = function (data) {
      this.buffers.push(data);
    };
    HashNoConstructor.prototype._final = function () {
      var buf = Buffer.concat(this.buffers);
      var r = this._hash(buf);
      this.buffers = null;
      return r;
    };
    function Hash(hash) {
      Base.call(this, 'digest');
      this._hash = hash;
    }
    inherits(Hash, Base);
    Hash.prototype._update = function (data) {
      this._hash.update(data);
    };
    Hash.prototype._final = function () {
      return this._hash.digest();
    };
    module.exports = function createHash(alg) {
      alg = alg.toLowerCase();
      if ('md5' === alg) return new HashNoConstructor(md5);
      if ('rmd160' === alg || 'ripemd160' === alg) return new HashNoConstructor(rmd160);
      return new Hash(sha(alg));
    };
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic("1fe", ["24b"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("24b");
  return module.exports;
});
$__System.registerDynamic('260', ['2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    (function (module, exports) {
      'use strict';

      function assert(val, msg) {
        if (!val) throw new Error(msg || 'Assertion failed');
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function () {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === 'le' || base === 'be') {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || 'be');
        }
      }
      if (typeof module === 'object') {
        module.exports = BN;
      } else {
        exports.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer;
      try {
        Buffer = $__require('buf' + 'fer').Buffer;
      } catch (e) {}
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === 'object' && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
      };
      BN.min = function min(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
      };
      BN.prototype._init = function init(number, base, endian) {
        if (typeof number === 'number') {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === 'object') {
          return this._initArray(number, base, endian);
        }
        if (base === 'hex') {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, '');
        var start = 0;
        if (number[0] === '-') {
          start++;
        }
        if (base === 16) {
          this._parseHex(number, start);
        } else {
          this._parseBase(number, base, start);
        }
        if (number[0] === '-') {
          this.negative = 1;
        }
        this.strip();
        if (endian !== 'le') return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 0x4000000) {
          this.words = [number & 0x3ffffff];
          this.length = 1;
        } else if (number < 0x10000000000000) {
          this.words = [number & 0x3ffffff, number / 0x4000000 & 0x3ffffff];
          this.length = 2;
        } else {
          assert(number < 0x20000000000000);
          this.words = [number & 0x3ffffff, number / 0x4000000 & 0x3ffffff, 1];
          this.length = 3;
        }
        if (endian !== 'le') return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === 'number');
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === 'be') {
          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === 'le') {
          for (i = 0, j = 0; i < number.length; i += 3) {
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this.strip();
      };
      function parseHex(str, start, end) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r <<= 4;
          if (c >= 49 && c <= 54) {
            r |= c - 49 + 0xa;
          } else if (c >= 17 && c <= 22) {
            r |= c - 17 + 0xa;
          } else {
            r |= c & 0xf;
          }
        }
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number, start) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        for (i = number.length - 6, j = 0; i >= start; i -= 6) {
          w = parseHex(number, i, i + 6);
          this.words[j] |= w << off & 0x3ffffff;
          this.words[j + 1] |= w >>> 26 - off & 0x3fffff;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
        if (i + 6 !== start) {
          w = parseHex(number, start, i + 6);
          this.words[j] |= w << off & 0x3ffffff;
          this.words[j + 1] |= w >>> 26 - off & 0x3fffff;
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul;
          if (c >= 49) {
            r += c - 49 + 0xa;
          } else if (c >= 17) {
            r += c - 17 + 0xa;
          } else {
            r += c;
          }
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 0x4000000) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i, number.length, base);
          for (i = 0; i < mod; i++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 0x4000000) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN.prototype.inspect = function inspect() {
        return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
      };
      var zeros = ['', '0', '00', '000', '0000', '00000', '000000', '0000000', '00000000', '000000000', '0000000000', '00000000000', '000000000000', '0000000000000', '00000000000000', '000000000000000', '0000000000000000', '00000000000000000', '000000000000000000', '0000000000000000000', '00000000000000000000', '000000000000000000000', '0000000000000000000000', '00000000000000000000000', '000000000000000000000000', '0000000000000000000000000'];
      var groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5];
      var groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === 'hex') {
          out = '';
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 0xffffff).toString(16);
            carry = w >>> 24 - off & 0xffffff;
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = '0' + out;
          }
          if (this.negative !== 0) {
            out = '-' + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = '';
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = '0' + out;
          }
          while (out.length % padding !== 0) {
            out = '0' + out;
          }
          if (this.negative !== 0) {
            out = '-' + out;
          }
          return out;
        }
        assert(false, 'Base should be between 2 and 36');
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 0x4000000;
        } else if (this.length === 3 && this.words[2] === 0x01) {
          ret += 0x10000000000000 + this.words[1] * 0x4000000;
        } else if (this.length > 2) {
          assert(false, 'Number can only safely store up to 53 bits');
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN.prototype.toBuffer = function toBuffer(endian, length) {
        assert(typeof Buffer !== 'undefined');
        return this.toArrayLike(Buffer, endian, length);
      };
      BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, 'byte array longer than desired length');
        assert(reqLength > 0, 'Requested array length <= 0');
        this.strip();
        var littleEndian = endian === 'le';
        var res = new ArrayType(reqLength);
        var b, i;
        var q = this.clone();
        if (!littleEndian) {
          for (i = 0; i < reqLength - byteLength; i++) {
            res[i] = 0;
          }
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(0xff);
            q.iushrn(8);
            res[reqLength - i - 1] = b;
          }
        } else {
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(0xff);
            q.iushrn(8);
            res[i] = b;
          }
          for (; i < reqLength; i++) {
            res[i] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 0x1000) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 0x40) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 0x8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 0x02) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0) return 26;
        var t = w;
        var r = 0;
        if ((t & 0x1fff) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 0x7f) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 0xf) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 0x3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 0x1) === 0) {
          r++;
        }
        return r;
      };
      BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26) break;
        }
        return r;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this.strip();
      };
      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this.strip();
      };
      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this.strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === 'number' && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 0x3ffffff;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 0x3ffffff >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === 'number' && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 0x3ffffff;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 0x3ffffff;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 0x3ffffff;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 0x3ffffff;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        var len = self.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 0x3ffffff;
        var carry = r / 0x4000000 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 0x3ffffff;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 0x4000000 | 0;
            rword = r & 0x3ffffff;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo(self, num, out) {
        var a = self.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 0x1fff;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 0x1fff;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 0x1fff;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 0x1fff;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 0x1fff;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 0x1fff;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 0x1fff;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 0x1fff;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 0x1fff;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 0x1fff;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 0x1fff;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 0x1fff;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 0x1fff;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 0x1fff;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 0x1fff;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 0x1fff;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 0x1fff;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 0x1fff;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 0x1fff;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 0x1fff;
        var bh9 = b9 >>> 13;
        out.negative = self.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 0x3ffffff;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 0x3ffffff;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 0x3ffffff;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 0x3ffffff;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 0x3ffffff;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 0x3ffffff;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 0x3ffffff;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 0x3ffffff;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 0x3ffffff;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 0x3ffffff;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 0x3ffffff;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 0x3ffffff;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 0x3ffffff;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 0x3ffffff;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 0x3ffffff;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 0x3ffffff;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 0x3ffffff;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 0x3ffffff;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 0x3ffffff;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        out.length = self.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 0x3ffffff;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 0x3ffffff;
            ncarry = ncarry + (r / 0x4000000 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 0x3ffffff;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 0x3ffffff;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1) return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1) return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 0x2000 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 0x3ffffff;
          if (w < 0x4000000) {
            carry = 0;
          } else {
            carry = w / 0x4000000 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 0x1fff;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 0x1fff;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert(carry === 0);
        assert((carry & ~0x1fff) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        assert(typeof num === 'number');
        assert(num < 0x4000000);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
          carry >>= 26;
          carry += w / 0x4000000 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 0x3ffffff;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0) return new BN(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0) break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0) continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === 'number' && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 0x3ffffff >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this.strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === 'number' && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {} else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === 'number' && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === 'number' && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, 'imaskn works only with positive numbers');
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === 'number');
        assert(num < 0x4000000);
        if (num < 0) return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
          this.words[i] -= 0x4000000;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === 'number');
        assert(num < 0x4000000);
        if (num < 0) return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 0x4000000;
            this.words[i + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 0x3ffffff;
          carry = (w >> 26) - (right / 0x4000000 | 0);
          this.words[i + shift] = w & 0x3ffffff;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 0x3ffffff;
        }
        if (carry === 0) return this.strip();
        assert(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 0x3ffffff;
        }
        this.negative = 1;
        return this.strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== 'mod') {
          q = new BN(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 0x4000000 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 0x3ffffff);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q.strip();
        }
        a.strip();
        if (mode !== 'div' && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== 'mod') {
            div = res.div.neg();
          }
          if (mode !== 'div') {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div: div,
            mod: mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== 'mod') {
            div = res.div.neg();
          }
          return {
            div: div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== 'div') {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod: mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === 'div') {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === 'mod') {
            return {
              div: null,
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, 'div', false).div;
      };
      BN.prototype.mod = function mod(num) {
        return this.divmod(num, 'mod', false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, 'mod', true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero()) return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modn = function modn(num) {
        assert(num <= 0x3ffffff);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return acc;
      };
      BN.prototype.idivn = function idivn(num) {
        assert(num <= 0x3ffffff);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 0x4000000;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        return this.strip();
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN(1);
        var B = new BN(0);
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === 'number');
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 0x3ffffff;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 0x3ffffff, 'Number is too big');
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b) continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, 'Already a number in reduction context');
        assert(this.negative === 0, 'red works only with positives');
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert(this.red, 'fromRed works only with numbers in reduction context');
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, 'Already a number in reduction context');
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, 'redAdd works only with red numbers');
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, 'redIAdd works only with red numbers');
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert(this.red, 'redSub works only with red numbers');
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert(this.red, 'redISub works only with red numbers');
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert(this.red, 'redShl works only with red numbers');
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert(this.red, 'redMul works only with red numbers');
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, 'redMul works only with red numbers');
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert(this.red, 'redSqr works only with red numbers');
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert(this.red, 'redISqr works only with red numbers');
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, 'redSqrt works only with red numbers');
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert(this.red, 'redInvm works only with red numbers');
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert(this.red, 'redNeg works only with red numbers');
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, 'redPow(normalNum)');
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          r.strip();
        }
        return r;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(this, 'k256', 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 0x3fffff;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 0x3d1;
          num.words[i] = lo & 0x3ffffff;
          lo = w * 0x40 + (lo / 0x4000000 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(this, 'p224', 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(this, 'p192', 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(this, '25519', '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 0x13 + carry;
          var lo = hi & 0x3ffffff;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name]) return primes[name];
        var prime;
        if (name === 'k256') {
          prime = new K256();
        } else if (name === 'p224') {
          prime = new P224();
        } else if (name === 'p192') {
          prime = new P192();
        } else if (name === 'p25519') {
          prime = new P25519();
        } else {
          throw new Error('Unknown prime ' + name);
        }
        primes[name] = prime;
        return prime;
      };
      function Red(m) {
        if (typeof m === 'string') {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), 'modulus must be greater than 1');
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, 'red works only with positives');
        assert(a.red, 'red works only with red numbers');
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, 'red works only with positives');
        assert(a.red && a.red === b.red, 'red works only with red numbers');
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime) return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero()) return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert(i < m);
          var b = this.pow(c, new BN(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num) {
        if (num.isZero()) return new BN(1);
        if (num.cmpn(1) === 0) return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === 'undefined' || module, this);
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic("1ee", ["260"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("260");
  return module.exports;
});
$__System.registerDynamic('21e', ['1ee', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    var bn = $__require('1ee');
    function withPublic(paddedMsg, key) {
      return new Buffer(paddedMsg.toRed(bn.mont(key.modulus)).redPow(new bn(key.publicExponent)).fromRed().toArray());
    }
    module.exports = withPublic;
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic('261', ['1fb', '21c', '21d', '1ee', '1f9', '1fe', '21e', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    var parseKeys = $__require('1fb');
    var mgf = $__require('21c');
    var xor = $__require('21d');
    var bn = $__require('1ee');
    var crt = $__require('1f9');
    var createHash = $__require('1fe');
    var withPublic = $__require('21e');
    module.exports = function privateDecrypt(private_key, enc, reverse) {
      var padding;
      if (private_key.padding) {
        padding = private_key.padding;
      } else if (reverse) {
        padding = 1;
      } else {
        padding = 4;
      }
      var key = parseKeys(private_key);
      var k = key.modulus.byteLength();
      if (enc.length > k || new bn(enc).cmp(key.modulus) >= 0) {
        throw new Error('decryption error');
      }
      var msg;
      if (reverse) {
        msg = withPublic(new bn(enc), key);
      } else {
        msg = crt(enc, key);
      }
      var zBuffer = new Buffer(k - msg.length);
      zBuffer.fill(0);
      msg = Buffer.concat([zBuffer, msg], k);
      if (padding === 4) {
        return oaep(key, msg);
      } else if (padding === 1) {
        return pkcs1(key, msg, reverse);
      } else if (padding === 3) {
        return msg;
      } else {
        throw new Error('unknown padding');
      }
    };
    function oaep(key, msg) {
      var n = key.modulus;
      var k = key.modulus.byteLength();
      var mLen = msg.length;
      var iHash = createHash('sha1').update(new Buffer('')).digest();
      var hLen = iHash.length;
      var hLen2 = 2 * hLen;
      if (msg[0] !== 0) {
        throw new Error('decryption error');
      }
      var maskedSeed = msg.slice(1, hLen + 1);
      var maskedDb = msg.slice(hLen + 1);
      var seed = xor(maskedSeed, mgf(maskedDb, hLen));
      var db = xor(maskedDb, mgf(seed, k - hLen - 1));
      if (compare(iHash, db.slice(0, hLen))) {
        throw new Error('decryption error');
      }
      var i = hLen;
      while (db[i] === 0) {
        i++;
      }
      if (db[i++] !== 1) {
        throw new Error('decryption error');
      }
      return db.slice(i);
    }
    function pkcs1(key, msg, reverse) {
      var p1 = msg.slice(0, 2);
      var i = 2;
      var status = 0;
      while (msg[i++] !== 0) {
        if (i >= msg.length) {
          status++;
          break;
        }
      }
      var ps = msg.slice(2, i - 1);
      var p2 = msg.slice(i - 1, i);
      if (p1.toString('hex') !== '0002' && !reverse || p1.toString('hex') !== '0001' && reverse) {
        status++;
      }
      if (ps.length < 8) {
        status++;
      }
      if (status) {
        throw new Error('decryption error');
      }
      return msg.slice(i);
    }
    function compare(a, b) {
      a = new Buffer(a);
      b = new Buffer(b);
      var dif = 0;
      var len = a.length;
      if (a.length !== b.length) {
        dif++;
        len = Math.min(a.length, b.length);
      }
      var i = -1;
      while (++i < len) {
        dif += a[i] ^ b[i];
      }
      return dif;
    }
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic('262', ['21b', '261'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  exports.publicEncrypt = $__require('21b');
  exports.privateDecrypt = $__require('261');
  exports.privateEncrypt = function privateEncrypt(key, buf) {
    return exports.publicEncrypt(key, buf, true);
  };
  exports.publicDecrypt = function publicDecrypt(key, buf) {
    return exports.privateDecrypt(key, buf, true);
  };
  return module.exports;
});
$__System.registerDynamic("263", ["262"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("262");
  return module.exports;
});
$__System.registerDynamic('264', ['1f1', '1fe', '1f8', '1f5', '24e', '1ea', '1f4', '1ff', '21a', '263'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = $__require('1f1');
  exports.createHash = exports.Hash = $__require('1fe');
  exports.createHmac = exports.Hmac = $__require('1f8');

  var hashes = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160'].concat(Object.keys($__require('1f5')));
  exports.getHashes = function () {
    return hashes;
  };

  var p = $__require('24e');
  exports.pbkdf2 = p.pbkdf2;
  exports.pbkdf2Sync = p.pbkdf2Sync;

  var aes = $__require('1ea');['Cipher', 'createCipher', 'Cipheriv', 'createCipheriv', 'Decipher', 'createDecipher', 'Decipheriv', 'createDecipheriv', 'getCiphers', 'listCiphers'].forEach(function (key) {
    exports[key] = aes[key];
  });

  var dh = $__require('1f4');['DiffieHellmanGroup', 'createDiffieHellmanGroup', 'getDiffieHellman', 'createDiffieHellman', 'DiffieHellman'].forEach(function (key) {
    exports[key] = dh[key];
  });

  var sign = $__require('1ff');['createSign', 'Sign', 'createVerify', 'Verify'].forEach(function (key) {
    exports[key] = sign[key];
  });

  exports.createECDH = $__require('21a');

  var publicEncrypt = $__require('263');['publicEncrypt', 'privateEncrypt', 'publicDecrypt', 'privateDecrypt'].forEach(function (key) {
    exports[key] = publicEncrypt[key];
  })

  // the least I can do is make error messages for the rest of the node.js/crypto api.
  ;['createCredentials'].forEach(function (name) {
    exports[name] = function () {
      throw new Error(['sorry, ' + name + ' is not implemented yet', 'we accept pull requests', 'https://github.com/crypto-browserify/crypto-browserify'].join('\n'));
    };
  });
  return module.exports;
});
$__System.registerDynamic("265", ["264"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("264");
  return module.exports;
});
$__System.registerDynamic('266', ['265'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  module.exports = $__System._nodeRequire ? $__System._nodeRequire('crypto') : $__require('265');
  return module.exports;
});
$__System.registerDynamic("38", ["266"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("266");
  return module.exports;
});
$__System.registerDynamic("1c2", ["1b6", "2a", "13"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer, process) {
    "use strict";

    var Long = $__require("1b6").Long;
    var _requestId = 0;
    var OP_QUERY = 2004;
    var OP_GETMORE = 2005;
    var OP_KILL_CURSORS = 2007;
    var OPTS_TAILABLE_CURSOR = 2;
    var OPTS_SLAVE = 4;
    var OPTS_OPLOG_REPLAY = 8;
    var OPTS_NO_CURSOR_TIMEOUT = 16;
    var OPTS_AWAIT_DATA = 32;
    var OPTS_EXHAUST = 64;
    var OPTS_PARTIAL = 128;
    var CURSOR_NOT_FOUND = 0;
    var QUERY_FAILURE = 2;
    var SHARD_CONFIG_STALE = 4;
    var AWAIT_CAPABLE = 8;
    var Query = function (bson, ns, query, options) {
      var self = this;
      if (ns == null) throw new Error("ns must be specified for query");
      if (query == null) throw new Error("query must be specified for query");
      if (!!~ns.indexOf("\x00")) {
        throw new Error("namespace cannot contain a null character");
      }
      this.bson = bson;
      this.ns = ns;
      this.query = query;
      this.options = options || {};
      this.numberToSkip = options.numberToSkip || 0;
      this.numberToReturn = options.numberToReturn || 0;
      this.returnFieldSelector = options.returnFieldSelector || null;
      this.requestId = Query.getRequestId();
      this.serializeFunctions = typeof options.serializeFunctions == 'boolean' ? options.serializeFunctions : false;
      this.ignoreUndefined = typeof options.ignoreUndefined == 'boolean' ? options.ignoreUndefined : false;
      this.maxBsonSize = options.maxBsonSize || 1024 * 1024 * 16;
      this.checkKeys = typeof options.checkKeys == 'boolean' ? options.checkKeys : true;
      this.batchSize = self.numberToReturn;
      this.tailable = false;
      this.slaveOk = typeof options.slaveOk == 'boolean' ? options.slaveOk : false;
      this.oplogReplay = false;
      this.noCursorTimeout = false;
      this.awaitData = false;
      this.exhaust = false;
      this.partial = false;
    };
    Query.prototype.incRequestId = function () {
      this.requestId = _requestId++;
    };
    Query.nextRequestId = function () {
      return _requestId + 1;
    };
    Query.prototype.toBin = function () {
      var self = this;
      var buffers = [];
      var projection = null;
      var flags = 0;
      if (this.tailable) {
        flags |= OPTS_TAILABLE_CURSOR;
      }
      if (this.slaveOk) {
        flags |= OPTS_SLAVE;
      }
      if (this.oplogReplay) {
        flags |= OPTS_OPLOG_REPLAY;
      }
      if (this.noCursorTimeout) {
        flags |= OPTS_NO_CURSOR_TIMEOUT;
      }
      if (this.awaitData) {
        flags |= OPTS_AWAIT_DATA;
      }
      if (this.exhaust) {
        flags |= OPTS_EXHAUST;
      }
      if (this.partial) {
        flags |= OPTS_PARTIAL;
      }
      if (self.batchSize != self.numberToReturn) self.numberToReturn = self.batchSize;
      var header = new Buffer(4 * 4 + 4 + Buffer.byteLength(self.ns) + 1 + 4 + 4);
      buffers.push(header);
      var query = self.bson.serialize(this.query, this.checkKeys, true, this.serializeFunctions, 0, this.ignoreUndefined);
      buffers.push(query);
      if (self.returnFieldSelector && Object.keys(self.returnFieldSelector).length > 0) {
        projection = self.bson.serialize(this.returnFieldSelector, this.checkKeys, true, this.serializeFunctions, this.ignoreUndefined);
        buffers.push(projection);
      }
      var totalLength = header.length + query.length + (projection ? projection.length : 0);
      var index = 4;
      header[3] = totalLength >> 24 & 0xff;
      header[2] = totalLength >> 16 & 0xff;
      header[1] = totalLength >> 8 & 0xff;
      header[0] = totalLength & 0xff;
      header[index + 3] = this.requestId >> 24 & 0xff;
      header[index + 2] = this.requestId >> 16 & 0xff;
      header[index + 1] = this.requestId >> 8 & 0xff;
      header[index] = this.requestId & 0xff;
      index = index + 4;
      header[index + 3] = 0 >> 24 & 0xff;
      header[index + 2] = 0 >> 16 & 0xff;
      header[index + 1] = 0 >> 8 & 0xff;
      header[index] = 0 & 0xff;
      index = index + 4;
      header[index + 3] = OP_QUERY >> 24 & 0xff;
      header[index + 2] = OP_QUERY >> 16 & 0xff;
      header[index + 1] = OP_QUERY >> 8 & 0xff;
      header[index] = OP_QUERY & 0xff;
      index = index + 4;
      header[index + 3] = flags >> 24 & 0xff;
      header[index + 2] = flags >> 16 & 0xff;
      header[index + 1] = flags >> 8 & 0xff;
      header[index] = flags & 0xff;
      index = index + 4;
      index = index + header.write(this.ns, index, 'utf8') + 1;
      header[index - 1] = 0;
      header[index + 3] = this.numberToSkip >> 24 & 0xff;
      header[index + 2] = this.numberToSkip >> 16 & 0xff;
      header[index + 1] = this.numberToSkip >> 8 & 0xff;
      header[index] = this.numberToSkip & 0xff;
      index = index + 4;
      header[index + 3] = this.numberToReturn >> 24 & 0xff;
      header[index + 2] = this.numberToReturn >> 16 & 0xff;
      header[index + 1] = this.numberToReturn >> 8 & 0xff;
      header[index] = this.numberToReturn & 0xff;
      index = index + 4;
      return buffers;
    };
    Query.getRequestId = function () {
      return ++_requestId;
    };
    var GetMore = function (bson, ns, cursorId, opts) {
      opts = opts || {};
      this.numberToReturn = opts.numberToReturn || 0;
      this.requestId = _requestId++;
      this.bson = bson;
      this.ns = ns;
      this.cursorId = cursorId;
    };
    GetMore.prototype.toBin = function () {
      var length = 4 + Buffer.byteLength(this.ns) + 1 + 4 + 8 + 4 * 4;
      var index = 0;
      var _buffer = new Buffer(length);
      _buffer[index + 3] = length >> 24 & 0xff;
      _buffer[index + 2] = length >> 16 & 0xff;
      _buffer[index + 1] = length >> 8 & 0xff;
      _buffer[index] = length & 0xff;
      index = index + 4;
      _buffer[index + 3] = this.requestId >> 24 & 0xff;
      _buffer[index + 2] = this.requestId >> 16 & 0xff;
      _buffer[index + 1] = this.requestId >> 8 & 0xff;
      _buffer[index] = this.requestId & 0xff;
      index = index + 4;
      _buffer[index + 3] = 0 >> 24 & 0xff;
      _buffer[index + 2] = 0 >> 16 & 0xff;
      _buffer[index + 1] = 0 >> 8 & 0xff;
      _buffer[index] = 0 & 0xff;
      index = index + 4;
      _buffer[index + 3] = OP_GETMORE >> 24 & 0xff;
      _buffer[index + 2] = OP_GETMORE >> 16 & 0xff;
      _buffer[index + 1] = OP_GETMORE >> 8 & 0xff;
      _buffer[index] = OP_GETMORE & 0xff;
      index = index + 4;
      _buffer[index + 3] = 0 >> 24 & 0xff;
      _buffer[index + 2] = 0 >> 16 & 0xff;
      _buffer[index + 1] = 0 >> 8 & 0xff;
      _buffer[index] = 0 & 0xff;
      index = index + 4;
      index = index + _buffer.write(this.ns, index, 'utf8') + 1;
      _buffer[index - 1] = 0;
      _buffer[index + 3] = this.numberToReturn >> 24 & 0xff;
      _buffer[index + 2] = this.numberToReturn >> 16 & 0xff;
      _buffer[index + 1] = this.numberToReturn >> 8 & 0xff;
      _buffer[index] = this.numberToReturn & 0xff;
      index = index + 4;
      _buffer[index + 3] = this.cursorId.getLowBits() >> 24 & 0xff;
      _buffer[index + 2] = this.cursorId.getLowBits() >> 16 & 0xff;
      _buffer[index + 1] = this.cursorId.getLowBits() >> 8 & 0xff;
      _buffer[index] = this.cursorId.getLowBits() & 0xff;
      index = index + 4;
      _buffer[index + 3] = this.cursorId.getHighBits() >> 24 & 0xff;
      _buffer[index + 2] = this.cursorId.getHighBits() >> 16 & 0xff;
      _buffer[index + 1] = this.cursorId.getHighBits() >> 8 & 0xff;
      _buffer[index] = this.cursorId.getHighBits() & 0xff;
      index = index + 4;
      return _buffer;
    };
    var KillCursor = function (bson, cursorIds) {
      this.requestId = _requestId++;
      this.cursorIds = cursorIds;
    };
    KillCursor.prototype.toBin = function () {
      var length = 4 + 4 + 4 * 4 + this.cursorIds.length * 8;
      var index = 0;
      var _buffer = new Buffer(length);
      _buffer[index + 3] = length >> 24 & 0xff;
      _buffer[index + 2] = length >> 16 & 0xff;
      _buffer[index + 1] = length >> 8 & 0xff;
      _buffer[index] = length & 0xff;
      index = index + 4;
      _buffer[index + 3] = this.requestId >> 24 & 0xff;
      _buffer[index + 2] = this.requestId >> 16 & 0xff;
      _buffer[index + 1] = this.requestId >> 8 & 0xff;
      _buffer[index] = this.requestId & 0xff;
      index = index + 4;
      _buffer[index + 3] = 0 >> 24 & 0xff;
      _buffer[index + 2] = 0 >> 16 & 0xff;
      _buffer[index + 1] = 0 >> 8 & 0xff;
      _buffer[index] = 0 & 0xff;
      index = index + 4;
      _buffer[index + 3] = OP_KILL_CURSORS >> 24 & 0xff;
      _buffer[index + 2] = OP_KILL_CURSORS >> 16 & 0xff;
      _buffer[index + 1] = OP_KILL_CURSORS >> 8 & 0xff;
      _buffer[index] = OP_KILL_CURSORS & 0xff;
      index = index + 4;
      _buffer[index + 3] = 0 >> 24 & 0xff;
      _buffer[index + 2] = 0 >> 16 & 0xff;
      _buffer[index + 1] = 0 >> 8 & 0xff;
      _buffer[index] = 0 & 0xff;
      index = index + 4;
      _buffer[index + 3] = this.cursorIds.length >> 24 & 0xff;
      _buffer[index + 2] = this.cursorIds.length >> 16 & 0xff;
      _buffer[index + 1] = this.cursorIds.length >> 8 & 0xff;
      _buffer[index] = this.cursorIds.length & 0xff;
      index = index + 4;
      for (var i = 0; i < this.cursorIds.length; i++) {
        _buffer[index + 3] = this.cursorIds[i].getLowBits() >> 24 & 0xff;
        _buffer[index + 2] = this.cursorIds[i].getLowBits() >> 16 & 0xff;
        _buffer[index + 1] = this.cursorIds[i].getLowBits() >> 8 & 0xff;
        _buffer[index] = this.cursorIds[i].getLowBits() & 0xff;
        index = index + 4;
        _buffer[index + 3] = this.cursorIds[i].getHighBits() >> 24 & 0xff;
        _buffer[index + 2] = this.cursorIds[i].getHighBits() >> 16 & 0xff;
        _buffer[index + 1] = this.cursorIds[i].getHighBits() >> 8 & 0xff;
        _buffer[index] = this.cursorIds[i].getHighBits() & 0xff;
        index = index + 4;
      }
      return _buffer;
    };
    var Response = function (bson, data, opts) {
      opts = opts || {
        promoteLongs: true,
        promoteValues: true,
        promoteBuffers: false
      };
      this.parsed = false;
      this.index = 0;
      this.raw = data;
      this.data = data;
      this.bson = bson;
      this.opts = opts;
      this.length = data[this.index] | data[this.index + 1] << 8 | data[this.index + 2] << 16 | data[this.index + 3] << 24;
      this.index = this.index + 4;
      this.requestId = data[this.index] | data[this.index + 1] << 8 | data[this.index + 2] << 16 | data[this.index + 3] << 24;
      this.index = this.index + 4;
      this.responseTo = data[this.index] | data[this.index + 1] << 8 | data[this.index + 2] << 16 | data[this.index + 3] << 24;
      this.index = this.index + 4;
      this.index = this.index + 4;
      this.responseFlags = data[this.index] | data[this.index + 1] << 8 | data[this.index + 2] << 16 | data[this.index + 3] << 24;
      this.index = this.index + 4;
      var lowBits = data[this.index] | data[this.index + 1] << 8 | data[this.index + 2] << 16 | data[this.index + 3] << 24;
      this.index = this.index + 4;
      var highBits = data[this.index] | data[this.index + 1] << 8 | data[this.index + 2] << 16 | data[this.index + 3] << 24;
      this.index = this.index + 4;
      this.cursorId = new Long(lowBits, highBits);
      this.startingFrom = data[this.index] | data[this.index + 1] << 8 | data[this.index + 2] << 16 | data[this.index + 3] << 24;
      this.index = this.index + 4;
      this.numberReturned = data[this.index] | data[this.index + 1] << 8 | data[this.index + 2] << 16 | data[this.index + 3] << 24;
      this.index = this.index + 4;
      this.documents = new Array(this.numberReturned);
      this.cursorNotFound = (this.responseFlags & CURSOR_NOT_FOUND) != 0;
      this.queryFailure = (this.responseFlags & QUERY_FAILURE) != 0;
      this.shardConfigStale = (this.responseFlags & SHARD_CONFIG_STALE) != 0;
      this.awaitCapable = (this.responseFlags & AWAIT_CAPABLE) != 0;
      this.promoteLongs = typeof opts.promoteLongs == 'boolean' ? opts.promoteLongs : true;
      this.promoteValues = typeof opts.promoteValues == 'boolean' ? opts.promoteValues : true;
      this.promoteBuffers = typeof opts.promoteBuffers == 'boolean' ? opts.promoteBuffers : false;
    };
    Response.prototype.isParsed = function () {
      return this.parsed;
    };
    Response.prototype.parse = function (options) {
      if (this.parsed) return;
      options = options || {};
      var raw = options.raw || false;
      var documentsReturnedIn = options.documentsReturnedIn || null;
      var promoteLongs = typeof options.promoteLongs == 'boolean' ? options.promoteLongs : this.opts.promoteLongs;
      var promoteValues = typeof options.promoteValues == 'boolean' ? options.promoteValues : this.opts.promoteValues;
      var promoteBuffers = typeof options.promoteBuffers == 'boolean' ? options.promoteBuffers : this.opts.promoteBuffers;
      var bsonSize, _options;
      if (this.numberReturned == 1 && documentsReturnedIn != null && raw) {
        bsonSize = this.data[this.index] | this.data[this.index + 1] << 8 | this.data[this.index + 2] << 16 | this.data[this.index + 3] << 24;
        var document = this.data.slice(this.index, this.index + bsonSize);
        var fieldsAsRaw = {};
        fieldsAsRaw[documentsReturnedIn] = true;
        _options = {
          promoteLongs: promoteLongs,
          promoteValues: promoteValues,
          promoteBuffers: promoteBuffers,
          fieldsAsRaw: fieldsAsRaw
        };
        var doc = this.bson.deserialize(document, _options);
        this.documents = doc.cursor[documentsReturnedIn];
        this.numberReturned = this.documents.length;
        this.cursorId = typeof doc.cursor.id == 'number' ? Long.fromNumber(doc.cursor.id) : doc.cursor.id;
        this.index = this.index + bsonSize;
        this.parsed = true;
        return;
      }
      for (var i = 0; i < this.numberReturned; i++) {
        bsonSize = this.data[this.index] | this.data[this.index + 1] << 8 | this.data[this.index + 2] << 16 | this.data[this.index + 3] << 24;
        _options = {
          promoteLongs: promoteLongs,
          promoteValues: promoteValues,
          promoteBuffers: promoteBuffers
        };
        if (raw) {
          this.documents[i] = this.data.slice(this.index, this.index + bsonSize);
        } else {
          this.documents[i] = this.bson.deserialize(this.data.slice(this.index, this.index + bsonSize), _options);
        }
        this.index = this.index + bsonSize;
      }
      this.parsed = true;
    };
    module.exports = {
      Query: Query,
      GetMore: GetMore,
      Response: Response,
      KillCursor: KillCursor
    };
  })($__require("2a").Buffer, $__require("13"));
  return module.exports;
});
$__System.registerDynamic('267', ['268', '166', '269', '26a', '26b', '26c', '26d', '26e', '26f', '270', '271', '272', '273', '274', '275', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    "use strict";

    var readIEEE754 = $__require('268').readIEEE754,
        f = $__require('166').format,
        Long = $__require('269').Long,
        Double = $__require('26a').Double,
        Timestamp = $__require('26b').Timestamp,
        ObjectID = $__require('26c').ObjectID,
        Symbol = $__require('26d').Symbol,
        Code = $__require('26e').Code,
        MinKey = $__require('26f').MinKey,
        MaxKey = $__require('270').MaxKey,
        Decimal128 = $__require('271'),
        Int32 = $__require('272'),
        DBRef = $__require('273').DBRef,
        BSONRegExp = $__require('274').BSONRegExp,
        Binary = $__require('275').Binary;
    var deserialize = function (buffer, options, isArray) {
      options = options == null ? {} : options;
      var index = options && options.index ? options.index : 0;
      var size = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
      if (size < 5 || buffer.length < size || size + index > buffer.length) {
        throw new Error("corrupt bson message");
      }
      if (buffer[index + size - 1] != 0) {
        throw new Error("One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00");
      }
      return deserializeObject(buffer, index, options, isArray);
    };
    var deserializeObject = function (buffer, index, options, isArray) {
      var evalFunctions = options['evalFunctions'] == null ? false : options['evalFunctions'];
      var cacheFunctions = options['cacheFunctions'] == null ? false : options['cacheFunctions'];
      var cacheFunctionsCrc32 = options['cacheFunctionsCrc32'] == null ? false : options['cacheFunctionsCrc32'];
      var fieldsAsRaw = options['fieldsAsRaw'] == null ? null : options['fieldsAsRaw'];
      var raw = options['raw'] == null ? false : options['raw'];
      var bsonRegExp = typeof options['bsonRegExp'] == 'boolean' ? options['bsonRegExp'] : false;
      var promoteBuffers = options['promoteBuffers'] == null ? false : options['promoteBuffers'];
      var promoteLongs = options['promoteLongs'] == null ? true : options['promoteLongs'];
      var promoteValues = options['promoteValues'] == null ? true : options['promoteValues'];
      var startIndex = index;
      if (buffer.length < 5) throw new Error("corrupt bson message < 5 bytes long");
      var size = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
      if (size < 5 || size > buffer.length) throw new Error("corrupt bson message");
      var object = isArray ? [] : {};
      var arrayIndex = 0;
      while (true) {
        var elementType = buffer[index++];
        if (elementType == 0) {
          break;
        }
        var i = index;
        while (buffer[i] !== 0x00 && i < buffer.length) {
          i++;
        }
        if (i >= buffer.length) throw new Error("Bad BSON Document: illegal CString");
        var name = isArray ? arrayIndex++ : buffer.toString('utf8', index, i);
        index = i + 1;
        if (elementType == BSON.BSON_DATA_STRING) {
          var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] != 0) throw new Error("bad string length in bson");
          object[name] = buffer.toString('utf8', index, index + stringSize - 1);
          index = index + stringSize;
        } else if (elementType == BSON.BSON_DATA_OID) {
          var oid = new Buffer(12);
          buffer.copy(oid, 0, index, index + 12);
          object[name] = new ObjectID(oid);
          index = index + 12;
        } else if (elementType == BSON.BSON_DATA_INT && promoteValues == false) {
          object[name] = new Int32(buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24);
        } else if (elementType == BSON.BSON_DATA_INT) {
          object[name] = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        } else if (elementType == BSON.BSON_DATA_NUMBER && promoteValues == false) {
          object[name] = new Double(buffer.readDoubleLE(index));
          index = index + 8;
        } else if (elementType == BSON.BSON_DATA_NUMBER) {
          object[name] = buffer.readDoubleLE(index);
          index = index + 8;
        } else if (elementType == BSON.BSON_DATA_DATE) {
          var lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          var highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          object[name] = new Date(new Long(lowBits, highBits).toNumber());
        } else if (elementType == BSON.BSON_DATA_BOOLEAN) {
          if (buffer[index] != 0 && buffer[index] != 1) throw new Error('illegal boolean type value');
          object[name] = buffer[index++] == 1;
        } else if (elementType == BSON.BSON_DATA_OBJECT) {
          var _index = index;
          var objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
          if (objectSize <= 0 || objectSize > buffer.length - index) throw new Error("bad embedded document length in bson");
          if (raw) {
            object[name] = buffer.slice(index, index + objectSize);
          } else {
            object[name] = deserializeObject(buffer, _index, options, false);
          }
          index = index + objectSize;
        } else if (elementType == BSON.BSON_DATA_ARRAY) {
          var _index = index;
          var objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
          var arrayOptions = options;
          var stopIndex = index + objectSize;
          if (fieldsAsRaw && fieldsAsRaw[name]) {
            arrayOptions = {};
            for (var n in options) arrayOptions[n] = options[n];
            arrayOptions['raw'] = true;
          }
          object[name] = deserializeObject(buffer, _index, arrayOptions, true);
          index = index + objectSize;
          if (buffer[index - 1] != 0) throw new Error('invalid array terminator byte');
          if (index != stopIndex) throw new Error('corrupted array bson');
        } else if (elementType == BSON.BSON_DATA_UNDEFINED) {
          object[name] = undefined;
        } else if (elementType == BSON.BSON_DATA_NULL) {
          object[name] = null;
        } else if (elementType == BSON.BSON_DATA_LONG) {
          var lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          var highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          var long = new Long(lowBits, highBits);
          if (promoteLongs && promoteValues == true) {
            object[name] = long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG) ? long.toNumber() : long;
          } else {
            object[name] = long;
          }
        } else if (elementType == BSON.BSON_DATA_DECIMAL128) {
          var bytes = new Buffer(16);
          buffer.copy(bytes, 0, index, index + 16);
          index = index + 16;
          var decimal128 = new Decimal128(bytes);
          object[name] = decimal128.toObject ? decimal128.toObject() : decimal128;
        } else if (elementType == BSON.BSON_DATA_BINARY) {
          var binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          var totalBinarySize = binarySize;
          var subType = buffer[index++];
          if (binarySize < 0) throw new Error('Negative binary type element size found');
          if (binarySize > buffer.length) throw new Error('Binary type size larger than document size');
          if (buffer['slice'] != null) {
            if (subType == Binary.SUBTYPE_BYTE_ARRAY) {
              binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
              if (binarySize < 0) throw new Error('Negative binary type element size found for subtype 0x02');
              if (binarySize > totalBinarySize - 4) throw new Error('Binary type with subtype 0x02 contains to long binary size');
              if (binarySize < totalBinarySize - 4) throw new Error('Binary type with subtype 0x02 contains to short binary size');
            }
            if (promoteBuffers && promoteValues) {
              object[name] = buffer.slice(index, index + binarySize);
            } else {
              object[name] = new Binary(buffer.slice(index, index + binarySize), subType);
            }
          } else {
            var _buffer = typeof Uint8Array != 'undefined' ? new Uint8Array(new ArrayBuffer(binarySize)) : new Array(binarySize);
            if (subType == Binary.SUBTYPE_BYTE_ARRAY) {
              binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
              if (binarySize < 0) throw new Error('Negative binary type element size found for subtype 0x02');
              if (binarySize > totalBinarySize - 4) throw new Error('Binary type with subtype 0x02 contains to long binary size');
              if (binarySize < totalBinarySize - 4) throw new Error('Binary type with subtype 0x02 contains to short binary size');
            }
            for (var i = 0; i < binarySize; i++) {
              _buffer[i] = buffer[index + i];
            }
            if (promoteBuffers && promoteValues) {
              object[name] = _buffer;
            } else {
              object[name] = new Binary(_buffer, subType);
            }
          }
          index = index + binarySize;
        } else if (elementType == BSON.BSON_DATA_REGEXP && bsonRegExp == false) {
          var i = index;
          while (buffer[i] !== 0x00 && i < buffer.length) {
            i++;
          }
          if (i >= buffer.length) throw new Error("Bad BSON Document: illegal CString");
          var source = buffer.toString('utf8', index, i);
          index = i + 1;
          var i = index;
          while (buffer[i] !== 0x00 && i < buffer.length) {
            i++;
          }
          if (i >= buffer.length) throw new Error("Bad BSON Document: illegal CString");
          var regExpOptions = buffer.toString('utf8', index, i);
          index = i + 1;
          var optionsArray = new Array(regExpOptions.length);
          for (var i = 0; i < regExpOptions.length; i++) {
            switch (regExpOptions[i]) {
              case 'm':
                optionsArray[i] = 'm';
                break;
              case 's':
                optionsArray[i] = 'g';
                break;
              case 'i':
                optionsArray[i] = 'i';
                break;
            }
          }
          object[name] = new RegExp(source, optionsArray.join(''));
        } else if (elementType == BSON.BSON_DATA_REGEXP && bsonRegExp == true) {
          var i = index;
          while (buffer[i] !== 0x00 && i < buffer.length) {
            i++;
          }
          if (i >= buffer.length) throw new Error("Bad BSON Document: illegal CString");
          var source = buffer.toString('utf8', index, i);
          index = i + 1;
          var i = index;
          while (buffer[i] !== 0x00 && i < buffer.length) {
            i++;
          }
          if (i >= buffer.length) throw new Error("Bad BSON Document: illegal CString");
          var regExpOptions = buffer.toString('utf8', index, i);
          index = i + 1;
          object[name] = new BSONRegExp(source, regExpOptions);
        } else if (elementType == BSON.BSON_DATA_SYMBOL) {
          var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] != 0) throw new Error("bad string length in bson");
          object[name] = new Symbol(buffer.toString('utf8', index, index + stringSize - 1));
          index = index + stringSize;
        } else if (elementType == BSON.BSON_DATA_TIMESTAMP) {
          var lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          var highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          object[name] = new Timestamp(lowBits, highBits);
        } else if (elementType == BSON.BSON_DATA_MIN_KEY) {
          object[name] = new MinKey();
        } else if (elementType == BSON.BSON_DATA_MAX_KEY) {
          object[name] = new MaxKey();
        } else if (elementType == BSON.BSON_DATA_CODE) {
          var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] != 0) throw new Error("bad string length in bson");
          var functionString = buffer.toString('utf8', index, index + stringSize - 1);
          if (evalFunctions) {
            var value = null;
            if (cacheFunctions) {
              var hash = cacheFunctionsCrc32 ? crc32(functionString) : functionString;
              object[name] = isolateEvalWithHash(functionCache, hash, functionString, object);
            } else {
              object[name] = isolateEval(functionString);
            }
          } else {
            object[name] = new Code(functionString);
          }
          index = index + stringSize;
        } else if (elementType == BSON.BSON_DATA_CODE_W_SCOPE) {
          var totalSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          if (totalSize < 4 + 4 + 4 + 1) {
            throw new Error("code_w_scope total size shorter minimum expected length");
          }
          var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] != 0) throw new Error("bad string length in bson");
          var functionString = buffer.toString('utf8', index, index + stringSize - 1);
          index = index + stringSize;
          var _index = index;
          var objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
          var scopeObject = deserializeObject(buffer, _index, options, false);
          index = index + objectSize;
          if (totalSize < 4 + 4 + objectSize + stringSize) {
            throw new Error('code_w_scope total size is to short, truncating scope');
          }
          if (totalSize > 4 + 4 + objectSize + stringSize) {
            throw new Error('code_w_scope total size is to long, clips outer document');
          }
          if (evalFunctions) {
            var value = null;
            if (cacheFunctions) {
              var hash = cacheFunctionsCrc32 ? crc32(functionString) : functionString;
              object[name] = isolateEvalWithHash(functionCache, hash, functionString, object);
            } else {
              object[name] = isolateEval(functionString);
            }
            object[name].scope = scopeObject;
          } else {
            object[name] = new Code(functionString, scopeObject);
          }
        } else if (elementType == BSON_DATA_DBPOINTER) {
          var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] != 0) throw new Error("bad string length in bson");
          var namespace = buffer.toString('utf8', index, index + stringSize - 1);
          index = index + stringSize;
          var oidBuffer = new Buffer(12);
          buffer.copy(oidBuffer, 0, index, index + 12);
          var oid = new ObjectID(oidBuffer);
          index = index + 12;
          var parts = namespace.split('.');
          var db = parts.shift();
          var collection = parts.join('.');
          object[name] = new DBRef(collection, oid, db);
        } else {
          throw new Error("Detected unknown BSON type " + elementType.toString(16) + " for fieldname \"" + name + "\", are you using the latest BSON parser");
        }
      }
      if (size != index - startIndex) {
        if (isArray) throw new Error('corrupt array bson');
        throw new Error('corrupt object bson');
      }
      if (object['$id'] != null) object = new DBRef(object['$ref'], object['$id'], object['$db']);
      return object;
    };
    var isolateEvalWithHash = function (functionCache, hash, functionString, object) {
      var value = null;
      if (functionCache[hash] == null) {
        eval("value = " + functionString);
        functionCache[hash] = value;
      }
      return functionCache[hash].bind(object);
    };
    var isolateEval = function (functionString) {
      var value = null;
      eval("value = " + functionString);
      return value;
    };
    var BSON = {};
    var functionCache = BSON.functionCache = {};
    BSON.BSON_DATA_NUMBER = 1;
    BSON.BSON_DATA_STRING = 2;
    BSON.BSON_DATA_OBJECT = 3;
    BSON.BSON_DATA_ARRAY = 4;
    BSON.BSON_DATA_BINARY = 5;
    BSON.BSON_DATA_UNDEFINED = 6;
    BSON.BSON_DATA_OID = 7;
    BSON.BSON_DATA_BOOLEAN = 8;
    BSON.BSON_DATA_DATE = 9;
    BSON.BSON_DATA_NULL = 10;
    BSON.BSON_DATA_REGEXP = 11;
    BSON.BSON_DATA_DBPOINTER = 12;
    BSON.BSON_DATA_CODE = 13;
    BSON.BSON_DATA_SYMBOL = 14;
    BSON.BSON_DATA_CODE_W_SCOPE = 15;
    BSON.BSON_DATA_INT = 16;
    BSON.BSON_DATA_TIMESTAMP = 17;
    BSON.BSON_DATA_LONG = 18;
    BSON.BSON_DATA_DECIMAL128 = 19;
    BSON.BSON_DATA_MIN_KEY = 0xff;
    BSON.BSON_DATA_MAX_KEY = 0x7f;
    BSON.BSON_BINARY_SUBTYPE_DEFAULT = 0;
    BSON.BSON_BINARY_SUBTYPE_FUNCTION = 1;
    BSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;
    BSON.BSON_BINARY_SUBTYPE_UUID = 3;
    BSON.BSON_BINARY_SUBTYPE_MD5 = 4;
    BSON.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;
    BSON.BSON_INT32_MAX = 0x7FFFFFFF;
    BSON.BSON_INT32_MIN = -0x80000000;
    BSON.BSON_INT64_MAX = Math.pow(2, 63) - 1;
    BSON.BSON_INT64_MIN = -Math.pow(2, 63);
    BSON.JS_INT_MAX = 0x20000000000000;
    BSON.JS_INT_MIN = -0x20000000000000;
    var JS_INT_MAX_LONG = Long.fromNumber(0x20000000000000);
    var JS_INT_MIN_LONG = Long.fromNumber(-0x20000000000000);
    module.exports = deserialize;
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic('276', [], true, function ($__require, exports, module) {
  /* */
  "use strict";

  // We have an ES6 Map available, return the native instance

  var define,
      global = this || self,
      GLOBAL = global;
  if (typeof global.Map !== 'undefined') {
    module.exports = global.Map;
    module.exports.Map = global.Map;
  } else {
    // We will return a polyfill
    var Map = function (array) {
      this._keys = [];
      this._values = {};

      for (var i = 0; i < array.length; i++) {
        if (array[i] == null) continue; // skip null and undefined
        var entry = array[i];
        var key = entry[0];
        var value = entry[1];
        // Add the key to the list of keys in order
        this._keys.push(key);
        // Add the key and value to the values dictionary with a point
        // to the location in the ordered keys list
        this._values[key] = { v: value, i: this._keys.length - 1 };
      }
    };

    Map.prototype.clear = function () {
      this._keys = [];
      this._values = {};
    };

    Map.prototype.delete = function (key) {
      var value = this._values[key];
      if (value == null) return false;
      // Delete entry
      delete this._values[key];
      // Remove the key from the ordered keys list
      this._keys.splice(value.i, 1);
      return true;
    };

    Map.prototype.entries = function () {
      var self = this;
      var index = 0;

      return {
        next: function () {
          var key = self._keys[index++];
          return {
            value: key !== undefined ? [key, self._values[key].v] : undefined,
            done: key !== undefined ? false : true
          };
        }
      };
    };

    Map.prototype.forEach = function (callback, self) {
      self = self || this;

      for (var i = 0; i < this._keys.length; i++) {
        var key = this._keys[i];
        // Call the forEach callback
        callback.call(self, this._values[key].v, key, self);
      }
    };

    Map.prototype.get = function (key) {
      return this._values[key] ? this._values[key].v : undefined;
    };

    Map.prototype.has = function (key) {
      return this._values[key] != null;
    };

    Map.prototype.keys = function (key) {
      var self = this;
      var index = 0;

      return {
        next: function () {
          var key = self._keys[index++];
          return {
            value: key !== undefined ? key : undefined,
            done: key !== undefined ? false : true
          };
        }
      };
    };

    Map.prototype.set = function (key, value) {
      if (this._values[key]) {
        this._values[key].v = value;
        return this;
      }

      // Add the key to the list of keys in order
      this._keys.push(key);
      // Add the key and value to the values dictionary with a point
      // to the location in the ordered keys list
      this._values[key] = { v: value, i: this._keys.length - 1 };
      return this;
    };

    Map.prototype.values = function (key, value) {
      var self = this;
      var index = 0;

      return {
        next: function () {
          var key = self._keys[index++];
          return {
            value: key !== undefined ? self._values[key].v : undefined,
            done: key !== undefined ? false : true
          };
        }
      };
    };

    // Last ismaster
    Object.defineProperty(Map.prototype, 'size', {
      enumerable: true,
      get: function () {
        return this._keys.length;
      }
    });

    module.exports = Map;
    module.exports.Map = Map;
  }
  return module.exports;
});
$__System.registerDynamic('272', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var Int32 = function (value) {
    if (!(this instanceof Int32)) return new Int32(value);

    this._bsontype = 'Int32';
    this.value = value;
  };

  /**
   * Access the number value.
   *
   * @method
   * @return {number} returns the wrapped int32 number.
   */
  Int32.prototype.valueOf = function () {
    return this.value;
  };

  /**
   * @ignore
   */
  Int32.prototype.toJSON = function () {
    return this.value;
  };

  module.exports = Int32;
  module.exports.Int32 = Int32;
  return module.exports;
});
$__System.registerDynamic('277', ['268', '269', '276', '26a', '26b', '26c', '26d', '26e', '274', '272', '26f', '270', '271', '273', '275', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    "use strict";

    var writeIEEE754 = $__require('268').writeIEEE754,
        readIEEE754 = $__require('268').readIEEE754,
        Long = $__require('269').Long,
        Map = $__require('276'),
        Double = $__require('26a').Double,
        Timestamp = $__require('26b').Timestamp,
        ObjectID = $__require('26c').ObjectID,
        Symbol = $__require('26d').Symbol,
        Code = $__require('26e').Code,
        BSONRegExp = $__require('274').BSONRegExp,
        Int32 = $__require('272').Int32,
        MinKey = $__require('26f').MinKey,
        MaxKey = $__require('270').MaxKey,
        Decimal128 = $__require('271'),
        DBRef = $__require('273').DBRef,
        Binary = $__require('275').Binary;
    try {
      var _Buffer = Uint8Array;
    } catch (e) {
      var _Buffer = Buffer;
    }
    var regexp = /\x00/;
    var isDate = function isDate(d) {
      return typeof d === 'object' && Object.prototype.toString.call(d) === '[object Date]';
    };
    var isRegExp = function isRegExp(d) {
      return Object.prototype.toString.call(d) === '[object RegExp]';
    };
    var serializeString = function (buffer, key, value, index, isArray) {
      buffer[index++] = BSON.BSON_DATA_STRING;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
      index = index + numberOfWrittenBytes + 1;
      buffer[index - 1] = 0;
      var size = buffer.write(value, index + 4, 'utf8');
      buffer[index + 3] = size + 1 >> 24 & 0xff;
      buffer[index + 2] = size + 1 >> 16 & 0xff;
      buffer[index + 1] = size + 1 >> 8 & 0xff;
      buffer[index] = size + 1 & 0xff;
      index = index + 4 + size;
      buffer[index++] = 0;
      return index;
    };
    var serializeNumber = function (buffer, key, value, index, isArray) {
      if (Math.floor(value) === value && value >= BSON.JS_INT_MIN && value <= BSON.JS_INT_MAX) {
        if (value >= BSON.BSON_INT32_MIN && value <= BSON.BSON_INT32_MAX) {
          buffer[index++] = BSON.BSON_DATA_INT;
          var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
          index = index + numberOfWrittenBytes;
          buffer[index++] = 0;
          buffer[index++] = value & 0xff;
          buffer[index++] = value >> 8 & 0xff;
          buffer[index++] = value >> 16 & 0xff;
          buffer[index++] = value >> 24 & 0xff;
        } else if (value >= BSON.JS_INT_MIN && value <= BSON.JS_INT_MAX) {
          buffer[index++] = BSON.BSON_DATA_NUMBER;
          var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
          index = index + numberOfWrittenBytes;
          buffer[index++] = 0;
          writeIEEE754(buffer, value, index, 'little', 52, 8);
          index = index + 8;
        } else {
          buffer[index++] = BSON.BSON_DATA_LONG;
          var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
          index = index + numberOfWrittenBytes;
          buffer[index++] = 0;
          var longVal = Long.fromNumber(value);
          var lowBits = longVal.getLowBits();
          var highBits = longVal.getHighBits();
          buffer[index++] = lowBits & 0xff;
          buffer[index++] = lowBits >> 8 & 0xff;
          buffer[index++] = lowBits >> 16 & 0xff;
          buffer[index++] = lowBits >> 24 & 0xff;
          buffer[index++] = highBits & 0xff;
          buffer[index++] = highBits >> 8 & 0xff;
          buffer[index++] = highBits >> 16 & 0xff;
          buffer[index++] = highBits >> 24 & 0xff;
        }
      } else {
        buffer[index++] = BSON.BSON_DATA_NUMBER;
        var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
        index = index + numberOfWrittenBytes;
        buffer[index++] = 0;
        writeIEEE754(buffer, value, index, 'little', 52, 8);
        index = index + 8;
      }
      return index;
    };
    var serializeUndefined = function (buffer, key, value, index, isArray) {
      buffer[index++] = BSON.BSON_DATA_NULL;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      return index;
    };
    var serializeBoolean = function (buffer, key, value, index, isArray) {
      buffer[index++] = BSON.BSON_DATA_BOOLEAN;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      buffer[index++] = value ? 1 : 0;
      return index;
    };
    var serializeDate = function (buffer, key, value, index, isArray) {
      buffer[index++] = BSON.BSON_DATA_DATE;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      var dateInMilis = Long.fromNumber(value.getTime());
      var lowBits = dateInMilis.getLowBits();
      var highBits = dateInMilis.getHighBits();
      buffer[index++] = lowBits & 0xff;
      buffer[index++] = lowBits >> 8 & 0xff;
      buffer[index++] = lowBits >> 16 & 0xff;
      buffer[index++] = lowBits >> 24 & 0xff;
      buffer[index++] = highBits & 0xff;
      buffer[index++] = highBits >> 8 & 0xff;
      buffer[index++] = highBits >> 16 & 0xff;
      buffer[index++] = highBits >> 24 & 0xff;
      return index;
    };
    var serializeRegExp = function (buffer, key, value, index, isArray) {
      buffer[index++] = BSON.BSON_DATA_REGEXP;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      if (value.source && value.source.match(regexp) != null) {
        throw Error("value " + value.source + " must not contain null bytes");
      }
      index = index + buffer.write(value.source, index, 'utf8');
      buffer[index++] = 0x00;
      if (value.global) buffer[index++] = 0x73;
      if (value.ignoreCase) buffer[index++] = 0x69;
      if (value.multiline) buffer[index++] = 0x6d;
      buffer[index++] = 0x00;
      return index;
    };
    var serializeBSONRegExp = function (buffer, key, value, index, isArray) {
      buffer[index++] = BSON.BSON_DATA_REGEXP;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      index = index + buffer.write(value.pattern, index, 'utf8');
      buffer[index++] = 0x00;
      index = index + buffer.write(value.options.split('').sort().join(''), index, 'utf8');
      buffer[index++] = 0x00;
      return index;
    };
    var serializeMinMax = function (buffer, key, value, index, isArray) {
      if (value === null) {
        buffer[index++] = BSON.BSON_DATA_NULL;
      } else if (value instanceof MinKey) {
        buffer[index++] = BSON.BSON_DATA_MIN_KEY;
      } else {
        buffer[index++] = BSON.BSON_DATA_MAX_KEY;
      }
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      return index;
    };
    var serializeObjectId = function (buffer, key, value, index, isArray) {
      buffer[index++] = BSON.BSON_DATA_OID;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      if (typeof value.id == 'string') {
        buffer.write(value.id, index, 'binary');
      } else if (value.id && value.id.copy) {
        value.id.copy(buffer, index, 0, 12);
      } else {
        throw new Error('object [' + JSON.stringify(value) + "] is not a valid ObjectId");
      }
      return index + 12;
    };
    var serializeBuffer = function (buffer, key, value, index, isArray) {
      buffer[index++] = BSON.BSON_DATA_BINARY;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      var size = value.length;
      buffer[index++] = size & 0xff;
      buffer[index++] = size >> 8 & 0xff;
      buffer[index++] = size >> 16 & 0xff;
      buffer[index++] = size >> 24 & 0xff;
      buffer[index++] = BSON.BSON_BINARY_SUBTYPE_DEFAULT;
      value.copy(buffer, index, 0, size);
      index = index + size;
      return index;
    };
    var serializeObject = function (buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, isArray, path) {
      for (var i = 0; i < path.length; i++) {
        if (path[i] === value) throw new Error('cyclic dependency detected');
      }
      path.push(value);
      buffer[index++] = Array.isArray(value) ? BSON.BSON_DATA_ARRAY : BSON.BSON_DATA_OBJECT;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      var endIndex = serializeInto(buffer, value, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);
      path.pop();
      var size = endIndex - index;
      return endIndex;
    };
    var serializeDecimal128 = function (buffer, key, value, index, isArray) {
      buffer[index++] = BSON.BSON_DATA_DECIMAL128;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      value.bytes.copy(buffer, index, 0, 16);
      return index + 16;
    };
    var serializeLong = function (buffer, key, value, index, isArray) {
      buffer[index++] = value._bsontype == 'Long' ? BSON.BSON_DATA_LONG : BSON.BSON_DATA_TIMESTAMP;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      var lowBits = value.getLowBits();
      var highBits = value.getHighBits();
      buffer[index++] = lowBits & 0xff;
      buffer[index++] = lowBits >> 8 & 0xff;
      buffer[index++] = lowBits >> 16 & 0xff;
      buffer[index++] = lowBits >> 24 & 0xff;
      buffer[index++] = highBits & 0xff;
      buffer[index++] = highBits >> 8 & 0xff;
      buffer[index++] = highBits >> 16 & 0xff;
      buffer[index++] = highBits >> 24 & 0xff;
      return index;
    };
    var serializeInt32 = function (buffer, key, value, index, isArray) {
      buffer[index++] = BSON.BSON_DATA_INT;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      buffer[index++] = value & 0xff;
      buffer[index++] = value >> 8 & 0xff;
      buffer[index++] = value >> 16 & 0xff;
      buffer[index++] = value >> 24 & 0xff;
      return index;
    };
    var serializeDouble = function (buffer, key, value, index, isArray) {
      buffer[index++] = BSON.BSON_DATA_NUMBER;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      writeIEEE754(buffer, value, index, 'little', 52, 8);
      index = index + 8;
      return index;
    };
    var serializeFunction = function (buffer, key, value, index, checkKeys, depth, isArray) {
      buffer[index++] = BSON.BSON_DATA_CODE;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      var functionString = value.toString();
      var size = buffer.write(functionString, index + 4, 'utf8') + 1;
      buffer[index] = size & 0xff;
      buffer[index + 1] = size >> 8 & 0xff;
      buffer[index + 2] = size >> 16 & 0xff;
      buffer[index + 3] = size >> 24 & 0xff;
      index = index + 4 + size - 1;
      buffer[index++] = 0;
      return index;
    };
    var serializeCode = function (buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, isArray) {
      if (value.scope && typeof value.scope == 'object') {
        buffer[index++] = BSON.BSON_DATA_CODE_W_SCOPE;
        var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
        index = index + numberOfWrittenBytes;
        buffer[index++] = 0;
        var startIndex = index;
        var functionString = typeof value.code == 'string' ? value.code : value.code.toString();
        index = index + 4;
        var codeSize = buffer.write(functionString, index + 4, 'utf8') + 1;
        buffer[index] = codeSize & 0xff;
        buffer[index + 1] = codeSize >> 8 & 0xff;
        buffer[index + 2] = codeSize >> 16 & 0xff;
        buffer[index + 3] = codeSize >> 24 & 0xff;
        buffer[index + 4 + codeSize - 1] = 0;
        index = index + codeSize + 4;
        var endIndex = serializeInto(buffer, value.scope, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined);
        index = endIndex - 1;
        var totalSize = endIndex - startIndex;
        buffer[startIndex++] = totalSize & 0xff;
        buffer[startIndex++] = totalSize >> 8 & 0xff;
        buffer[startIndex++] = totalSize >> 16 & 0xff;
        buffer[startIndex++] = totalSize >> 24 & 0xff;
        buffer[index++] = 0;
      } else {
        buffer[index++] = BSON.BSON_DATA_CODE;
        var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
        index = index + numberOfWrittenBytes;
        buffer[index++] = 0;
        var functionString = value.code.toString();
        var size = buffer.write(functionString, index + 4, 'utf8') + 1;
        buffer[index] = size & 0xff;
        buffer[index + 1] = size >> 8 & 0xff;
        buffer[index + 2] = size >> 16 & 0xff;
        buffer[index + 3] = size >> 24 & 0xff;
        index = index + 4 + size - 1;
        buffer[index++] = 0;
      }
      return index;
    };
    var serializeBinary = function (buffer, key, value, index, isArray) {
      buffer[index++] = BSON.BSON_DATA_BINARY;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      var data = value.value(true);
      var size = value.position;
      if (value.sub_type == Binary.SUBTYPE_BYTE_ARRAY) size = size + 4;
      buffer[index++] = size & 0xff;
      buffer[index++] = size >> 8 & 0xff;
      buffer[index++] = size >> 16 & 0xff;
      buffer[index++] = size >> 24 & 0xff;
      buffer[index++] = value.sub_type;
      if (value.sub_type == Binary.SUBTYPE_BYTE_ARRAY) {
        size = size - 4;
        buffer[index++] = size & 0xff;
        buffer[index++] = size >> 8 & 0xff;
        buffer[index++] = size >> 16 & 0xff;
        buffer[index++] = size >> 24 & 0xff;
      }
      data.copy(buffer, index, 0, value.position);
      index = index + value.position;
      return index;
    };
    var serializeSymbol = function (buffer, key, value, index, isArray) {
      buffer[index++] = BSON.BSON_DATA_SYMBOL;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      var size = buffer.write(value.value, index + 4, 'utf8') + 1;
      buffer[index] = size & 0xff;
      buffer[index + 1] = size >> 8 & 0xff;
      buffer[index + 2] = size >> 16 & 0xff;
      buffer[index + 3] = size >> 24 & 0xff;
      index = index + 4 + size - 1;
      buffer[index++] = 0x00;
      return index;
    };
    var serializeDBRef = function (buffer, key, value, index, depth, serializeFunctions, isArray) {
      buffer[index++] = BSON.BSON_DATA_OBJECT;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      var startIndex = index;
      var endIndex;
      if (null != value.db) {
        endIndex = serializeInto(buffer, {
          '$ref': value.namespace,
          '$id': value.oid,
          '$db': value.db
        }, false, index, depth + 1, serializeFunctions);
      } else {
        endIndex = serializeInto(buffer, {
          '$ref': value.namespace,
          '$id': value.oid
        }, false, index, depth + 1, serializeFunctions);
      }
      var size = endIndex - startIndex;
      buffer[startIndex++] = size & 0xff;
      buffer[startIndex++] = size >> 8 & 0xff;
      buffer[startIndex++] = size >> 16 & 0xff;
      buffer[startIndex++] = size >> 24 & 0xff;
      return endIndex;
    };
    var serializeInto = function serializeInto(buffer, object, checkKeys, startingIndex, depth, serializeFunctions, ignoreUndefined, path) {
      startingIndex = startingIndex || 0;
      path = path || [];
      path.push(object);
      var index = startingIndex + 4;
      var self = this;
      if (Array.isArray(object)) {
        for (var i = 0; i < object.length; i++) {
          var key = "" + i;
          var value = object[i];
          if (value && value.toBSON) {
            if (typeof value.toBSON != 'function') throw new Error("toBSON is not a function");
            value = value.toBSON();
          }
          var type = typeof value;
          if (type == 'string') {
            index = serializeString(buffer, key, value, index, true);
          } else if (type == 'number') {
            index = serializeNumber(buffer, key, value, index, true);
          } else if (type == 'boolean') {
            index = serializeBoolean(buffer, key, value, index, true);
          } else if (value instanceof Date || isDate(value)) {
            index = serializeDate(buffer, key, value, index, true);
          } else if (type == 'undefined' || value == null) {
            index = serializeUndefined(buffer, key, value, index, true);
          } else if (value['_bsontype'] == 'ObjectID') {
            index = serializeObjectId(buffer, key, value, index, true);
          } else if (Buffer.isBuffer(value)) {
            index = serializeBuffer(buffer, key, value, index, true);
          } else if (value instanceof RegExp || isRegExp(value)) {
            index = serializeRegExp(buffer, key, value, index, true);
          } else if (type == 'object' && value['_bsontype'] == null) {
            index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, true, path);
          } else if (type == 'object' && value['_bsontype'] == 'Decimal128') {
            index = serializeDecimal128(buffer, key, value, index, true);
          } else if (value['_bsontype'] == 'Long' || value['_bsontype'] == 'Timestamp') {
            index = serializeLong(buffer, key, value, index, true);
          } else if (value['_bsontype'] == 'Double') {
            index = serializeDouble(buffer, key, value, index, true);
          } else if (typeof value == 'function' && serializeFunctions) {
            index = serializeFunction(buffer, key, value, index, checkKeys, depth, serializeFunctions, true);
          } else if (value['_bsontype'] == 'Code') {
            index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, true);
          } else if (value['_bsontype'] == 'Binary') {
            index = serializeBinary(buffer, key, value, index, true);
          } else if (value['_bsontype'] == 'Symbol') {
            index = serializeSymbol(buffer, key, value, index, true);
          } else if (value['_bsontype'] == 'DBRef') {
            index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, true);
          } else if (value['_bsontype'] == 'BSONRegExp') {
            index = serializeBSONRegExp(buffer, key, value, index, true);
          } else if (value['_bsontype'] == 'Int32') {
            index = serializeInt32(buffer, key, value, index, true);
          } else if (value['_bsontype'] == 'MinKey' || value['_bsontype'] == 'MaxKey') {
            index = serializeMinMax(buffer, key, value, index, true);
          }
        }
      } else if (object instanceof Map) {
        var iterator = object.entries();
        var done = false;
        while (!done) {
          var entry = iterator.next();
          done = entry.done;
          if (done) continue;
          var key = entry.value[0];
          var value = entry.value[1];
          var type = typeof value;
          if (key != '$db' && key != '$ref' && key != '$id') {
            if (key.match(regexp) != null) {
              throw Error("key " + key + " must not contain null bytes");
            }
            if (checkKeys) {
              if ('$' == key[0]) {
                throw Error("key " + key + " must not start with '$'");
              } else if (!!~key.indexOf('.')) {
                throw Error("key " + key + " must not contain '.'");
              }
            }
          }
          if (type == 'string') {
            index = serializeString(buffer, key, value, index);
          } else if (type == 'number') {
            index = serializeNumber(buffer, key, value, index);
          } else if (type == 'boolean') {
            index = serializeBoolean(buffer, key, value, index);
          } else if (value instanceof Date || isDate(value)) {
            index = serializeDate(buffer, key, value, index);
          } else if (value === undefined && ignoreUndefined == true) {} else if (value === null || value === undefined) {
            index = serializeUndefined(buffer, key, value, index);
          } else if (value['_bsontype'] == 'ObjectID') {
            index = serializeObjectId(buffer, key, value, index);
          } else if (Buffer.isBuffer(value)) {
            index = serializeBuffer(buffer, key, value, index);
          } else if (value instanceof RegExp || isRegExp(value)) {
            index = serializeRegExp(buffer, key, value, index);
          } else if (type == 'object' && value['_bsontype'] == null) {
            index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, false, path);
          } else if (type == 'object' && value['_bsontype'] == 'Decimal128') {
            index = serializeDecimal128(buffer, key, value, index);
          } else if (value['_bsontype'] == 'Long' || value['_bsontype'] == 'Timestamp') {
            index = serializeLong(buffer, key, value, index);
          } else if (value['_bsontype'] == 'Double') {
            index = serializeDouble(buffer, key, value, index);
          } else if (value['_bsontype'] == 'Code') {
            index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined);
          } else if (typeof value == 'function' && serializeFunctions) {
            index = serializeFunction(buffer, key, value, index, checkKeys, depth, serializeFunctions);
          } else if (value['_bsontype'] == 'Binary') {
            index = serializeBinary(buffer, key, value, index);
          } else if (value['_bsontype'] == 'Symbol') {
            index = serializeSymbol(buffer, key, value, index);
          } else if (value['_bsontype'] == 'DBRef') {
            index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions);
          } else if (value['_bsontype'] == 'BSONRegExp') {
            index = serializeBSONRegExp(buffer, key, value, index);
          } else if (value['_bsontype'] == 'Int32') {
            index = serializeInt32(buffer, key, value, index);
          } else if (value['_bsontype'] == 'MinKey' || value['_bsontype'] == 'MaxKey') {
            index = serializeMinMax(buffer, key, value, index);
          }
        }
      } else {
        if (object.toBSON) {
          if (typeof object.toBSON != 'function') throw new Error("toBSON is not a function");
          object = object.toBSON();
          if (object != null && typeof object != 'object') throw new Error("toBSON function did not return an object");
        }
        for (var key in object) {
          var value = object[key];
          if (value && value.toBSON) {
            if (typeof value.toBSON != 'function') throw new Error("toBSON is not a function");
            value = value.toBSON();
          }
          var type = typeof value;
          if (key != '$db' && key != '$ref' && key != '$id') {
            if (key.match(regexp) != null) {
              throw Error("key " + key + " must not contain null bytes");
            }
            if (checkKeys) {
              if ('$' == key[0]) {
                throw Error("key " + key + " must not start with '$'");
              } else if (!!~key.indexOf('.')) {
                throw Error("key " + key + " must not contain '.'");
              }
            }
          }
          if (type == 'string') {
            index = serializeString(buffer, key, value, index);
          } else if (type == 'number') {
            index = serializeNumber(buffer, key, value, index);
          } else if (type == 'boolean') {
            index = serializeBoolean(buffer, key, value, index);
          } else if (value instanceof Date || isDate(value)) {
            index = serializeDate(buffer, key, value, index);
          } else if (value === undefined && ignoreUndefined == true) {} else if (value === null || value === undefined) {
            index = serializeUndefined(buffer, key, value, index);
          } else if (value['_bsontype'] == 'ObjectID') {
            index = serializeObjectId(buffer, key, value, index);
          } else if (Buffer.isBuffer(value)) {
            index = serializeBuffer(buffer, key, value, index);
          } else if (value instanceof RegExp || isRegExp(value)) {
            index = serializeRegExp(buffer, key, value, index);
          } else if (type == 'object' && value['_bsontype'] == null) {
            index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, false, path);
          } else if (type == 'object' && value['_bsontype'] == 'Decimal128') {
            index = serializeDecimal128(buffer, key, value, index);
          } else if (value['_bsontype'] == 'Long' || value['_bsontype'] == 'Timestamp') {
            index = serializeLong(buffer, key, value, index);
          } else if (value['_bsontype'] == 'Double') {
            index = serializeDouble(buffer, key, value, index);
          } else if (value['_bsontype'] == 'Code') {
            index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined);
          } else if (typeof value == 'function' && serializeFunctions) {
            index = serializeFunction(buffer, key, value, index, checkKeys, depth, serializeFunctions);
          } else if (value['_bsontype'] == 'Binary') {
            index = serializeBinary(buffer, key, value, index);
          } else if (value['_bsontype'] == 'Symbol') {
            index = serializeSymbol(buffer, key, value, index);
          } else if (value['_bsontype'] == 'DBRef') {
            index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions);
          } else if (value['_bsontype'] == 'BSONRegExp') {
            index = serializeBSONRegExp(buffer, key, value, index);
          } else if (value['_bsontype'] == 'Int32') {
            index = serializeInt32(buffer, key, value, index);
          } else if (value['_bsontype'] == 'MinKey' || value['_bsontype'] == 'MaxKey') {
            index = serializeMinMax(buffer, key, value, index);
          }
        }
      }
      path.pop();
      buffer[index++] = 0x00;
      var size = index - startingIndex;
      buffer[startingIndex++] = size & 0xff;
      buffer[startingIndex++] = size >> 8 & 0xff;
      buffer[startingIndex++] = size >> 16 & 0xff;
      buffer[startingIndex++] = size >> 24 & 0xff;
      return index;
    };
    var BSON = {};
    var functionCache = BSON.functionCache = {};
    BSON.BSON_DATA_NUMBER = 1;
    BSON.BSON_DATA_STRING = 2;
    BSON.BSON_DATA_OBJECT = 3;
    BSON.BSON_DATA_ARRAY = 4;
    BSON.BSON_DATA_BINARY = 5;
    BSON.BSON_DATA_UNDEFINED = 6;
    BSON.BSON_DATA_OID = 7;
    BSON.BSON_DATA_BOOLEAN = 8;
    BSON.BSON_DATA_DATE = 9;
    BSON.BSON_DATA_NULL = 10;
    BSON.BSON_DATA_REGEXP = 11;
    BSON.BSON_DATA_CODE = 13;
    BSON.BSON_DATA_SYMBOL = 14;
    BSON.BSON_DATA_CODE_W_SCOPE = 15;
    BSON.BSON_DATA_INT = 16;
    BSON.BSON_DATA_TIMESTAMP = 17;
    BSON.BSON_DATA_LONG = 18;
    BSON.BSON_DATA_DECIMAL128 = 19;
    BSON.BSON_DATA_MIN_KEY = 0xff;
    BSON.BSON_DATA_MAX_KEY = 0x7f;
    BSON.BSON_BINARY_SUBTYPE_DEFAULT = 0;
    BSON.BSON_BINARY_SUBTYPE_FUNCTION = 1;
    BSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;
    BSON.BSON_BINARY_SUBTYPE_UUID = 3;
    BSON.BSON_BINARY_SUBTYPE_MD5 = 4;
    BSON.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;
    BSON.BSON_INT32_MAX = 0x7FFFFFFF;
    BSON.BSON_INT32_MIN = -0x80000000;
    BSON.BSON_INT64_MAX = Math.pow(2, 63) - 1;
    BSON.BSON_INT64_MIN = -Math.pow(2, 63);
    BSON.JS_INT_MAX = 0x20000000000000;
    BSON.JS_INT_MIN = -0x20000000000000;
    var JS_INT_MAX_LONG = Long.fromNumber(0x20000000000000);
    var JS_INT_MIN_LONG = Long.fromNumber(-0x20000000000000);
    module.exports = serializeInto;
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic('268', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  // Copyright (c) 2008, Fair Oaks Labs, Inc.
  // All rights reserved.
  // 
  // Redistribution and use in source and binary forms, with or without
  // modification, are permitted provided that the following conditions are met:
  // 
  //  * Redistributions of source code must retain the above copyright notice,
  //    this list of conditions and the following disclaimer.
  // 
  //  * Redistributions in binary form must reproduce the above copyright notice,
  //    this list of conditions and the following disclaimer in the documentation
  //    and/or other materials provided with the distribution.
  // 
  //  * Neither the name of Fair Oaks Labs, Inc. nor the names of its contributors
  //    may be used to endorse or promote products derived from this software
  //    without specific prior written permission.
  // 
  // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  // ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  // LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  // CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  // SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  // INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  // CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  // POSSIBILITY OF SUCH DAMAGE.
  //
  //
  // Modifications to writeIEEE754 to support negative zeroes made by Brian White

  var readIEEE754 = function (buffer, offset, endian, mLen, nBytes) {
    var e,
        m,
        bBE = endian === 'big',
        eLen = nBytes * 8 - mLen - 1,
        eMax = (1 << eLen) - 1,
        eBias = eMax >> 1,
        nBits = -7,
        i = bBE ? 0 : nBytes - 1,
        d = bBE ? 1 : -1,
        s = buffer[offset + i];

    i += d;

    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  };

  var writeIEEE754 = function (buffer, value, offset, endian, mLen, nBytes) {
    var e,
        m,
        c,
        bBE = endian === 'big',
        eLen = nBytes * 8 - mLen - 1,
        eMax = (1 << eLen) - 1,
        eBias = eMax >> 1,
        rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
        i = bBE ? nBytes - 1 : 0,
        d = bBE ? -1 : 1,
        s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;

    value = Math.abs(value);

    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }

      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }

    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

    e = e << mLen | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

    buffer[offset + i - d] |= s * 128;
  };

  exports.readIEEE754 = readIEEE754;
  exports.writeIEEE754 = writeIEEE754;
  return module.exports;
});
$__System.registerDynamic('26a', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /**
   * A class representation of the BSON Double type.
   *
   * @class
   * @param {number} value the number we want to represent as a double.
   * @return {Double}
   */
  function Double(value) {
    if (!(this instanceof Double)) return new Double(value);

    this._bsontype = 'Double';
    this.value = value;
  }

  /**
   * Access the number value.
   *
   * @method
   * @return {number} returns the wrapped double number.
   */
  Double.prototype.valueOf = function () {
    return this.value;
  };

  /**
   * @ignore
   */
  Double.prototype.toJSON = function () {
    return this.value;
  };

  module.exports = Double;
  module.exports.Double = Double;
  return module.exports;
});
$__System.registerDynamic('26b', ['13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    function Timestamp(low, high) {
      if (!(this instanceof Timestamp)) return new Timestamp(low, high);
      this._bsontype = 'Timestamp';
      this.low_ = low | 0;
      this.high_ = high | 0;
    }
    ;
    Timestamp.prototype.toInt = function () {
      return this.low_;
    };
    Timestamp.prototype.toNumber = function () {
      return this.high_ * Timestamp.TWO_PWR_32_DBL_ + this.getLowBitsUnsigned();
    };
    Timestamp.prototype.toJSON = function () {
      return this.toString();
    };
    Timestamp.prototype.toString = function (opt_radix) {
      var radix = opt_radix || 10;
      if (radix < 2 || 36 < radix) {
        throw Error('radix out of range: ' + radix);
      }
      if (this.isZero()) {
        return '0';
      }
      if (this.isNegative()) {
        if (this.equals(Timestamp.MIN_VALUE)) {
          var radixTimestamp = Timestamp.fromNumber(radix);
          var div = this.div(radixTimestamp);
          var rem = div.multiply(radixTimestamp).subtract(this);
          return div.toString(radix) + rem.toInt().toString(radix);
        } else {
          return '-' + this.negate().toString(radix);
        }
      }
      var radixToPower = Timestamp.fromNumber(Math.pow(radix, 6));
      var rem = this;
      var result = '';
      while (true) {
        var remDiv = rem.div(radixToPower);
        var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();
        var digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero()) {
          return digits + result;
        } else {
          while (digits.length < 6) {
            digits = '0' + digits;
          }
          result = '' + digits + result;
        }
      }
    };
    Timestamp.prototype.getHighBits = function () {
      return this.high_;
    };
    Timestamp.prototype.getLowBits = function () {
      return this.low_;
    };
    Timestamp.prototype.getLowBitsUnsigned = function () {
      return this.low_ >= 0 ? this.low_ : Timestamp.TWO_PWR_32_DBL_ + this.low_;
    };
    Timestamp.prototype.getNumBitsAbs = function () {
      if (this.isNegative()) {
        if (this.equals(Timestamp.MIN_VALUE)) {
          return 64;
        } else {
          return this.negate().getNumBitsAbs();
        }
      } else {
        var val = this.high_ != 0 ? this.high_ : this.low_;
        for (var bit = 31; bit > 0; bit--) {
          if ((val & 1 << bit) != 0) {
            break;
          }
        }
        return this.high_ != 0 ? bit + 33 : bit + 1;
      }
    };
    Timestamp.prototype.isZero = function () {
      return this.high_ == 0 && this.low_ == 0;
    };
    Timestamp.prototype.isNegative = function () {
      return this.high_ < 0;
    };
    Timestamp.prototype.isOdd = function () {
      return (this.low_ & 1) == 1;
    };
    Timestamp.prototype.equals = function (other) {
      return this.high_ == other.high_ && this.low_ == other.low_;
    };
    Timestamp.prototype.notEquals = function (other) {
      return this.high_ != other.high_ || this.low_ != other.low_;
    };
    Timestamp.prototype.lessThan = function (other) {
      return this.compare(other) < 0;
    };
    Timestamp.prototype.lessThanOrEqual = function (other) {
      return this.compare(other) <= 0;
    };
    Timestamp.prototype.greaterThan = function (other) {
      return this.compare(other) > 0;
    };
    Timestamp.prototype.greaterThanOrEqual = function (other) {
      return this.compare(other) >= 0;
    };
    Timestamp.prototype.compare = function (other) {
      if (this.equals(other)) {
        return 0;
      }
      var thisNeg = this.isNegative();
      var otherNeg = other.isNegative();
      if (thisNeg && !otherNeg) {
        return -1;
      }
      if (!thisNeg && otherNeg) {
        return 1;
      }
      if (this.subtract(other).isNegative()) {
        return -1;
      } else {
        return 1;
      }
    };
    Timestamp.prototype.negate = function () {
      if (this.equals(Timestamp.MIN_VALUE)) {
        return Timestamp.MIN_VALUE;
      } else {
        return this.not().add(Timestamp.ONE);
      }
    };
    Timestamp.prototype.add = function (other) {
      var a48 = this.high_ >>> 16;
      var a32 = this.high_ & 0xFFFF;
      var a16 = this.low_ >>> 16;
      var a00 = this.low_ & 0xFFFF;
      var b48 = other.high_ >>> 16;
      var b32 = other.high_ & 0xFFFF;
      var b16 = other.low_ >>> 16;
      var b00 = other.low_ & 0xFFFF;
      var c48 = 0,
          c32 = 0,
          c16 = 0,
          c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 0xFFFF;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 0xFFFF;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 0xFFFF;
      c48 += a48 + b48;
      c48 &= 0xFFFF;
      return Timestamp.fromBits(c16 << 16 | c00, c48 << 16 | c32);
    };
    Timestamp.prototype.subtract = function (other) {
      return this.add(other.negate());
    };
    Timestamp.prototype.multiply = function (other) {
      if (this.isZero()) {
        return Timestamp.ZERO;
      } else if (other.isZero()) {
        return Timestamp.ZERO;
      }
      if (this.equals(Timestamp.MIN_VALUE)) {
        return other.isOdd() ? Timestamp.MIN_VALUE : Timestamp.ZERO;
      } else if (other.equals(Timestamp.MIN_VALUE)) {
        return this.isOdd() ? Timestamp.MIN_VALUE : Timestamp.ZERO;
      }
      if (this.isNegative()) {
        if (other.isNegative()) {
          return this.negate().multiply(other.negate());
        } else {
          return this.negate().multiply(other).negate();
        }
      } else if (other.isNegative()) {
        return this.multiply(other.negate()).negate();
      }
      if (this.lessThan(Timestamp.TWO_PWR_24_) && other.lessThan(Timestamp.TWO_PWR_24_)) {
        return Timestamp.fromNumber(this.toNumber() * other.toNumber());
      }
      var a48 = this.high_ >>> 16;
      var a32 = this.high_ & 0xFFFF;
      var a16 = this.low_ >>> 16;
      var a00 = this.low_ & 0xFFFF;
      var b48 = other.high_ >>> 16;
      var b32 = other.high_ & 0xFFFF;
      var b16 = other.low_ >>> 16;
      var b00 = other.low_ & 0xFFFF;
      var c48 = 0,
          c32 = 0,
          c16 = 0,
          c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 0xFFFF;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 0xFFFF;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 0xFFFF;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 0xFFFF;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 0xFFFF;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 0xFFFF;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 0xFFFF;
      return Timestamp.fromBits(c16 << 16 | c00, c48 << 16 | c32);
    };
    Timestamp.prototype.div = function (other) {
      if (other.isZero()) {
        throw Error('division by zero');
      } else if (this.isZero()) {
        return Timestamp.ZERO;
      }
      if (this.equals(Timestamp.MIN_VALUE)) {
        if (other.equals(Timestamp.ONE) || other.equals(Timestamp.NEG_ONE)) {
          return Timestamp.MIN_VALUE;
        } else if (other.equals(Timestamp.MIN_VALUE)) {
          return Timestamp.ONE;
        } else {
          var halfThis = this.shiftRight(1);
          var approx = halfThis.div(other).shiftLeft(1);
          if (approx.equals(Timestamp.ZERO)) {
            return other.isNegative() ? Timestamp.ONE : Timestamp.NEG_ONE;
          } else {
            var rem = this.subtract(other.multiply(approx));
            var result = approx.add(rem.div(other));
            return result;
          }
        }
      } else if (other.equals(Timestamp.MIN_VALUE)) {
        return Timestamp.ZERO;
      }
      if (this.isNegative()) {
        if (other.isNegative()) {
          return this.negate().div(other.negate());
        } else {
          return this.negate().div(other).negate();
        }
      } else if (other.isNegative()) {
        return this.div(other.negate()).negate();
      }
      var res = Timestamp.ZERO;
      var rem = this;
      while (rem.greaterThanOrEqual(other)) {
        var approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));
        var log2 = Math.ceil(Math.log(approx) / Math.LN2);
        var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);
        var approxRes = Timestamp.fromNumber(approx);
        var approxRem = approxRes.multiply(other);
        while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
          approx -= delta;
          approxRes = Timestamp.fromNumber(approx);
          approxRem = approxRes.multiply(other);
        }
        if (approxRes.isZero()) {
          approxRes = Timestamp.ONE;
        }
        res = res.add(approxRes);
        rem = rem.subtract(approxRem);
      }
      return res;
    };
    Timestamp.prototype.modulo = function (other) {
      return this.subtract(this.div(other).multiply(other));
    };
    Timestamp.prototype.not = function () {
      return Timestamp.fromBits(~this.low_, ~this.high_);
    };
    Timestamp.prototype.and = function (other) {
      return Timestamp.fromBits(this.low_ & other.low_, this.high_ & other.high_);
    };
    Timestamp.prototype.or = function (other) {
      return Timestamp.fromBits(this.low_ | other.low_, this.high_ | other.high_);
    };
    Timestamp.prototype.xor = function (other) {
      return Timestamp.fromBits(this.low_ ^ other.low_, this.high_ ^ other.high_);
    };
    Timestamp.prototype.shiftLeft = function (numBits) {
      numBits &= 63;
      if (numBits == 0) {
        return this;
      } else {
        var low = this.low_;
        if (numBits < 32) {
          var high = this.high_;
          return Timestamp.fromBits(low << numBits, high << numBits | low >>> 32 - numBits);
        } else {
          return Timestamp.fromBits(0, low << numBits - 32);
        }
      }
    };
    Timestamp.prototype.shiftRight = function (numBits) {
      numBits &= 63;
      if (numBits == 0) {
        return this;
      } else {
        var high = this.high_;
        if (numBits < 32) {
          var low = this.low_;
          return Timestamp.fromBits(low >>> numBits | high << 32 - numBits, high >> numBits);
        } else {
          return Timestamp.fromBits(high >> numBits - 32, high >= 0 ? 0 : -1);
        }
      }
    };
    Timestamp.prototype.shiftRightUnsigned = function (numBits) {
      numBits &= 63;
      if (numBits == 0) {
        return this;
      } else {
        var high = this.high_;
        if (numBits < 32) {
          var low = this.low_;
          return Timestamp.fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits);
        } else if (numBits == 32) {
          return Timestamp.fromBits(high, 0);
        } else {
          return Timestamp.fromBits(high >>> numBits - 32, 0);
        }
      }
    };
    Timestamp.fromInt = function (value) {
      if (-128 <= value && value < 128) {
        var cachedObj = Timestamp.INT_CACHE_[value];
        if (cachedObj) {
          return cachedObj;
        }
      }
      var obj = new Timestamp(value | 0, value < 0 ? -1 : 0);
      if (-128 <= value && value < 128) {
        Timestamp.INT_CACHE_[value] = obj;
      }
      return obj;
    };
    Timestamp.fromNumber = function (value) {
      if (isNaN(value) || !isFinite(value)) {
        return Timestamp.ZERO;
      } else if (value <= -Timestamp.TWO_PWR_63_DBL_) {
        return Timestamp.MIN_VALUE;
      } else if (value + 1 >= Timestamp.TWO_PWR_63_DBL_) {
        return Timestamp.MAX_VALUE;
      } else if (value < 0) {
        return Timestamp.fromNumber(-value).negate();
      } else {
        return new Timestamp(value % Timestamp.TWO_PWR_32_DBL_ | 0, value / Timestamp.TWO_PWR_32_DBL_ | 0);
      }
    };
    Timestamp.fromBits = function (lowBits, highBits) {
      return new Timestamp(lowBits, highBits);
    };
    Timestamp.fromString = function (str, opt_radix) {
      if (str.length == 0) {
        throw Error('number format error: empty string');
      }
      var radix = opt_radix || 10;
      if (radix < 2 || 36 < radix) {
        throw Error('radix out of range: ' + radix);
      }
      if (str.charAt(0) == '-') {
        return Timestamp.fromString(str.substring(1), radix).negate();
      } else if (str.indexOf('-') >= 0) {
        throw Error('number format error: interior "-" character: ' + str);
      }
      var radixToPower = Timestamp.fromNumber(Math.pow(radix, 8));
      var result = Timestamp.ZERO;
      for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i);
        var value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
          var power = Timestamp.fromNumber(Math.pow(radix, size));
          result = result.multiply(power).add(Timestamp.fromNumber(value));
        } else {
          result = result.multiply(radixToPower);
          result = result.add(Timestamp.fromNumber(value));
        }
      }
      return result;
    };
    Timestamp.INT_CACHE_ = {};
    Timestamp.TWO_PWR_16_DBL_ = 1 << 16;
    Timestamp.TWO_PWR_24_DBL_ = 1 << 24;
    Timestamp.TWO_PWR_32_DBL_ = Timestamp.TWO_PWR_16_DBL_ * Timestamp.TWO_PWR_16_DBL_;
    Timestamp.TWO_PWR_31_DBL_ = Timestamp.TWO_PWR_32_DBL_ / 2;
    Timestamp.TWO_PWR_48_DBL_ = Timestamp.TWO_PWR_32_DBL_ * Timestamp.TWO_PWR_16_DBL_;
    Timestamp.TWO_PWR_64_DBL_ = Timestamp.TWO_PWR_32_DBL_ * Timestamp.TWO_PWR_32_DBL_;
    Timestamp.TWO_PWR_63_DBL_ = Timestamp.TWO_PWR_64_DBL_ / 2;
    Timestamp.ZERO = Timestamp.fromInt(0);
    Timestamp.ONE = Timestamp.fromInt(1);
    Timestamp.NEG_ONE = Timestamp.fromInt(-1);
    Timestamp.MAX_VALUE = Timestamp.fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0);
    Timestamp.MIN_VALUE = Timestamp.fromBits(0, 0x80000000 | 0);
    Timestamp.TWO_PWR_24_ = Timestamp.fromInt(1 << 24);
    module.exports = Timestamp;
    module.exports.Timestamp = Timestamp;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic("26c", ["2a", "13"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer, process) {
    var MACHINE_ID = parseInt(Math.random() * 0xFFFFFF, 10);
    var checkForHexRegExp = new RegExp("^[0-9a-fA-F]{24}$");
    var ObjectID = function ObjectID(id) {
      if (id instanceof ObjectID) return id;
      if (!(this instanceof ObjectID)) return new ObjectID(id);
      this._bsontype = 'ObjectID';
      var __id = null;
      var valid = ObjectID.isValid(id);
      if (!valid && id != null) {
        throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
      } else if (valid && typeof id == 'string' && id.length == 24) {
        return ObjectID.createFromHexString(id);
      } else if (id == null || typeof id == 'number') {
        this.id = this.generate(id);
      } else if (id != null && id.length === 12) {
        this.id = id;
      } else if (id != null && id.toHexString) {
        return id;
      } else {
        throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
      }
      if (ObjectID.cacheHexString) this.__id = this.toHexString();
    };
    var ObjectId = ObjectID;
    var hexTable = [];
    for (var i = 0; i < 256; i++) {
      hexTable[i] = (i <= 15 ? '0' : '') + i.toString(16);
    }
    ObjectID.prototype.toHexString = function () {
      if (ObjectID.cacheHexString && this.__id) return this.__id;
      var hexString = '';
      if (!this.id || !this.id.length) {
        throw new Error('invalid ObjectId, ObjectId.id must be either a string or a Buffer, but is [' + JSON.stringify(this.id) + ']');
      }
      if (this.id instanceof _Buffer) {
        hexString = convertToHex(this.id);
        if (ObjectID.cacheHexString) this.__id = hexString;
        return hexString;
      }
      for (var i = 0; i < this.id.length; i++) {
        hexString += hexTable[this.id.charCodeAt(i)];
      }
      if (ObjectID.cacheHexString) this.__id = hexString;
      return hexString;
    };
    ObjectID.prototype.get_inc = function () {
      return ObjectID.index = (ObjectID.index + 1) % 0xFFFFFF;
    };
    ObjectID.prototype.getInc = function () {
      return this.get_inc();
    };
    ObjectID.prototype.generate = function (time) {
      if ('number' != typeof time) {
        time = ~~(Date.now() / 1000);
      }
      var pid = (typeof process === 'undefined' ? Math.floor(Math.random() * 100000) : process.pid) % 0xFFFF;
      var inc = this.get_inc();
      var buffer = new Buffer(12);
      buffer[3] = time & 0xff;
      buffer[2] = time >> 8 & 0xff;
      buffer[1] = time >> 16 & 0xff;
      buffer[0] = time >> 24 & 0xff;
      buffer[6] = MACHINE_ID & 0xff;
      buffer[5] = MACHINE_ID >> 8 & 0xff;
      buffer[4] = MACHINE_ID >> 16 & 0xff;
      buffer[8] = pid & 0xff;
      buffer[7] = pid >> 8 & 0xff;
      buffer[11] = inc & 0xff;
      buffer[10] = inc >> 8 & 0xff;
      buffer[9] = inc >> 16 & 0xff;
      return buffer;
    };
    ObjectID.prototype.toString = function () {
      return this.toHexString();
    };
    ObjectID.prototype.inspect = ObjectID.prototype.toString;
    ObjectID.prototype.toJSON = function () {
      return this.toHexString();
    };
    ObjectID.prototype.equals = function equals(otherId) {
      var id;
      if (otherId instanceof ObjectID) {
        return this.toString() == otherId.toString();
      } else if (typeof otherId == 'string' && ObjectID.isValid(otherId) && otherId.length == 12 && this.id instanceof _Buffer) {
        return otherId === this.id.toString('binary');
      } else if (typeof otherId == 'string' && ObjectID.isValid(otherId) && otherId.length == 24) {
        return otherId === this.toHexString();
      } else if (typeof otherId == 'string' && ObjectID.isValid(otherId) && otherId.length == 12) {
        return otherId === this.id;
      } else if (otherId != null && (otherId instanceof ObjectID || otherId.toHexString)) {
        return otherId.toHexString() === this.toHexString();
      } else {
        return false;
      }
    };
    ObjectID.prototype.getTimestamp = function () {
      var timestamp = new Date();
      var time = this.id[3] | this.id[2] << 8 | this.id[1] << 16 | this.id[0] << 24;
      timestamp.setTime(Math.floor(time) * 1000);
      return timestamp;
    };
    ObjectID.index = ~~(Math.random() * 0xFFFFFF);
    ObjectID.createPk = function createPk() {
      return new ObjectID();
    };
    ObjectID.createFromTime = function createFromTime(time) {
      var buffer = new Buffer([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
      buffer[3] = time & 0xff;
      buffer[2] = time >> 8 & 0xff;
      buffer[1] = time >> 16 & 0xff;
      buffer[0] = time >> 24 & 0xff;
      return new ObjectID(buffer);
    };
    var encodeLookup = '0123456789abcdef'.split('');
    var decodeLookup = [];
    var i = 0;
    while (i < 10) decodeLookup[0x30 + i] = i++;
    while (i < 16) decodeLookup[0x41 - 10 + i] = decodeLookup[0x61 - 10 + i] = i++;
    var _Buffer = Buffer;
    var convertToHex = function (bytes) {
      return bytes.toString('hex');
    };
    ObjectID.createFromHexString = function createFromHexString(string) {
      if (typeof string === 'undefined' || string != null && string.length != 24) throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
      var length = string.length;
      if (length > 12 * 2) {
        throw new Error('Id cannot be longer than 12 bytes');
      }
      var sizeof = length >> 1;
      var array = new _Buffer(sizeof);
      var n = 0;
      var i = 0;
      while (i < length) {
        array[n++] = decodeLookup[string.charCodeAt(i++)] << 4 | decodeLookup[string.charCodeAt(i++)];
      }
      return new ObjectID(array);
    };
    ObjectID.isValid = function isValid(id) {
      if (id == null) return false;
      if (typeof id == 'number') {
        return true;
      }
      if (typeof id == 'string') {
        return id.length == 12 || id.length == 24 && checkForHexRegExp.test(id);
      }
      if (id instanceof ObjectID) {
        return true;
      }
      if (id instanceof _Buffer) {
        return true;
      }
      if (id.toHexString) {
        return id.id.length == 12 || id.id.length == 24 && checkForHexRegExp.test(id.id);
      }
      return false;
    };
    Object.defineProperty(ObjectID.prototype, "generationTime", {
      enumerable: true,
      get: function () {
        return this.id[3] | this.id[2] << 8 | this.id[1] << 16 | this.id[0] << 24;
      },
      set: function (value) {
        this.id[3] = value & 0xff;
        this.id[2] = value >> 8 & 0xff;
        this.id[1] = value >> 16 & 0xff;
        this.id[0] = value >> 24 & 0xff;
      }
    });
    module.exports = ObjectID;
    module.exports.ObjectID = ObjectID;
    module.exports.ObjectId = ObjectID;
  })($__require("2a").Buffer, $__require("13"));
  return module.exports;
});
$__System.registerDynamic('26d', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /**
   * A class representation of the BSON Symbol type.
   *
   * @class
   * @deprecated
   * @param {string} value the string representing the symbol.
   * @return {Symbol}
   */
  function Symbol(value) {
    if (!(this instanceof Symbol)) return new Symbol(value);
    this._bsontype = 'Symbol';
    this.value = value;
  }

  /**
   * Access the wrapped string value.
   *
   * @method
   * @return {String} returns the wrapped string.
   */
  Symbol.prototype.valueOf = function () {
    return this.value;
  };

  /**
   * @ignore
   */
  Symbol.prototype.toString = function () {
    return this.value;
  };

  /**
   * @ignore
   */
  Symbol.prototype.inspect = function () {
    return this.value;
  };

  /**
   * @ignore
   */
  Symbol.prototype.toJSON = function () {
    return this.value;
  };

  module.exports = Symbol;
  module.exports.Symbol = Symbol;
  return module.exports;
});
$__System.registerDynamic('274', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /**
   * A class representation of the BSON RegExp type.
   *
   * @class
   * @return {BSONRegExp} A MinKey instance
   */
  function BSONRegExp(pattern, options) {
    if (!(this instanceof BSONRegExp)) return new BSONRegExp();

    // Execute
    this._bsontype = 'BSONRegExp';
    this.pattern = pattern;
    this.options = options;

    // Validate options
    for (var i = 0; i < options.length; i++) {
      if (!(this.options[i] == 'i' || this.options[i] == 'm' || this.options[i] == 'x' || this.options[i] == 'l' || this.options[i] == 's' || this.options[i] == 'u')) {
        throw new Error('the regular expression options [' + this.options[i] + "] is not supported");
      }
    }
  }

  module.exports = BSONRegExp;
  module.exports.BSONRegExp = BSONRegExp;
  return module.exports;
});
$__System.registerDynamic('26e', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /**
   * A class representation of the BSON Code type.
   *
   * @class
   * @param {(string|function)} code a string or function.
   * @param {Object} [scope] an optional scope for the function.
   * @return {Code}
   */
  var Code = function Code(code, scope) {
    if (!(this instanceof Code)) return new Code(code, scope);
    this._bsontype = 'Code';
    this.code = code;
    this.scope = scope;
  };

  /**
   * @ignore
   */
  Code.prototype.toJSON = function () {
    return { scope: this.scope, code: this.code };
  };

  module.exports = Code;
  module.exports.Code = Code;
  return module.exports;
});
$__System.registerDynamic('269', ['13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    function Long(low, high) {
      if (!(this instanceof Long)) return new Long(low, high);
      this._bsontype = 'Long';
      this.low_ = low | 0;
      this.high_ = high | 0;
    }
    ;
    Long.prototype.toInt = function () {
      return this.low_;
    };
    Long.prototype.toNumber = function () {
      return this.high_ * Long.TWO_PWR_32_DBL_ + this.getLowBitsUnsigned();
    };
    Long.prototype.toJSON = function () {
      return this.toString();
    };
    Long.prototype.toString = function (opt_radix) {
      var radix = opt_radix || 10;
      if (radix < 2 || 36 < radix) {
        throw Error('radix out of range: ' + radix);
      }
      if (this.isZero()) {
        return '0';
      }
      if (this.isNegative()) {
        if (this.equals(Long.MIN_VALUE)) {
          var radixLong = Long.fromNumber(radix);
          var div = this.div(radixLong);
          var rem = div.multiply(radixLong).subtract(this);
          return div.toString(radix) + rem.toInt().toString(radix);
        } else {
          return '-' + this.negate().toString(radix);
        }
      }
      var radixToPower = Long.fromNumber(Math.pow(radix, 6));
      var rem = this;
      var result = '';
      while (true) {
        var remDiv = rem.div(radixToPower);
        var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();
        var digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero()) {
          return digits + result;
        } else {
          while (digits.length < 6) {
            digits = '0' + digits;
          }
          result = '' + digits + result;
        }
      }
    };
    Long.prototype.getHighBits = function () {
      return this.high_;
    };
    Long.prototype.getLowBits = function () {
      return this.low_;
    };
    Long.prototype.getLowBitsUnsigned = function () {
      return this.low_ >= 0 ? this.low_ : Long.TWO_PWR_32_DBL_ + this.low_;
    };
    Long.prototype.getNumBitsAbs = function () {
      if (this.isNegative()) {
        if (this.equals(Long.MIN_VALUE)) {
          return 64;
        } else {
          return this.negate().getNumBitsAbs();
        }
      } else {
        var val = this.high_ != 0 ? this.high_ : this.low_;
        for (var bit = 31; bit > 0; bit--) {
          if ((val & 1 << bit) != 0) {
            break;
          }
        }
        return this.high_ != 0 ? bit + 33 : bit + 1;
      }
    };
    Long.prototype.isZero = function () {
      return this.high_ == 0 && this.low_ == 0;
    };
    Long.prototype.isNegative = function () {
      return this.high_ < 0;
    };
    Long.prototype.isOdd = function () {
      return (this.low_ & 1) == 1;
    };
    Long.prototype.equals = function (other) {
      return this.high_ == other.high_ && this.low_ == other.low_;
    };
    Long.prototype.notEquals = function (other) {
      return this.high_ != other.high_ || this.low_ != other.low_;
    };
    Long.prototype.lessThan = function (other) {
      return this.compare(other) < 0;
    };
    Long.prototype.lessThanOrEqual = function (other) {
      return this.compare(other) <= 0;
    };
    Long.prototype.greaterThan = function (other) {
      return this.compare(other) > 0;
    };
    Long.prototype.greaterThanOrEqual = function (other) {
      return this.compare(other) >= 0;
    };
    Long.prototype.compare = function (other) {
      if (this.equals(other)) {
        return 0;
      }
      var thisNeg = this.isNegative();
      var otherNeg = other.isNegative();
      if (thisNeg && !otherNeg) {
        return -1;
      }
      if (!thisNeg && otherNeg) {
        return 1;
      }
      if (this.subtract(other).isNegative()) {
        return -1;
      } else {
        return 1;
      }
    };
    Long.prototype.negate = function () {
      if (this.equals(Long.MIN_VALUE)) {
        return Long.MIN_VALUE;
      } else {
        return this.not().add(Long.ONE);
      }
    };
    Long.prototype.add = function (other) {
      var a48 = this.high_ >>> 16;
      var a32 = this.high_ & 0xFFFF;
      var a16 = this.low_ >>> 16;
      var a00 = this.low_ & 0xFFFF;
      var b48 = other.high_ >>> 16;
      var b32 = other.high_ & 0xFFFF;
      var b16 = other.low_ >>> 16;
      var b00 = other.low_ & 0xFFFF;
      var c48 = 0,
          c32 = 0,
          c16 = 0,
          c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 0xFFFF;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 0xFFFF;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 0xFFFF;
      c48 += a48 + b48;
      c48 &= 0xFFFF;
      return Long.fromBits(c16 << 16 | c00, c48 << 16 | c32);
    };
    Long.prototype.subtract = function (other) {
      return this.add(other.negate());
    };
    Long.prototype.multiply = function (other) {
      if (this.isZero()) {
        return Long.ZERO;
      } else if (other.isZero()) {
        return Long.ZERO;
      }
      if (this.equals(Long.MIN_VALUE)) {
        return other.isOdd() ? Long.MIN_VALUE : Long.ZERO;
      } else if (other.equals(Long.MIN_VALUE)) {
        return this.isOdd() ? Long.MIN_VALUE : Long.ZERO;
      }
      if (this.isNegative()) {
        if (other.isNegative()) {
          return this.negate().multiply(other.negate());
        } else {
          return this.negate().multiply(other).negate();
        }
      } else if (other.isNegative()) {
        return this.multiply(other.negate()).negate();
      }
      if (this.lessThan(Long.TWO_PWR_24_) && other.lessThan(Long.TWO_PWR_24_)) {
        return Long.fromNumber(this.toNumber() * other.toNumber());
      }
      var a48 = this.high_ >>> 16;
      var a32 = this.high_ & 0xFFFF;
      var a16 = this.low_ >>> 16;
      var a00 = this.low_ & 0xFFFF;
      var b48 = other.high_ >>> 16;
      var b32 = other.high_ & 0xFFFF;
      var b16 = other.low_ >>> 16;
      var b00 = other.low_ & 0xFFFF;
      var c48 = 0,
          c32 = 0,
          c16 = 0,
          c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 0xFFFF;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 0xFFFF;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 0xFFFF;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 0xFFFF;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 0xFFFF;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 0xFFFF;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 0xFFFF;
      return Long.fromBits(c16 << 16 | c00, c48 << 16 | c32);
    };
    Long.prototype.div = function (other) {
      if (other.isZero()) {
        throw Error('division by zero');
      } else if (this.isZero()) {
        return Long.ZERO;
      }
      if (this.equals(Long.MIN_VALUE)) {
        if (other.equals(Long.ONE) || other.equals(Long.NEG_ONE)) {
          return Long.MIN_VALUE;
        } else if (other.equals(Long.MIN_VALUE)) {
          return Long.ONE;
        } else {
          var halfThis = this.shiftRight(1);
          var approx = halfThis.div(other).shiftLeft(1);
          if (approx.equals(Long.ZERO)) {
            return other.isNegative() ? Long.ONE : Long.NEG_ONE;
          } else {
            var rem = this.subtract(other.multiply(approx));
            var result = approx.add(rem.div(other));
            return result;
          }
        }
      } else if (other.equals(Long.MIN_VALUE)) {
        return Long.ZERO;
      }
      if (this.isNegative()) {
        if (other.isNegative()) {
          return this.negate().div(other.negate());
        } else {
          return this.negate().div(other).negate();
        }
      } else if (other.isNegative()) {
        return this.div(other.negate()).negate();
      }
      var res = Long.ZERO;
      var rem = this;
      while (rem.greaterThanOrEqual(other)) {
        var approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));
        var log2 = Math.ceil(Math.log(approx) / Math.LN2);
        var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);
        var approxRes = Long.fromNumber(approx);
        var approxRem = approxRes.multiply(other);
        while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
          approx -= delta;
          approxRes = Long.fromNumber(approx);
          approxRem = approxRes.multiply(other);
        }
        if (approxRes.isZero()) {
          approxRes = Long.ONE;
        }
        res = res.add(approxRes);
        rem = rem.subtract(approxRem);
      }
      return res;
    };
    Long.prototype.modulo = function (other) {
      return this.subtract(this.div(other).multiply(other));
    };
    Long.prototype.not = function () {
      return Long.fromBits(~this.low_, ~this.high_);
    };
    Long.prototype.and = function (other) {
      return Long.fromBits(this.low_ & other.low_, this.high_ & other.high_);
    };
    Long.prototype.or = function (other) {
      return Long.fromBits(this.low_ | other.low_, this.high_ | other.high_);
    };
    Long.prototype.xor = function (other) {
      return Long.fromBits(this.low_ ^ other.low_, this.high_ ^ other.high_);
    };
    Long.prototype.shiftLeft = function (numBits) {
      numBits &= 63;
      if (numBits == 0) {
        return this;
      } else {
        var low = this.low_;
        if (numBits < 32) {
          var high = this.high_;
          return Long.fromBits(low << numBits, high << numBits | low >>> 32 - numBits);
        } else {
          return Long.fromBits(0, low << numBits - 32);
        }
      }
    };
    Long.prototype.shiftRight = function (numBits) {
      numBits &= 63;
      if (numBits == 0) {
        return this;
      } else {
        var high = this.high_;
        if (numBits < 32) {
          var low = this.low_;
          return Long.fromBits(low >>> numBits | high << 32 - numBits, high >> numBits);
        } else {
          return Long.fromBits(high >> numBits - 32, high >= 0 ? 0 : -1);
        }
      }
    };
    Long.prototype.shiftRightUnsigned = function (numBits) {
      numBits &= 63;
      if (numBits == 0) {
        return this;
      } else {
        var high = this.high_;
        if (numBits < 32) {
          var low = this.low_;
          return Long.fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits);
        } else if (numBits == 32) {
          return Long.fromBits(high, 0);
        } else {
          return Long.fromBits(high >>> numBits - 32, 0);
        }
      }
    };
    Long.fromInt = function (value) {
      if (-128 <= value && value < 128) {
        var cachedObj = Long.INT_CACHE_[value];
        if (cachedObj) {
          return cachedObj;
        }
      }
      var obj = new Long(value | 0, value < 0 ? -1 : 0);
      if (-128 <= value && value < 128) {
        Long.INT_CACHE_[value] = obj;
      }
      return obj;
    };
    Long.fromNumber = function (value) {
      if (isNaN(value) || !isFinite(value)) {
        return Long.ZERO;
      } else if (value <= -Long.TWO_PWR_63_DBL_) {
        return Long.MIN_VALUE;
      } else if (value + 1 >= Long.TWO_PWR_63_DBL_) {
        return Long.MAX_VALUE;
      } else if (value < 0) {
        return Long.fromNumber(-value).negate();
      } else {
        return new Long(value % Long.TWO_PWR_32_DBL_ | 0, value / Long.TWO_PWR_32_DBL_ | 0);
      }
    };
    Long.fromBits = function (lowBits, highBits) {
      return new Long(lowBits, highBits);
    };
    Long.fromString = function (str, opt_radix) {
      if (str.length == 0) {
        throw Error('number format error: empty string');
      }
      var radix = opt_radix || 10;
      if (radix < 2 || 36 < radix) {
        throw Error('radix out of range: ' + radix);
      }
      if (str.charAt(0) == '-') {
        return Long.fromString(str.substring(1), radix).negate();
      } else if (str.indexOf('-') >= 0) {
        throw Error('number format error: interior "-" character: ' + str);
      }
      var radixToPower = Long.fromNumber(Math.pow(radix, 8));
      var result = Long.ZERO;
      for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i);
        var value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
          var power = Long.fromNumber(Math.pow(radix, size));
          result = result.multiply(power).add(Long.fromNumber(value));
        } else {
          result = result.multiply(radixToPower);
          result = result.add(Long.fromNumber(value));
        }
      }
      return result;
    };
    Long.INT_CACHE_ = {};
    Long.TWO_PWR_16_DBL_ = 1 << 16;
    Long.TWO_PWR_24_DBL_ = 1 << 24;
    Long.TWO_PWR_32_DBL_ = Long.TWO_PWR_16_DBL_ * Long.TWO_PWR_16_DBL_;
    Long.TWO_PWR_31_DBL_ = Long.TWO_PWR_32_DBL_ / 2;
    Long.TWO_PWR_48_DBL_ = Long.TWO_PWR_32_DBL_ * Long.TWO_PWR_16_DBL_;
    Long.TWO_PWR_64_DBL_ = Long.TWO_PWR_32_DBL_ * Long.TWO_PWR_32_DBL_;
    Long.TWO_PWR_63_DBL_ = Long.TWO_PWR_64_DBL_ / 2;
    Long.ZERO = Long.fromInt(0);
    Long.ONE = Long.fromInt(1);
    Long.NEG_ONE = Long.fromInt(-1);
    Long.MAX_VALUE = Long.fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0);
    Long.MIN_VALUE = Long.fromBits(0, 0x80000000 | 0);
    Long.TWO_PWR_24_ = Long.fromInt(1 << 24);
    module.exports = Long;
    module.exports.Long = Long;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('271', ['269', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    "use strict";

    var Long = $__require('269');
    var PARSE_STRING_REGEXP = /^(\+|\-)?(\d+|(\d*\.\d*))?(E|e)?([\-\+])?(\d+)?$/;
    var PARSE_INF_REGEXP = /^(\+|\-)?(Infinity|inf)$/i;
    var PARSE_NAN_REGEXP = /^(\+|\-)?NaN$/i;
    var EXPONENT_MAX = 6111;
    var EXPONENT_MIN = -6176;
    var EXPONENT_BIAS = 6176;
    var MAX_DIGITS = 34;
    var NAN_BUFFER = [0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00].reverse();
    var INF_NEGATIVE_BUFFER = [0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00].reverse();
    var INF_POSITIVE_BUFFER = [0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00].reverse();
    var EXPONENT_REGEX = /^([\-\+])?(\d+)?$/;
    var isDigit = function (value) {
      return !isNaN(parseInt(value, 10));
    };
    var divideu128 = function (value) {
      var DIVISOR = Long.fromNumber(1000 * 1000 * 1000);
      var _rem = Long.fromNumber(0);
      var i = 0;
      if (!value.parts[0] && !value.parts[1] && !value.parts[2] && !value.parts[3]) {
        return {
          quotient: value,
          rem: _rem
        };
      }
      for (var i = 0; i <= 3; i++) {
        _rem = _rem.shiftLeft(32);
        _rem = _rem.add(new Long(value.parts[i], 0));
        value.parts[i] = _rem.div(DIVISOR).low_;
        _rem = _rem.modulo(DIVISOR);
      }
      return {
        quotient: value,
        rem: _rem
      };
    };
    var multiply64x2 = function (left, right) {
      if (!left && !right) {
        return {
          high: Long.fromNumber(0),
          low: Long.fromNumber(0)
        };
      }
      var leftHigh = left.shiftRightUnsigned(32);
      var leftLow = new Long(left.getLowBits(), 0);
      var rightHigh = right.shiftRightUnsigned(32);
      var rightLow = new Long(right.getLowBits(), 0);
      var productHigh = leftHigh.multiply(rightHigh);
      var productMid = leftHigh.multiply(rightLow);
      var productMid2 = leftLow.multiply(rightHigh);
      var productLow = leftLow.multiply(rightLow);
      productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
      productMid = new Long(productMid.getLowBits(), 0).add(productMid2).add(productLow.shiftRightUnsigned(32));
      productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
      productLow = productMid.shiftLeft(32).add(new Long(productLow.getLowBits(), 0));
      return {
        high: productHigh,
        low: productLow
      };
    };
    var lessThan = function (left, right) {
      var uhleft = left.high_ >>> 0;
      var uhright = right.high_ >>> 0;
      if (uhleft < uhright) {
        return true;
      } else if (uhleft == uhright) {
        var ulleft = left.low_ >>> 0;
        var ulright = right.low_ >>> 0;
        if (ulleft < ulright) return true;
      }
      return false;
    };
    var longtoHex = function (value) {
      var buffer = new Buffer(8);
      var index = 0;
      buffer[index++] = value.low_ & 0xff;
      buffer[index++] = value.low_ >> 8 & 0xff;
      buffer[index++] = value.low_ >> 16 & 0xff;
      buffer[index++] = value.low_ >> 24 & 0xff;
      buffer[index++] = value.high_ & 0xff;
      buffer[index++] = value.high_ >> 8 & 0xff;
      buffer[index++] = value.high_ >> 16 & 0xff;
      buffer[index++] = value.high_ >> 24 & 0xff;
      return buffer.reverse().toString('hex');
    };
    var int32toHex = function (value) {
      var buffer = new Buffer(4);
      var index = 0;
      buffer[index++] = value & 0xff;
      buffer[index++] = value >> 8 & 0xff;
      buffer[index++] = value >> 16 & 0xff;
      buffer[index++] = value >> 24 & 0xff;
      return buffer.reverse().toString('hex');
    };
    var Decimal128 = function (bytes) {
      this._bsontype = 'Decimal128';
      this.bytes = bytes;
    };
    Decimal128.fromString = function (string) {
      var isNegative = false;
      var sawRadix = false;
      var foundNonZero = false;
      var significantDigits = 0;
      var nDigitsRead = 0;
      var nDigits = 0;
      var radixPosition = 0;
      var firstNonZero = 0;
      var digits = [0];
      var nDigitsStored = 0;
      var digitsInsert = 0;
      var firstDigit = 0;
      var lastDigit = 0;
      var exponent = 0;
      var i = 0;
      var significandHigh = [0, 0];
      var significandLow = [0, 0];
      var biasedExponent = 0;
      var index = 0;
      string = string.trim();
      var stringMatch = string.match(PARSE_STRING_REGEXP);
      var infMatch = string.match(PARSE_INF_REGEXP);
      var nanMatch = string.match(PARSE_NAN_REGEXP);
      if (!stringMatch && !infMatch && !nanMatch || string.length == 0) {
        throw new Error("" + string + " not a valid Decimal128 string");
      }
      if (stringMatch && stringMatch[4] && stringMatch[2] === undefined) {
        throw new Error("" + string + " not a valid Decimal128 string");
      }
      if (string[index] == '+' || string[index] == '-') {
        isNegative = string[index++] == '-';
      }
      if (!isDigit(string[index]) && string[index] != '.') {
        if (string[index] == 'i' || string[index] == 'I') {
          return new Decimal128(new Buffer(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));
        } else if (string[index] == 'N') {
          return new Decimal128(new Buffer(NAN_BUFFER));
        }
      }
      while (isDigit(string[index]) || string[index] == '.') {
        if (string[index] == '.') {
          if (sawRadix) {
            return new Decimal128(new Buffer(NAN_BUFFER));
          }
          sawRadix = true;
          index = index + 1;
          continue;
        }
        if (nDigitsStored < 34) {
          if (string[index] != '0' || foundNonZero) {
            if (!foundNonZero) {
              firstNonZero = nDigitsRead;
            }
            foundNonZero = true;
            digits[digitsInsert++] = parseInt(string[index], 10);
            nDigitsStored = nDigitsStored + 1;
          }
        }
        if (foundNonZero) {
          nDigits = nDigits + 1;
        }
        if (sawRadix) {
          radixPosition = radixPosition + 1;
        }
        nDigitsRead = nDigitsRead + 1;
        index = index + 1;
      }
      if (sawRadix && !nDigitsRead) {
        throw new Error("" + string + " not a valid Decimal128 string");
      }
      if (string[index] == 'e' || string[index] == 'E') {
        var match = string.substr(++index).match(EXPONENT_REGEX);
        if (!match || !match[2]) {
          return new Decimal128(new Buffer(NAN_BUFFER));
        }
        exponent = parseInt(match[0], 10);
        index = index + match[0].length;
      }
      if (string[index]) {
        return new Decimal128(new Buffer(NAN_BUFFER));
      }
      firstDigit = 0;
      if (!nDigitsStored) {
        firstDigit = 0;
        lastDigit = 0;
        digits[0] = 0;
        nDigits = 1;
        nDigitsStored = 1;
        significantDigits = 0;
      } else {
        lastDigit = nDigitsStored - 1;
        significantDigits = nDigits;
        if (exponent != 0 && significantDigits != 1) {
          while (string[firstNonZero + significantDigits - 1] == '0') {
            significantDigits = significantDigits - 1;
          }
        }
      }
      if (exponent <= radixPosition && radixPosition - exponent > 1 << 14) {
        exponent = EXPONENT_MIN;
      } else {
        exponent = exponent - radixPosition;
      }
      while (exponent > EXPONENT_MAX) {
        lastDigit = lastDigit + 1;
        if (lastDigit - firstDigit > MAX_DIGITS) {
          var digitsString = digits.join('');
          if (digitsString.match(/^0+$/)) {
            exponent = EXPONENT_MAX;
            break;
          } else {
            return new Decimal128(new Buffer(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));
          }
        }
        exponent = exponent - 1;
      }
      while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {
        if (lastDigit == 0) {
          exponent = EXPONENT_MIN;
          significantDigits = 0;
          break;
        }
        if (nDigitsStored < nDigits) {
          nDigits = nDigits - 1;
        } else {
          lastDigit = lastDigit - 1;
        }
        if (exponent < EXPONENT_MAX) {
          exponent = exponent + 1;
        } else {
          var digitsString = digits.join('');
          if (digitsString.match(/^0+$/)) {
            exponent = EXPONENT_MAX;
            break;
          } else {
            return new Decimal128(new Buffer(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));
          }
        }
      }
      if (lastDigit - firstDigit + 1 < significantDigits && string[significantDigits] != '0') {
        var endOfString = nDigitsRead;
        if (sawRadix && exponent == EXPONENT_MIN) {
          firstNonZero = firstNonZero + 1;
          endOfString = endOfString + 1;
        }
        var roundDigit = parseInt(string[firstNonZero + lastDigit + 1], 10);
        var roundBit = 0;
        if (roundDigit >= 5) {
          roundBit = 1;
          if (roundDigit == 5) {
            roundBit = digits[lastDigit] % 2 == 1;
            for (var i = firstNonZero + lastDigit + 2; i < endOfString; i++) {
              if (parseInt(string[i], 10)) {
                roundBit = 1;
                break;
              }
            }
          }
        }
        if (roundBit) {
          var dIdx = lastDigit;
          for (; dIdx >= 0; dIdx--) {
            if (++digits[dIdx] > 9) {
              digits[dIdx] = 0;
              if (dIdx == 0) {
                if (exponent < EXPONENT_MAX) {
                  exponent = exponent + 1;
                  digits[dIdx] = 1;
                } else {
                  return new Decimal128(new Buffer(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));
                }
              }
            } else {
              break;
            }
          }
        }
      }
      significandHigh = Long.fromNumber(0);
      significandLow = Long.fromNumber(0);
      if (significantDigits == 0) {
        significandHigh = Long.fromNumber(0);
        significandLow = Long.fromNumber(0);
      } else if (lastDigit - firstDigit < 17) {
        var dIdx = firstDigit;
        significandLow = Long.fromNumber(digits[dIdx++]);
        significandHigh = new Long(0, 0);
        for (; dIdx <= lastDigit; dIdx++) {
          significandLow = significandLow.multiply(Long.fromNumber(10));
          significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));
        }
      } else {
        var dIdx = firstDigit;
        significandHigh = Long.fromNumber(digits[dIdx++]);
        for (; dIdx <= lastDigit - 17; dIdx++) {
          significandHigh = significandHigh.multiply(Long.fromNumber(10));
          significandHigh = significandHigh.add(Long.fromNumber(digits[dIdx]));
        }
        significandLow = Long.fromNumber(digits[dIdx++]);
        for (; dIdx <= lastDigit; dIdx++) {
          significandLow = significandLow.multiply(Long.fromNumber(10));
          significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));
        }
      }
      var significand = multiply64x2(significandHigh, Long.fromString("100000000000000000"));
      significand.low = significand.low.add(significandLow);
      if (lessThan(significand.low, significandLow)) {
        significand.high = significand.high.add(Long.fromNumber(1));
      }
      var biasedExponent = exponent + EXPONENT_BIAS;
      var dec = {
        low: Long.fromNumber(0),
        high: Long.fromNumber(0)
      };
      if (significand.high.shiftRightUnsigned(49).and(Long.fromNumber(1)).equals(Long.fromNumber)) {
        dec.high = dec.high.or(Long.fromNumber(0x3).shiftLeft(61));
        dec.high = dec.high.or(Long.fromNumber(biasedExponent).and(Long.fromNumber(0x3fff).shiftLeft(47)));
        dec.high = dec.high.or(significand.high.and(Long.fromNumber(0x7fffffffffff)));
      } else {
        dec.high = dec.high.or(Long.fromNumber(biasedExponent & 0x3fff).shiftLeft(49));
        dec.high = dec.high.or(significand.high.and(Long.fromNumber(0x1ffffffffffff)));
      }
      dec.low = significand.low;
      if (isNegative) {
        dec.high = dec.high.or(Long.fromString('9223372036854775808'));
      }
      var buffer = new Buffer(16);
      var index = 0;
      buffer[index++] = dec.low.low_ & 0xff;
      buffer[index++] = dec.low.low_ >> 8 & 0xff;
      buffer[index++] = dec.low.low_ >> 16 & 0xff;
      buffer[index++] = dec.low.low_ >> 24 & 0xff;
      buffer[index++] = dec.low.high_ & 0xff;
      buffer[index++] = dec.low.high_ >> 8 & 0xff;
      buffer[index++] = dec.low.high_ >> 16 & 0xff;
      buffer[index++] = dec.low.high_ >> 24 & 0xff;
      buffer[index++] = dec.high.low_ & 0xff;
      buffer[index++] = dec.high.low_ >> 8 & 0xff;
      buffer[index++] = dec.high.low_ >> 16 & 0xff;
      buffer[index++] = dec.high.low_ >> 24 & 0xff;
      buffer[index++] = dec.high.high_ & 0xff;
      buffer[index++] = dec.high.high_ >> 8 & 0xff;
      buffer[index++] = dec.high.high_ >> 16 & 0xff;
      buffer[index++] = dec.high.high_ >> 24 & 0xff;
      return new Decimal128(buffer);
    };
    var COMBINATION_MASK = 0x1f;
    var EXPONENT_MASK = 0x3fff;
    var COMBINATION_INFINITY = 30;
    var COMBINATION_NAN = 31;
    var COMBINATION_SNAN = 32;
    var EXPONENT_BIAS = 6176;
    Decimal128.prototype.toString = function () {
      var high;
      var midh;
      var midl;
      var low;
      var combination;
      var biased_exponent;
      var significand_digits = 0;
      var significand = new Array(36);
      for (var i = 0; i < significand.length; i++) significand[i] = 0;
      var index = 0;
      var exponent;
      var scientific_exponent;
      var is_zero = false;
      var significand_msb;
      var significand128 = { parts: new Array(4) };
      var i;
      var j, k;
      var string = [];
      var index = 0;
      var buffer = this.bytes;
      low = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
      midl = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
      midh = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
      high = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
      var index = 0;
      var dec = {
        low: new Long(low, midl),
        high: new Long(midh, high)
      };
      if (dec.high.lessThan(Long.ZERO)) {
        string.push('-');
      }
      combination = high >> 26 & COMBINATION_MASK;
      if (combination >> 3 == 3) {
        if (combination == COMBINATION_INFINITY) {
          return string.join('') + "Infinity";
        } else if (combination == COMBINATION_NAN) {
          return "NaN";
        } else {
          biased_exponent = high >> 15 & EXPONENT_MASK;
          significand_msb = 0x08 + (high >> 14 & 0x01);
        }
      } else {
        significand_msb = high >> 14 & 0x07;
        biased_exponent = high >> 17 & EXPONENT_MASK;
      }
      exponent = biased_exponent - EXPONENT_BIAS;
      significand128.parts[0] = (high & 0x3fff) + ((significand_msb & 0xf) << 14);
      significand128.parts[1] = midh;
      significand128.parts[2] = midl;
      significand128.parts[3] = low;
      if (significand128.parts[0] == 0 && significand128.parts[1] == 0 && significand128.parts[2] == 0 && significand128.parts[3] == 0) {
        is_zero = true;
      } else {
        for (var k = 3; k >= 0; k--) {
          var least_digits = 0;
          var result = divideu128(significand128);
          significand128 = result.quotient;
          least_digits = result.rem.low_;
          if (!least_digits) continue;
          for (var j = 8; j >= 0; j--) {
            significand[k * 9 + j] = least_digits % 10;
            least_digits = Math.floor(least_digits / 10);
          }
        }
      }
      if (is_zero) {
        significand_digits = 1;
        significand[index] = 0;
      } else {
        significand_digits = 36;
        var i = 0;
        while (!significand[index]) {
          i++;
          significand_digits = significand_digits - 1;
          index = index + 1;
        }
      }
      scientific_exponent = significand_digits - 1 + exponent;
      if (scientific_exponent >= 34 || scientific_exponent <= -7 || exponent > 0) {
        string.push(significand[index++]);
        significand_digits = significand_digits - 1;
        if (significand_digits) {
          string.push('.');
        }
        for (var i = 0; i < significand_digits; i++) {
          string.push(significand[index++]);
        }
        string.push('E');
        if (scientific_exponent > 0) {
          string.push('+' + scientific_exponent);
        } else {
          string.push(scientific_exponent);
        }
      } else {
        if (exponent >= 0) {
          for (var i = 0; i < significand_digits; i++) {
            string.push(significand[index++]);
          }
        } else {
          var radix_position = significand_digits + exponent;
          if (radix_position > 0) {
            for (var i = 0; i < radix_position; i++) {
              string.push(significand[index++]);
            }
          } else {
            string.push('0');
          }
          string.push('.');
          while (radix_position++ < 0) {
            string.push('0');
          }
          for (var i = 0; i < significand_digits - Math.max(radix_position - 1, 0); i++) {
            string.push(significand[index++]);
          }
        }
      }
      return string.join('');
    };
    Decimal128.prototype.toJSON = function () {
      return { "$numberDecimal": this.toString() };
    };
    module.exports = Decimal128;
    module.exports.Decimal128 = Decimal128;
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic('26f', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /**
   * A class representation of the BSON MinKey type.
   *
   * @class
   * @return {MinKey} A MinKey instance
   */
  function MinKey() {
    if (!(this instanceof MinKey)) return new MinKey();

    this._bsontype = 'MinKey';
  }

  module.exports = MinKey;
  module.exports.MinKey = MinKey;
  return module.exports;
});
$__System.registerDynamic('270', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /**
   * A class representation of the BSON MaxKey type.
   *
   * @class
   * @return {MaxKey} A MaxKey instance
   */
  function MaxKey() {
    if (!(this instanceof MaxKey)) return new MaxKey();

    this._bsontype = 'MaxKey';
  }

  module.exports = MaxKey;
  module.exports.MaxKey = MaxKey;
  return module.exports;
});
$__System.registerDynamic('273', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /**
   * A class representation of the BSON DBRef type.
   *
   * @class
   * @param {string} namespace the collection name.
   * @param {ObjectID} oid the reference ObjectID.
   * @param {string} [db] optional db name, if omitted the reference is local to the current db.
   * @return {DBRef}
   */
  function DBRef(namespace, oid, db) {
    if (!(this instanceof DBRef)) return new DBRef(namespace, oid, db);

    this._bsontype = 'DBRef';
    this.namespace = namespace;
    this.oid = oid;
    this.db = db;
  };

  /**
   * @ignore
   * @api private
   */
  DBRef.prototype.toJSON = function () {
    return {
      '$ref': this.namespace,
      '$id': this.oid,
      '$db': this.db == null ? '' : this.db
    };
  };

  module.exports = DBRef;
  module.exports.DBRef = DBRef;
  return module.exports;
});
$__System.registerDynamic('275', ['2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    if (typeof global !== 'undefined') {
      var Buffer = $__require('2a').Buffer;
    }
    function Binary(buffer, subType) {
      if (!(this instanceof Binary)) return new Binary(buffer, subType);
      this._bsontype = 'Binary';
      if (buffer instanceof Number) {
        this.sub_type = buffer;
        this.position = 0;
      } else {
        this.sub_type = subType == null ? BSON_BINARY_SUBTYPE_DEFAULT : subType;
        this.position = 0;
      }
      if (buffer != null && !(buffer instanceof Number)) {
        if (typeof buffer == 'string') {
          if (typeof Buffer != 'undefined') {
            this.buffer = new Buffer(buffer);
          } else if (typeof Uint8Array != 'undefined' || Object.prototype.toString.call(buffer) == '[object Array]') {
            this.buffer = writeStringToArray(buffer);
          } else {
            throw new Error("only String, Buffer, Uint8Array or Array accepted");
          }
        } else {
          this.buffer = buffer;
        }
        this.position = buffer.length;
      } else {
        if (typeof Buffer != 'undefined') {
          this.buffer = new Buffer(Binary.BUFFER_SIZE);
        } else if (typeof Uint8Array != 'undefined') {
          this.buffer = new Uint8Array(new ArrayBuffer(Binary.BUFFER_SIZE));
        } else {
          this.buffer = new Array(Binary.BUFFER_SIZE);
        }
        this.position = 0;
      }
    }
    ;
    Binary.prototype.put = function put(byte_value) {
      if (byte_value['length'] != null && typeof byte_value != 'number' && byte_value.length != 1) throw new Error("only accepts single character String, Uint8Array or Array");
      if (typeof byte_value != 'number' && byte_value < 0 || byte_value > 255) throw new Error("only accepts number in a valid unsigned byte range 0-255");
      var decoded_byte = null;
      if (typeof byte_value == 'string') {
        decoded_byte = byte_value.charCodeAt(0);
      } else if (byte_value['length'] != null) {
        decoded_byte = byte_value[0];
      } else {
        decoded_byte = byte_value;
      }
      if (this.buffer.length > this.position) {
        this.buffer[this.position++] = decoded_byte;
      } else {
        if (typeof Buffer != 'undefined' && Buffer.isBuffer(this.buffer)) {
          var buffer = new Buffer(Binary.BUFFER_SIZE + this.buffer.length);
          this.buffer.copy(buffer, 0, 0, this.buffer.length);
          this.buffer = buffer;
          this.buffer[this.position++] = decoded_byte;
        } else {
          var buffer = null;
          if (Object.prototype.toString.call(this.buffer) == '[object Uint8Array]') {
            buffer = new Uint8Array(new ArrayBuffer(Binary.BUFFER_SIZE + this.buffer.length));
          } else {
            buffer = new Array(Binary.BUFFER_SIZE + this.buffer.length);
          }
          for (var i = 0; i < this.buffer.length; i++) {
            buffer[i] = this.buffer[i];
          }
          this.buffer = buffer;
          this.buffer[this.position++] = decoded_byte;
        }
      }
    };
    Binary.prototype.write = function write(string, offset) {
      offset = typeof offset == 'number' ? offset : this.position;
      if (this.buffer.length < offset + string.length) {
        var buffer = null;
        if (typeof Buffer != 'undefined' && Buffer.isBuffer(this.buffer)) {
          buffer = new Buffer(this.buffer.length + string.length);
          this.buffer.copy(buffer, 0, 0, this.buffer.length);
        } else if (Object.prototype.toString.call(this.buffer) == '[object Uint8Array]') {
          buffer = new Uint8Array(new ArrayBuffer(this.buffer.length + string.length));
          for (var i = 0; i < this.position; i++) {
            buffer[i] = this.buffer[i];
          }
        }
        this.buffer = buffer;
      }
      if (typeof Buffer != 'undefined' && Buffer.isBuffer(string) && Buffer.isBuffer(this.buffer)) {
        string.copy(this.buffer, offset, 0, string.length);
        this.position = offset + string.length > this.position ? offset + string.length : this.position;
      } else if (typeof Buffer != 'undefined' && typeof string == 'string' && Buffer.isBuffer(this.buffer)) {
        this.buffer.write(string, offset, 'binary');
        this.position = offset + string.length > this.position ? offset + string.length : this.position;
      } else if (Object.prototype.toString.call(string) == '[object Uint8Array]' || Object.prototype.toString.call(string) == '[object Array]' && typeof string != 'string') {
        for (var i = 0; i < string.length; i++) {
          this.buffer[offset++] = string[i];
        }
        this.position = offset > this.position ? offset : this.position;
      } else if (typeof string == 'string') {
        for (var i = 0; i < string.length; i++) {
          this.buffer[offset++] = string.charCodeAt(i);
        }
        this.position = offset > this.position ? offset : this.position;
      }
    };
    Binary.prototype.read = function read(position, length) {
      length = length && length > 0 ? length : this.position;
      if (this.buffer['slice']) {
        return this.buffer.slice(position, position + length);
      } else {
        var buffer = typeof Uint8Array != 'undefined' ? new Uint8Array(new ArrayBuffer(length)) : new Array(length);
        for (var i = 0; i < length; i++) {
          buffer[i] = this.buffer[position++];
        }
      }
      return buffer;
    };
    Binary.prototype.value = function value(asRaw) {
      asRaw = asRaw == null ? false : asRaw;
      if (asRaw && typeof Buffer != 'undefined' && Buffer.isBuffer(this.buffer) && this.buffer.length == this.position) return this.buffer;
      if (typeof Buffer != 'undefined' && Buffer.isBuffer(this.buffer)) {
        return asRaw ? this.buffer.slice(0, this.position) : this.buffer.toString('binary', 0, this.position);
      } else {
        if (asRaw) {
          if (this.buffer['slice'] != null) {
            return this.buffer.slice(0, this.position);
          } else {
            var newBuffer = Object.prototype.toString.call(this.buffer) == '[object Uint8Array]' ? new Uint8Array(new ArrayBuffer(this.position)) : new Array(this.position);
            for (var i = 0; i < this.position; i++) {
              newBuffer[i] = this.buffer[i];
            }
            return newBuffer;
          }
        } else {
          return convertArraytoUtf8BinaryString(this.buffer, 0, this.position);
        }
      }
    };
    Binary.prototype.length = function length() {
      return this.position;
    };
    Binary.prototype.toJSON = function () {
      return this.buffer != null ? this.buffer.toString('base64') : '';
    };
    Binary.prototype.toString = function (format) {
      return this.buffer != null ? this.buffer.slice(0, this.position).toString(format) : '';
    };
    var BSON_BINARY_SUBTYPE_DEFAULT = 0;
    var writeStringToArray = function (data) {
      var buffer = typeof Uint8Array != 'undefined' ? new Uint8Array(new ArrayBuffer(data.length)) : new Array(data.length);
      for (var i = 0; i < data.length; i++) {
        buffer[i] = data.charCodeAt(i);
      }
      return buffer;
    };
    var convertArraytoUtf8BinaryString = function (byteArray, startIndex, endIndex) {
      var result = "";
      for (var i = startIndex; i < endIndex; i++) {
        result = result + String.fromCharCode(byteArray[i]);
      }
      return result;
    };
    Binary.BUFFER_SIZE = 256;
    Binary.SUBTYPE_DEFAULT = 0;
    Binary.SUBTYPE_FUNCTION = 1;
    Binary.SUBTYPE_BYTE_ARRAY = 2;
    Binary.SUBTYPE_UUID_OLD = 3;
    Binary.SUBTYPE_UUID = 4;
    Binary.SUBTYPE_MD5 = 5;
    Binary.SUBTYPE_USER_DEFINED = 128;
    module.exports = Binary;
    module.exports.Binary = Binary;
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic('278', ['268', '269', '26a', '26b', '26c', '26d', '274', '26e', '271', '26f', '270', '273', '275', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    "use strict";

    var writeIEEE754 = $__require('268').writeIEEE754,
        readIEEE754 = $__require('268').readIEEE754,
        Long = $__require('269').Long,
        Double = $__require('26a').Double,
        Timestamp = $__require('26b').Timestamp,
        ObjectID = $__require('26c').ObjectID,
        Symbol = $__require('26d').Symbol,
        BSONRegExp = $__require('274').BSONRegExp,
        Code = $__require('26e').Code,
        Decimal128 = $__require('271'),
        MinKey = $__require('26f').MinKey,
        MaxKey = $__require('270').MaxKey,
        DBRef = $__require('273').DBRef,
        Binary = $__require('275').Binary;
    var isDate = function isDate(d) {
      return typeof d === 'object' && Object.prototype.toString.call(d) === '[object Date]';
    };
    var calculateObjectSize = function calculateObjectSize(object, serializeFunctions, ignoreUndefined) {
      var totalLength = 4 + 1;
      if (Array.isArray(object)) {
        for (var i = 0; i < object.length; i++) {
          totalLength += calculateElement(i.toString(), object[i], serializeFunctions, true, ignoreUndefined);
        }
      } else {
        if (object.toBSON) {
          object = object.toBSON();
        }
        for (var key in object) {
          totalLength += calculateElement(key, object[key], serializeFunctions, false, ignoreUndefined);
        }
      }
      return totalLength;
    };
    function calculateElement(name, value, serializeFunctions, isArray, ignoreUndefined) {
      if (value && value.toBSON) {
        value = value.toBSON();
      }
      switch (typeof value) {
        case 'string':
          return 1 + Buffer.byteLength(name, 'utf8') + 1 + 4 + Buffer.byteLength(value, 'utf8') + 1;
        case 'number':
          if (Math.floor(value) === value && value >= BSON.JS_INT_MIN && value <= BSON.JS_INT_MAX) {
            if (value >= BSON.BSON_INT32_MIN && value <= BSON.BSON_INT32_MAX) {
              return (name != null ? Buffer.byteLength(name, 'utf8') + 1 : 0) + (4 + 1);
            } else {
              return (name != null ? Buffer.byteLength(name, 'utf8') + 1 : 0) + (8 + 1);
            }
          } else {
            return (name != null ? Buffer.byteLength(name, 'utf8') + 1 : 0) + (8 + 1);
          }
        case 'undefined':
          if (isArray || !ignoreUndefined) return (name != null ? Buffer.byteLength(name, 'utf8') + 1 : 0) + 1;
          return 0;
        case 'boolean':
          return (name != null ? Buffer.byteLength(name, 'utf8') + 1 : 0) + (1 + 1);
        case 'object':
          if (value == null || value instanceof MinKey || value instanceof MaxKey || value['_bsontype'] == 'MinKey' || value['_bsontype'] == 'MaxKey') {
            return (name != null ? Buffer.byteLength(name, 'utf8') + 1 : 0) + 1;
          } else if (value instanceof ObjectID || value['_bsontype'] == 'ObjectID') {
            return (name != null ? Buffer.byteLength(name, 'utf8') + 1 : 0) + (12 + 1);
          } else if (value instanceof Date || isDate(value)) {
            return (name != null ? Buffer.byteLength(name, 'utf8') + 1 : 0) + (8 + 1);
          } else if (typeof Buffer !== 'undefined' && Buffer.isBuffer(value)) {
            return (name != null ? Buffer.byteLength(name, 'utf8') + 1 : 0) + (1 + 4 + 1) + value.length;
          } else if (value instanceof Long || value instanceof Double || value instanceof Timestamp || value['_bsontype'] == 'Long' || value['_bsontype'] == 'Double' || value['_bsontype'] == 'Timestamp') {
            return (name != null ? Buffer.byteLength(name, 'utf8') + 1 : 0) + (8 + 1);
          } else if (value instanceof Decimal128 || value['_bsontype'] == 'Decimal128') {
            return (name != null ? Buffer.byteLength(name, 'utf8') + 1 : 0) + (16 + 1);
          } else if (value instanceof Code || value['_bsontype'] == 'Code') {
            if (value.scope != null && Object.keys(value.scope).length > 0) {
              return (name != null ? Buffer.byteLength(name, 'utf8') + 1 : 0) + 1 + 4 + 4 + Buffer.byteLength(value.code.toString(), 'utf8') + 1 + calculateObjectSize(value.scope, serializeFunctions, ignoreUndefined);
            } else {
              return (name != null ? Buffer.byteLength(name, 'utf8') + 1 : 0) + 1 + 4 + Buffer.byteLength(value.code.toString(), 'utf8') + 1;
            }
          } else if (value instanceof Binary || value['_bsontype'] == 'Binary') {
            if (value.sub_type == Binary.SUBTYPE_BYTE_ARRAY) {
              return (name != null ? Buffer.byteLength(name, 'utf8') + 1 : 0) + (value.position + 1 + 4 + 1 + 4);
            } else {
              return (name != null ? Buffer.byteLength(name, 'utf8') + 1 : 0) + (value.position + 1 + 4 + 1);
            }
          } else if (value instanceof Symbol || value['_bsontype'] == 'Symbol') {
            return (name != null ? Buffer.byteLength(name, 'utf8') + 1 : 0) + Buffer.byteLength(value.value, 'utf8') + 4 + 1 + 1;
          } else if (value instanceof DBRef || value['_bsontype'] == 'DBRef') {
            var ordered_values = {
              '$ref': value.namespace,
              '$id': value.oid
            };
            if (null != value.db) {
              ordered_values['$db'] = value.db;
            }
            return (name != null ? Buffer.byteLength(name, 'utf8') + 1 : 0) + 1 + calculateObjectSize(ordered_values, serializeFunctions, ignoreUndefined);
          } else if (value instanceof RegExp || Object.prototype.toString.call(value) === '[object RegExp]') {
            return (name != null ? Buffer.byteLength(name, 'utf8') + 1 : 0) + 1 + Buffer.byteLength(value.source, 'utf8') + 1 + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1;
          } else if (value instanceof BSONRegExp || value['_bsontype'] == 'BSONRegExp') {
            return (name != null ? Buffer.byteLength(name, 'utf8') + 1 : 0) + 1 + Buffer.byteLength(value.pattern, 'utf8') + 1 + Buffer.byteLength(value.options, 'utf8') + 1;
          } else {
            return (name != null ? Buffer.byteLength(name, 'utf8') + 1 : 0) + calculateObjectSize(value, serializeFunctions, ignoreUndefined) + 1;
          }
        case 'function':
          if (value instanceof RegExp || Object.prototype.toString.call(value) === '[object RegExp]' || String.call(value) == '[object RegExp]') {
            return (name != null ? Buffer.byteLength(name, 'utf8') + 1 : 0) + 1 + Buffer.byteLength(value.source, 'utf8') + 1 + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1;
          } else {
            if (serializeFunctions && value.scope != null && Object.keys(value.scope).length > 0) {
              return (name != null ? Buffer.byteLength(name, 'utf8') + 1 : 0) + 1 + 4 + 4 + Buffer.byteLength(value.toString(), 'utf8') + 1 + calculateObjectSize(value.scope, serializeFunctions, ignoreUndefined);
            } else if (serializeFunctions) {
              return (name != null ? Buffer.byteLength(name, 'utf8') + 1 : 0) + 1 + 4 + Buffer.byteLength(value.toString(), 'utf8') + 1;
            }
          }
      }
      return 0;
    }
    var BSON = {};
    BSON.BSON_INT32_MAX = 0x7FFFFFFF;
    BSON.BSON_INT32_MIN = -0x80000000;
    BSON.JS_INT_MAX = 0x20000000000000;
    BSON.JS_INT_MIN = -0x20000000000000;
    module.exports = calculateObjectSize;
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic('279', ['268', '276', '269', '26a', '26b', '26c', '274', '26d', '272', '26e', '271', '26f', '270', '273', '275', '267', '277', '278', '2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    "use strict";

    var writeIEEE754 = $__require('268').writeIEEE754,
        readIEEE754 = $__require('268').readIEEE754,
        Map = $__require('276'),
        Long = $__require('269'),
        Double = $__require('26a'),
        Timestamp = $__require('26b'),
        ObjectID = $__require('26c'),
        BSONRegExp = $__require('274'),
        Symbol = $__require('26d'),
        Int32 = $__require('272'),
        Code = $__require('26e'),
        Decimal128 = $__require('271'),
        MinKey = $__require('26f'),
        MaxKey = $__require('270'),
        DBRef = $__require('273'),
        Binary = $__require('275');
    var deserialize = $__require('267'),
        serializer = $__require('277'),
        calculateObjectSize = $__require('278');
    var MAXSIZE = 1024 * 1024 * 17;
    var buffer = new Buffer(MAXSIZE);
    var BSON = function () {};
    BSON.prototype.serialize = function serialize(object, checkKeys, asBuffer, serializeFunctions, index, ignoreUndefined) {
      var serializationIndex = serializer(buffer, object, checkKeys, index || 0, 0, serializeFunctions, ignoreUndefined, []);
      var finishedBuffer = new Buffer(serializationIndex);
      buffer.copy(finishedBuffer, 0, 0, finishedBuffer.length);
      return finishedBuffer;
    };
    BSON.prototype.serializeWithBufferAndIndex = function (object, checkKeys, finalBuffer, startIndex, serializeFunctions, ignoreUndefined) {
      var serializationIndex = serializer(buffer, object, checkKeys, startIndex || 0, 0, serializeFunctions, ignoreUndefined);
      buffer.copy(finalBuffer, startIndex, 0, serializationIndex);
      return serializationIndex - 1;
    };
    BSON.prototype.deserialize = function (data, options) {
      return deserialize(data, options);
    };
    BSON.prototype.calculateObjectSize = function (object, serializeFunctions, ignoreUndefined) {
      return calculateObjectSize(object, serializeFunctions, ignoreUndefined);
    };
    BSON.prototype.deserializeStream = function (data, startIndex, numberOfDocuments, documents, docStartIndex, options) {
      options = options != null ? options : {};
      var index = startIndex;
      for (var i = 0; i < numberOfDocuments; i++) {
        var size = data[index] | data[index + 1] << 8 | data[index + 2] << 16 | data[index + 3] << 24;
        options['index'] = index;
        documents[docStartIndex + i] = this.deserialize(data, options);
        index = index + size;
      }
      return index;
    };
    BSON.BSON_INT32_MAX = 0x7FFFFFFF;
    BSON.BSON_INT32_MIN = -0x80000000;
    BSON.BSON_INT64_MAX = Math.pow(2, 63) - 1;
    BSON.BSON_INT64_MIN = -Math.pow(2, 63);
    BSON.JS_INT_MAX = 0x20000000000000;
    BSON.JS_INT_MIN = -0x20000000000000;
    var JS_INT_MAX_LONG = Long.fromNumber(0x20000000000000);
    var JS_INT_MIN_LONG = Long.fromNumber(-0x20000000000000);
    BSON.BSON_DATA_NUMBER = 1;
    BSON.BSON_DATA_STRING = 2;
    BSON.BSON_DATA_OBJECT = 3;
    BSON.BSON_DATA_ARRAY = 4;
    BSON.BSON_DATA_BINARY = 5;
    BSON.BSON_DATA_OID = 7;
    BSON.BSON_DATA_BOOLEAN = 8;
    BSON.BSON_DATA_DATE = 9;
    BSON.BSON_DATA_NULL = 10;
    BSON.BSON_DATA_REGEXP = 11;
    BSON.BSON_DATA_CODE = 13;
    BSON.BSON_DATA_SYMBOL = 14;
    BSON.BSON_DATA_CODE_W_SCOPE = 15;
    BSON.BSON_DATA_INT = 16;
    BSON.BSON_DATA_TIMESTAMP = 17;
    BSON.BSON_DATA_LONG = 18;
    BSON.BSON_DATA_MIN_KEY = 0xff;
    BSON.BSON_DATA_MAX_KEY = 0x7f;
    BSON.BSON_BINARY_SUBTYPE_DEFAULT = 0;
    BSON.BSON_BINARY_SUBTYPE_FUNCTION = 1;
    BSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;
    BSON.BSON_BINARY_SUBTYPE_UUID = 3;
    BSON.BSON_BINARY_SUBTYPE_MD5 = 4;
    BSON.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;
    module.exports = BSON;
    module.exports.Code = Code;
    module.exports.Map = Map;
    module.exports.Symbol = Symbol;
    module.exports.BSON = BSON;
    module.exports.DBRef = DBRef;
    module.exports.Binary = Binary;
    module.exports.ObjectID = ObjectID;
    module.exports.Long = Long;
    module.exports.Timestamp = Timestamp;
    module.exports.Double = Double;
    module.exports.Int32 = Int32;
    module.exports.MinKey = MinKey;
    module.exports.MaxKey = MaxKey;
    module.exports.BSONRegExp = BSONRegExp;
    module.exports.Decimal128 = Decimal128;
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic("1b6", ["279"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("279");
  return module.exports;
});
$__System.registerDynamic('1ab', [], true, function ($__require, exports, module) {
  /* */
  "use strict";

  /**
   * Creates a new MongoError
   * @class
   * @augments Error
   * @param {string} message The error message
   * @return {MongoError} A MongoError instance
   */

  var define,
      global = this || self,
      GLOBAL = global;
  function MongoError(message) {
    this.name = 'MongoError';
    this.message = message;
    Error.captureStackTrace(this, MongoError);
  }

  /**
   * Creates a new MongoError object
   * @method
   * @param {object} options The error options
   * @return {MongoError} A MongoError instance
   */
  MongoError.create = function (options) {
    var err = null;

    if (options instanceof Error) {
      err = new MongoError(options.message);
      err.stack = options.stack;
    } else if (typeof options == 'string') {
      err = new MongoError(options);
    } else {
      err = new MongoError(options.message || options.errmsg || options.$err || "n/a");
      // Other options
      for (var name in options) {
        err[name] = options[name];
      }
    }

    return err;
  };

  // Extend JavaScript error
  MongoError.prototype = new Error();

  module.exports = MongoError;
  return module.exports;
});
$__System.registerDynamic('1b5', ['166', '38', '1c2', '1b6', '1ab', '2a', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer, process) {
    "use strict";

    var f = $__require('166').format,
        crypto = $__require('38'),
        Query = $__require('1c2').Query,
        Binary = $__require('1b6').Binary,
        MongoError = $__require('1ab');
    var AuthSession = function (db, username, password) {
      this.db = db;
      this.username = username;
      this.password = password;
    };
    AuthSession.prototype.equal = function (session) {
      return session.db == this.db && session.username == this.username && session.password == this.password;
    };
    var id = 0;
    var ScramSHA1 = function (bson) {
      this.bson = bson;
      this.authStore = [];
      this.id = id++;
    };
    var parsePayload = function (payload) {
      var dict = {};
      var parts = payload.split(',');
      for (var i = 0; i < parts.length; i++) {
        var valueParts = parts[i].split('=');
        dict[valueParts[0]] = valueParts[1];
      }
      return dict;
    };
    var passwordDigest = function (username, password) {
      if (typeof username != 'string') throw new MongoError("username must be a string");
      if (typeof password != 'string') throw new MongoError("password must be a string");
      if (password.length == 0) throw new MongoError("password cannot be empty");
      var md5 = crypto.createHash('md5');
      md5.update(username + ":mongo:" + password, 'utf8');
      return md5.digest('hex');
    };
    var xor = function (a, b) {
      if (!Buffer.isBuffer(a)) a = new Buffer(a);
      if (!Buffer.isBuffer(b)) b = new Buffer(b);
      var res = [];
      if (a.length > b.length) {
        for (var i = 0; i < b.length; i++) {
          res.push(a[i] ^ b[i]);
        }
      } else {
        for (i = 0; i < a.length; i++) {
          res.push(a[i] ^ b[i]);
        }
      }
      return new Buffer(res);
    };
    var hi = function (data, salt, iterations) {
      var digest = function (msg) {
        var hmac = crypto.createHmac('sha1', data);
        hmac.update(msg);
        return new Buffer(hmac.digest('base64'), 'base64');
      };
      salt = Buffer.concat([salt, new Buffer('\x00\x00\x00\x01')]);
      var ui = digest(salt);
      var u1 = ui;
      for (var i = 0; i < iterations - 1; i++) {
        u1 = digest(u1);
        ui = xor(ui, u1);
      }
      return ui;
    };
    ScramSHA1.prototype.auth = function (server, connections, db, username, password, callback) {
      var self = this;
      var count = connections.length;
      if (count == 0) return callback(null, null);
      var numberOfValidConnections = 0;
      var errorObject = null;
      var executeScram = function (connection) {
        username = username.replace('=', "=3D").replace(',', '=2C');
        var nonce = crypto.randomBytes(24).toString('base64');
        var firstBare = f("n=%s,r=%s", username, nonce);
        var cmd = {
          saslStart: 1,
          mechanism: 'SCRAM-SHA-1',
          payload: new Binary(f("n,,%s", firstBare)),
          autoAuthorize: 1
        };
        var handleError = function (err, r) {
          if (err) {
            numberOfValidConnections = numberOfValidConnections - 1;
            errorObject = err;
            return false;
          } else if (r.result['$err']) {
            errorObject = r.result;
            return false;
          } else if (r.result['errmsg']) {
            errorObject = r.result;
            return false;
          } else {
            numberOfValidConnections = numberOfValidConnections + 1;
          }
          return true;
        };
        var finish = function (_count, _numberOfValidConnections) {
          if (_count == 0 && _numberOfValidConnections > 0) {
            addAuthSession(self.authStore, new AuthSession(db, username, password));
            return callback(null, true);
          } else if (_count == 0) {
            if (errorObject == null) errorObject = new MongoError(f("failed to authenticate using scram"));
            return callback(errorObject, false);
          }
        };
        var handleEnd = function (_err, _r) {
          handleError(_err, _r);
          count = count - 1;
          finish(count, numberOfValidConnections);
        };
        server(connection, new Query(self.bson, f("%s.$cmd", db), cmd, {
          numberToSkip: 0,
          numberToReturn: 1
        }), function (err, r) {
          if (handleError(err, r) == false) {
            count = count - 1;
            if (count == 0 && numberOfValidConnections > 0) {
              addAuthSession(self.authStore, new AuthSession(db, username, password));
              return callback(null, true);
            } else if (count == 0) {
              if (errorObject == null) errorObject = new MongoError(f("failed to authenticate using scram"));
              return callback(errorObject, false);
            }
            return;
          }
          var dict = parsePayload(r.result.payload.value());
          var iterations = parseInt(dict.i, 10);
          var salt = dict.s;
          var rnonce = dict.r;
          var withoutProof = f("c=biws,r=%s", rnonce);
          var passwordDig = passwordDigest(username, password);
          var saltedPassword = hi(passwordDig, new Buffer(salt, 'base64'), iterations);
          var hmac = crypto.createHmac('sha1', saltedPassword);
          hmac.update(new Buffer("Client Key"));
          var clientKey = new Buffer(hmac.digest('base64'), 'base64');
          var hash = crypto.createHash('sha1');
          hash.update(clientKey);
          var storedKey = new Buffer(hash.digest('base64'), 'base64');
          var authMsg = [firstBare, r.result.payload.value().toString('base64'), withoutProof].join(',');
          hmac = crypto.createHmac('sha1', storedKey);
          hmac.update(new Buffer(authMsg));
          var clientSig = new Buffer(hmac.digest('base64'), 'base64');
          var clientProof = f("p=%s", new Buffer(xor(clientKey, clientSig)).toString('base64'));
          var clientFinal = [withoutProof, clientProof].join(',');
          hmac = crypto.createHmac('sha1', saltedPassword);
          hmac.update(new Buffer('Server Key'));
          var serverKey = new Buffer(hmac.digest('base64'), 'base64');
          hmac = crypto.createHmac('sha1', serverKey);
          hmac.update(new Buffer(authMsg));
          var cmd = {
            saslContinue: 1,
            conversationId: r.result.conversationId,
            payload: new Binary(new Buffer(clientFinal))
          };
          server(connection, new Query(self.bson, f("%s.$cmd", db), cmd, {
            numberToSkip: 0,
            numberToReturn: 1
          }), function (err, r) {
            if (r && r.result.done == false) {
              var cmd = {
                saslContinue: 1,
                conversationId: r.result.conversationId,
                payload: new Buffer(0)
              };
              server(connection, new Query(self.bson, f("%s.$cmd", db), cmd, {
                numberToSkip: 0,
                numberToReturn: 1
              }), function (err, r) {
                handleEnd(err, r);
              });
            } else {
              handleEnd(err, r);
            }
          });
        });
      };
      var _execute = function (_connection) {
        process.nextTick(function () {
          executeScram(_connection);
        });
      };
      while (connections.length > 0) {
        _execute(connections.shift());
      }
    };
    var addAuthSession = function (authStore, session) {
      var found = false;
      for (var i = 0; i < authStore.length; i++) {
        if (authStore[i].equal(session)) {
          found = true;
          break;
        }
      }
      if (!found) authStore.push(session);
    };
    ScramSHA1.prototype.logout = function (dbName) {
      this.authStore = this.authStore.filter(function (x) {
        return x.db != dbName;
      });
    };
    ScramSHA1.prototype.reauthenticate = function (server, connections, callback) {
      var authStore = this.authStore.slice(0);
      var count = authStore.length;
      if (count == 0) return callback(null, null);
      for (var i = 0; i < authStore.length; i++) {
        this.auth(server, connections, authStore[i].db, authStore[i].username, authStore[i].password, function (err) {
          count = count - 1;
          if (count == 0) {
            callback(err, null);
          }
        });
      }
    };
    module.exports = ScramSHA1;
  })($__require('2a').Buffer, $__require('13'));
  return module.exports;
});
$__System.registerDynamic('27a', ['1ab', '1c0', '1ae', '1ac', '1ce', '1a9', '1ad', '1aa', '1b6', '1c2', '1b0', '1b1', '1b2', '1b3', '1b5'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  module.exports = {
    MongoError: $__require('1ab'),
    Connection: $__require('1c0'),
    Server: $__require('1ae'),
    ReplSet: $__require('1ac'),
    Mongos: $__require('1ce'),
    Logger: $__require('1a9'),
    Cursor: $__require('1ad'),
    ReadPreference: $__require('1aa'),
    BSON: $__require('1b6'),
    Query: $__require('1c2').Query,
    MongoCR: $__require('1b0'),
    X509: $__require('1b1'),
    Plain: $__require('1b2'),
    GSSAPI: $__require('1b3'),
    ScramSHA1: $__require('1b5')
  };
  return module.exports;
});
$__System.registerDynamic("18f", ["27a"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("27a");
  return module.exports;
});
$__System.registerDynamic("18e", ["18f", "13"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    "use strict";

    var MongoError = $__require("18f").MongoError;
    var shallowClone = function (obj) {
      var copy = {};
      for (var name in obj) copy[name] = obj[name];
      return copy;
    };
    var getSingleProperty = function (obj, name, value) {
      Object.defineProperty(obj, name, {
        enumerable: true,
        get: function () {
          return value;
        }
      });
    };
    var formatSortValue = exports.formatSortValue = function (sortDirection) {
      var value = ("" + sortDirection).toLowerCase();
      switch (value) {
        case 'ascending':
        case 'asc':
        case '1':
          return 1;
        case 'descending':
        case 'desc':
        case '-1':
          return -1;
        default:
          throw new Error("Illegal sort clause, must be of the form " + "[['field1', '(ascending|descending)'], " + "['field2', '(ascending|descending)']]");
      }
    };
    var formattedOrderClause = exports.formattedOrderClause = function (sortValue) {
      var orderBy = {};
      if (sortValue == null) return null;
      if (Array.isArray(sortValue)) {
        if (sortValue.length === 0) {
          return null;
        }
        for (var i = 0; i < sortValue.length; i++) {
          if (sortValue[i].constructor == String) {
            orderBy[sortValue[i]] = 1;
          } else {
            orderBy[sortValue[i][0]] = formatSortValue(sortValue[i][1]);
          }
        }
      } else if (sortValue != null && typeof sortValue == 'object') {
        orderBy = sortValue;
      } else if (typeof sortValue == 'string') {
        orderBy[sortValue] = 1;
      } else {
        throw new Error("Illegal sort clause, must be of the form " + "[['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]");
      }
      return orderBy;
    };
    var checkCollectionName = function checkCollectionName(collectionName) {
      if ('string' !== typeof collectionName) {
        throw Error("collection name must be a String");
      }
      if (!collectionName || collectionName.indexOf('..') != -1) {
        throw Error("collection names cannot be empty");
      }
      if (collectionName.indexOf('$') != -1 && collectionName.match(/((^\$cmd)|(oplog\.\$main))/) == null) {
        throw Error("collection names must not contain '$'");
      }
      if (collectionName.match(/^\.|\.$/) != null) {
        throw Error("collection names must not start or end with '.'");
      }
      if (!!~collectionName.indexOf("\x00")) {
        throw new Error("collection names cannot contain a null character");
      }
    };
    var handleCallback = function (callback, err, value1, value2) {
      try {
        if (callback == null) return;
        if (callback) {
          return value2 ? callback(err, value1, value2) : callback(err, value1);
        }
      } catch (err) {
        process.nextTick(function () {
          throw err;
        });
        return false;
      }
      return true;
    };
    var toError = function (error) {
      if (error instanceof Error) return error;
      var msg = error.err || error.errmsg || error.errMessage || error;
      var e = MongoError.create({
        message: msg,
        driver: true
      });
      var keys = typeof error == 'object' ? Object.keys(error) : [];
      for (var i = 0; i < keys.length; i++) {
        try {
          e[keys[i]] = error[keys[i]];
        } catch (err) {}
      }
      return e;
    };
    var normalizeHintField = function normalizeHintField(hint) {
      var finalHint = null;
      if (typeof hint == 'string') {
        finalHint = hint;
      } else if (Array.isArray(hint)) {
        finalHint = {};
        hint.forEach(function (param) {
          finalHint[param] = 1;
        });
      } else if (hint != null && typeof hint == 'object') {
        finalHint = {};
        for (var name in hint) {
          finalHint[name] = hint[name];
        }
      }
      return finalHint;
    };
    var parseIndexOptions = function (fieldOrSpec) {
      var fieldHash = {};
      var indexes = [];
      var keys;
      if ('string' == typeof fieldOrSpec) {
        indexes.push(fieldOrSpec + '_' + 1);
        fieldHash[fieldOrSpec] = 1;
      } else if (Array.isArray(fieldOrSpec)) {
        fieldOrSpec.forEach(function (f) {
          if ('string' == typeof f) {
            indexes.push(f + '_' + 1);
            fieldHash[f] = 1;
          } else if (Array.isArray(f)) {
            indexes.push(f[0] + '_' + (f[1] || 1));
            fieldHash[f[0]] = f[1] || 1;
          } else if (isObject(f)) {
            keys = Object.keys(f);
            keys.forEach(function (k) {
              indexes.push(k + '_' + f[k]);
              fieldHash[k] = f[k];
            });
          } else {}
        });
      } else if (isObject(fieldOrSpec)) {
        keys = Object.keys(fieldOrSpec);
        keys.forEach(function (key) {
          indexes.push(key + '_' + fieldOrSpec[key]);
          fieldHash[key] = fieldOrSpec[key];
        });
      }
      return {
        name: indexes.join("_"),
        keys: keys,
        fieldHash: fieldHash
      };
    };
    var isObject = exports.isObject = function (arg) {
      return '[object Object]' == toString.call(arg);
    };
    var debugOptions = function (debugFields, options) {
      var finaloptions = {};
      debugFields.forEach(function (n) {
        finaloptions[n] = options[n];
      });
      return finaloptions;
    };
    var decorateCommand = function (command, options, exclude) {
      for (var name in options) {
        if (exclude[name] == null) command[name] = options[name];
      }
      return command;
    };
    var mergeOptions = function (target, source) {
      for (var name in source) {
        target[name] = source[name];
      }
      return target;
    };
    var translateOptions = function (target, source) {
      var translations = {
        'sslCA': 'ca',
        'sslValidate': 'rejectUnauthorized',
        'sslKey': 'key',
        'sslCert': 'cert',
        'sslPass': 'passphrase',
        'socketTimeoutMS': 'socketTimeout',
        'connectTimeoutMS': 'connectionTimeout',
        'replicaSet': 'setName',
        'rs_name': 'setName',
        'secondaryAcceptableLatencyMS': 'acceptableLatency',
        'connectWithNoPrimary': 'secondaryOnlyConnectionAllowed',
        'acceptableLatencyMS': 'localThresholdMS'
      };
      for (var name in source) {
        if (translations[name]) {
          target[translations[name]] = source[name];
        } else {
          target[name] = source[name];
        }
      }
      return target;
    };
    var filterOptions = function (options, names) {
      var filterOptions = {};
      for (var name in options) {
        if (names.indexOf(name) != -1) filterOptions[name] = options[name];
      }
      return filterOptions;
    };
    var assign = Object.assign ? Object.assign : function assign(target) {
      if (target === undefined || target === null) {
        throw new TypeError('Cannot convert first argument to object');
      }
      var to = Object(target);
      for (var i = 1; i < arguments.length; i++) {
        var nextSource = arguments[i];
        if (nextSource === undefined || nextSource === null) {
          continue;
        }
        var keysArray = Object.keys(Object(nextSource));
        for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
          var nextKey = keysArray[nextIndex];
          var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
          if (desc !== undefined && desc.enumerable) {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
      return to;
    };
    exports.filterOptions = filterOptions;
    exports.mergeOptions = mergeOptions;
    exports.translateOptions = translateOptions;
    exports.shallowClone = shallowClone;
    exports.getSingleProperty = getSingleProperty;
    exports.checkCollectionName = checkCollectionName;
    exports.toError = toError;
    exports.formattedOrderClause = formattedOrderClause;
    exports.parseIndexOptions = parseIndexOptions;
    exports.normalizeHintField = normalizeHintField;
    exports.handleCallback = handleCallback;
    exports.decorateCommand = decorateCommand;
    exports.isObject = isObject;
    exports.debugOptions = debugOptions;
    exports.MAX_JS_INT = 0x20000000000000;
    exports.assign = assign;
  })($__require("13"));
  return module.exports;
});
$__System.registerDynamic("27b", ["13"], true, function ($__require, exports, module) {
  /* */
  "format cjs";

  var define,
      global = this || self,
      GLOBAL = global;
  (function (process) {
    (function () {
      "use strict";

      function lib$es6$promise$utils$$objectOrFunction(x) {
        return typeof x === 'function' || typeof x === 'object' && x !== null;
      }
      function lib$es6$promise$utils$$isFunction(x) {
        return typeof x === 'function';
      }
      function lib$es6$promise$utils$$isMaybeThenable(x) {
        return typeof x === 'object' && x !== null;
      }
      var lib$es6$promise$utils$$_isArray;
      if (!Array.isArray) {
        lib$es6$promise$utils$$_isArray = function (x) {
          return Object.prototype.toString.call(x) === '[object Array]';
        };
      } else {
        lib$es6$promise$utils$$_isArray = Array.isArray;
      }
      var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;
      var lib$es6$promise$asap$$len = 0;
      var lib$es6$promise$asap$$vertxNext;
      var lib$es6$promise$asap$$customSchedulerFn;
      var lib$es6$promise$asap$$asap = function asap(callback, arg) {
        lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;
        lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;
        lib$es6$promise$asap$$len += 2;
        if (lib$es6$promise$asap$$len === 2) {
          if (lib$es6$promise$asap$$customSchedulerFn) {
            lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);
          } else {
            lib$es6$promise$asap$$scheduleFlush();
          }
        }
      };
      function lib$es6$promise$asap$$setScheduler(scheduleFn) {
        lib$es6$promise$asap$$customSchedulerFn = scheduleFn;
      }
      function lib$es6$promise$asap$$setAsap(asapFn) {
        lib$es6$promise$asap$$asap = asapFn;
      }
      var lib$es6$promise$asap$$browserWindow = typeof window !== 'undefined' ? window : undefined;
      var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};
      var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;
      var lib$es6$promise$asap$$isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';
      var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';
      function lib$es6$promise$asap$$useNextTick() {
        return function () {
          process.nextTick(lib$es6$promise$asap$$flush);
        };
      }
      function lib$es6$promise$asap$$useVertxTimer() {
        return function () {
          lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);
        };
      }
      function lib$es6$promise$asap$$useMutationObserver() {
        var iterations = 0;
        var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);
        var node = document.createTextNode('');
        observer.observe(node, { characterData: true });
        return function () {
          node.data = iterations = ++iterations % 2;
        };
      }
      function lib$es6$promise$asap$$useMessageChannel() {
        var channel = new MessageChannel();
        channel.port1.onmessage = lib$es6$promise$asap$$flush;
        return function () {
          channel.port2.postMessage(0);
        };
      }
      function lib$es6$promise$asap$$useSetTimeout() {
        return function () {
          setTimeout(lib$es6$promise$asap$$flush, 1);
        };
      }
      var lib$es6$promise$asap$$queue = new Array(1000);
      function lib$es6$promise$asap$$flush() {
        for (var i = 0; i < lib$es6$promise$asap$$len; i += 2) {
          var callback = lib$es6$promise$asap$$queue[i];
          var arg = lib$es6$promise$asap$$queue[i + 1];
          callback(arg);
          lib$es6$promise$asap$$queue[i] = undefined;
          lib$es6$promise$asap$$queue[i + 1] = undefined;
        }
        lib$es6$promise$asap$$len = 0;
      }
      function lib$es6$promise$asap$$attemptVertx() {
        try {
          var r = $__require;
          var vertx = r('vertx');
          lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;
          return lib$es6$promise$asap$$useVertxTimer();
        } catch (e) {
          return lib$es6$promise$asap$$useSetTimeout();
        }
      }
      var lib$es6$promise$asap$$scheduleFlush;
      if (lib$es6$promise$asap$$isNode) {
        lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();
      } else if (lib$es6$promise$asap$$BrowserMutationObserver) {
        lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();
      } else if (lib$es6$promise$asap$$isWorker) {
        lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();
      } else if (lib$es6$promise$asap$$browserWindow === undefined && typeof $__require === 'function') {
        lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();
      } else {
        lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();
      }
      function lib$es6$promise$then$$then(onFulfillment, onRejection) {
        var parent = this;
        var child = new this.constructor(lib$es6$promise$$internal$$noop);
        if (child[lib$es6$promise$$internal$$PROMISE_ID] === undefined) {
          lib$es6$promise$$internal$$makePromise(child);
        }
        var state = parent._state;
        if (state) {
          var callback = arguments[state - 1];
          lib$es6$promise$asap$$asap(function () {
            lib$es6$promise$$internal$$invokeCallback(state, child, callback, parent._result);
          });
        } else {
          lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);
        }
        return child;
      }
      var lib$es6$promise$then$$default = lib$es6$promise$then$$then;
      function lib$es6$promise$promise$resolve$$resolve(object) {
        var Constructor = this;
        if (object && typeof object === 'object' && object.constructor === Constructor) {
          return object;
        }
        var promise = new Constructor(lib$es6$promise$$internal$$noop);
        lib$es6$promise$$internal$$resolve(promise, object);
        return promise;
      }
      var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;
      var lib$es6$promise$$internal$$PROMISE_ID = Math.random().toString(36).substring(16);
      function lib$es6$promise$$internal$$noop() {}
      var lib$es6$promise$$internal$$PENDING = void 0;
      var lib$es6$promise$$internal$$FULFILLED = 1;
      var lib$es6$promise$$internal$$REJECTED = 2;
      var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();
      function lib$es6$promise$$internal$$selfFulfillment() {
        return new TypeError("You cannot resolve a promise with itself");
      }
      function lib$es6$promise$$internal$$cannotReturnOwn() {
        return new TypeError('A promises callback cannot return that same promise.');
      }
      function lib$es6$promise$$internal$$getThen(promise) {
        try {
          return promise.then;
        } catch (error) {
          lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;
          return lib$es6$promise$$internal$$GET_THEN_ERROR;
        }
      }
      function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
        try {
          then.call(value, fulfillmentHandler, rejectionHandler);
        } catch (e) {
          return e;
        }
      }
      function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {
        lib$es6$promise$asap$$asap(function (promise) {
          var sealed = false;
          var error = lib$es6$promise$$internal$$tryThen(then, thenable, function (value) {
            if (sealed) {
              return;
            }
            sealed = true;
            if (thenable !== value) {
              lib$es6$promise$$internal$$resolve(promise, value);
            } else {
              lib$es6$promise$$internal$$fulfill(promise, value);
            }
          }, function (reason) {
            if (sealed) {
              return;
            }
            sealed = true;
            lib$es6$promise$$internal$$reject(promise, reason);
          }, 'Settle: ' + (promise._label || ' unknown promise'));
          if (!sealed && error) {
            sealed = true;
            lib$es6$promise$$internal$$reject(promise, error);
          }
        }, promise);
      }
      function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {
        if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {
          lib$es6$promise$$internal$$fulfill(promise, thenable._result);
        } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {
          lib$es6$promise$$internal$$reject(promise, thenable._result);
        } else {
          lib$es6$promise$$internal$$subscribe(thenable, undefined, function (value) {
            lib$es6$promise$$internal$$resolve(promise, value);
          }, function (reason) {
            lib$es6$promise$$internal$$reject(promise, reason);
          });
        }
      }
      function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable, then) {
        if (maybeThenable.constructor === promise.constructor && then === lib$es6$promise$then$$default && constructor.resolve === lib$es6$promise$promise$resolve$$default) {
          lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);
        } else {
          if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {
            lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);
          } else if (then === undefined) {
            lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
          } else if (lib$es6$promise$utils$$isFunction(then)) {
            lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);
          } else {
            lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
          }
        }
      }
      function lib$es6$promise$$internal$$resolve(promise, value) {
        if (promise === value) {
          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());
        } else if (lib$es6$promise$utils$$objectOrFunction(value)) {
          lib$es6$promise$$internal$$handleMaybeThenable(promise, value, lib$es6$promise$$internal$$getThen(value));
        } else {
          lib$es6$promise$$internal$$fulfill(promise, value);
        }
      }
      function lib$es6$promise$$internal$$publishRejection(promise) {
        if (promise._onerror) {
          promise._onerror(promise._result);
        }
        lib$es6$promise$$internal$$publish(promise);
      }
      function lib$es6$promise$$internal$$fulfill(promise, value) {
        if (promise._state !== lib$es6$promise$$internal$$PENDING) {
          return;
        }
        promise._result = value;
        promise._state = lib$es6$promise$$internal$$FULFILLED;
        if (promise._subscribers.length !== 0) {
          lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);
        }
      }
      function lib$es6$promise$$internal$$reject(promise, reason) {
        if (promise._state !== lib$es6$promise$$internal$$PENDING) {
          return;
        }
        promise._state = lib$es6$promise$$internal$$REJECTED;
        promise._result = reason;
        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);
      }
      function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
        var subscribers = parent._subscribers;
        var length = subscribers.length;
        parent._onerror = null;
        subscribers[length] = child;
        subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;
        subscribers[length + lib$es6$promise$$internal$$REJECTED] = onRejection;
        if (length === 0 && parent._state) {
          lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);
        }
      }
      function lib$es6$promise$$internal$$publish(promise) {
        var subscribers = promise._subscribers;
        var settled = promise._state;
        if (subscribers.length === 0) {
          return;
        }
        var child,
            callback,
            detail = promise._result;
        for (var i = 0; i < subscribers.length; i += 3) {
          child = subscribers[i];
          callback = subscribers[i + settled];
          if (child) {
            lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);
          } else {
            callback(detail);
          }
        }
        promise._subscribers.length = 0;
      }
      function lib$es6$promise$$internal$$ErrorObject() {
        this.error = null;
      }
      var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();
      function lib$es6$promise$$internal$$tryCatch(callback, detail) {
        try {
          return callback(detail);
        } catch (e) {
          lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;
          return lib$es6$promise$$internal$$TRY_CATCH_ERROR;
        }
      }
      function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {
        var hasCallback = lib$es6$promise$utils$$isFunction(callback),
            value,
            error,
            succeeded,
            failed;
        if (hasCallback) {
          value = lib$es6$promise$$internal$$tryCatch(callback, detail);
          if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {
            failed = true;
            error = value.error;
            value = null;
          } else {
            succeeded = true;
          }
          if (promise === value) {
            lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());
            return;
          }
        } else {
          value = detail;
          succeeded = true;
        }
        if (promise._state !== lib$es6$promise$$internal$$PENDING) {} else if (hasCallback && succeeded) {
          lib$es6$promise$$internal$$resolve(promise, value);
        } else if (failed) {
          lib$es6$promise$$internal$$reject(promise, error);
        } else if (settled === lib$es6$promise$$internal$$FULFILLED) {
          lib$es6$promise$$internal$$fulfill(promise, value);
        } else if (settled === lib$es6$promise$$internal$$REJECTED) {
          lib$es6$promise$$internal$$reject(promise, value);
        }
      }
      function lib$es6$promise$$internal$$initializePromise(promise, resolver) {
        try {
          resolver(function resolvePromise(value) {
            lib$es6$promise$$internal$$resolve(promise, value);
          }, function rejectPromise(reason) {
            lib$es6$promise$$internal$$reject(promise, reason);
          });
        } catch (e) {
          lib$es6$promise$$internal$$reject(promise, e);
        }
      }
      var lib$es6$promise$$internal$$id = 0;
      function lib$es6$promise$$internal$$nextId() {
        return lib$es6$promise$$internal$$id++;
      }
      function lib$es6$promise$$internal$$makePromise(promise) {
        promise[lib$es6$promise$$internal$$PROMISE_ID] = lib$es6$promise$$internal$$id++;
        promise._state = undefined;
        promise._result = undefined;
        promise._subscribers = [];
      }
      function lib$es6$promise$promise$all$$all(entries) {
        return new lib$es6$promise$enumerator$$default(this, entries).promise;
      }
      var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;
      function lib$es6$promise$promise$race$$race(entries) {
        var Constructor = this;
        if (!lib$es6$promise$utils$$isArray(entries)) {
          return new Constructor(function (resolve, reject) {
            reject(new TypeError('You must pass an array to race.'));
          });
        } else {
          return new Constructor(function (resolve, reject) {
            var length = entries.length;
            for (var i = 0; i < length; i++) {
              Constructor.resolve(entries[i]).then(resolve, reject);
            }
          });
        }
      }
      var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;
      function lib$es6$promise$promise$reject$$reject(reason) {
        var Constructor = this;
        var promise = new Constructor(lib$es6$promise$$internal$$noop);
        lib$es6$promise$$internal$$reject(promise, reason);
        return promise;
      }
      var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;
      function lib$es6$promise$promise$$needsResolver() {
        throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
      }
      function lib$es6$promise$promise$$needsNew() {
        throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
      }
      var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;
      function lib$es6$promise$promise$$Promise(resolver) {
        this[lib$es6$promise$$internal$$PROMISE_ID] = lib$es6$promise$$internal$$nextId();
        this._result = this._state = undefined;
        this._subscribers = [];
        if (lib$es6$promise$$internal$$noop !== resolver) {
          typeof resolver !== 'function' && lib$es6$promise$promise$$needsResolver();
          this instanceof lib$es6$promise$promise$$Promise ? lib$es6$promise$$internal$$initializePromise(this, resolver) : lib$es6$promise$promise$$needsNew();
        }
      }
      lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;
      lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;
      lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;
      lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;
      lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;
      lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;
      lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;
      lib$es6$promise$promise$$Promise.prototype = {
        constructor: lib$es6$promise$promise$$Promise,
        then: lib$es6$promise$then$$default,
        'catch': function (onRejection) {
          return this.then(null, onRejection);
        }
      };
      var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;
      function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {
        this._instanceConstructor = Constructor;
        this.promise = new Constructor(lib$es6$promise$$internal$$noop);
        if (!this.promise[lib$es6$promise$$internal$$PROMISE_ID]) {
          lib$es6$promise$$internal$$makePromise(this.promise);
        }
        if (lib$es6$promise$utils$$isArray(input)) {
          this._input = input;
          this.length = input.length;
          this._remaining = input.length;
          this._result = new Array(this.length);
          if (this.length === 0) {
            lib$es6$promise$$internal$$fulfill(this.promise, this._result);
          } else {
            this.length = this.length || 0;
            this._enumerate();
            if (this._remaining === 0) {
              lib$es6$promise$$internal$$fulfill(this.promise, this._result);
            }
          }
        } else {
          lib$es6$promise$$internal$$reject(this.promise, lib$es6$promise$enumerator$$validationError());
        }
      }
      function lib$es6$promise$enumerator$$validationError() {
        return new Error('Array Methods must be provided an Array');
      }
      lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function () {
        var length = this.length;
        var input = this._input;
        for (var i = 0; this._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
          this._eachEntry(input[i], i);
        }
      };
      lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function (entry, i) {
        var c = this._instanceConstructor;
        var resolve = c.resolve;
        if (resolve === lib$es6$promise$promise$resolve$$default) {
          var then = lib$es6$promise$$internal$$getThen(entry);
          if (then === lib$es6$promise$then$$default && entry._state !== lib$es6$promise$$internal$$PENDING) {
            this._settledAt(entry._state, i, entry._result);
          } else if (typeof then !== 'function') {
            this._remaining--;
            this._result[i] = entry;
          } else if (c === lib$es6$promise$promise$$default) {
            var promise = new c(lib$es6$promise$$internal$$noop);
            lib$es6$promise$$internal$$handleMaybeThenable(promise, entry, then);
            this._willSettleAt(promise, i);
          } else {
            this._willSettleAt(new c(function (resolve) {
              resolve(entry);
            }), i);
          }
        } else {
          this._willSettleAt(resolve(entry), i);
        }
      };
      lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function (state, i, value) {
        var promise = this.promise;
        if (promise._state === lib$es6$promise$$internal$$PENDING) {
          this._remaining--;
          if (state === lib$es6$promise$$internal$$REJECTED) {
            lib$es6$promise$$internal$$reject(promise, value);
          } else {
            this._result[i] = value;
          }
        }
        if (this._remaining === 0) {
          lib$es6$promise$$internal$$fulfill(promise, this._result);
        }
      };
      lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function (promise, i) {
        var enumerator = this;
        lib$es6$promise$$internal$$subscribe(promise, undefined, function (value) {
          enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);
        }, function (reason) {
          enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);
        });
      };
      function lib$es6$promise$polyfill$$polyfill() {
        var local;
        if (typeof global !== 'undefined') {
          local = global;
        } else if (typeof self !== 'undefined') {
          local = self;
        } else {
          try {
            local = Function('return this')();
          } catch (e) {
            throw new Error('polyfill failed because global object is unavailable in this environment');
          }
        }
        var P = local.Promise;
        if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {
          return;
        }
        local.Promise = lib$es6$promise$promise$$default;
      }
      var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;
      var lib$es6$promise$umd$$ES6Promise = {
        'Promise': lib$es6$promise$promise$$default,
        'polyfill': lib$es6$promise$polyfill$$default
      };
      if (typeof define === 'function' && define['amd']) {
        define(function () {
          return lib$es6$promise$umd$$ES6Promise;
        });
      } else if (typeof module !== 'undefined' && module['exports']) {
        module['exports'] = lib$es6$promise$umd$$ES6Promise;
      } else if (typeof this !== 'undefined') {
        this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;
      }
      lib$es6$promise$polyfill$$default();
    }).call(this);
  })($__require("13"));
  return module.exports;
});
$__System.registerDynamic("190", ["27b"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("27b");
  return module.exports;
});
$__System.registerDynamic('27c', ['55', '1a6', '1a7', '18e', '166', '190'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var Emitter = $__require('55').EventEmitter;
  var GridFSBucketReadStream = $__require('1a6');
  var GridFSBucketWriteStream = $__require('1a7');
  var shallowClone = $__require('18e').shallowClone;
  var toError = $__require('18e').toError;
  var util = $__require('166');
  var DEFAULT_GRIDFS_BUCKET_OPTIONS = {
    bucketName: 'fs',
    chunkSizeBytes: 255 * 1024
  };
  module.exports = GridFSBucket;
  function GridFSBucket(db, options) {
    Emitter.apply(this);
    this.setMaxListeners(0);
    if (options && typeof options === 'object') {
      options = shallowClone(options);
      var keys = Object.keys(DEFAULT_GRIDFS_BUCKET_OPTIONS);
      for (var i = 0; i < keys.length; ++i) {
        if (!options[keys[i]]) {
          options[keys[i]] = DEFAULT_GRIDFS_BUCKET_OPTIONS[keys[i]];
        }
      }
    } else {
      options = DEFAULT_GRIDFS_BUCKET_OPTIONS;
    }
    this.s = {
      db: db,
      options: options,
      _chunksCollection: db.collection(options.bucketName + '.chunks'),
      _filesCollection: db.collection(options.bucketName + '.files'),
      checkedIndexes: false,
      calledOpenUploadStream: false,
      promiseLibrary: db.s.promiseLibrary || (typeof global.Promise == 'function' ? global.Promise : $__require('190').Promise)
    };
  }
  util.inherits(GridFSBucket, Emitter);
  GridFSBucket.prototype.openUploadStream = function (filename, options) {
    if (options) {
      options = shallowClone(options);
    } else {
      options = {};
    }
    if (!options.chunkSizeBytes) {
      options.chunkSizeBytes = this.s.options.chunkSizeBytes;
    }
    return new GridFSBucketWriteStream(this, filename, options);
  };
  GridFSBucket.prototype.openUploadStreamWithId = function (id, filename, options) {
    if (options) {
      options = shallowClone(options);
    } else {
      options = {};
    }
    if (!options.chunkSizeBytes) {
      options.chunkSizeBytes = this.s.options.chunkSizeBytes;
    }
    options.id = id;
    return new GridFSBucketWriteStream(this, filename, options);
  };
  GridFSBucket.prototype.openDownloadStream = function (id, options) {
    var filter = { _id: id };
    options = {
      start: options && options.start,
      end: options && options.end
    };
    return new GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, filter, options);
  };
  GridFSBucket.prototype.delete = function (id, callback) {
    if (typeof callback === 'function') {
      return _delete(this, id, callback);
    }
    var _this = this;
    return new this.s.promiseLibrary(function (resolve, reject) {
      _delete(_this, id, function (error, res) {
        if (error) {
          reject(error);
        } else {
          resolve(res);
        }
      });
    });
  };
  function _delete(_this, id, callback) {
    _this.s._filesCollection.deleteOne({ _id: id }, function (error, res) {
      if (error) {
        return callback(error);
      }
      _this.s._chunksCollection.deleteMany({ files_id: id }, function (error) {
        if (error) {
          return callback(error);
        }
        if (!res.result.n) {
          var errmsg = 'FileNotFound: no file with id ' + id + ' found';
          return callback(new Error(errmsg));
        }
        callback();
      });
    });
  }
  GridFSBucket.prototype.find = function (filter, options) {
    filter = filter || {};
    options = options || {};
    var cursor = this.s._filesCollection.find(filter);
    if (options.batchSize != null) {
      cursor.batchSize(options.batchSize);
    }
    if (options.limit != null) {
      cursor.limit(options.limit);
    }
    if (options.maxTimeMS != null) {
      cursor.maxTimeMS(options.maxTimeMS);
    }
    if (options.noCursorTimeout != null) {
      cursor.addCursorFlag('noCursorTimeout', options.noCursorTimeout);
    }
    if (options.skip != null) {
      cursor.skip(options.skip);
    }
    if (options.sort != null) {
      cursor.sort(options.sort);
    }
    return cursor;
  };
  GridFSBucket.prototype.openDownloadStreamByName = function (filename, options) {
    var sort = { uploadDate: -1 };
    var skip = null;
    if (options && options.revision != null) {
      if (options.revision >= 0) {
        sort = { uploadDate: 1 };
        skip = options.revision;
      } else {
        skip = -options.revision - 1;
      }
    }
    var filter = { filename: filename };
    options = {
      sort: sort,
      skip: skip,
      start: options && options.start,
      end: options && options.end
    };
    return new GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, filter, options);
  };
  GridFSBucket.prototype.rename = function (id, filename, callback) {
    if (typeof callback === 'function') {
      return _rename(this, id, filename, callback);
    }
    var _this = this;
    return new this.s.promiseLibrary(function (resolve, reject) {
      _rename(_this, id, filename, function (error, res) {
        if (error) {
          reject(error);
        } else {
          resolve(res);
        }
      });
    });
  };
  function _rename(_this, id, filename, callback) {
    var filter = { _id: id };
    var update = { $set: { filename: filename } };
    _this.s._filesCollection.updateOne(filter, update, function (error, res) {
      if (error) {
        return callback(error);
      }
      if (!res.result.n) {
        return callback(toError('File with id ' + id + ' not found'));
      }
      callback();
    });
  }
  GridFSBucket.prototype.drop = function (callback) {
    if (typeof callback === 'function') {
      return _drop(this, callback);
    }
    var _this = this;
    return new this.s.promiseLibrary(function (resolve, reject) {
      _drop(_this, function (error, res) {
        if (error) {
          reject(error);
        } else {
          resolve(res);
        }
      });
    });
  };
  function _drop(_this, callback) {
    _this.s._filesCollection.drop(function (error) {
      if (error) {
        return callback(error);
      }
      _this.s._chunksCollection.drop(function (error) {
        if (error) {
          return callback(error);
        }
        return callback();
      });
    });
  }
  return module.exports;
});
$__System.registerDynamic('27d', ['18f', '17e', '189', '191', '186', '185', '18a', '18c', '18b', '188', '183', '196', '184', '27c'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var core = $__require('18f'),
      Instrumentation = $__require('17e');
  var connect = $__require('189').connect;
  connect.MongoError = core.MongoError;
  connect.Admin = $__require('191');
  connect.MongoClient = $__require('189');
  connect.Db = $__require('186');
  connect.Collection = $__require('185');
  connect.Server = $__require('18a');
  connect.ReplSet = $__require('18c');
  connect.Mongos = $__require('18b');
  connect.ReadPreference = $__require('188');
  connect.GridStore = $__require('183');
  connect.Chunk = $__require('196');
  connect.Logger = core.Logger;
  connect.Cursor = $__require('184');
  connect.GridFSBucket = $__require('27c');
  connect.CoreServer = $__require('18f').Server;
  connect.CoreConnection = $__require('18f').Connection;
  connect.Binary = core.BSON.Binary;
  connect.Code = core.BSON.Code;
  connect.Map = core.BSON.Map;
  connect.DBRef = core.BSON.DBRef;
  connect.Double = core.BSON.Double;
  connect.Int32 = core.BSON.Int32;
  connect.Long = core.BSON.Long;
  connect.MinKey = core.BSON.MinKey;
  connect.MaxKey = core.BSON.MaxKey;
  connect.ObjectID = core.BSON.ObjectID;
  connect.ObjectId = core.BSON.ObjectID;
  connect.Symbol = core.BSON.Symbol;
  connect.Timestamp = core.BSON.Timestamp;
  connect.Decimal128 = core.BSON.Decimal128;
  connect.connect = connect;
  connect.instrument = function (options, callback) {
    if (typeof options == 'function') callback = options, options = {};
    return new Instrumentation(core, options, callback);
  };
  module.exports = connect;
  return module.exports;
});
$__System.registerDynamic("27e", ["27d"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("27d");
  return module.exports;
});
$__System.registerDynamic("27f", [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  const mongoLABSURLINFO = "mongodb://bryanAdmin:Verysilveredin09@ds019856.mlab.com:19856/bryanportfoliodb";
  module.exports = mongoLABSURLINFO;
  //bryanportfoliodb
  //NWyX2BMhRXtsM-8MggIVSUBKjwV2bkGa
  //let mongodbURL = "mongodb://bryanAdmin:Verysilveredin09@ds019856.mlab.com:19856/bryanportfoliodb"
  //Verysilveredin09  bryanAdmin
  //mongodb://<dbuser>:<dbpassword>@ds019856.mlab.com:19856/bryanportfoliodb

  return module.exports;
});
$__System.registerDynamic('280', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /**
   * Helpers.
   */

  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var y = d * 365.25;

  /**
   * Parse or format the given `val`.
   *
   * Options:
   *
   *  - `long` verbose formatting [false]
   *
   * @param {String|Number} val
   * @param {Object} options
   * @return {String|Number}
   * @api public
   */

  module.exports = function (val, options) {
    options = options || {};
    if ('string' == typeof val) return parse(val);
    return options.long ? long(val) : short(val);
  };

  /**
   * Parse the given `str` and return milliseconds.
   *
   * @param {String} str
   * @return {Number}
   * @api private
   */

  function parse(str) {
    str = '' + str;
    if (str.length > 10000) return;
    var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
    if (!match) return;
    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();
    switch (type) {
      case 'years':
      case 'year':
      case 'yrs':
      case 'yr':
      case 'y':
        return n * y;
      case 'days':
      case 'day':
      case 'd':
        return n * d;
      case 'hours':
      case 'hour':
      case 'hrs':
      case 'hr':
      case 'h':
        return n * h;
      case 'minutes':
      case 'minute':
      case 'mins':
      case 'min':
      case 'm':
        return n * m;
      case 'seconds':
      case 'second':
      case 'secs':
      case 'sec':
      case 's':
        return n * s;
      case 'milliseconds':
      case 'millisecond':
      case 'msecs':
      case 'msec':
      case 'ms':
        return n;
    }
  }

  /**
   * Short format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */

  function short(ms) {
    if (ms >= d) return Math.round(ms / d) + 'd';
    if (ms >= h) return Math.round(ms / h) + 'h';
    if (ms >= m) return Math.round(ms / m) + 'm';
    if (ms >= s) return Math.round(ms / s) + 's';
    return ms + 'ms';
  }

  /**
   * Long format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */

  function long(ms) {
    return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
  }

  /**
   * Pluralization helper.
   */

  function plural(ms, n, name) {
    if (ms < n) return;
    if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
    return Math.ceil(ms / n) + ' ' + name + 's';
  }
  return module.exports;
});
$__System.registerDynamic("54", ["280"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("280");
  return module.exports;
});
$__System.registerDynamic('281', ['54'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;

  /**
   * This is the common logic for both the Node.js and web browser
   * implementations of `debug()`.
   *
   * Expose `debug()` as the module.
   */

  exports = module.exports = debug;
  exports.coerce = coerce;
  exports.disable = disable;
  exports.enable = enable;
  exports.enabled = enabled;
  exports.humanize = $__require('54');

  /**
   * The currently active debug mode names, and names to skip.
   */

  exports.names = [];
  exports.skips = [];

  /**
   * Map of special "%n" handling functions, for the debug "format" argument.
   *
   * Valid key names are a single, lowercased letter, i.e. "n".
   */

  exports.formatters = {};

  /**
   * Previously assigned color.
   */

  var prevColor = 0;

  /**
   * Previous log timestamp.
   */

  var prevTime;

  /**
   * Select a color.
   *
   * @return {Number}
   * @api private
   */

  function selectColor() {
    return exports.colors[prevColor++ % exports.colors.length];
  }

  /**
   * Create a debugger with the given `namespace`.
   *
   * @param {String} namespace
   * @return {Function}
   * @api public
   */

  function debug(namespace) {

    // define the `disabled` version
    function disabled() {}
    disabled.enabled = false;

    // define the `enabled` version
    function enabled() {

      var self = enabled;

      // set `diff` timestamp
      var curr = +new Date();
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;

      // add the `color` if not set
      if (null == self.useColors) self.useColors = exports.useColors();
      if (null == self.color && self.useColors) self.color = selectColor();

      var args = Array.prototype.slice.call(arguments);

      args[0] = exports.coerce(args[0]);

      if ('string' !== typeof args[0]) {
        // anything else let's inspect with %o
        args = ['%o'].concat(args);
      }

      // apply any `formatters` transformations
      var index = 0;
      args[0] = args[0].replace(/%([a-z%])/g, function (match, format) {
        // if we encounter an escaped % then don't increase the array index
        if (match === '%%') return match;
        index++;
        var formatter = exports.formatters[format];
        if ('function' === typeof formatter) {
          var val = args[index];
          match = formatter.call(self, val);

          // now we need to remove `args[index]` since it's inlined in the `format`
          args.splice(index, 1);
          index--;
        }
        return match;
      });

      if ('function' === typeof exports.formatArgs) {
        args = exports.formatArgs.apply(self, args);
      }
      var logFn = enabled.log || exports.log || console.log.bind(console);
      logFn.apply(self, args);
    }
    enabled.enabled = true;

    var fn = exports.enabled(namespace) ? enabled : disabled;

    fn.namespace = namespace;

    return fn;
  }

  /**
   * Enables a debug mode by namespaces. This can include modes
   * separated by a colon and wildcards.
   *
   * @param {String} namespaces
   * @api public
   */

  function enable(namespaces) {
    exports.save(namespaces);

    var split = (namespaces || '').split(/[\s,]+/);
    var len = split.length;

    for (var i = 0; i < len; i++) {
      if (!split[i]) continue; // ignore empty strings
      namespaces = split[i].replace(/\*/g, '.*?');
      if (namespaces[0] === '-') {
        exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
      } else {
        exports.names.push(new RegExp('^' + namespaces + '$'));
      }
    }
  }

  /**
   * Disable debug output.
   *
   * @api public
   */

  function disable() {
    exports.enable('');
  }

  /**
   * Returns true if the given mode name is enabled, false otherwise.
   *
   * @param {String} name
   * @return {Boolean}
   * @api public
   */

  function enabled(name) {
    var i, len;
    for (i = 0, len = exports.skips.length; i < len; i++) {
      if (exports.skips[i].test(name)) {
        return false;
      }
    }
    for (i = 0, len = exports.names.length; i < len; i++) {
      if (exports.names[i].test(name)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Coerce `val`.
   *
   * @param {Mixed} val
   * @return {Mixed}
   * @api private
   */

  function coerce(val) {
    if (val instanceof Error) return val.stack || val.message;
    return val;
  }
  return module.exports;
});
$__System.registerDynamic('282', ['281'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;

  /**
   * This is the web browser implementation of `debug()`.
   *
   * Expose `debug()` as the module.
   */

  exports = module.exports = $__require('281');
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();

  /**
   * Colors.
   */

  exports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];

  /**
   * Currently only WebKit-based Web Inspectors, Firefox >= v31,
   * and the Firebug extension (any Firefox version) are known
   * to support "%c" CSS customizations.
   *
   * TODO: add a `localStorage` variable to explicitly enable/disable colors
   */

  function useColors() {
    // is webkit? http://stackoverflow.com/a/16459606/376773
    return 'WebkitAppearance' in document.documentElement.style ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    window.console && (console.firebug || console.exception && console.table) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31;
  }

  /**
   * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
   */

  exports.formatters.j = function (v) {
    return JSON.stringify(v);
  };

  /**
   * Colorize log arguments if enabled.
   *
   * @api public
   */

  function formatArgs() {
    var args = arguments;
    var useColors = this.useColors;

    args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);

    if (!useColors) return args;

    var c = 'color: ' + this.color;
    args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

    // the final "%c" is somewhat tricky, because there could be other
    // arguments passed either before or after the %c, so we need to
    // figure out the correct index to insert the CSS into
    var index = 0;
    var lastC = 0;
    args[0].replace(/%[a-z%]/g, function (match) {
      if ('%%' === match) return;
      index++;
      if ('%c' === match) {
        // we only are interested in the *last* %c
        // (the user may have provided their own)
        lastC = index;
      }
    });

    args.splice(lastC, 0, c);
    return args;
  }

  /**
   * Invokes `console.log()` when available.
   * No-op when `console.log` is not a "function".
   *
   * @api public
   */

  function log() {
    // this hackery is required for IE8/9, where
    // the `console.log` function doesn't have 'apply'
    return 'object' === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
  }

  /**
   * Save `namespaces`.
   *
   * @param {String} namespaces
   * @api private
   */

  function save(namespaces) {
    try {
      if (null == namespaces) {
        exports.storage.removeItem('debug');
      } else {
        exports.storage.debug = namespaces;
      }
    } catch (e) {}
  }

  /**
   * Load `namespaces`.
   *
   * @return {String} returns the previously persisted debug modes
   * @api private
   */

  function load() {
    var r;
    try {
      r = exports.storage.debug;
    } catch (e) {}
    return r;
  }

  /**
   * Enable namespaces listed in `localStorage.debug` initially.
   */

  exports.enable(load());

  /**
   * Localstorage attempts to return the localstorage.
   *
   * This is necessary because safari throws
   * when a user disables cookies/localstorage
   * and you attempt to access it.
   *
   * @return {LocalStorage}
   * @api private
   */

  function localstorage() {
    try {
      return window.localStorage;
    } catch (e) {}
  }
  return module.exports;
});
$__System.registerDynamic("8", ["282"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("282");
  return module.exports;
});
$__System.registerDynamic('283', [], true, function ($__require, exports, module) {
  /*!
   * escape-html
   * Copyright(c) 2012-2013 TJ Holowaychuk
   * Copyright(c) 2015 Andreas Lubbe
   * Copyright(c) 2015 Tiancheng "Timothy" Gu
   * MIT Licensed
   */

  'use strict';

  /**
   * Module variables.
   * @private
   */

  var define,
      global = this || self,
      GLOBAL = global;
  var matchHtmlRegExp = /["'&<>]/;

  /**
   * Module exports.
   * @public
   */

  module.exports = escapeHtml;

  /**
   * Escape special characters in the given string of html.
   *
   * @param  {string} string The string to escape for inserting into HTML
   * @return {string}
   * @public
   */

  function escapeHtml(string) {
    var str = '' + string;
    var match = matchHtmlRegExp.exec(str);

    if (!match) {
      return str;
    }

    var escape;
    var html = '';
    var index = 0;
    var lastIndex = 0;

    for (index = match.index; index < str.length; index++) {
      switch (str.charCodeAt(index)) {
        case 34:
          // "
          escape = '&quot;';
          break;
        case 38:
          // &
          escape = '&amp;';
          break;
        case 39:
          // '
          escape = '&#39;';
          break;
        case 60:
          // <
          escape = '&lt;';
          break;
        case 62:
          // >
          escape = '&gt;';
          break;
        default:
          continue;
      }

      if (lastIndex !== index) {
        html += str.substring(lastIndex, index);
      }

      lastIndex = index + 1;
      html += escape;
    }

    return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
  }
  return module.exports;
});
$__System.registerDynamic("3d", ["283"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("283");
  return module.exports;
});
$__System.registerDynamic('284', [], true, function ($__require, exports, module) {
  /*!
   * ee-first
   * Copyright(c) 2014 Jonathan Ong
   * MIT Licensed
   */

  'use strict';

  /**
   * Module exports.
   * @public
   */

  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = first;

  /**
   * Get the first event in a set of event emitters and event pairs.
   *
   * @param {array} stuff
   * @param {function} done
   * @public
   */

  function first(stuff, done) {
    if (!Array.isArray(stuff)) throw new TypeError('arg must be an array of [ee, events...] arrays');

    var cleanups = [];

    for (var i = 0; i < stuff.length; i++) {
      var arr = stuff[i];

      if (!Array.isArray(arr) || arr.length < 2) throw new TypeError('each array member must be [ee, events...]');

      var ee = arr[0];

      for (var j = 1; j < arr.length; j++) {
        var event = arr[j];
        var fn = listener(event, callback);

        // listen to the event
        ee.on(event, fn);
        // push this listener to the list of cleanups
        cleanups.push({
          ee: ee,
          event: event,
          fn: fn
        });
      }
    }

    function callback() {
      cleanup();
      done.apply(null, arguments);
    }

    function cleanup() {
      var x;
      for (var i = 0; i < cleanups.length; i++) {
        x = cleanups[i];
        x.ee.removeListener(x.event, x.fn);
      }
    }

    function thunk(fn) {
      done = fn;
    }

    thunk.cancel = cleanup;

    return thunk;
  }

  /**
   * Create the event listener.
   * @private
   */

  function listener(event, done) {
    return function onevent(arg1) {
      var args = new Array(arguments.length);
      var ee = this;
      var err = event === 'error' ? arg1 : null;

      // copy args to prevent arguments escaping scope
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }

      done(err, ee, event, args);
    };
  }
  return module.exports;
});
$__System.registerDynamic("285", ["284"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("284");
  return module.exports;
});
$__System.registerDynamic('286', ['285', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    module.exports = onFinished;
    module.exports.isFinished = isFinished;
    var first = $__require('285');
    var defer = typeof setImmediate === 'function' ? setImmediate : function (fn) {
      process.nextTick(fn.bind.apply(fn, arguments));
    };
    function onFinished(msg, listener) {
      if (isFinished(msg) !== false) {
        defer(listener, null, msg);
        return msg;
      }
      attachListener(msg, listener);
      return msg;
    }
    function isFinished(msg) {
      var socket = msg.socket;
      if (typeof msg.finished === 'boolean') {
        return Boolean(msg.finished || socket && !socket.writable);
      }
      if (typeof msg.complete === 'boolean') {
        return Boolean(msg.upgrade || !socket || !socket.readable || msg.complete && !msg.readable);
      }
      return undefined;
    }
    function attachFinishedListener(msg, callback) {
      var eeMsg;
      var eeSocket;
      var finished = false;
      function onFinish(error) {
        eeMsg.cancel();
        eeSocket.cancel();
        finished = true;
        callback(error);
      }
      eeMsg = eeSocket = first([[msg, 'end', 'finish']], onFinish);
      function onSocket(socket) {
        msg.removeListener('socket', onSocket);
        if (finished) return;
        if (eeMsg !== eeSocket) return;
        eeSocket = first([[socket, 'error', 'close']], onFinish);
      }
      if (msg.socket) {
        onSocket(msg.socket);
        return;
      }
      msg.on('socket', onSocket);
      if (msg.socket === undefined) {
        patchAssignSocket(msg, onSocket);
      }
    }
    function attachListener(msg, listener) {
      var attached = msg.__onFinished;
      if (!attached || !attached.queue) {
        attached = msg.__onFinished = createListener(msg);
        attachFinishedListener(msg, attached);
      }
      attached.queue.push(listener);
    }
    function createListener(msg) {
      function listener(err) {
        if (msg.__onFinished === listener) msg.__onFinished = null;
        if (!listener.queue) return;
        var queue = listener.queue;
        listener.queue = null;
        for (var i = 0; i < queue.length; i++) {
          queue[i](err, msg);
        }
      }
      listener.queue = [];
      return listener;
    }
    function patchAssignSocket(res, callback) {
      var assignSocket = res.assignSocket;
      if (typeof assignSocket !== 'function') return;
      res.assignSocket = function _assignSocket(socket) {
        assignSocket.call(this, socket);
        callback(socket);
      };
    }
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic("3f", ["286"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("286");
  return module.exports;
});
$__System.registerDynamic('287', [], true, function ($__require, exports, module) {
  /*!
   * unpipe
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */

  'use strict';

  /**
   * Module exports.
   * @public
   */

  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = unpipe;

  /**
   * Determine if there are Node.js pipe-like data listeners.
   * @private
   */

  function hasPipeDataListeners(stream) {
    var listeners = stream.listeners('data');

    for (var i = 0; i < listeners.length; i++) {
      if (listeners[i].name === 'ondata') {
        return true;
      }
    }

    return false;
  }

  /**
   * Unpipe a stream from all destinations.
   *
   * @param {object} stream
   * @public
   */

  function unpipe(stream) {
    if (!stream) {
      throw new TypeError('argument stream is required');
    }

    if (typeof stream.unpipe === 'function') {
      // new-style
      stream.unpipe();
      return;
    }

    // Node.js 0.8 hack
    if (!hasPipeDataListeners(stream)) {
      return;
    }

    var listener;
    var listeners = stream.listeners('close');

    for (var i = 0; i < listeners.length; i++) {
      listener = listeners[i];

      if (listener.name !== 'cleanup' && listener.name !== 'onclose') {
        continue;
      }

      // invoke the listener
      listener.call(stream);
    }
  }
  return module.exports;
});
$__System.registerDynamic("13b", ["287"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("287");
  return module.exports;
});
$__System.registerDynamic('288', ['8', '3d', '11', '3f', '13b', '2a', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer, process) {
    'use strict';

    var debug = $__require('8')('finalhandler');
    var escapeHtml = $__require('3d');
    var http = $__require('11');
    var onFinished = $__require('3f');
    var unpipe = $__require('13b');
    var defer = typeof setImmediate === 'function' ? setImmediate : function (fn) {
      process.nextTick(fn.bind.apply(fn, arguments));
    };
    var isFinished = onFinished.isFinished;
    module.exports = finalhandler;
    function finalhandler(req, res, options) {
      var opts = options || {};
      var env = opts.env || 'production' || 'development';
      var onerror = opts.onerror;
      return function (err) {
        var status = res.statusCode;
        if (!err && res._header) {
          debug('cannot 404 after headers sent');
          return;
        }
        if (err) {
          if (err.statusCode) {
            status = err.statusCode;
          }
          if (err.status) {
            status = err.status;
          }
          if (!status || status < 400) {
            status = 500;
          }
          var msg = env === 'production' ? http.STATUS_CODES[status] : err.stack || err.toString();
          msg = escapeHtml(msg).replace(/\n/g, '<br>').replace(/  /g, ' &nbsp;') + '\n';
        } else {
          status = 404;
          msg = 'Cannot ' + escapeHtml(req.method) + ' ' + escapeHtml(req.originalUrl || req.url) + '\n';
        }
        debug('default %s', status);
        if (err && onerror) {
          defer(onerror, err, req, res);
        }
        if (res._header) {
          return req.socket.destroy();
        }
        send(req, res, status, msg);
      };
    }
    function send(req, res, status, body) {
      function write() {
        res.statusCode = status;
        res.setHeader('X-Content-Type-Options', 'nosniff');
        res.setHeader('Content-Type', 'text/html; charset=utf-8');
        res.setHeader('Content-Length', Buffer.byteLength(body, 'utf8'));
        if (req.method === 'HEAD') {
          res.end();
          return;
        }
        res.end(body, 'utf8');
      }
      if (isFinished(req)) {
        write();
        return;
      }
      unpipe(req);
      onFinished(req, write);
      req.resume();
    }
  })($__require('2a').Buffer, $__require('13'));
  return module.exports;
});
$__System.registerDynamic("10", ["288"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("288");
  return module.exports;
});
$__System.registerDynamic('289', ['28a', '28f', '28b', '28c', '28d', '28e', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    exports = module.exports = $__require('28a');
    exports.Stream = $__require('28f');
    exports.Readable = exports;
    exports.Writable = $__require('28b');
    exports.Duplex = $__require('28c');
    exports.Transform = $__require('28d');
    exports.PassThrough = $__require('28e');
    if (!process.browser && process.env.READABLE_STREAM === 'disable') {
      module.exports = $__require('28f');
    }
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('290', ['28b'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  module.exports = $__require('28b');
  return module.exports;
});
$__System.registerDynamic('291', ['28c'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  module.exports = $__require('28c');
  return module.exports;
});
$__System.registerDynamic('292', ['28d'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  module.exports = $__require('28d');
  return module.exports;
});
$__System.registerDynamic('293', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  module.exports = Array.isArray || function (arr) {
    return Object.prototype.toString.call(arr) == '[object Array]';
  };
  return module.exports;
});
$__System.registerDynamic("294", ["293"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("293");
  return module.exports;
});
$__System.registerDynamic('295', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  // Copyright Joyent, Inc. and other Node contributors.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a
  // copy of this software and associated documentation files (the
  // "Software"), to deal in the Software without restriction, including
  // without limitation the rights to use, copy, modify, merge, publish,
  // distribute, sublicense, and/or sell copies of the Software, and to permit
  // persons to whom the Software is furnished to do so, subject to the
  // following conditions:
  //
  // The above copyright notice and this permission notice shall be included
  // in all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
  // USE OR OTHER DEALINGS IN THE SOFTWARE.

  function EventEmitter() {
    this._events = this._events || {};
    this._maxListeners = this._maxListeners || undefined;
  }
  module.exports = EventEmitter;

  // Backwards-compat with node 0.10.x
  EventEmitter.EventEmitter = EventEmitter;

  EventEmitter.prototype._events = undefined;
  EventEmitter.prototype._maxListeners = undefined;

  // By default EventEmitters will print a warning if more than 10 listeners are
  // added to it. This is a useful default which helps finding memory leaks.
  EventEmitter.defaultMaxListeners = 10;

  // Obviously not all Emitters should be limited to 10. This function allows
  // that to be increased. Set to zero for unlimited.
  EventEmitter.prototype.setMaxListeners = function (n) {
    if (!isNumber(n) || n < 0 || isNaN(n)) throw TypeError('n must be a positive number');
    this._maxListeners = n;
    return this;
  };

  EventEmitter.prototype.emit = function (type) {
    var er, handler, len, args, i, listeners;

    if (!this._events) this._events = {};

    // If there is no 'error' event listener then throw.
    if (type === 'error') {
      if (!this._events.error || isObject(this._events.error) && !this._events.error.length) {
        er = arguments[1];
        if (er instanceof Error) {
          throw er; // Unhandled 'error' event
        }
        throw TypeError('Uncaught, unspecified "error" event.');
      }
    }

    handler = this._events[type];

    if (isUndefined(handler)) return false;

    if (isFunction(handler)) {
      switch (arguments.length) {
        // fast cases
        case 1:
          handler.call(this);
          break;
        case 2:
          handler.call(this, arguments[1]);
          break;
        case 3:
          handler.call(this, arguments[1], arguments[2]);
          break;
        // slower
        default:
          len = arguments.length;
          args = new Array(len - 1);
          for (i = 1; i < len; i++) args[i - 1] = arguments[i];
          handler.apply(this, args);
      }
    } else if (isObject(handler)) {
      len = arguments.length;
      args = new Array(len - 1);
      for (i = 1; i < len; i++) args[i - 1] = arguments[i];

      listeners = handler.slice();
      len = listeners.length;
      for (i = 0; i < len; i++) listeners[i].apply(this, args);
    }

    return true;
  };

  EventEmitter.prototype.addListener = function (type, listener) {
    var m;

    if (!isFunction(listener)) throw TypeError('listener must be a function');

    if (!this._events) this._events = {};

    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (this._events.newListener) this.emit('newListener', type, isFunction(listener.listener) ? listener.listener : listener);

    if (!this._events[type])
      // Optimize the case of one listener. Don't need the extra array object.
      this._events[type] = listener;else if (isObject(this._events[type]))
      // If we've already got an array, just append.
      this._events[type].push(listener);else
      // Adding the second element, need to change to array.
      this._events[type] = [this._events[type], listener];

    // Check for listener leak
    if (isObject(this._events[type]) && !this._events[type].warned) {
      var m;
      if (!isUndefined(this._maxListeners)) {
        m = this._maxListeners;
      } else {
        m = EventEmitter.defaultMaxListeners;
      }

      if (m && m > 0 && this._events[type].length > m) {
        this._events[type].warned = true;
        console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);
        if (typeof console.trace === 'function') {
          // not supported in IE 10
          console.trace();
        }
      }
    }

    return this;
  };

  EventEmitter.prototype.on = EventEmitter.prototype.addListener;

  EventEmitter.prototype.once = function (type, listener) {
    if (!isFunction(listener)) throw TypeError('listener must be a function');

    var fired = false;

    function g() {
      this.removeListener(type, g);

      if (!fired) {
        fired = true;
        listener.apply(this, arguments);
      }
    }

    g.listener = listener;
    this.on(type, g);

    return this;
  };

  // emits a 'removeListener' event iff the listener was removed
  EventEmitter.prototype.removeListener = function (type, listener) {
    var list, position, length, i;

    if (!isFunction(listener)) throw TypeError('listener must be a function');

    if (!this._events || !this._events[type]) return this;

    list = this._events[type];
    length = list.length;
    position = -1;

    if (list === listener || isFunction(list.listener) && list.listener === listener) {
      delete this._events[type];
      if (this._events.removeListener) this.emit('removeListener', type, listener);
    } else if (isObject(list)) {
      for (i = length; i-- > 0;) {
        if (list[i] === listener || list[i].listener && list[i].listener === listener) {
          position = i;
          break;
        }
      }

      if (position < 0) return this;

      if (list.length === 1) {
        list.length = 0;
        delete this._events[type];
      } else {
        list.splice(position, 1);
      }

      if (this._events.removeListener) this.emit('removeListener', type, listener);
    }

    return this;
  };

  EventEmitter.prototype.removeAllListeners = function (type) {
    var key, listeners;

    if (!this._events) return this;

    // not listening for removeListener, no need to emit
    if (!this._events.removeListener) {
      if (arguments.length === 0) this._events = {};else if (this._events[type]) delete this._events[type];
      return this;
    }

    // emit removeListener for all listeners on all events
    if (arguments.length === 0) {
      for (key in this._events) {
        if (key === 'removeListener') continue;
        this.removeAllListeners(key);
      }
      this.removeAllListeners('removeListener');
      this._events = {};
      return this;
    }

    listeners = this._events[type];

    if (isFunction(listeners)) {
      this.removeListener(type, listeners);
    } else {
      // LIFO order
      while (listeners.length) this.removeListener(type, listeners[listeners.length - 1]);
    }
    delete this._events[type];

    return this;
  };

  EventEmitter.prototype.listeners = function (type) {
    var ret;
    if (!this._events || !this._events[type]) ret = [];else if (isFunction(this._events[type])) ret = [this._events[type]];else ret = this._events[type].slice();
    return ret;
  };

  EventEmitter.listenerCount = function (emitter, type) {
    var ret;
    if (!emitter._events || !emitter._events[type]) ret = 0;else if (isFunction(emitter._events[type])) ret = 1;else ret = emitter._events[type].length;
    return ret;
  };

  function isFunction(arg) {
    return typeof arg === 'function';
  }

  function isNumber(arg) {
    return typeof arg === 'number';
  }

  function isObject(arg) {
    return typeof arg === 'object' && arg !== null;
  }

  function isUndefined(arg) {
    return arg === void 0;
  }
  return module.exports;
});
$__System.registerDynamic("296", ["295"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("295");
  return module.exports;
});
$__System.registerDynamic('297', ['296'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  module.exports = $__System._nodeRequire ? $__System._nodeRequire('events') : $__require('296');
  return module.exports;
});
$__System.registerDynamic("55", ["297"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("297");
  return module.exports;
});
$__System.registerDynamic('298', ['2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    var Buffer = $__require('2a').Buffer;
    var isBufferEncoding = Buffer.isEncoding || function (encoding) {
      switch (encoding && encoding.toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
        case 'raw':
          return true;
        default:
          return false;
      }
    };
    function assertEncoding(encoding) {
      if (encoding && !isBufferEncoding(encoding)) {
        throw new Error('Unknown encoding: ' + encoding);
      }
    }
    var StringDecoder = exports.StringDecoder = function (encoding) {
      this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
      assertEncoding(encoding);
      switch (this.encoding) {
        case 'utf8':
          this.surrogateSize = 3;
          break;
        case 'ucs2':
        case 'utf16le':
          this.surrogateSize = 2;
          this.detectIncompleteChar = utf16DetectIncompleteChar;
          break;
        case 'base64':
          this.surrogateSize = 3;
          this.detectIncompleteChar = base64DetectIncompleteChar;
          break;
        default:
          this.write = passThroughWrite;
          return;
      }
      this.charBuffer = new Buffer(6);
      this.charReceived = 0;
      this.charLength = 0;
    };
    StringDecoder.prototype.write = function (buffer) {
      var charStr = '';
      while (this.charLength) {
        var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
        buffer.copy(this.charBuffer, this.charReceived, 0, available);
        this.charReceived += available;
        if (this.charReceived < this.charLength) {
          return '';
        }
        buffer = buffer.slice(available, buffer.length);
        charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
        var charCode = charStr.charCodeAt(charStr.length - 1);
        if (charCode >= 0xD800 && charCode <= 0xDBFF) {
          this.charLength += this.surrogateSize;
          charStr = '';
          continue;
        }
        this.charReceived = this.charLength = 0;
        if (buffer.length === 0) {
          return charStr;
        }
        break;
      }
      this.detectIncompleteChar(buffer);
      var end = buffer.length;
      if (this.charLength) {
        buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
        end -= this.charReceived;
      }
      charStr += buffer.toString(this.encoding, 0, end);
      var end = charStr.length - 1;
      var charCode = charStr.charCodeAt(end);
      if (charCode >= 0xD800 && charCode <= 0xDBFF) {
        var size = this.surrogateSize;
        this.charLength += size;
        this.charReceived += size;
        this.charBuffer.copy(this.charBuffer, size, 0, size);
        buffer.copy(this.charBuffer, 0, 0, size);
        return charStr.substring(0, end);
      }
      return charStr;
    };
    StringDecoder.prototype.detectIncompleteChar = function (buffer) {
      var i = buffer.length >= 3 ? 3 : buffer.length;
      for (; i > 0; i--) {
        var c = buffer[buffer.length - i];
        if (i == 1 && c >> 5 == 0x06) {
          this.charLength = 2;
          break;
        }
        if (i <= 2 && c >> 4 == 0x0E) {
          this.charLength = 3;
          break;
        }
        if (i <= 3 && c >> 3 == 0x1E) {
          this.charLength = 4;
          break;
        }
      }
      this.charReceived = i;
    };
    StringDecoder.prototype.end = function (buffer) {
      var res = '';
      if (buffer && buffer.length) res = this.write(buffer);
      if (this.charReceived) {
        var cr = this.charReceived;
        var buf = this.charBuffer;
        var enc = this.encoding;
        res += buf.slice(0, cr).toString(enc);
      }
      return res;
    };
    function passThroughWrite(buffer) {
      return buffer.toString(this.encoding);
    }
    function utf16DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 2;
      this.charLength = this.charReceived ? 2 : 0;
    }
    function base64DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 3;
      this.charLength = this.charReceived ? 3 : 0;
    }
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic("19e", ["298"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("298");
  return module.exports;
});
$__System.registerDynamic('28a', ['294', '2a', '55', '28f', '19d', '46', '@empty', '28c', '19e', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer, process) {
    module.exports = Readable;
    var isArray = $__require('294');
    var Buffer = $__require('2a').Buffer;
    Readable.ReadableState = ReadableState;
    var EE = $__require('55').EventEmitter;
    if (!EE.listenerCount) EE.listenerCount = function (emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = $__require('28f');
    var util = $__require('19d');
    util.inherits = $__require('46');
    var StringDecoder;
    var debug = $__require('@empty');
    if (debug && debug.debuglog) {
      debug = debug.debuglog('stream');
    } else {
      debug = function () {};
    }
    util.inherits(Readable, Stream);
    function ReadableState(options, stream) {
      var Duplex = $__require('28c');
      options = options || {};
      var hwm = options.highWaterMark;
      var defaultHwm = options.objectMode ? 16 : 16 * 1024;
      this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
      this.highWaterMark = ~~this.highWaterMark;
      this.buffer = [];
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.objectMode = !!options.objectMode;
      if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.defaultEncoding = options.defaultEncoding || 'utf8';
      this.ranOut = false;
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder) StringDecoder = $__require('19e').StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      var Duplex = $__require('28c');
      if (!(this instanceof Readable)) return new Readable(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      Stream.call(this);
    }
    Readable.prototype.push = function (chunk, encoding) {
      var state = this._readableState;
      if (util.isString(chunk) && !state.objectMode) {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = new Buffer(chunk, encoding);
          encoding = '';
        }
      }
      return readableAddChunk(this, state, chunk, encoding, false);
    };
    Readable.prototype.unshift = function (chunk) {
      var state = this._readableState;
      return readableAddChunk(this, state, chunk, '', true);
    };
    function readableAddChunk(stream, state, chunk, encoding, addToFront) {
      var er = chunkInvalid(state, chunk);
      if (er) {
        stream.emit('error', er);
      } else if (util.isNullOrUndefined(chunk)) {
        state.reading = false;
        if (!state.ended) onEofChunk(stream, state);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (state.ended && !addToFront) {
          var e = new Error('stream.push() after EOF');
          stream.emit('error', e);
        } else if (state.endEmitted && addToFront) {
          var e = new Error('stream.unshift() after end event');
          stream.emit('error', e);
        } else {
          if (state.decoder && !addToFront && !encoding) chunk = state.decoder.write(chunk);
          if (!addToFront) state.reading = false;
          if (state.flowing && state.length === 0 && !state.sync) {
            stream.emit('data', chunk);
            stream.read(0);
          } else {
            state.length += state.objectMode ? 1 : chunk.length;
            if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
            if (state.needReadable) emitReadable(stream);
          }
          maybeReadMore(stream, state);
        }
      } else if (!addToFront) {
        state.reading = false;
      }
      return needMoreData(state);
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable.prototype.setEncoding = function (enc) {
      if (!StringDecoder) StringDecoder = $__require('19e').StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 0x800000;
    function roundUpToNextPowerOf2(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        for (var p = 1; p < 32; p <<= 1) n |= n >> p;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (state.length === 0 && state.ended) return 0;
      if (state.objectMode) return n === 0 ? 0 : 1;
      if (isNaN(n) || util.isNull(n)) {
        if (state.flowing && state.buffer.length) return state.buffer[0].length;else return state.length;
      }
      if (n <= 0) return 0;
      if (n > state.highWaterMark) state.highWaterMark = roundUpToNextPowerOf2(n);
      if (n > state.length) {
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        } else return state.length;
      }
      return n;
    }
    Readable.prototype.read = function (n) {
      debug('read', n);
      var state = this._readableState;
      var nOrig = n;
      if (!util.isNumber(n) || n > 0) state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug('read: emitReadable', state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug('need readable', doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug('length less than watermark', doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug('reading or ended', doRead);
      }
      if (doRead) {
        debug('do read');
        state.reading = true;
        state.sync = true;
        if (state.length === 0) state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
      }
      if (doRead && !state.reading) n = howMuchToRead(nOrig, state);
      var ret;
      if (n > 0) ret = fromList(n, state);else ret = null;
      if (util.isNull(ret)) {
        state.needReadable = true;
        n = 0;
      }
      state.length -= n;
      if (state.length === 0 && !state.ended) state.needReadable = true;
      if (nOrig !== n && state.ended && state.length === 0) endReadable(this);
      if (!util.isNull(ret)) this.emit('data', ret);
      return ret;
    };
    function chunkInvalid(state, chunk) {
      var er = null;
      if (!util.isBuffer(chunk) && !util.isString(chunk) && !util.isNullOrUndefined(chunk) && !state.objectMode) {
        er = new TypeError('Invalid non-string/buffer chunk');
      }
      return er;
    }
    function onEofChunk(stream, state) {
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      emitReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug('emitReadable', state.flowing);
        state.emittedReadable = true;
        if (state.sync) process.nextTick(function () {
          emitReadable_(stream);
        });else emitReadable_(stream);
      }
    }
    function emitReadable_(stream) {
      debug('emit readable');
      stream.emit('readable');
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(function () {
          maybeReadMore_(stream, state);
        });
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug('maybeReadMore read 0');
        stream.read(0);
        if (len === state.length) break;else len = state.length;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function (n) {
      this.emit('error', new Error('not implemented'));
    };
    Readable.prototype.pipe = function (dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : cleanup;
      if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
      dest.on('unpipe', onunpipe);
      function onunpipe(readable) {
        debug('onunpipe');
        if (readable === src) {
          cleanup();
        }
      }
      function onend() {
        debug('onend');
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on('drain', ondrain);
      function cleanup() {
        debug('cleanup');
        dest.removeListener('close', onclose);
        dest.removeListener('finish', onfinish);
        dest.removeListener('drain', ondrain);
        dest.removeListener('error', onerror);
        dest.removeListener('unpipe', onunpipe);
        src.removeListener('end', onend);
        src.removeListener('end', cleanup);
        src.removeListener('data', ondata);
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
      }
      src.on('data', ondata);
      function ondata(chunk) {
        debug('ondata');
        var ret = dest.write(chunk);
        if (false === ret) {
          debug('false write response, pause', src._readableState.awaitDrain);
          src._readableState.awaitDrain++;
          src.pause();
        }
      }
      function onerror(er) {
        debug('onerror', er);
        unpipe();
        dest.removeListener('error', onerror);
        if (EE.listenerCount(dest, 'error') === 0) dest.emit('error', er);
      }
      if (!dest._events || !dest._events.error) dest.on('error', onerror);else if (isArray(dest._events.error)) dest._events.error.unshift(onerror);else dest._events.error = [onerror, dest._events.error];
      function onclose() {
        dest.removeListener('finish', onfinish);
        unpipe();
      }
      dest.once('close', onclose);
      function onfinish() {
        debug('onfinish');
        dest.removeListener('close', onclose);
        unpipe();
      }
      dest.once('finish', onfinish);
      function unpipe() {
        debug('unpipe');
        src.unpipe(dest);
      }
      dest.emit('pipe', src);
      if (!state.flowing) {
        debug('pipe resume');
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function () {
        var state = src._readableState;
        debug('pipeOnDrain', state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function (dest) {
      var state = this._readableState;
      if (state.pipesCount === 0) return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes) return this;
        if (!dest) dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit('unpipe', this);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) dests[i].emit('unpipe', this);
        return this;
      }
      var i = indexOf(state.pipes, dest);
      if (i === -1) return this;
      state.pipes.splice(i, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1) state.pipes = state.pipes[0];
      dest.emit('unpipe', this);
      return this;
    };
    Readable.prototype.on = function (ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      if (ev === 'data' && false !== this._readableState.flowing) {
        this.resume();
      }
      if (ev === 'readable' && this.readable) {
        var state = this._readableState;
        if (!state.readableListening) {
          state.readableListening = true;
          state.emittedReadable = false;
          state.needReadable = true;
          if (!state.reading) {
            var self = this;
            process.nextTick(function () {
              debug('readable nexttick read 0');
              self.read(0);
            });
          } else if (state.length) {
            emitReadable(this, state);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.resume = function () {
      var state = this._readableState;
      if (!state.flowing) {
        debug('resume');
        state.flowing = true;
        if (!state.reading) {
          debug('resume read 0');
          this.read(0);
        }
        resume(this, state);
      }
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(function () {
          resume_(stream, state);
        });
      }
    }
    function resume_(stream, state) {
      state.resumeScheduled = false;
      stream.emit('resume');
      flow(stream);
      if (state.flowing && !state.reading) stream.read(0);
    }
    Readable.prototype.pause = function () {
      debug('call pause flowing=%j', this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug('pause');
        this._readableState.flowing = false;
        this.emit('pause');
      }
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug('flow', state.flowing);
      if (state.flowing) {
        do {
          var chunk = stream.read();
        } while (null !== chunk && state.flowing);
      }
    }
    Readable.prototype.wrap = function (stream) {
      var state = this._readableState;
      var paused = false;
      var self = this;
      stream.on('end', function () {
        debug('wrapped end');
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) self.push(chunk);
        }
        self.push(null);
      });
      stream.on('data', function (chunk) {
        debug('wrapped data');
        if (state.decoder) chunk = state.decoder.write(chunk);
        if (!chunk || !state.objectMode && !chunk.length) return;
        var ret = self.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
          this[i] = function (method) {
            return function () {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      var events = ['error', 'close', 'destroy', 'pause', 'resume'];
      forEach(events, function (ev) {
        stream.on(ev, self.emit.bind(self, ev));
      });
      self._read = function (n) {
        debug('wrapped _read', n);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return self;
    };
    Readable._fromList = fromList;
    function fromList(n, state) {
      var list = state.buffer;
      var length = state.length;
      var stringMode = !!state.decoder;
      var objectMode = !!state.objectMode;
      var ret;
      if (list.length === 0) return null;
      if (length === 0) ret = null;else if (objectMode) ret = list.shift();else if (!n || n >= length) {
        if (stringMode) ret = list.join('');else ret = Buffer.concat(list, length);
        list.length = 0;
      } else {
        if (n < list[0].length) {
          var buf = list[0];
          ret = buf.slice(0, n);
          list[0] = buf.slice(n);
        } else if (n === list[0].length) {
          ret = list.shift();
        } else {
          if (stringMode) ret = '';else ret = new Buffer(n);
          var c = 0;
          for (var i = 0, l = list.length; i < l && c < n; i++) {
            var buf = list[0];
            var cpy = Math.min(n - c, buf.length);
            if (stringMode) ret += buf.slice(0, cpy);else buf.copy(ret, c, 0, cpy);
            if (cpy < buf.length) list[0] = buf.slice(cpy);else list.shift();
            c += cpy;
          }
        }
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0) throw new Error('endReadable called on non-empty stream');
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(function () {
          if (!state.endEmitted && state.length === 0) {
            state.endEmitted = true;
            stream.readable = false;
            stream.emit('end');
          }
        });
      }
    }
    function forEach(xs, f) {
      for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) return i;
      }
      return -1;
    }
  })($__require('2a').Buffer, $__require('13'));
  return module.exports;
});
$__System.registerDynamic('28b', ['2a', '19d', '46', '28f', '28c', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer, process) {
    module.exports = Writable;
    var Buffer = $__require('2a').Buffer;
    Writable.WritableState = WritableState;
    var util = $__require('19d');
    util.inherits = $__require('46');
    var Stream = $__require('28f');
    util.inherits(Writable, Stream);
    function WriteReq(chunk, encoding, cb) {
      this.chunk = chunk;
      this.encoding = encoding;
      this.callback = cb;
    }
    function WritableState(options, stream) {
      var Duplex = $__require('28c');
      options = options || {};
      var hwm = options.highWaterMark;
      var defaultHwm = options.objectMode ? 16 : 16 * 1024;
      this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
      this.objectMode = !!options.objectMode;
      if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = ~~this.highWaterMark;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || 'utf8';
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function (er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.buffer = [];
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
    }
    function Writable(options) {
      var Duplex = $__require('28c');
      if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);
      this._writableState = new WritableState(options, this);
      this.writable = true;
      Stream.call(this);
    }
    Writable.prototype.pipe = function () {
      this.emit('error', new Error('Cannot pipe. Not readable.'));
    };
    function writeAfterEnd(stream, state, cb) {
      var er = new Error('write after end');
      stream.emit('error', er);
      process.nextTick(function () {
        cb(er);
      });
    }
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      if (!util.isBuffer(chunk) && !util.isString(chunk) && !util.isNullOrUndefined(chunk) && !state.objectMode) {
        var er = new TypeError('Invalid non-string/buffer chunk');
        stream.emit('error', er);
        process.nextTick(function () {
          cb(er);
        });
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function (chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      if (util.isFunction(encoding)) {
        cb = encoding;
        encoding = null;
      }
      if (util.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
      if (!util.isFunction(cb)) cb = function () {};
      if (state.ended) writeAfterEnd(this, state, cb);else if (validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function () {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function () {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.buffer.length) clearBuffer(this, state);
      }
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && util.isString(chunk)) {
        chunk = new Buffer(chunk, encoding);
      }
      return chunk;
    }
    function writeOrBuffer(stream, state, chunk, encoding, cb) {
      chunk = decodeChunk(state, chunk, encoding);
      if (util.isBuffer(chunk)) encoding = 'buffer';
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret) state.needDrain = true;
      if (state.writing || state.corked) state.buffer.push(new WriteReq(chunk, encoding, cb));else doWrite(stream, state, false, len, chunk, encoding, cb);
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      if (sync) process.nextTick(function () {
        state.pendingcb--;
        cb(er);
      });else {
        state.pendingcb--;
        cb(er);
      }
      stream._writableState.errorEmitted = true;
      stream.emit('error', er);
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er) onwriteError(stream, state, sync, er, cb);else {
        var finished = needFinish(stream, state);
        if (!finished && !state.corked && !state.bufferProcessing && state.buffer.length) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(function () {
            afterWrite(stream, state, finished, cb);
          });
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished) onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit('drain');
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      if (stream._writev && state.buffer.length > 1) {
        var cbs = [];
        for (var c = 0; c < state.buffer.length; c++) cbs.push(state.buffer[c].callback);
        state.pendingcb++;
        doWrite(stream, state, true, state.length, state.buffer, '', function (err) {
          for (var i = 0; i < cbs.length; i++) {
            state.pendingcb--;
            cbs[i](err);
          }
        });
        state.buffer = [];
      } else {
        for (var c = 0; c < state.buffer.length; c++) {
          var entry = state.buffer[c];
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          if (state.writing) {
            c++;
            break;
          }
        }
        if (c < state.buffer.length) state.buffer = state.buffer.slice(c);else state.buffer.length = 0;
      }
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function (chunk, encoding, cb) {
      cb(new Error('not implemented'));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function (chunk, encoding, cb) {
      var state = this._writableState;
      if (util.isFunction(chunk)) {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (util.isFunction(encoding)) {
        cb = encoding;
        encoding = null;
      }
      if (!util.isNullOrUndefined(chunk)) this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending && !state.finished) endWritable(this, state, cb);
    };
    function needFinish(stream, state) {
      return state.ending && state.length === 0 && !state.finished && !state.writing;
    }
    function prefinish(stream, state) {
      if (!state.prefinished) {
        state.prefinished = true;
        stream.emit('prefinish');
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(stream, state);
      if (need) {
        if (state.pendingcb === 0) {
          prefinish(stream, state);
          state.finished = true;
          stream.emit('finish');
        } else prefinish(stream, state);
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
      }
      state.ended = true;
    }
  })($__require('2a').Buffer, $__require('13'));
  return module.exports;
});
$__System.registerDynamic('28c', ['19d', '46', '28a', '28b', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    module.exports = Duplex;
    var objectKeys = Object.keys || function (obj) {
      var keys = [];
      for (var key in obj) keys.push(key);
      return keys;
    };
    var util = $__require('19d');
    util.inherits = $__require('46');
    var Readable = $__require('28a');
    var Writable = $__require('28b');
    util.inherits(Duplex, Readable);
    forEach(objectKeys(Writable.prototype), function (method) {
      if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
    });
    function Duplex(options) {
      if (!(this instanceof Duplex)) return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false) this.readable = false;
      if (options && options.writable === false) this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
      this.once('end', onend);
    }
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended) return;
      process.nextTick(this.end.bind(this));
    }
    function forEach(xs, f) {
      for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('28d', ['28c', '19d', '46', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    module.exports = Transform;
    var Duplex = $__require('28c');
    var util = $__require('19d');
    util.inherits = $__require('46');
    util.inherits(Transform, Duplex);
    function TransformState(options, stream) {
      this.afterTransform = function (er, data) {
        return afterTransform(stream, er, data);
      };
      this.needTransform = false;
      this.transforming = false;
      this.writecb = null;
      this.writechunk = null;
    }
    function afterTransform(stream, er, data) {
      var ts = stream._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));
      ts.writechunk = null;
      ts.writecb = null;
      if (!util.isNullOrUndefined(data)) stream.push(data);
      if (cb) cb(er);
      var rs = stream._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        stream._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform)) return new Transform(options);
      Duplex.call(this, options);
      this._transformState = new TransformState(options, this);
      var stream = this;
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      this.once('prefinish', function () {
        if (util.isFunction(this._flush)) this._flush(function (er) {
          done(stream, er);
        });else done(stream);
      });
    }
    Transform.prototype.push = function (chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function (chunk, encoding, cb) {
      throw new Error('not implemented');
    };
    Transform.prototype._write = function (chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function (n) {
      var ts = this._transformState;
      if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    function done(stream, er) {
      if (er) return stream.emit('error', er);
      var ws = stream._writableState;
      var ts = stream._transformState;
      if (ws.length) throw new Error('calling transform done when ws.length != 0');
      if (ts.transforming) throw new Error('calling transform done when still transforming');
      return stream.push(null);
    }
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic('28e', ['28d', '19d', '46'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  module.exports = PassThrough;
  var Transform = $__require('28d');
  var util = $__require('19d');
  util.inherits = $__require('46');
  util.inherits(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough)) return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function (chunk, encoding, cb) {
    cb(null, chunk);
  };
  return module.exports;
});
$__System.registerDynamic('299', ['28e'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  module.exports = $__require('28e');
  return module.exports;
});
$__System.registerDynamic('28f', ['55', '46', '289', '290', '291', '292', '299'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  module.exports = Stream;
  var EE = $__require('55').EventEmitter;
  var inherits = $__require('46');
  inherits(Stream, EE);
  Stream.Readable = $__require('289');
  Stream.Writable = $__require('290');
  Stream.Duplex = $__require('291');
  Stream.Transform = $__require('292');
  Stream.PassThrough = $__require('299');
  Stream.Stream = Stream;
  function Stream() {
    EE.call(this);
  }
  Stream.prototype.pipe = function (dest, options) {
    var source = this;
    function ondata(chunk) {
      if (dest.writable) {
        if (false === dest.write(chunk) && source.pause) {
          source.pause();
        }
      }
    }
    source.on('data', ondata);
    function ondrain() {
      if (source.readable && source.resume) {
        source.resume();
      }
    }
    dest.on('drain', ondrain);
    if (!dest._isStdio && (!options || options.end !== false)) {
      source.on('end', onend);
      source.on('close', onclose);
    }
    var didOnEnd = false;
    function onend() {
      if (didOnEnd) return;
      didOnEnd = true;
      dest.end();
    }
    function onclose() {
      if (didOnEnd) return;
      didOnEnd = true;
      if (typeof dest.destroy === 'function') dest.destroy();
    }
    function onerror(er) {
      cleanup();
      if (EE.listenerCount(this, 'error') === 0) {
        throw er;
      }
    }
    source.on('error', onerror);
    dest.on('error', onerror);
    function cleanup() {
      source.removeListener('data', ondata);
      dest.removeListener('drain', ondrain);
      source.removeListener('end', onend);
      source.removeListener('close', onclose);
      source.removeListener('error', onerror);
      dest.removeListener('error', onerror);
      source.removeListener('end', cleanup);
      source.removeListener('close', cleanup);
      dest.removeListener('close', cleanup);
    }
    source.on('end', cleanup);
    source.on('close', cleanup);
    dest.on('close', cleanup);
    dest.emit('pipe', source);
    return dest;
  };
  return module.exports;
});
$__System.registerDynamic("29a", ["28f"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("28f");
  return module.exports;
});
$__System.registerDynamic('29b', ['29a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  module.exports = $__System._nodeRequire ? $__System._nodeRequire('stream') : $__require('29a');
  return module.exports;
});
$__System.registerDynamic("49", ["29b"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("29b");
  return module.exports;
});
$__System.registerDynamic('29c', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function isBuffer(arg) {
    return arg && typeof arg === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
  };
  return module.exports;
});
$__System.registerDynamic('29d', ['29c', '46', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    var formatRegExp = /%[sdj%]/g;
    exports.format = function (f) {
      if (!isString(f)) {
        var objects = [];
        for (var i = 0; i < arguments.length; i++) {
          objects.push(inspect(arguments[i]));
        }
        return objects.join(' ');
      }
      var i = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f).replace(formatRegExp, function (x) {
        if (x === '%%') return '%';
        if (i >= len) return x;
        switch (x) {
          case '%s':
            return String(args[i++]);
          case '%d':
            return Number(args[i++]);
          case '%j':
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return '[Circular]';
            }
          default:
            return x;
        }
      });
      for (var x = args[i]; i < len; x = args[++i]) {
        if (isNull(x) || !isObject(x)) {
          str += ' ' + x;
        } else {
          str += ' ' + inspect(x);
        }
      }
      return str;
    };
    exports.deprecate = function (fn, msg) {
      if (isUndefined(global.process)) {
        return function () {
          return exports.deprecate(fn, msg).apply(this, arguments);
        };
      }
      if (process.noDeprecation === true) {
        return fn;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (process.throwDeprecation) {
            throw new Error(msg);
          } else if (process.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    };
    var debugs = {};
    var debugEnviron;
    exports.debuglog = function (set) {
      if (isUndefined(debugEnviron)) debugEnviron = process.env.NODE_DEBUG || '';
      set = set.toUpperCase();
      if (!debugs[set]) {
        if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
          var pid = process.pid;
          debugs[set] = function () {
            var msg = exports.format.apply(exports, arguments);
            console.error('%s %d: %s', set, pid, msg);
          };
        } else {
          debugs[set] = function () {};
        }
      }
      return debugs[set];
    };
    function inspect(obj, opts) {
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      if (arguments.length >= 3) ctx.depth = arguments[2];
      if (arguments.length >= 4) ctx.colors = arguments[3];
      if (isBoolean(opts)) {
        ctx.showHidden = opts;
      } else if (opts) {
        exports._extend(ctx, opts);
      }
      if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
      if (isUndefined(ctx.depth)) ctx.depth = 2;
      if (isUndefined(ctx.colors)) ctx.colors = false;
      if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
      if (ctx.colors) ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    exports.inspect = inspect;
    inspect.colors = {
      'bold': [1, 22],
      'italic': [3, 23],
      'underline': [4, 24],
      'inverse': [7, 27],
      'white': [37, 39],
      'grey': [90, 39],
      'black': [30, 39],
      'blue': [34, 39],
      'cyan': [36, 39],
      'green': [32, 39],
      'magenta': [35, 39],
      'red': [31, 39],
      'yellow': [33, 39]
    };
    inspect.styles = {
      'special': 'cyan',
      'number': 'yellow',
      'boolean': 'yellow',
      'undefined': 'grey',
      'null': 'bold',
      'string': 'green',
      'date': 'magenta',
      'regexp': 'red'
    };
    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];
      if (style) {
        return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
      } else {
        return str;
      }
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array) {
      var hash = {};
      array.forEach(function (val, idx) {
        hash[val] = true;
      });
      return hash;
    }
    function formatValue(ctx, value, recurseTimes) {
      if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports.inspect && !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);
      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      }
      if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
        return formatError(value);
      }
      if (keys.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ': ' + value.name : '';
          return ctx.stylize('[Function' + name + ']', 'special');
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), 'date');
        }
        if (isError(value)) {
          return formatError(value);
        }
      }
      var base = '',
          array = false,
          braces = ['{', '}'];
      if (isArray(value)) {
        array = true;
        braces = ['[', ']'];
      }
      if (isFunction(value)) {
        var n = value.name ? ': ' + value.name : '';
        base = ' [Function' + n + ']';
      }
      if (isRegExp(value)) {
        base = ' ' + RegExp.prototype.toString.call(value);
      }
      if (isDate(value)) {
        base = ' ' + Date.prototype.toUTCString.call(value);
      }
      if (isError(value)) {
        base = ' ' + formatError(value);
      }
      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }
      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        } else {
          return ctx.stylize('[Object]', 'special');
        }
      }
      ctx.seen.push(value);
      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function (key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }
      ctx.seen.pop();
      return reduceToSingleString(output, base, braces);
    }
    function formatPrimitive(ctx, value) {
      if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');
      if (isString(value)) {
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
        return ctx.stylize(simple, 'string');
      }
      if (isNumber(value)) return ctx.stylize('' + value, 'number');
      if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
      if (isNull(value)) return ctx.stylize('null', 'null');
    }
    function formatError(value) {
      return '[' + Error.prototype.toString.call(value) + ']';
    }
    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty(value, String(i))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
        } else {
          output.push('');
        }
      }
      keys.forEach(function (key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
        }
      });
      return output;
    }
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize('[Getter/Setter]', 'special');
        } else {
          str = ctx.stylize('[Getter]', 'special');
        }
      } else {
        if (desc.set) {
          str = ctx.stylize('[Setter]', 'special');
        }
      }
      if (!hasOwnProperty(visibleKeys, key)) {
        name = '[' + key + ']';
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf('\n') > -1) {
            if (array) {
              str = str.split('\n').map(function (line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function (line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = ctx.stylize('[Circular]', 'special');
        }
      }
      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = ctx.stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, 'string');
        }
      }
      return name + ': ' + str;
    }
    function reduceToSingleString(output, base, braces) {
      var numLinesEst = 0;
      var length = output.reduce(function (prev, cur) {
        numLinesEst++;
        if (cur.indexOf('\n') >= 0) numLinesEst++;
        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
      }, 0);
      if (length > 60) {
        return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
      }
      return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }
    function isArray(ar) {
      return Array.isArray(ar);
    }
    exports.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === 'boolean';
    }
    exports.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === 'number';
    }
    exports.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === 'string';
    }
    exports.isString = isString;
    function isSymbol(arg) {
      return typeof arg === 'symbol';
    }
    exports.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    function isRegExp(re) {
      return isObject(re) && objectToString(re) === '[object RegExp]';
    }
    exports.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === 'object' && arg !== null;
    }
    exports.isObject = isObject;
    function isDate(d) {
      return isObject(d) && objectToString(d) === '[object Date]';
    }
    exports.isDate = isDate;
    function isError(e) {
      return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
    }
    exports.isError = isError;
    function isFunction(arg) {
      return typeof arg === 'function';
    }
    exports.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || typeof arg === 'undefined';
    }
    exports.isPrimitive = isPrimitive;
    exports.isBuffer = $__require('29c');
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
    function pad(n) {
      return n < 10 ? '0' + n.toString(10) : n.toString(10);
    }
    var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    function timestamp() {
      var d = new Date();
      var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
      return [d.getDate(), months[d.getMonth()], time].join(' ');
    }
    exports.log = function () {
      console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
    };
    exports.inherits = $__require('46');
    exports._extend = function (origin, add) {
      if (!add || !isObject(add)) return origin;
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    };
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic("161", ["29d"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("29d");
  return module.exports;
});
$__System.registerDynamic('29e', ['161'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  module.exports = $__System._nodeRequire ? $__System._nodeRequire('util') : $__require('161');
  return module.exports;
});
$__System.registerDynamic("166", ["29e"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("29e");
  return module.exports;
});
$__System.registerDynamic('29f', ['49', '166'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var Stream = $__require('49');
  var util = $__require('166');
  var Response = module.exports = function (res) {
    this.offset = 0;
    this.readable = true;
  };
  util.inherits(Response, Stream);
  var capable = {
    streaming: true,
    status2: true
  };
  function parseHeaders(res) {
    var lines = res.getAllResponseHeaders().split(/\r?\n/);
    var headers = {};
    for (var i = 0; i < lines.length; i++) {
      var line = lines[i];
      if (line === '') continue;
      var m = line.match(/^([^:]+):\s*(.*)/);
      if (m) {
        var key = m[1].toLowerCase(),
            value = m[2];
        if (headers[key] !== undefined) {
          if (isArray(headers[key])) {
            headers[key].push(value);
          } else {
            headers[key] = [headers[key], value];
          }
        } else {
          headers[key] = value;
        }
      } else {
        headers[line] = true;
      }
    }
    return headers;
  }
  Response.prototype.getResponse = function (xhr) {
    var respType = String(xhr.responseType).toLowerCase();
    if (respType === 'blob') return xhr.responseBlob || xhr.response;
    if (respType === 'arraybuffer') return xhr.response;
    return xhr.responseText;
  };
  Response.prototype.getHeader = function (key) {
    return this.headers[key.toLowerCase()];
  };
  Response.prototype.handle = function (res) {
    if (res.readyState === 2 && capable.status2) {
      try {
        this.statusCode = res.status;
        this.headers = parseHeaders(res);
      } catch (err) {
        capable.status2 = false;
      }
      if (capable.status2) {
        this.emit('ready');
      }
    } else if (capable.streaming && res.readyState === 3) {
      try {
        if (!this.statusCode) {
          this.statusCode = res.status;
          this.headers = parseHeaders(res);
          this.emit('ready');
        }
      } catch (err) {}
      try {
        this._emitData(res);
      } catch (err) {
        capable.streaming = false;
      }
    } else if (res.readyState === 4) {
      if (!this.statusCode) {
        this.statusCode = res.status;
        this.emit('ready');
      }
      this._emitData(res);
      if (res.error) {
        this.emit('error', this.getResponse(res));
      } else this.emit('end');
      this.emit('close');
    }
  };
  Response.prototype._emitData = function (res) {
    var respBody = this.getResponse(res);
    if (respBody.toString().match(/ArrayBuffer/)) {
      this.emit('data', new Uint8Array(respBody, this.offset));
      this.offset = respBody.byteLength;
      return;
    }
    if (respBody.length > this.offset) {
      this.emit('data', respBody.slice(this.offset));
      this.offset = respBody.length;
    }
  };
  var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
  };
  return module.exports;
});
$__System.registerDynamic('2a0', [], true, function ($__require, exports, module) {
  /* */
  "format cjs";

  var define,
      global = this || self,
      GLOBAL = global;
  ;(function () {

    var object = typeof exports != 'undefined' ? exports : this; // #8: web workers
    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

    function InvalidCharacterError(message) {
      this.message = message;
    }
    InvalidCharacterError.prototype = new Error();
    InvalidCharacterError.prototype.name = 'InvalidCharacterError';

    // encoder
    // [https://gist.github.com/999166] by [https://github.com/nignag]
    object.btoa || (object.btoa = function (input) {
      for (
      // initialize result and counter
      var block, charCode, idx = 0, map = chars, output = '';
      // if the next input index does not exist:
      //   change the mapping table to "="
      //   check if d has no fractional digits
      input.charAt(idx | 0) || (map = '=', idx % 1);
      // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
      output += map.charAt(63 & block >> 8 - idx % 1 * 8)) {
        charCode = input.charCodeAt(idx += 3 / 4);
        if (charCode > 0xFF) {
          throw new InvalidCharacterError("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
        }
        block = block << 8 | charCode;
      }
      return output;
    });

    // decoder
    // [https://gist.github.com/1020396] by [https://github.com/atk]
    object.atob || (object.atob = function (input) {
      input = input.replace(/=+$/, '');
      if (input.length % 4 == 1) {
        throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
      }
      for (
      // initialize result and counters
      var bc = 0, bs, buffer, idx = 0, output = '';
      // get next character
      buffer = input.charAt(idx++);
      // character found in table? initialize bit storage and add its ascii value;
      ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
      // and if not first of each 4 characters,
      // convert the first 8 bits to one ascii character
      bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0) {
        // try to find character in table (0-63, not found => -1)
        buffer = chars.indexOf(buffer);
      }
      return output;
    });
  })();
  return module.exports;
});
$__System.registerDynamic("2a1", ["2a0"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("2a0");
  return module.exports;
});
$__System.registerDynamic('2a2', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  if (typeof Object.create === 'function') {
    // implementation from standard node.js 'util' module
    module.exports = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    };
  } else {
    // old school shim for old browsers
    module.exports = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function () {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    };
  }
  return module.exports;
});
$__System.registerDynamic("46", ["2a2"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("2a2");
  return module.exports;
});
$__System.registerDynamic('2a3', ['49', '29f', '2a1', '46'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var Stream = $__require('49');
  var Response = $__require('29f');
  var Base64 = $__require('2a1');
  var inherits = $__require('46');
  var Request = module.exports = function (xhr, params) {
    var self = this;
    self.writable = true;
    self.xhr = xhr;
    self.body = [];
    self.uri = (params.protocol || 'http:') + '//' + params.host + (params.port ? ':' + params.port : '') + (params.path || '/');
    ;
    if (typeof params.withCredentials === 'undefined') {
      params.withCredentials = true;
    }
    try {
      xhr.withCredentials = params.withCredentials;
    } catch (e) {}
    if (params.responseType) try {
      xhr.responseType = params.responseType;
    } catch (e) {}
    xhr.open(params.method || 'GET', self.uri, true);
    xhr.onerror = function (event) {
      self.emit('error', new Error('Network error'));
    };
    self._headers = {};
    if (params.headers) {
      var keys = objectKeys(params.headers);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (!self.isSafeRequestHeader(key)) continue;
        var value = params.headers[key];
        self.setHeader(key, value);
      }
    }
    if (params.auth) {
      this.setHeader('Authorization', 'Basic ' + Base64.btoa(params.auth));
    }
    var res = new Response();
    res.on('close', function () {
      self.emit('close');
    });
    res.on('ready', function () {
      self.emit('response', res);
    });
    res.on('error', function (err) {
      self.emit('error', err);
    });
    xhr.onreadystatechange = function () {
      if (xhr.__aborted) return;
      res.handle(xhr);
    };
  };
  inherits(Request, Stream);
  Request.prototype.setHeader = function (key, value) {
    this._headers[key.toLowerCase()] = value;
  };
  Request.prototype.getHeader = function (key) {
    return this._headers[key.toLowerCase()];
  };
  Request.prototype.removeHeader = function (key) {
    delete this._headers[key.toLowerCase()];
  };
  Request.prototype.write = function (s) {
    this.body.push(s);
  };
  Request.prototype.destroy = function (s) {
    this.xhr.__aborted = true;
    this.xhr.abort();
    this.emit('close');
  };
  Request.prototype.end = function (s) {
    if (s !== undefined) this.body.push(s);
    var keys = objectKeys(this._headers);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var value = this._headers[key];
      if (isArray(value)) {
        for (var j = 0; j < value.length; j++) {
          this.xhr.setRequestHeader(key, value[j]);
        }
      } else this.xhr.setRequestHeader(key, value);
    }
    if (this.body.length === 0) {
      this.xhr.send('');
    } else if (typeof this.body[0] === 'string') {
      this.xhr.send(this.body.join(''));
    } else if (isArray(this.body[0])) {
      var body = [];
      for (var i = 0; i < this.body.length; i++) {
        body.push.apply(body, this.body[i]);
      }
      this.xhr.send(body);
    } else if (/Array/.test(Object.prototype.toString.call(this.body[0]))) {
      var len = 0;
      for (var i = 0; i < this.body.length; i++) {
        len += this.body[i].length;
      }
      var body = new this.body[0].constructor(len);
      var k = 0;
      for (var i = 0; i < this.body.length; i++) {
        var b = this.body[i];
        for (var j = 0; j < b.length; j++) {
          body[k++] = b[j];
        }
      }
      this.xhr.send(body);
    } else if (isXHR2Compatible(this.body[0])) {
      this.xhr.send(this.body[0]);
    } else {
      var body = '';
      for (var i = 0; i < this.body.length; i++) {
        body += this.body[i].toString();
      }
      this.xhr.send(body);
    }
  };
  Request.unsafeHeaders = ["accept-charset", "accept-encoding", "access-control-request-headers", "access-control-request-method", "connection", "content-length", "cookie", "cookie2", "content-transfer-encoding", "date", "expect", "host", "keep-alive", "origin", "referer", "te", "trailer", "transfer-encoding", "upgrade", "user-agent", "via"];
  Request.prototype.isSafeRequestHeader = function (headerName) {
    if (!headerName) return false;
    return indexOf(Request.unsafeHeaders, headerName.toLowerCase()) === -1;
  };
  var objectKeys = Object.keys || function (obj) {
    var keys = [];
    for (var key in obj) keys.push(key);
    return keys;
  };
  var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
  };
  var indexOf = function (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) {
      if (xs[i] === x) return i;
    }
    return -1;
  };
  var isXHR2Compatible = function (obj) {
    if (typeof Blob !== 'undefined' && obj instanceof Blob) return true;
    if (typeof ArrayBuffer !== 'undefined' && obj instanceof ArrayBuffer) return true;
    if (typeof FormData !== 'undefined' && obj instanceof FormData) return true;
  };
  return module.exports;
});
$__System.registerDynamic('2a4', ['55', '2a3', '57'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  if ($__System._nodeRequire) {
    module.exports = $__System._nodeRequire('http');
  } else {
    var http = module.exports;
    var EventEmitter = $__require('55').EventEmitter;
    var Request = $__require('2a3');
    var url = $__require('57');
    http.request = function (params, cb) {
      if (typeof params === 'string') {
        params = url.parse(params);
      }
      if (!params) params = {};
      if (!params.host && !params.port) {
        params.port = parseInt(window.location.port, 10);
      }
      if (!params.host && params.hostname) {
        params.host = params.hostname;
      }
      if (!params.protocol) {
        if (params.scheme) {
          params.protocol = params.scheme + ':';
        } else {
          params.protocol = window.location.protocol;
        }
      }
      if (!params.host) {
        params.host = window.location.hostname || window.location.host;
      }
      if (/:/.test(params.host)) {
        if (!params.port) {
          params.port = params.host.split(':')[1];
        }
        params.host = params.host.split(':')[0];
      }
      if (!params.port) params.port = params.protocol == 'https:' ? 443 : 80;
      var req = new Request(new xhrHttp(), params);
      if (cb) req.on('response', cb);
      return req;
    };
    http.get = function (params, cb) {
      params.method = 'GET';
      var req = http.request(params, cb);
      req.end();
      return req;
    };
    http.Agent = function () {};
    http.Agent.defaultMaxSockets = 4;
    var xhrHttp = function () {
      if (typeof window === 'undefined') {
        throw new Error('no window object present');
      } else if (window.XMLHttpRequest) {
        return window.XMLHttpRequest;
      } else if (window.ActiveXObject) {
        var axs = ['Msxml2.XMLHTTP.6.0', 'Msxml2.XMLHTTP.3.0', 'Microsoft.XMLHTTP'];
        for (var i = 0; i < axs.length; i++) {
          try {
            var ax = new window.ActiveXObject(axs[i]);
            return function () {
              if (ax) {
                var ax_ = ax;
                ax = null;
                return ax_;
              } else {
                return new window.ActiveXObject(axs[i]);
              }
            };
          } catch (e) {}
        }
        throw new Error('ajax not supported in this browser');
      } else {
        throw new Error('ajax not supported in this browser');
      }
    }();
    http.STATUS_CODES = {
      100: 'Continue',
      101: 'Switching Protocols',
      102: 'Processing',
      200: 'OK',
      201: 'Created',
      202: 'Accepted',
      203: 'Non-Authoritative Information',
      204: 'No Content',
      205: 'Reset Content',
      206: 'Partial Content',
      207: 'Multi-Status',
      300: 'Multiple Choices',
      301: 'Moved Permanently',
      302: 'Moved Temporarily',
      303: 'See Other',
      304: 'Not Modified',
      305: 'Use Proxy',
      307: 'Temporary Redirect',
      400: 'Bad Request',
      401: 'Unauthorized',
      402: 'Payment Required',
      403: 'Forbidden',
      404: 'Not Found',
      405: 'Method Not Allowed',
      406: 'Not Acceptable',
      407: 'Proxy Authentication Required',
      408: 'Request Time-out',
      409: 'Conflict',
      410: 'Gone',
      411: 'Length Required',
      412: 'Precondition Failed',
      413: 'Request Entity Too Large',
      414: 'Request-URI Too Large',
      415: 'Unsupported Media Type',
      416: 'Requested Range Not Satisfiable',
      417: 'Expectation Failed',
      418: 'I\'m a teapot',
      422: 'Unprocessable Entity',
      423: 'Locked',
      424: 'Failed Dependency',
      425: 'Unordered Collection',
      426: 'Upgrade Required',
      428: 'Precondition Required',
      429: 'Too Many Requests',
      431: 'Request Header Fields Too Large',
      500: 'Internal Server Error',
      501: 'Not Implemented',
      502: 'Bad Gateway',
      503: 'Service Unavailable',
      504: 'Gateway Time-out',
      505: 'HTTP Version Not Supported',
      506: 'Variant Also Negotiates',
      507: 'Insufficient Storage',
      509: 'Bandwidth Limit Exceeded',
      510: 'Not Extended',
      511: 'Network Authentication Required'
    };
  }
  return module.exports;
});
$__System.registerDynamic("11", ["2a4"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("2a4");
  return module.exports;
});
$__System.registerDynamic("2a5", [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /**
   * Merge object b with object a.
   *
   *     var a = { foo: 'bar' }
   *       , b = { bar: 'baz' };
   *
   *     merge(a, b);
   *     // => { foo: 'bar', bar: 'baz' }
   *
   * @param {Object} a
   * @param {Object} b
   * @return {Object}
   * @api public
   */

  exports = module.exports = function (a, b) {
    if (a && b) {
      for (var key in b) {
        a[key] = b[key];
      }
    }
    return a;
  };
  return module.exports;
});
$__System.registerDynamic("f", ["2a5"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("2a5");
  return module.exports;
});
$__System.registerDynamic('2a6', ['13'], true, function ($__require, exports, module) {
  /* */
  "format cjs";

  var define,
      global = this || self,
      GLOBAL = global;
  (function (process) {
    ;
    (function (root) {
      var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
      var freeModule = typeof module == 'object' && module && !module.nodeType && module;
      var freeGlobal = typeof global == 'object' && global;
      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
        root = freeGlobal;
      }
      var punycode,
          maxInt = 2147483647,
          base = 36,
          tMin = 1,
          tMax = 26,
          skew = 38,
          damp = 700,
          initialBias = 72,
          initialN = 128,
          delimiter = '-',
          regexPunycode = /^xn--/,
          regexNonASCII = /[^\x20-\x7E]/,
          regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
          errors = {
        'overflow': 'Overflow: input needs wider integers to process',
        'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
        'invalid-input': 'Invalid input'
      },
          baseMinusTMin = base - tMin,
          floor = Math.floor,
          stringFromCharCode = String.fromCharCode,
          key;
      function error(type) {
        throw RangeError(errors[type]);
      }
      function map(array, fn) {
        var length = array.length;
        var result = [];
        while (length--) {
          result[length] = fn(array[length]);
        }
        return result;
      }
      function mapDomain(string, fn) {
        var parts = string.split('@');
        var result = '';
        if (parts.length > 1) {
          result = parts[0] + '@';
          string = parts[1];
        }
        string = string.replace(regexSeparators, '\x2E');
        var labels = string.split('.');
        var encoded = map(labels, fn).join('.');
        return result + encoded;
      }
      function ucs2decode(string) {
        var output = [],
            counter = 0,
            length = string.length,
            value,
            extra;
        while (counter < length) {
          value = string.charCodeAt(counter++);
          if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
            extra = string.charCodeAt(counter++);
            if ((extra & 0xFC00) == 0xDC00) {
              output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      function ucs2encode(array) {
        return map(array, function (value) {
          var output = '';
          if (value > 0xFFFF) {
            value -= 0x10000;
            output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
            value = 0xDC00 | value & 0x3FF;
          }
          output += stringFromCharCode(value);
          return output;
        }).join('');
      }
      function basicToDigit(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      }
      function digitToBasic(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      }
      function adapt(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (; delta > baseMinusTMin * tMax >> 1; k += base) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
      }
      function decode(input) {
        var output = [],
            inputLength = input.length,
            out,
            i = 0,
            n = initialN,
            bias = initialBias,
            basic,
            j,
            index,
            oldi,
            w,
            k,
            digit,
            t,
            baseMinusT;
        basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (j = 0; j < basic; ++j) {
          if (input.charCodeAt(j) >= 0x80) {
            error('not-basic');
          }
          output.push(input.charCodeAt(j));
        }
        for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) {
          for (oldi = i, w = 1, k = base;; k += base) {
            if (index >= inputLength) {
              error('invalid-input');
            }
            digit = basicToDigit(input.charCodeAt(index++));
            if (digit >= base || digit > floor((maxInt - i) / w)) {
              error('overflow');
            }
            i += digit * w;
            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (digit < t) {
              break;
            }
            baseMinusT = base - t;
            if (w > floor(maxInt / baseMinusT)) {
              error('overflow');
            }
            w *= baseMinusT;
          }
          out = output.length + 1;
          bias = adapt(i - oldi, out, oldi == 0);
          if (floor(i / out) > maxInt - n) {
            error('overflow');
          }
          n += floor(i / out);
          i %= out;
          output.splice(i++, 0, n);
        }
        return ucs2encode(output);
      }
      function encode(input) {
        var n,
            delta,
            handledCPCount,
            basicLength,
            bias,
            j,
            m,
            q,
            k,
            t,
            currentValue,
            output = [],
            inputLength,
            handledCPCountPlusOne,
            baseMinusT,
            qMinusT;
        input = ucs2decode(input);
        inputLength = input.length;
        n = initialN;
        delta = 0;
        bias = initialBias;
        for (j = 0; j < inputLength; ++j) {
          currentValue = input[j];
          if (currentValue < 0x80) {
            output.push(stringFromCharCode(currentValue));
          }
        }
        handledCPCount = basicLength = output.length;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          for (m = maxInt, j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue >= n && currentValue < m) {
              m = currentValue;
            }
          }
          handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error('overflow');
          }
          delta += (m - n) * handledCPCountPlusOne;
          n = m;
          for (j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue < n && ++delta > maxInt) {
              error('overflow');
            }
            if (currentValue == n) {
              for (q = delta, k = base;; k += base) {
                t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (q < t) {
                  break;
                }
                qMinusT = q - t;
                baseMinusT = base - t;
                output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                q = floor(qMinusT / baseMinusT);
              }
              output.push(stringFromCharCode(digitToBasic(q, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
          ++delta;
          ++n;
        }
        return output.join('');
      }
      function toUnicode(input) {
        return mapDomain(input, function (string) {
          return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
        });
      }
      function toASCII(input) {
        return mapDomain(input, function (string) {
          return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
        });
      }
      punycode = {
        'version': '1.3.2',
        'ucs2': {
          'decode': ucs2decode,
          'encode': ucs2encode
        },
        'decode': decode,
        'encode': encode,
        'toASCII': toASCII,
        'toUnicode': toUnicode
      };
      if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
        define('punycode', function () {
          return punycode;
        });
      } else if (freeExports && freeModule) {
        if (module.exports == freeExports) {
          freeModule.exports = punycode;
        } else {
          for (key in punycode) {
            punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
          }
        }
      } else {
        root.punycode = punycode;
      }
    })(this);
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic("2a7", ["2a6"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("2a6");
  return module.exports;
});
$__System.registerDynamic('2a8', [], true, function ($__require, exports, module) {
  // Copyright Joyent, Inc. and other Node contributors.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a
  // copy of this software and associated documentation files (the
  // "Software"), to deal in the Software without restriction, including
  // without limitation the rights to use, copy, modify, merge, publish,
  // distribute, sublicense, and/or sell copies of the Software, and to permit
  // persons to whom the Software is furnished to do so, subject to the
  // following conditions:
  //
  // The above copyright notice and this permission notice shall be included
  // in all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
  // USE OR OTHER DEALINGS IN THE SOFTWARE.

  'use strict';

  // If obj.hasOwnProperty has been overridden, then calling
  // obj.hasOwnProperty(prop) will break.
  // See: https://github.com/joyent/node/issues/1707

  var define,
      global = this || self,
      GLOBAL = global;
  function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }

  module.exports = function (qs, sep, eq, options) {
    sep = sep || '&';
    eq = eq || '=';
    var obj = {};

    if (typeof qs !== 'string' || qs.length === 0) {
      return obj;
    }

    var regexp = /\+/g;
    qs = qs.split(sep);

    var maxKeys = 1000;
    if (options && typeof options.maxKeys === 'number') {
      maxKeys = options.maxKeys;
    }

    var len = qs.length;
    // maxKeys <= 0 means that we should not limit keys count
    if (maxKeys > 0 && len > maxKeys) {
      len = maxKeys;
    }

    for (var i = 0; i < len; ++i) {
      var x = qs[i].replace(regexp, '%20'),
          idx = x.indexOf(eq),
          kstr,
          vstr,
          k,
          v;

      if (idx >= 0) {
        kstr = x.substr(0, idx);
        vstr = x.substr(idx + 1);
      } else {
        kstr = x;
        vstr = '';
      }

      k = decodeURIComponent(kstr);
      v = decodeURIComponent(vstr);

      if (!hasOwnProperty(obj, k)) {
        obj[k] = v;
      } else if (Array.isArray(obj[k])) {
        obj[k].push(v);
      } else {
        obj[k] = [obj[k], v];
      }
    }

    return obj;
  };
  return module.exports;
});
$__System.registerDynamic('2a9', [], true, function ($__require, exports, module) {
  // Copyright Joyent, Inc. and other Node contributors.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a
  // copy of this software and associated documentation files (the
  // "Software"), to deal in the Software without restriction, including
  // without limitation the rights to use, copy, modify, merge, publish,
  // distribute, sublicense, and/or sell copies of the Software, and to permit
  // persons to whom the Software is furnished to do so, subject to the
  // following conditions:
  //
  // The above copyright notice and this permission notice shall be included
  // in all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
  // USE OR OTHER DEALINGS IN THE SOFTWARE.

  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var stringifyPrimitive = function (v) {
    switch (typeof v) {
      case 'string':
        return v;

      case 'boolean':
        return v ? 'true' : 'false';

      case 'number':
        return isFinite(v) ? v : '';

      default:
        return '';
    }
  };

  module.exports = function (obj, sep, eq, name) {
    sep = sep || '&';
    eq = eq || '=';
    if (obj === null) {
      obj = undefined;
    }

    if (typeof obj === 'object') {
      return Object.keys(obj).map(function (k) {
        var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
        if (Array.isArray(obj[k])) {
          return obj[k].map(function (v) {
            return ks + encodeURIComponent(stringifyPrimitive(v));
          }).join(sep);
        } else {
          return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
        }
      }).join(sep);
    }

    if (!name) return '';
    return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
  };
  return module.exports;
});
$__System.registerDynamic('2aa', ['2a8', '2a9'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  exports.decode = exports.parse = $__require('2a8');
  exports.encode = exports.stringify = $__require('2a9');
  return module.exports;
});
$__System.registerDynamic("177", ["2aa"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("2aa");
  return module.exports;
});
$__System.registerDynamic('2ab', ['2a7', '177'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  // Copyright Joyent, Inc. and other Node contributors.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a
  // copy of this software and associated documentation files (the
  // "Software"), to deal in the Software without restriction, including
  // without limitation the rights to use, copy, modify, merge, publish,
  // distribute, sublicense, and/or sell copies of the Software, and to permit
  // persons to whom the Software is furnished to do so, subject to the
  // following conditions:
  //
  // The above copyright notice and this permission notice shall be included
  // in all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
  // USE OR OTHER DEALINGS IN THE SOFTWARE.

  var punycode = $__require('2a7');

  exports.parse = urlParse;
  exports.resolve = urlResolve;
  exports.resolveObject = urlResolveObject;
  exports.format = urlFormat;

  exports.Url = Url;

  function Url() {
    this.protocol = null;
    this.slashes = null;
    this.auth = null;
    this.host = null;
    this.port = null;
    this.hostname = null;
    this.hash = null;
    this.search = null;
    this.query = null;
    this.pathname = null;
    this.path = null;
    this.href = null;
  }

  // Reference: RFC 3986, RFC 1808, RFC 2396

  // define these here so at least they only have to be
  // compiled once on the first module load.
  var protocolPattern = /^([a-z0-9.+-]+:)/i,
      portPattern = /:[0-9]*$/,


  // RFC 2396: characters reserved for delimiting URLs.
  // We actually just auto-escape these.
  delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],


  // RFC 2396: characters not allowed for various reasons.
  unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),


  // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
  autoEscape = ['\''].concat(unwise),

  // Characters that are never ever allowed in a hostname.
  // Note that any invalid chars are also handled, but these
  // are the ones that are *expected* to be seen, so we fast-path
  // them.
  nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
      hostEndingChars = ['/', '?', '#'],
      hostnameMaxLen = 255,
      hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
      hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,

  // protocols that can allow "unsafe" and "unwise" chars.
  unsafeProtocol = {
    'javascript': true,
    'javascript:': true
  },

  // protocols that never have a hostname.
  hostlessProtocol = {
    'javascript': true,
    'javascript:': true
  },

  // protocols that always contain a // bit.
  slashedProtocol = {
    'http': true,
    'https': true,
    'ftp': true,
    'gopher': true,
    'file': true,
    'http:': true,
    'https:': true,
    'ftp:': true,
    'gopher:': true,
    'file:': true
  },
      querystring = $__require('177');

  function urlParse(url, parseQueryString, slashesDenoteHost) {
    if (url && isObject(url) && url instanceof Url) return url;

    var u = new Url();
    u.parse(url, parseQueryString, slashesDenoteHost);
    return u;
  }

  Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
    if (!isString(url)) {
      throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
    }

    var rest = url;

    // trim before proceeding.
    // This is to support parse stuff like "  http://foo.com  \n"
    rest = rest.trim();

    var proto = protocolPattern.exec(rest);
    if (proto) {
      proto = proto[0];
      var lowerProto = proto.toLowerCase();
      this.protocol = lowerProto;
      rest = rest.substr(proto.length);
    }

    // figure out if it's got a host
    // user@server is *always* interpreted as a hostname, and url
    // resolution will treat //foo/bar as host=foo,path=bar because that's
    // how the browser resolves relative URLs.
    if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
      var slashes = rest.substr(0, 2) === '//';
      if (slashes && !(proto && hostlessProtocol[proto])) {
        rest = rest.substr(2);
        this.slashes = true;
      }
    }

    if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {

      // there's a hostname.
      // the first instance of /, ?, ;, or # ends the host.
      //
      // If there is an @ in the hostname, then non-host chars *are* allowed
      // to the left of the last @ sign, unless some host-ending character
      // comes *before* the @-sign.
      // URLs are obnoxious.
      //
      // ex:
      // http://a@b@c/ => user:a@b host:c
      // http://a@b?@c => user:a host:c path:/?@c

      // v0.12 TODO(isaacs): This is not quite how Chrome does things.
      // Review our test case against browsers more comprehensively.

      // find the first instance of any hostEndingChars
      var hostEnd = -1;
      for (var i = 0; i < hostEndingChars.length; i++) {
        var hec = rest.indexOf(hostEndingChars[i]);
        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
      }

      // at this point, either we have an explicit point where the
      // auth portion cannot go past, or the last @ char is the decider.
      var auth, atSign;
      if (hostEnd === -1) {
        // atSign can be anywhere.
        atSign = rest.lastIndexOf('@');
      } else {
        // atSign must be in auth portion.
        // http://a@b/c@d => host:b auth:a path:/c@d
        atSign = rest.lastIndexOf('@', hostEnd);
      }

      // Now we have a portion which is definitely the auth.
      // Pull that off.
      if (atSign !== -1) {
        auth = rest.slice(0, atSign);
        rest = rest.slice(atSign + 1);
        this.auth = decodeURIComponent(auth);
      }

      // the host is the remaining to the left of the first non-host char
      hostEnd = -1;
      for (var i = 0; i < nonHostChars.length; i++) {
        var hec = rest.indexOf(nonHostChars[i]);
        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
      }
      // if we still have not hit it, then the entire thing is a host.
      if (hostEnd === -1) hostEnd = rest.length;

      this.host = rest.slice(0, hostEnd);
      rest = rest.slice(hostEnd);

      // pull out port.
      this.parseHost();

      // we've indicated that there is a hostname,
      // so even if it's empty, it has to be present.
      this.hostname = this.hostname || '';

      // if hostname begins with [ and ends with ]
      // assume that it's an IPv6 address.
      var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';

      // validate a little.
      if (!ipv6Hostname) {
        var hostparts = this.hostname.split(/\./);
        for (var i = 0, l = hostparts.length; i < l; i++) {
          var part = hostparts[i];
          if (!part) continue;
          if (!part.match(hostnamePartPattern)) {
            var newpart = '';
            for (var j = 0, k = part.length; j < k; j++) {
              if (part.charCodeAt(j) > 127) {
                // we replace non-ASCII char with a temporary placeholder
                // we need this to make sure size of hostname is not
                // broken by replacing non-ASCII by nothing
                newpart += 'x';
              } else {
                newpart += part[j];
              }
            }
            // we test again with ASCII char only
            if (!newpart.match(hostnamePartPattern)) {
              var validParts = hostparts.slice(0, i);
              var notHost = hostparts.slice(i + 1);
              var bit = part.match(hostnamePartStart);
              if (bit) {
                validParts.push(bit[1]);
                notHost.unshift(bit[2]);
              }
              if (notHost.length) {
                rest = '/' + notHost.join('.') + rest;
              }
              this.hostname = validParts.join('.');
              break;
            }
          }
        }
      }

      if (this.hostname.length > hostnameMaxLen) {
        this.hostname = '';
      } else {
        // hostnames are always lower case.
        this.hostname = this.hostname.toLowerCase();
      }

      if (!ipv6Hostname) {
        // IDNA Support: Returns a puny coded representation of "domain".
        // It only converts the part of the domain name that
        // has non ASCII characters. I.e. it dosent matter if
        // you call it with a domain that already is in ASCII.
        var domainArray = this.hostname.split('.');
        var newOut = [];
        for (var i = 0; i < domainArray.length; ++i) {
          var s = domainArray[i];
          newOut.push(s.match(/[^A-Za-z0-9_-]/) ? 'xn--' + punycode.encode(s) : s);
        }
        this.hostname = newOut.join('.');
      }

      var p = this.port ? ':' + this.port : '';
      var h = this.hostname || '';
      this.host = h + p;
      this.href += this.host;

      // strip [ and ] from the hostname
      // the host field still retains them, though
      if (ipv6Hostname) {
        this.hostname = this.hostname.substr(1, this.hostname.length - 2);
        if (rest[0] !== '/') {
          rest = '/' + rest;
        }
      }
    }

    // now rest is set to the post-host stuff.
    // chop off any delim chars.
    if (!unsafeProtocol[lowerProto]) {

      // First, make 100% sure that any "autoEscape" chars get
      // escaped, even if encodeURIComponent doesn't think they
      // need to be.
      for (var i = 0, l = autoEscape.length; i < l; i++) {
        var ae = autoEscape[i];
        var esc = encodeURIComponent(ae);
        if (esc === ae) {
          esc = escape(ae);
        }
        rest = rest.split(ae).join(esc);
      }
    }

    // chop off from the tail first.
    var hash = rest.indexOf('#');
    if (hash !== -1) {
      // got a fragment string.
      this.hash = rest.substr(hash);
      rest = rest.slice(0, hash);
    }
    var qm = rest.indexOf('?');
    if (qm !== -1) {
      this.search = rest.substr(qm);
      this.query = rest.substr(qm + 1);
      if (parseQueryString) {
        this.query = querystring.parse(this.query);
      }
      rest = rest.slice(0, qm);
    } else if (parseQueryString) {
      // no query string, but parseQueryString still requested
      this.search = '';
      this.query = {};
    }
    if (rest) this.pathname = rest;
    if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
      this.pathname = '/';
    }

    //to support http.request
    if (this.pathname || this.search) {
      var p = this.pathname || '';
      var s = this.search || '';
      this.path = p + s;
    }

    // finally, reconstruct the href based on what has been validated.
    this.href = this.format();
    return this;
  };

  // format a parsed object into a url string
  function urlFormat(obj) {
    // ensure it's an object, and not a string url.
    // If it's an obj, this is a no-op.
    // this way, you can call url_format() on strings
    // to clean up potentially wonky urls.
    if (isString(obj)) obj = urlParse(obj);
    if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
    return obj.format();
  }

  Url.prototype.format = function () {
    var auth = this.auth || '';
    if (auth) {
      auth = encodeURIComponent(auth);
      auth = auth.replace(/%3A/i, ':');
      auth += '@';
    }

    var protocol = this.protocol || '',
        pathname = this.pathname || '',
        hash = this.hash || '',
        host = false,
        query = '';

    if (this.host) {
      host = auth + this.host;
    } else if (this.hostname) {
      host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');
      if (this.port) {
        host += ':' + this.port;
      }
    }

    if (this.query && isObject(this.query) && Object.keys(this.query).length) {
      query = querystring.stringify(this.query);
    }

    var search = this.search || query && '?' + query || '';

    if (protocol && protocol.substr(-1) !== ':') protocol += ':';

    // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
    // unless they had them to begin with.
    if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
      host = '//' + (host || '');
      if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
    } else if (!host) {
      host = '';
    }

    if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
    if (search && search.charAt(0) !== '?') search = '?' + search;

    pathname = pathname.replace(/[?#]/g, function (match) {
      return encodeURIComponent(match);
    });
    search = search.replace('#', '%23');

    return protocol + host + pathname + search + hash;
  };

  function urlResolve(source, relative) {
    return urlParse(source, false, true).resolve(relative);
  }

  Url.prototype.resolve = function (relative) {
    return this.resolveObject(urlParse(relative, false, true)).format();
  };

  function urlResolveObject(source, relative) {
    if (!source) return relative;
    return urlParse(source, false, true).resolveObject(relative);
  }

  Url.prototype.resolveObject = function (relative) {
    if (isString(relative)) {
      var rel = new Url();
      rel.parse(relative, false, true);
      relative = rel;
    }

    var result = new Url();
    Object.keys(this).forEach(function (k) {
      result[k] = this[k];
    }, this);

    // hash is always overridden, no matter what.
    // even href="" will remove it.
    result.hash = relative.hash;

    // if the relative url is empty, then there's nothing left to do here.
    if (relative.href === '') {
      result.href = result.format();
      return result;
    }

    // hrefs like //foo/bar always cut to the protocol.
    if (relative.slashes && !relative.protocol) {
      // take everything except the protocol from relative
      Object.keys(relative).forEach(function (k) {
        if (k !== 'protocol') result[k] = relative[k];
      });

      //urlParse appends trailing / to urls like http://www.example.com
      if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
        result.path = result.pathname = '/';
      }

      result.href = result.format();
      return result;
    }

    if (relative.protocol && relative.protocol !== result.protocol) {
      // if it's a known url protocol, then changing
      // the protocol does weird things
      // first, if it's not file:, then we MUST have a host,
      // and if there was a path
      // to begin with, then we MUST have a path.
      // if it is file:, then the host is dropped,
      // because that's known to be hostless.
      // anything else is assumed to be absolute.
      if (!slashedProtocol[relative.protocol]) {
        Object.keys(relative).forEach(function (k) {
          result[k] = relative[k];
        });
        result.href = result.format();
        return result;
      }

      result.protocol = relative.protocol;
      if (!relative.host && !hostlessProtocol[relative.protocol]) {
        var relPath = (relative.pathname || '').split('/');
        while (relPath.length && !(relative.host = relPath.shift()));
        if (!relative.host) relative.host = '';
        if (!relative.hostname) relative.hostname = '';
        if (relPath[0] !== '') relPath.unshift('');
        if (relPath.length < 2) relPath.unshift('');
        result.pathname = relPath.join('/');
      } else {
        result.pathname = relative.pathname;
      }
      result.search = relative.search;
      result.query = relative.query;
      result.host = relative.host || '';
      result.auth = relative.auth;
      result.hostname = relative.hostname || relative.host;
      result.port = relative.port;
      // to support http.request
      if (result.pathname || result.search) {
        var p = result.pathname || '';
        var s = result.search || '';
        result.path = p + s;
      }
      result.slashes = result.slashes || relative.slashes;
      result.href = result.format();
      return result;
    }

    var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',
        isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',
        mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname,
        removeAllDots = mustEndAbs,
        srcPath = result.pathname && result.pathname.split('/') || [],
        relPath = relative.pathname && relative.pathname.split('/') || [],
        psychotic = result.protocol && !slashedProtocol[result.protocol];

    // if the url is a non-slashed url, then relative
    // links like ../.. should be able
    // to crawl up to the hostname, as well.  This is strange.
    // result.protocol has already been set by now.
    // Later on, put the first path part into the host field.
    if (psychotic) {
      result.hostname = '';
      result.port = null;
      if (result.host) {
        if (srcPath[0] === '') srcPath[0] = result.host;else srcPath.unshift(result.host);
      }
      result.host = '';
      if (relative.protocol) {
        relative.hostname = null;
        relative.port = null;
        if (relative.host) {
          if (relPath[0] === '') relPath[0] = relative.host;else relPath.unshift(relative.host);
        }
        relative.host = null;
      }
      mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
    }

    if (isRelAbs) {
      // it's absolute.
      result.host = relative.host || relative.host === '' ? relative.host : result.host;
      result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;
      result.search = relative.search;
      result.query = relative.query;
      srcPath = relPath;
      // fall through to the dot-handling below.
    } else if (relPath.length) {
      // it's relative
      // throw away the existing file, and take the new path instead.
      if (!srcPath) srcPath = [];
      srcPath.pop();
      srcPath = srcPath.concat(relPath);
      result.search = relative.search;
      result.query = relative.query;
    } else if (!isNullOrUndefined(relative.search)) {
      // just pull out the search.
      // like href='?foo'.
      // Put this after the other two cases because it simplifies the booleans
      if (psychotic) {
        result.hostname = result.host = srcPath.shift();
        //occationaly the auth can get stuck only in host
        //this especialy happens in cases like
        //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
        var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
        if (authInHost) {
          result.auth = authInHost.shift();
          result.host = result.hostname = authInHost.shift();
        }
      }
      result.search = relative.search;
      result.query = relative.query;
      //to support http.request
      if (!isNull(result.pathname) || !isNull(result.search)) {
        result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
      }
      result.href = result.format();
      return result;
    }

    if (!srcPath.length) {
      // no path at all.  easy.
      // we've already handled the other stuff above.
      result.pathname = null;
      //to support http.request
      if (result.search) {
        result.path = '/' + result.search;
      } else {
        result.path = null;
      }
      result.href = result.format();
      return result;
    }

    // if a url ENDs in . or .., then it must get a trailing slash.
    // however, if it ends in anything else non-slashy,
    // then it must NOT get a trailing slash.
    var last = srcPath.slice(-1)[0];
    var hasTrailingSlash = (result.host || relative.host) && (last === '.' || last === '..') || last === '';

    // strip single dots, resolve double dots to parent dir
    // if the path tries to go above the root, `up` ends up > 0
    var up = 0;
    for (var i = srcPath.length; i >= 0; i--) {
      last = srcPath[i];
      if (last == '.') {
        srcPath.splice(i, 1);
      } else if (last === '..') {
        srcPath.splice(i, 1);
        up++;
      } else if (up) {
        srcPath.splice(i, 1);
        up--;
      }
    }

    // if the path is allowed to go above the root, restore leading ..s
    if (!mustEndAbs && !removeAllDots) {
      for (; up--; up) {
        srcPath.unshift('..');
      }
    }

    if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
      srcPath.unshift('');
    }

    if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {
      srcPath.push('');
    }

    var isAbsolute = srcPath[0] === '' || srcPath[0] && srcPath[0].charAt(0) === '/';

    // put the host back
    if (psychotic) {
      result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';
      //occationaly the auth can get stuck only in host
      //this especialy happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }

    mustEndAbs = mustEndAbs || result.host && srcPath.length;

    if (mustEndAbs && !isAbsolute) {
      srcPath.unshift('');
    }

    if (!srcPath.length) {
      result.pathname = null;
      result.path = null;
    } else {
      result.pathname = srcPath.join('/');
    }

    //to support request.http
    if (!isNull(result.pathname) || !isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
    }
    result.auth = relative.auth || result.auth;
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  };

  Url.prototype.parseHost = function () {
    var host = this.host;
    var port = portPattern.exec(host);
    if (port) {
      port = port[0];
      if (port !== ':') {
        this.port = port.substr(1);
      }
      host = host.substr(0, host.length - port.length);
    }
    if (host) this.hostname = host;
  };

  function isString(arg) {
    return typeof arg === "string";
  }

  function isObject(arg) {
    return typeof arg === 'object' && arg !== null;
  }

  function isNull(arg) {
    return arg === null;
  }
  function isNullOrUndefined(arg) {
    return arg == null;
  }
  return module.exports;
});
$__System.registerDynamic("2ac", ["2ab"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("2ab");
  return module.exports;
});
$__System.registerDynamic('2ad', ['2ac'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  module.exports = $__System._nodeRequire ? $__System._nodeRequire('url') : $__require('2ac');
  return module.exports;
});
$__System.registerDynamic("57", ["2ad"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("2ad");
  return module.exports;
});
$__System.registerDynamic('2ae', ['57'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var url = $__require('57');
  var parse = url.parse;
  var Url = url.Url;
  var simplePathRegExp = /^(\/\/?(?!\/)[^\?#\s]*)(\?[^#\s]*)?$/;
  module.exports = parseurl;
  module.exports.original = originalurl;
  function parseurl(req) {
    var url = req.url;
    if (url === undefined) {
      return undefined;
    }
    var parsed = req._parsedUrl;
    if (fresh(url, parsed)) {
      return parsed;
    }
    parsed = fastparse(url);
    parsed._raw = url;
    return req._parsedUrl = parsed;
  }
  ;
  function originalurl(req) {
    var url = req.originalUrl;
    if (typeof url !== 'string') {
      return parseurl(req);
    }
    var parsed = req._parsedOriginalUrl;
    if (fresh(url, parsed)) {
      return parsed;
    }
    parsed = fastparse(url);
    parsed._raw = url;
    return req._parsedOriginalUrl = parsed;
  }
  ;
  function fastparse(str) {
    var simplePath = typeof str === 'string' && simplePathRegExp.exec(str);
    if (simplePath) {
      var pathname = simplePath[1];
      var search = simplePath[2] || null;
      var url = Url !== undefined ? new Url() : {};
      url.path = str;
      url.href = str;
      url.pathname = pathname;
      url.search = search;
      url.query = search && search.substr(1);
      return url;
    }
    return parse(str);
  }
  function fresh(url, parsedUrl) {
    return typeof parsedUrl === 'object' && parsedUrl !== null && (Url === undefined || parsedUrl instanceof Url) && parsedUrl._raw === url;
  }
  return module.exports;
});
$__System.registerDynamic("19", ["2ae"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("2ae");
  return module.exports;
});
$__System.registerDynamic('2af', ['8', '55', '10', '11', 'f', '19', '13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var debug = $__require('8')('connect:dispatcher');
    var EventEmitter = $__require('55').EventEmitter;
    var finalhandler = $__require('10');
    var http = $__require('11');
    var merge = $__require('f');
    var parseUrl = $__require('19');
    module.exports = createServer;
    var env = 'production' || 'development';
    var proto = {};
    var defer = typeof setImmediate === 'function' ? setImmediate : function (fn) {
      process.nextTick(fn.bind.apply(fn, arguments));
    };
    function createServer() {
      function app(req, res, next) {
        app.handle(req, res, next);
      }
      merge(app, proto);
      merge(app, EventEmitter.prototype);
      app.route = '/';
      app.stack = [];
      return app;
    }
    proto.use = function use(route, fn) {
      var handle = fn;
      var path = route;
      if (typeof route !== 'string') {
        handle = route;
        path = '/';
      }
      if (typeof handle.handle === 'function') {
        var server = handle;
        server.route = path;
        handle = function (req, res, next) {
          server.handle(req, res, next);
        };
      }
      if (handle instanceof http.Server) {
        handle = handle.listeners('request')[0];
      }
      if (path[path.length - 1] === '/') {
        path = path.slice(0, -1);
      }
      debug('use %s %s', path || '/', handle.name || 'anonymous');
      this.stack.push({
        route: path,
        handle: handle
      });
      return this;
    };
    proto.handle = function handle(req, res, out) {
      var index = 0;
      var protohost = getProtohost(req.url) || '';
      var removed = '';
      var slashAdded = false;
      var stack = this.stack;
      var done = out || finalhandler(req, res, {
        env: env,
        onerror: logerror
      });
      req.originalUrl = req.originalUrl || req.url;
      function next(err) {
        if (slashAdded) {
          req.url = req.url.substr(1);
          slashAdded = false;
        }
        if (removed.length !== 0) {
          req.url = protohost + removed + req.url.substr(protohost.length);
          removed = '';
        }
        var layer = stack[index++];
        if (!layer) {
          defer(done, err);
          return;
        }
        var path = parseUrl(req).pathname || '/';
        var route = layer.route;
        if (path.toLowerCase().substr(0, route.length) !== route.toLowerCase()) {
          return next(err);
        }
        var c = path[route.length];
        if (c !== undefined && '/' !== c && '.' !== c) {
          return next(err);
        }
        if (route.length !== 0 && route !== '/') {
          removed = route;
          req.url = protohost + req.url.substr(protohost.length + removed.length);
          if (!protohost && req.url[0] !== '/') {
            req.url = '/' + req.url;
            slashAdded = true;
          }
        }
        call(layer.handle, route, err, req, res, next);
      }
      next();
    };
    proto.listen = function listen() {
      var server = http.createServer(this);
      return server.listen.apply(server, arguments);
    };
    function call(handle, route, err, req, res, next) {
      var arity = handle.length;
      var error = err;
      var hasError = Boolean(err);
      debug('%s %s : %s', handle.name || '<anonymous>', route, req.originalUrl);
      try {
        if (hasError && arity === 4) {
          handle(err, req, res, next);
          return;
        } else if (!hasError && arity < 4) {
          handle(req, res, next);
          return;
        }
      } catch (e) {
        error = e;
      }
      next(error);
    }
    function logerror(err) {
      if (env !== 'test') console.error(err.stack || err.toString());
    }
    function getProtohost(url) {
      if (url.length === 0 || url[0] === '/') {
        return undefined;
      }
      var searchIndex = url.indexOf('?');
      var pathLength = searchIndex !== -1 ? searchIndex : url.length;
      var fqdnIndex = url.substr(0, pathLength).indexOf('://');
      return fqdnIndex !== -1 ? url.substr(0, url.indexOf('/', 3 + fqdnIndex)) : undefined;
    }
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic("2b0", ["2af"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("2af");
  return module.exports;
});
$__System.registerDynamic("2b1", [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = { "defaultMiddleware": ["dnsPrefetchControl", "frameguard", "hidePoweredBy", "hsts", "ieNoOpen", "noSniff", "xssFilter"] };
  return module.exports;
});
$__System.registerDynamic('2b2', [], true, function ($__require, exports, module) {
    var define,
        global = this || self,
        GLOBAL = global;
    /* */
    module.exports = function (obj) {
        if (typeof obj === 'string') return camelCase(obj);
        return walk(obj);
    };

    function walk(obj) {
        if (!obj || typeof obj !== 'object') return obj;
        if (isDate(obj) || isRegex(obj)) return obj;
        if (isArray(obj)) return map(obj, walk);
        return reduce(objectKeys(obj), function (acc, key) {
            var camel = camelCase(key);
            acc[camel] = walk(obj[key]);
            return acc;
        }, {});
    }

    function camelCase(str) {
        return str.replace(/[_.-](\w|$)/g, function (_, x) {
            return x.toUpperCase();
        });
    }

    var isArray = Array.isArray || function (obj) {
        return Object.prototype.toString.call(obj) === '[object Array]';
    };

    var isDate = function (obj) {
        return Object.prototype.toString.call(obj) === '[object Date]';
    };

    var isRegex = function (obj) {
        return Object.prototype.toString.call(obj) === '[object RegExp]';
    };

    var has = Object.prototype.hasOwnProperty;
    var objectKeys = Object.keys || function (obj) {
        var keys = [];
        for (var key in obj) {
            if (has.call(obj, key)) keys.push(key);
        }
        return keys;
    };

    function map(xs, f) {
        if (xs.map) return xs.map(f);
        var res = [];
        for (var i = 0; i < xs.length; i++) {
            res.push(f(xs[i], i));
        }
        return res;
    }

    function reduce(xs, f, acc) {
        if (xs.reduce) return xs.reduce(f, acc);
        for (var i = 0; i < xs.length; i++) {
            acc = f(acc, xs[i], i);
        }
        return acc;
    }
    return module.exports;
});
$__System.registerDynamic("2b3", ["2b2"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("2b2");
  return module.exports;
});
$__System.registerDynamic('2b4', [], true, function ($__require, exports, module) {
  /*!
   * dashify <https://github.com/jonschlinkert/dashify>
   *
   * Copyright (c) 2015 Jon Schlinkert.
   * Licensed under the MIT license.
   */

  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = function dashify(str) {
    if (typeof str !== 'string') {
      throw new TypeError('expected a string');
    }
    str = str.replace(/([a-z])([A-Z])/g, '$1-$2');
    str = str.replace(/[ \t\W]/g, '-');
    str = str.replace(/^-+|-+$/g, '');
    return str.toLowerCase();
  };
  return module.exports;
});
$__System.registerDynamic("2b5", ["2b4"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("2b4");
  return module.exports;
});
$__System.registerDynamic('2b6', ['2b5'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var dashify = $__require('2b5');

  module.exports = function (options) {
    var directives = options.directives;

    var keysSeen = {};

    return Object.keys(directives).reduce(function (result, originalKey) {
      var directive = dashify(originalKey);

      if (keysSeen[directive]) {
        throw new Error(originalKey + ' is specified more than once');
      }
      keysSeen[directive] = true;

      var value = directives[originalKey];
      if (Array.isArray(value)) {
        value = value.join(' ');
      } else if (value === true) {
        value = '';
      }

      if (value) {
        return result.concat(directive + ' ' + value);
      } else {
        return result.concat(directive);
      }
    }, []).join('; ');
  };
  return module.exports;
});
$__System.registerDynamic("2b7", ["2b6"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("2b6");
  return module.exports;
});
$__System.registerDynamic('2b8', [], true, function ($__require, exports, module) {
  /* */
  "format cjs";
  /*!
   * Platform.js v1.3.1 <http://mths.be/platform>
   * Copyright 2014-2016 Benjamin Tan <https://d10.github.io/>
   * Copyright 2011-2013 John-David Dalton <http://allyoucanleet.com/>
   * Available under MIT license <http://mths.be/mit>
   */

  var define,
      global = this || self,
      GLOBAL = global;
  ;(function () {
    'use strict';

    /** Used to determine if values are of the language type `Object` */

    var objectTypes = {
      'function': true,
      'object': true
    };

    /** Used as a reference to the global object */
    var root = objectTypes[typeof window] && window || this;

    /** Backup possible global object */
    var oldRoot = root;

    /** Detect free variable `exports` */
    var freeExports = objectTypes[typeof exports] && exports;

    /** Detect free variable `module` */
    var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

    /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
    var freeGlobal = freeExports && freeModule && typeof global == 'object' && global;
    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {
      root = freeGlobal;
    }

    /**
     * Used as the maximum length of an array-like object.
     * See the [ES6 spec](http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength)
     * for more details.
     */
    var maxSafeInteger = Math.pow(2, 53) - 1;

    /** Opera regexp */
    var reOpera = /\bOpera/;

    /** Possible global object */
    var thisBinding = this;

    /** Used for native method references */
    var objectProto = Object.prototype;

    /** Used to check for own properties of an object */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /** Used to resolve the internal `[[Class]]` of values */
    var toString = objectProto.toString;

    /*--------------------------------------------------------------------------*/

    /**
     * Capitalizes a string value.
     *
     * @private
     * @param {string} string The string to capitalize.
     * @returns {string} The capitalized string.
     */
    function capitalize(string) {
      string = String(string);
      return string.charAt(0).toUpperCase() + string.slice(1);
    }

    /**
     * A utility function to clean up the OS name.
     *
     * @private
     * @param {string} os The OS name to clean up.
     * @param {string} [pattern] A `RegExp` pattern matching the OS name.
     * @param {string} [label] A label for the OS.
     */
    function cleanupOS(os, pattern, label) {
      // platform tokens defined at
      // http://msdn.microsoft.com/en-us/library/ms537503(VS.85).aspx
      // http://web.archive.org/web/20081122053950/http://msdn.microsoft.com/en-us/library/ms537503(VS.85).aspx
      var data = {
        '6.4': '10',
        '6.3': '8.1',
        '6.2': '8',
        '6.1': 'Server 2008 R2 / 7',
        '6.0': 'Server 2008 / Vista',
        '5.2': 'Server 2003 / XP 64-bit',
        '5.1': 'XP',
        '5.01': '2000 SP1',
        '5.0': '2000',
        '4.0': 'NT',
        '4.90': 'ME'
      };
      // detect Windows version from platform tokens
      if (pattern && label && /^Win/i.test(os) && (data = data[(0 /*Opera 9.25 fix*/, /[\d.]+$/.exec(os))])) {
        os = 'Windows ' + data;
      }
      // correct character case and cleanup
      os = String(os);

      if (pattern && label) {
        os = os.replace(RegExp(pattern, 'i'), label);
      }

      os = format(os.replace(/ ce$/i, ' CE').replace(/\bhpw/i, 'web').replace(/\bMacintosh\b/, 'Mac OS').replace(/_PowerPC\b/i, ' OS').replace(/\b(OS X) [^ \d]+/i, '$1').replace(/\bMac (OS X)\b/, '$1').replace(/\/(\d)/, ' $1').replace(/_/g, '.').replace(/(?: BePC|[ .]*fc[ \d.]+)$/i, '').replace(/\bx86\.64\b/gi, 'x86_64').replace(/\b(Windows Phone) OS\b/, '$1').split(' on ')[0]);

      return os;
    }

    /**
     * An iteration utility for arrays and objects.
     *
     * @private
     * @param {Array|Object} object The object to iterate over.
     * @param {Function} callback The function called per iteration.
     */
    function each(object, callback) {
      var index = -1,
          length = object ? object.length : 0;

      if (typeof length == 'number' && length > -1 && length <= maxSafeInteger) {
        while (++index < length) {
          callback(object[index], index, object);
        }
      } else {
        forOwn(object, callback);
      }
    }

    /**
     * Trim and conditionally capitalize string values.
     *
     * @private
     * @param {string} string The string to format.
     * @returns {string} The formatted string.
     */
    function format(string) {
      string = trim(string);
      return (/^(?:webOS|i(?:OS|P))/.test(string) ? string : capitalize(string)
      );
    }

    /**
     * Iterates over an object's own properties, executing the `callback` for each.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} callback The function executed per own property.
     */
    function forOwn(object, callback) {
      for (var key in object) {
        if (hasOwnProperty.call(object, key)) {
          callback(object[key], key, object);
        }
      }
    }

    /**
     * Gets the internal `[[Class]]` of a value.
     *
     * @private
     * @param {*} value The value.
     * @returns {string} The `[[Class]]`.
     */
    function getClassOf(value) {
      return value == null ? capitalize(value) : toString.call(value).slice(8, -1);
    }

    /**
     * Host objects can return type values that are different from their actual
     * data type. The objects we are concerned with usually return non-primitive
     * types of "object", "function", or "unknown".
     *
     * @private
     * @param {*} object The owner of the property.
     * @param {string} property The property to check.
     * @returns {boolean} Returns `true` if the property value is a non-primitive, else `false`.
     */
    function isHostType(object, property) {
      var type = object != null ? typeof object[property] : 'number';
      return !/^(?:boolean|number|string|undefined)$/.test(type) && (type == 'object' ? !!object[property] : true);
    }

    /**
     * Prepares a string for use in a `RegExp` by making hyphens and spaces optional.
     *
     * @private
     * @param {string} string The string to qualify.
     * @returns {string} The qualified string.
     */
    function qualify(string) {
      return String(string).replace(/([ -])(?!$)/g, '$1?');
    }

    /**
     * A bare-bones `Array#reduce` like utility function.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} callback The function called per iteration.
     * @returns {*} The accumulated result.
     */
    function reduce(array, callback) {
      var accumulator = null;
      each(array, function (value, index) {
        accumulator = callback(accumulator, value, index, array);
      });
      return accumulator;
    }

    /**
     * Removes leading and trailing whitespace from a string.
     *
     * @private
     * @param {string} string The string to trim.
     * @returns {string} The trimmed string.
     */
    function trim(string) {
      return String(string).replace(/^ +| +$/g, '');
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a new platform object.
     *
     * @memberOf platform
     * @param {Object|string} [ua=navigator.userAgent] The user agent string or
     *  context object.
     * @returns {Object} A platform object.
     */
    function parse(ua) {

      /** The environment context object */
      var context = root;

      /** Used to flag when a custom context is provided */
      var isCustomContext = ua && typeof ua == 'object' && getClassOf(ua) != 'String';

      // juggle arguments
      if (isCustomContext) {
        context = ua;
        ua = null;
      }

      /** Browser navigator object */
      var nav = context.navigator || {};

      /** Browser user agent string */
      var userAgent = nav.userAgent || '';

      ua || (ua = userAgent);

      /** Used to flag when `thisBinding` is the [ModuleScope] */
      var isModuleScope = isCustomContext || thisBinding == oldRoot;

      /** Used to detect if browser is like Chrome */
      var likeChrome = isCustomContext ? !!nav.likeChrome : /\bChrome\b/.test(ua) && !/internal|\n/i.test(toString.toString());

      /** Internal `[[Class]]` value shortcuts */
      var objectClass = 'Object',
          airRuntimeClass = isCustomContext ? objectClass : 'ScriptBridgingProxyObject',
          enviroClass = isCustomContext ? objectClass : 'Environment',
          javaClass = isCustomContext && context.java ? 'JavaPackage' : getClassOf(context.java),
          phantomClass = isCustomContext ? objectClass : 'RuntimeObject';

      /** Detect Java environment */
      var java = /\bJava/.test(javaClass) && context.java;

      /** Detect Rhino */
      var rhino = java && getClassOf(context.environment) == enviroClass;

      /** A character to represent alpha */
      var alpha = java ? 'a' : '\u03b1';

      /** A character to represent beta */
      var beta = java ? 'b' : '\u03b2';

      /** Browser document object */
      var doc = context.document || {};

      /**
       * Detect Opera browser (Presto-based)
       * http://www.howtocreate.co.uk/operaStuff/operaObject.html
       * http://dev.opera.com/articles/view/opera-mini-web-content-authoring-guidelines/#operamini
       */
      var opera = context.operamini || context.opera;

      /** Opera `[[Class]]` */
      var operaClass = reOpera.test(operaClass = isCustomContext && opera ? opera['[[Class]]'] : getClassOf(opera)) ? operaClass : opera = null;

      /*------------------------------------------------------------------------*/

      /** Temporary variable used over the script's lifetime */
      var data;

      /** The CPU architecture */
      var arch = ua;

      /** Platform description array */
      var description = [];

      /** Platform alpha/beta indicator */
      var prerelease = null;

      /** A flag to indicate that environment features should be used to resolve the platform */
      var useFeatures = ua == userAgent;

      /** The browser/environment version */
      var version = useFeatures && opera && typeof opera.version == 'function' && opera.version();

      /** A flag to indicate if the OS ends with "/ Version" */
      var isSpecialCasedOS;

      /* Detectable layout engines (order is important) */
      var layout = getLayout(['Trident', { 'label': 'WebKit', 'pattern': 'AppleWebKit' }, 'iCab', 'Presto', 'NetFront', 'Tasman', 'KHTML', 'Gecko']);

      /* Detectable browser names (order is important) */
      var name = getName(['Adobe AIR', 'Arora', 'Avant Browser', 'Breach', 'Camino', 'Epiphany', 'Fennec', 'Flock', 'Galeon', 'GreenBrowser', 'iCab', 'Iceweasel', { 'label': 'SRWare Iron', 'pattern': 'Iron' }, 'K-Meleon', 'Konqueror', 'Lunascape', 'Maxthon', 'Midori', 'Nook Browser', 'PhantomJS', 'Raven', 'Rekonq', 'RockMelt', 'SeaMonkey', { 'label': 'Silk', 'pattern': '(?:Cloud9|Silk-Accelerated)' }, 'Sleipnir', 'SlimBrowser', 'Sunrise', 'Swiftfox', 'WebPositive', 'Opera Mini', { 'label': 'Opera Mini', 'pattern': 'OPiOS' }, 'Opera', { 'label': 'Opera', 'pattern': 'OPR' }, 'Chrome', { 'label': 'Chrome Mobile', 'pattern': '(?:CriOS|CrMo)' }, { 'label': 'Firefox', 'pattern': '(?:Firefox|Minefield)' }, { 'label': 'IE', 'pattern': 'IEMobile' }, { 'label': 'IE', 'pattern': 'MSIE' }, 'Safari']);

      /* Detectable products (order is important) */
      var product = getProduct([{ 'label': 'BlackBerry', 'pattern': 'BB10' }, 'BlackBerry', { 'label': 'Galaxy S', 'pattern': 'GT-I9000' }, { 'label': 'Galaxy S2', 'pattern': 'GT-I9100' }, { 'label': 'Galaxy S3', 'pattern': 'GT-I9300' }, { 'label': 'Galaxy S4', 'pattern': 'GT-I9500' }, 'Google TV', 'Lumia', 'iPad', 'iPod', 'iPhone', 'Kindle', { 'label': 'Kindle Fire', 'pattern': '(?:Cloud9|Silk-Accelerated)' }, 'Nook', 'PlayBook', 'PlayStation 4', 'PlayStation 3', 'PlayStation Vita', 'TouchPad', 'Transformer', { 'label': 'Wii U', 'pattern': 'WiiU' }, 'Wii', 'Xbox One', { 'label': 'Xbox 360', 'pattern': 'Xbox' }, 'Xoom']);

      /* Detectable manufacturers */
      var manufacturer = getManufacturer({
        'Apple': { 'iPad': 1, 'iPhone': 1, 'iPod': 1 },
        'Amazon': { 'Kindle': 1, 'Kindle Fire': 1 },
        'Asus': { 'Transformer': 1 },
        'Barnes & Noble': { 'Nook': 1 },
        'BlackBerry': { 'PlayBook': 1 },
        'Google': { 'Google TV': 1 },
        'HP': { 'TouchPad': 1 },
        'HTC': {},
        'LG': {},
        'Microsoft': { 'Xbox': 1, 'Xbox One': 1 },
        'Motorola': { 'Xoom': 1 },
        'Nintendo': { 'Wii U': 1, 'Wii': 1 },
        'Nokia': { 'Lumia': 1 },
        'Samsung': { 'Galaxy S': 1, 'Galaxy S2': 1, 'Galaxy S3': 1, 'Galaxy S4': 1 },
        'Sony': { 'PlayStation 4': 1, 'PlayStation 3': 1, 'PlayStation Vita': 1 }
      });

      /* Detectable OSes (order is important) */
      var os = getOS(['Windows Phone ', 'Android', 'CentOS', 'Debian', 'Fedora', 'FreeBSD', 'Gentoo', 'Haiku', 'Kubuntu', 'Linux Mint', 'Red Hat', 'SuSE', 'Ubuntu', 'Xubuntu', 'Cygwin', 'Symbian OS', 'hpwOS', 'webOS ', 'webOS', 'Tablet OS', 'Linux', 'Mac OS X', 'Macintosh', 'Mac', 'Windows 98;', 'Windows ']);

      /*------------------------------------------------------------------------*/

      /**
       * Picks the layout engine from an array of guesses.
       *
       * @private
       * @param {Array} guesses An array of guesses.
       * @returns {null|string} The detected layout engine.
       */
      function getLayout(guesses) {
        return reduce(guesses, function (result, guess) {
          return result || RegExp('\\b' + (guess.pattern || qualify(guess)) + '\\b', 'i').exec(ua) && (guess.label || guess);
        });
      }

      /**
       * Picks the manufacturer from an array of guesses.
       *
       * @private
       * @param {Array} guesses An object of guesses.
       * @returns {null|string} The detected manufacturer.
       */
      function getManufacturer(guesses) {
        return reduce(guesses, function (result, value, key) {
          // lookup the manufacturer by product or scan the UA for the manufacturer
          return result || (value[product] || value[(0 /*Opera 9.25 fix*/, /^[a-z]+(?: +[a-z]+\b)*/i.exec(product))] || RegExp('\\b' + qualify(key) + '(?:\\b|\\w*\\d)', 'i').exec(ua)) && key;
        });
      }

      /**
       * Picks the browser name from an array of guesses.
       *
       * @private
       * @param {Array} guesses An array of guesses.
       * @returns {null|string} The detected browser name.
       */
      function getName(guesses) {
        return reduce(guesses, function (result, guess) {
          return result || RegExp('\\b' + (guess.pattern || qualify(guess)) + '\\b', 'i').exec(ua) && (guess.label || guess);
        });
      }

      /**
       * Picks the OS name from an array of guesses.
       *
       * @private
       * @param {Array} guesses An array of guesses.
       * @returns {null|string} The detected OS name.
       */
      function getOS(guesses) {
        return reduce(guesses, function (result, guess) {
          var pattern = guess.pattern || qualify(guess);
          if (!result && (result = RegExp('\\b' + pattern + '(?:/[\\d.]+|[ \\w.]*)', 'i').exec(ua))) {
            result = cleanupOS(result, pattern, guess.label || guess);
          }
          return result;
        });
      }

      /**
       * Picks the product name from an array of guesses.
       *
       * @private
       * @param {Array} guesses An array of guesses.
       * @returns {null|string} The detected product name.
       */
      function getProduct(guesses) {
        return reduce(guesses, function (result, guess) {
          var pattern = guess.pattern || qualify(guess);
          if (!result && (result = RegExp('\\b' + pattern + ' *\\d+[.\\w_]*', 'i').exec(ua) || RegExp('\\b' + pattern + '(?:; *(?:[a-z]+[_-])?[a-z]+\\d+|[^ ();-]*)', 'i').exec(ua))) {
            // split by forward slash and append product version if needed
            if ((result = String(guess.label && !RegExp(pattern, 'i').test(guess.label) ? guess.label : result).split('/'))[1] && !/[\d.]+/.test(result[0])) {
              result[0] += ' ' + result[1];
            }
            // correct character case and cleanup
            guess = guess.label || guess;
            result = format(result[0].replace(RegExp(pattern, 'i'), guess).replace(RegExp('; *(?:' + guess + '[_-])?', 'i'), ' ').replace(RegExp('(' + guess + ')[-_.]?(\\w)', 'i'), '$1 $2'));
          }
          return result;
        });
      }

      /**
       * Resolves the version using an array of UA patterns.
       *
       * @private
       * @param {Array} patterns An array of UA patterns.
       * @returns {null|string} The detected version.
       */
      function getVersion(patterns) {
        return reduce(patterns, function (result, pattern) {
          return result || (RegExp(pattern + '(?:-[\\d.]+/|(?: for [\\w-]+)?[ /-])([\\d.]+[^ ();/_-]*)', 'i').exec(ua) || 0)[1] || null;
        });
      }

      /**
       * Returns `platform.description` when the platform object is coerced to a string.
       *
       * @name toString
       * @memberOf platform
       * @returns {string} Returns `platform.description` if available, else an empty string.
       */
      function toStringPlatform() {
        return this.description || '';
      }

      /*------------------------------------------------------------------------*/

      // convert layout to an array so we can add extra details
      layout && (layout = [layout]);

      // detect product names that contain their manufacturer's name
      if (manufacturer && !product) {
        product = getProduct([manufacturer]);
      }
      // clean up Google TV
      if (data = /\bGoogle TV\b/.exec(product)) {
        product = data[0];
      }
      // detect simulators
      if (/\bSimulator\b/i.test(ua)) {
        product = (product ? product + ' ' : '') + 'Simulator';
      }
      // detect Opera Mini 8+ running in Turbo/Uncompressed mode on iOS
      if (name == 'Opera Mini' && /\bOPiOS\b/.test(ua)) {
        description.push('running in Turbo/Uncompressed mode');
      }
      // detect iOS
      if (/^iP/.test(product)) {
        name || (name = 'Safari');
        os = 'iOS' + ((data = / OS ([\d_]+)/i.exec(ua)) ? ' ' + data[1].replace(/_/g, '.') : '');
      }
      // detect Kubuntu
      else if (name == 'Konqueror' && !/buntu/i.test(os)) {
          os = 'Kubuntu';
        }
        // detect Android browsers
        else if (manufacturer && manufacturer != 'Google' && (/Chrome/.test(name) && !/\bMobile Safari\b/i.test(ua) || /\bVita\b/.test(product))) {
            name = 'Android Browser';
            os = /\bAndroid\b/.test(os) ? os : 'Android';
          }
          // detect false positives for Firefox/Safari
          else if (!name || (data = !/\bMinefield\b|\(Android;/i.test(ua) && /\b(?:Firefox|Safari)\b/.exec(name))) {
              // escape the `/` for Firefox 1
              if (name && !product && /[\/,]|^[^(]+?\)/.test(ua.slice(ua.indexOf(data + '/') + 8))) {
                // clear name of false positives
                name = null;
              }
              // reassign a generic name
              if ((data = product || manufacturer || os) && (product || manufacturer || /\b(?:Android|Symbian OS|Tablet OS|webOS)\b/.test(os))) {
                name = /[a-z]+(?: Hat)?/i.exec(/\bAndroid\b/.test(os) ? os : data) + ' Browser';
              }
            }
      // detect Firefox OS
      if ((data = /\((Mobile|Tablet).*?Firefox\b/i.exec(ua)) && data[1]) {
        os = 'Firefox OS';
        if (!product) {
          product = data[1];
        }
      }
      // detect non-Opera versions (order is important)
      if (!version) {
        version = getVersion(['(?:Cloud9|CriOS|CrMo|IEMobile|Iron|Opera ?Mini|OPiOS|OPR|Raven|Silk(?!/[\\d.]+$))', 'Version', qualify(name), '(?:Firefox|Minefield|NetFront)']);
      }
      // detect stubborn layout engines
      if (layout == 'iCab' && parseFloat(version) > 3) {
        layout = ['WebKit'];
      } else if (layout != 'Trident' && (data = /\bOpera\b/.test(name) && (/\bOPR\b/.test(ua) ? 'Blink' : 'Presto') || /\b(?:Midori|Nook|Safari)\b/i.test(ua) && 'WebKit' || !layout && /\bMSIE\b/i.test(ua) && (os == 'Mac OS' ? 'Tasman' : 'Trident'))) {
        layout = [data];
      }
      // detect NetFront on PlayStation
      else if (/\bPlayStation\b(?! Vita\b)/i.test(name) && layout == 'WebKit') {
          layout = ['NetFront'];
        }
      // detect Windows Phone 7 desktop mode
      if (name == 'IE' && (data = (/; *(?:XBLWP|ZuneWP)(\d+)/i.exec(ua) || 0)[1])) {
        name += ' Mobile';
        os = 'Windows Phone ' + (/\+$/.test(data) ? data : data + '.x');
        description.unshift('desktop mode');
      }
      // detect Windows Phone 8+ desktop mode
      else if (/\bWPDesktop\b/i.test(ua)) {
          name = 'IE Mobile';
          os = 'Windows Phone 8+';
          description.unshift('desktop mode');
          version || (version = (/\brv:([\d.]+)/.exec(ua) || 0)[1]);
        }
        // detect IE 11 and above
        else if (name != 'IE' && layout == 'Trident' && (data = /\brv:([\d.]+)/.exec(ua))) {
            if (!/\bWPDesktop\b/i.test(ua)) {
              if (name) {
                description.push('identifying as ' + name + (version ? ' ' + version : ''));
              }
              name = 'IE';
            }
            version = data[1];
          }
          // detect Microsoft Edge
          else if ((name == 'Chrome' || name != 'IE') && (data = /\bEdge\/([\d.]+)/.exec(ua))) {
              name = 'Microsoft Edge';
              version = data[1];
              layout = ['Trident'];
            }
      // leverage environment features
      if (useFeatures) {
        // detect server-side environments
        // Rhino has a global function while others have a global object
        if (isHostType(context, 'global')) {
          if (java) {
            data = java.lang.System;
            arch = data.getProperty('os.arch');
            os = os || data.getProperty('os.name') + ' ' + data.getProperty('os.version');
          }
          if (isModuleScope && isHostType(context, 'system') && (data = [context.system])[0]) {
            os || (os = data[0].os || null);
            try {
              data[1] = context.require('ringo/engine').version;
              version = data[1].join('.');
              name = 'RingoJS';
            } catch (e) {
              if (data[0].global.system == context.system) {
                name = 'Narwhal';
              }
            }
          } else if (typeof context.process == 'object' && (data = context.process)) {
            name = 'Node.js';
            arch = data.arch;
            os = data.platform;
            version = /[\d.]+/.exec(data.version)[0];
          } else if (rhino) {
            name = 'Rhino';
          }
        }
        // detect Adobe AIR
        else if (getClassOf(data = context.runtime) == airRuntimeClass) {
            name = 'Adobe AIR';
            os = data.flash.system.Capabilities.os;
          }
          // detect PhantomJS
          else if (getClassOf(data = context.phantom) == phantomClass) {
              name = 'PhantomJS';
              version = (data = data.version || null) && data.major + '.' + data.minor + '.' + data.patch;
            }
            // detect IE compatibility modes
            else if (typeof doc.documentMode == 'number' && (data = /\bTrident\/(\d+)/i.exec(ua))) {
                // we're in compatibility mode when the Trident version + 4 doesn't
                // equal the document mode
                version = [version, doc.documentMode];
                if ((data = +data[1] + 4) != version[1]) {
                  description.push('IE ' + version[1] + ' mode');
                  layout && (layout[1] = '');
                  version[1] = data;
                }
                version = name == 'IE' ? String(version[1].toFixed(1)) : version[0];
              }
        os = os && format(os);
      }
      // detect prerelease phases
      if (version && (data = /(?:[ab]|dp|pre|[ab]\d+pre)(?:\d+\+?)?$/i.exec(version) || /(?:alpha|beta)(?: ?\d)?/i.exec(ua + ';' + (useFeatures && nav.appMinorVersion)) || /\bMinefield\b/i.test(ua) && 'a')) {
        prerelease = /b/i.test(data) ? 'beta' : 'alpha';
        version = version.replace(RegExp(data + '\\+?$'), '') + (prerelease == 'beta' ? beta : alpha) + (/\d+\+?/.exec(data) || '');
      }
      // detect Firefox Mobile
      if (name == 'Fennec' || name == 'Firefox' && /\b(?:Android|Firefox OS)\b/.test(os)) {
        name = 'Firefox Mobile';
      }
      // obscure Maxthon's unreliable version
      else if (name == 'Maxthon' && version) {
          version = version.replace(/\.[\d.]+/, '.x');
        }
        // detect Silk desktop/accelerated modes
        else if (name == 'Silk') {
            if (!/\bMobi/i.test(ua)) {
              os = 'Android';
              description.unshift('desktop mode');
            }
            if (/Accelerated *= *true/i.test(ua)) {
              description.unshift('accelerated');
            }
          }
          // detect Xbox 360 and Xbox One
          else if (/\bXbox\b/i.test(product)) {
              os = null;
              if (product == 'Xbox 360' && /\bIEMobile\b/.test(ua)) {
                description.unshift('mobile mode');
              }
            }
            // add mobile postfix
            else if ((/^(?:Chrome|IE|Opera)$/.test(name) || name && !product && !/Browser|Mobi/.test(name)) && (os == 'Windows CE' || /Mobi/i.test(ua))) {
                name += ' Mobile';
              }
              // detect IE platform preview
              else if (name == 'IE' && useFeatures && context.external === null) {
                  description.unshift('platform preview');
                }
                // detect BlackBerry OS version
                // http://docs.blackberry.com/en/developers/deliverables/18169/HTTP_headers_sent_by_BB_Browser_1234911_11.jsp
                else if ((/\bBlackBerry\b/.test(product) || /\bBB10\b/.test(ua)) && (data = (RegExp(product.replace(/ +/g, ' *') + '/([.\\d]+)', 'i').exec(ua) || 0)[1] || version)) {
                    data = [data, /BB10/.test(ua)];
                    os = (data[1] ? (product = null, manufacturer = 'BlackBerry') : 'Device Software') + ' ' + data[0];
                    version = null;
                  }
                  // detect Opera identifying/masking itself as another browser
                  // http://www.opera.com/support/kb/view/843/
                  else if (this != forOwn && product != 'Wii' && (useFeatures && opera || /Opera/.test(name) && /\b(?:MSIE|Firefox)\b/i.test(ua) || name == 'Firefox' && /\bOS X (?:\d+\.){2,}/.test(os) || name == 'IE' && (os && !/^Win/.test(os) && version > 5.5 || /\bWindows XP\b/.test(os) && version > 8 || version == 8 && !/\bTrident\b/.test(ua))) && !reOpera.test(data = parse.call(forOwn, ua.replace(reOpera, '') + ';')) && data.name) {

                      // when "indentifying", the UA contains both Opera and the other browser's name
                      data = 'ing as ' + data.name + ((data = data.version) ? ' ' + data : '');
                      if (reOpera.test(name)) {
                        if (/\bIE\b/.test(data) && os == 'Mac OS') {
                          os = null;
                        }
                        data = 'identify' + data;
                      }
                      // when "masking", the UA contains only the other browser's name
                      else {
                          data = 'mask' + data;
                          if (operaClass) {
                            name = format(operaClass.replace(/([a-z])([A-Z])/g, '$1 $2'));
                          } else {
                            name = 'Opera';
                          }
                          if (/\bIE\b/.test(data)) {
                            os = null;
                          }
                          if (!useFeatures) {
                            version = null;
                          }
                        }
                      layout = ['Presto'];
                      description.push(data);
                    }
      // detect WebKit Nightly and approximate Chrome/Safari versions
      if (data = (/\bAppleWebKit\/([\d.]+\+?)/i.exec(ua) || 0)[1]) {
        // correct build for numeric comparison
        // (e.g. "532.5" becomes "532.05")
        data = [parseFloat(data.replace(/\.(\d)$/, '.0$1')), data];
        // nightly builds are postfixed with a `+`
        if (name == 'Safari' && data[1].slice(-1) == '+') {
          name = 'WebKit Nightly';
          prerelease = 'alpha';
          version = data[1].slice(0, -1);
        }
        // clear incorrect browser versions
        else if (version == data[1] || version == (data[2] = (/\bSafari\/([\d.]+\+?)/i.exec(ua) || 0)[1])) {
            version = null;
          }
        // use the full Chrome version when available
        data[1] = (/\bChrome\/([\d.]+)/i.exec(ua) || 0)[1];
        // detect Blink layout engine
        if (data[0] == 537.36 && data[2] == 537.36 && parseFloat(data[1]) >= 28 && name != 'IE' && name != 'Microsoft Edge') {
          layout = ['Blink'];
        }
        // detect JavaScriptCore
        // http://stackoverflow.com/questions/6768474/how-can-i-detect-which-javascript-engine-v8-or-jsc-is-used-at-runtime-in-androi
        if (!useFeatures || !likeChrome && !data[1]) {
          layout && (layout[1] = 'like Safari');
          data = (data = data[0], data < 400 ? 1 : data < 500 ? 2 : data < 526 ? 3 : data < 533 ? 4 : data < 534 ? '4+' : data < 535 ? 5 : data < 537 ? 6 : data < 538 ? 7 : data < 601 ? 8 : '8');
        } else {
          layout && (layout[1] = 'like Chrome');
          data = data[1] || (data = data[0], data < 530 ? 1 : data < 532 ? 2 : data < 532.05 ? 3 : data < 533 ? 4 : data < 534.03 ? 5 : data < 534.07 ? 6 : data < 534.10 ? 7 : data < 534.13 ? 8 : data < 534.16 ? 9 : data < 534.24 ? 10 : data < 534.30 ? 11 : data < 535.01 ? 12 : data < 535.02 ? '13+' : data < 535.07 ? 15 : data < 535.11 ? 16 : data < 535.19 ? 17 : data < 536.05 ? 18 : data < 536.10 ? 19 : data < 537.01 ? 20 : data < 537.11 ? '21+' : data < 537.13 ? 23 : data < 537.18 ? 24 : data < 537.24 ? 25 : data < 537.36 ? 26 : layout != 'Blink' ? '27' : '28');
        }
        // add the postfix of ".x" or "+" for approximate versions
        layout && (layout[1] += ' ' + (data += typeof data == 'number' ? '.x' : /[.+]/.test(data) ? '' : '+'));
        // obscure version for some Safari 1-2 releases
        if (name == 'Safari' && (!version || parseInt(version) > 45)) {
          version = data;
        }
      }
      // detect Opera desktop modes
      if (name == 'Opera' && (data = /\bzbov|zvav$/.exec(os))) {
        name += ' ';
        description.unshift('desktop mode');
        if (data == 'zvav') {
          name += 'Mini';
          version = null;
        } else {
          name += 'Mobile';
        }
        os = os.replace(RegExp(' *' + data + '$'), '');
      }
      // detect Chrome desktop mode
      else if (name == 'Safari' && /\bChrome\b/.exec(layout && layout[1])) {
          description.unshift('desktop mode');
          name = 'Chrome Mobile';
          version = null;

          if (/\bOS X\b/.test(os)) {
            manufacturer = 'Apple';
            os = 'iOS 4.3+';
          } else {
            os = null;
          }
        }
      // strip incorrect OS versions
      if (version && version.indexOf(data = /[\d.]+$/.exec(os)) == 0 && ua.indexOf('/' + data + '-') > -1) {
        os = trim(os.replace(data, ''));
      }
      // add layout engine
      if (layout && !/\b(?:Avant|Nook)\b/.test(name) && (/Browser|Lunascape|Maxthon/.test(name) || /^(?:Adobe|Arora|Breach|Midori|Opera|Phantom|Rekonq|Rock|Sleipnir|Web)/.test(name) && layout[1])) {
        // don't add layout details to description if they are falsey
        (data = layout[layout.length - 1]) && description.push(data);
      }
      // combine contextual information
      if (description.length) {
        description = ['(' + description.join('; ') + ')'];
      }
      // append manufacturer
      if (manufacturer && product && product.indexOf(manufacturer) < 0) {
        description.push('on ' + manufacturer);
      }
      // append product
      if (product) {
        description.push((/^on /.test(description[description.length - 1]) ? '' : 'on ') + product);
      }
      // parse OS into an object
      if (os) {
        data = / ([\d.+]+)$/.exec(os);
        isSpecialCasedOS = data && os.charAt(os.length - data[0].length - 1) == '/';
        os = {
          'architecture': 32,
          'family': data && !isSpecialCasedOS ? os.replace(data[0], '') : os,
          'version': data ? data[1] : null,
          'toString': function () {
            var version = this.version;
            return this.family + (version && !isSpecialCasedOS ? ' ' + version : '') + (this.architecture == 64 ? ' 64-bit' : '');
          }
        };
      }
      // add browser/OS architecture
      if ((data = /\b(?:AMD|IA|Win|WOW|x86_|x)64\b/i.exec(arch)) && !/\bi686\b/i.test(arch)) {
        if (os) {
          os.architecture = 64;
          os.family = os.family.replace(RegExp(' *' + data), '');
        }
        if (name && (/\bWOW64\b/i.test(ua) || useFeatures && /\w(?:86|32)$/.test(nav.cpuClass || nav.platform) && !/\bWin64; x64\b/i.test(ua))) {
          description.unshift('32-bit');
        }
      }

      ua || (ua = null);

      /*------------------------------------------------------------------------*/

      /**
       * The platform object.
       *
       * @name platform
       * @type Object
       */
      var platform = {};

      /**
       * The platform description.
       *
       * @memberOf platform
       * @type string|null
       */
      platform.description = ua;

      /**
       * The name of the browser's layout engine.
       *
       * @memberOf platform
       * @type string|null
       */
      platform.layout = layout && layout[0];

      /**
       * The name of the product's manufacturer.
       *
       * @memberOf platform
       * @type string|null
       */
      platform.manufacturer = manufacturer;

      /**
       * The name of the browser/environment.
       *
       * @memberOf platform
       * @type string|null
       */
      platform.name = name;

      /**
       * The alpha/beta release indicator.
       *
       * @memberOf platform
       * @type string|null
       */
      platform.prerelease = prerelease;

      /**
       * The name of the product hosting the browser.
       *
       * @memberOf platform
       * @type string|null
       */
      platform.product = product;

      /**
       * The browser's user agent string.
       *
       * @memberOf platform
       * @type string|null
       */
      platform.ua = ua;

      /**
       * The browser/environment version.
       *
       * @memberOf platform
       * @type string|null
       */
      platform.version = name && version;

      /**
       * The name of the operating system.
       *
       * @memberOf platform
       * @type Object
       */
      platform.os = os || {

        /**
         * The CPU architecture the OS is built for.
         *
         * @memberOf platform.os
         * @type number|null
         */
        'architecture': null,

        /**
         * The family of the OS.
         *
         * Common values include:
         * "Windows", "Windows Server 2008 R2 / 7", "Windows Server 2008 / Vista",
         * "Windows XP", "OS X", "Ubuntu", "Debian", "Fedora", "Red Hat", "SuSE",
         * "Android", "iOS" and "Windows Phone"
         *
         * @memberOf platform.os
         * @type string|null
         */
        'family': null,

        /**
         * The version of the OS.
         *
         * @memberOf platform.os
         * @type string|null
         */
        'version': null,

        /**
         * Returns the OS string.
         *
         * @memberOf platform.os
         * @returns {string} The OS string.
         */
        'toString': function () {
          return 'null';
        }
      };

      platform.parse = parse;
      platform.toString = toStringPlatform;

      if (platform.version) {
        description.unshift(version);
      }
      if (platform.name) {
        description.unshift(name);
      }
      if (os && name && !(os == String(os).split(' ')[0] && (os == name.split(' ')[0] || product))) {
        description.push(product ? '(' + os + ')' : 'on ' + os);
      }
      if (description.length) {
        platform.description = description.join(' ');
      }
      return platform;
    }

    /*--------------------------------------------------------------------------*/

    // export platform
    // some AMD build optimizers, like r.js, check for condition patterns like the following:
    if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
      // define as an anonymous module so, through path mapping, it can be aliased
      define(function () {
        return parse();
      });
    }
    // check for `exports` after `define` in case a build optimizer adds an `exports` object
    else if (freeExports && freeModule) {
        // in Narwhal, Node.js, Rhino -require, or RingoJS
        forOwn(parse(), function (value, key) {
          freeExports[key] = value;
        });
      }
      // in a browser or Rhino
      else {
          root.platform = parse();
        }
  }).call(this);
  return module.exports;
});
$__System.registerDynamic("2b9", ["2b8"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("2b8");
  return module.exports;
});
$__System.registerDynamic('2ba', ['2bb', '2bc'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var isFunction = $__require('2bb');
  var config = $__require('2bc');
  module.exports = function sourceListCheck(key, value, options) {
    var directiveInfo = config.directives[key];
    if (value === false) {
      return;
    }
    if (!Array.isArray(value)) {
      throw new Error('"' + value + '" is not a valid value for ' + key + '. Use an array of strings.');
    }
    if (value.length === 0) {
      throw new Error(key + ' must have at least one value. To block everything, set ' + key + ' to ["\'none\'"].');
    }
    value.forEach(function (sourceExpression) {
      if (!sourceExpression) {
        throw new Error('"' + sourceExpression + '" is not a valid source expression. Only non-empty strings are allowed.');
      }
      if (isFunction(sourceExpression)) {
        return;
      }
      sourceExpression = sourceExpression.valueOf();
      if (typeof sourceExpression !== 'string' || sourceExpression.length === 0) {
        throw new Error('"' + sourceExpression + '" is not a valid source expression. Only non-empty strings are allowed.');
      }
      if (!directiveInfo.hasUnsafes && config.unsafes.indexOf(sourceExpression) !== -1) {
        throw new Error('"' + sourceExpression + '" does not make sense in ' + key + '. Remove it.');
      }
      if (config.mustQuote.indexOf(sourceExpression) !== -1) {
        throw new Error('"' + sourceExpression + '" must be quoted in ' + key + '. Change it to "\'' + sourceExpression + '\'" in your source list. Force this by enabling loose mode.');
      }
    });
  };
  return module.exports;
});
$__System.registerDynamic('2bd', ['2bc', '2bb'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var config = $__require('2bc');
  var isFunction = $__require('2bb');
  var notAllowed = ['self', "'self'"].concat(config.unsafes);
  module.exports = function pluginTypesCheck(key, value, options) {
    if (!Array.isArray(value) && value !== false) {
      throw new Error('"' + value + '" is not a valid value for ' + key + '. Use an array of strings.');
    }
    if (value.length === 0) {
      throw new Error(key + ' must have at least one value. To block everything, set ' + key + ' to ["\'none\'"].');
    }
    value.forEach(function (pluginType) {
      if (!pluginType) {
        throw new Error('"' + pluginType + '" is not a valid plugin type. Only non-empty strings are allowed.');
      }
      if (isFunction(pluginType)) {
        return;
      }
      pluginType = pluginType.valueOf();
      if (typeof pluginType !== 'string' || pluginType.length === 0) {
        throw new Error('"' + pluginType + '" is not a valid plugin type. Only non-empty strings are allowed.');
      }
      if (notAllowed.indexOf(pluginType) !== -1) {
        throw new Error('"' + pluginType + '" does not make sense in ' + key + '. Remove it.');
      }
      if (config.mustQuote.indexOf(pluginType) !== -1) {
        throw new Error('"' + pluginType + '" must be quoted in ' + key + '. Change it to "\'' + pluginType + '\'" in your source list. Force this by enabling loose mode.');
      }
    });
  };
  return module.exports;
});
$__System.registerDynamic('2be', ['2bb', '2bc'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var isFunction = $__require('2bb');
  var config = $__require('2bc');
  module.exports = function sandboxCheck(key, value, options) {
    if (value === false) {
      return;
    }
    if (value === true) {
      return;
    }
    if (!Array.isArray(value)) {
      throw new Error('"' + value + '" is not a valid value for ' + key + '. Use an array of strings or `true`.');
    }
    if (value.length === 0) {
      throw new Error(key + ' must have at least one value. To block everything, set ' + key + ' to `true`.');
    }
    value.forEach(function (expression) {
      if (isFunction(expression)) {
        return;
      }
      if (config.sandboxDirectives.indexOf(expression) === -1) {
        throw new Error('"' + expression + '" is not a valid ' + key + ' directive. Remove it.');
      }
    });
  };
  return module.exports;
});
$__System.registerDynamic('2bf', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function isString(value) {
    return Object.prototype.toString.call(value) === '[object String]';
  };
  return module.exports;
});
$__System.registerDynamic('2c0', ['2bb', '2bf'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var isFunction = $__require('2bb');
  var isString = $__require('2bf');
  module.exports = function (key, value) {
    if (value === false) {
      return;
    }
    if (isFunction(value)) {
      return;
    }
    if (!isString(value) || value.length === 0) {
      throw new Error('"' + value + '" is not a valid value for ' + key + '. Use a non-empty string.');
    }
  };
  return module.exports;
});
$__System.registerDynamic('2c1', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function isBoolean(value) {
    return Object.prototype.toString.call(value) === '[object Boolean]';
  };
  return module.exports;
});
$__System.registerDynamic('2c2', ['2c1'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var isBoolean = $__require('2c1');
  module.exports = function (key, value) {
    if (!isBoolean(value)) {
      throw new Error('"' + value + '" is not a valid value for ' + key + '. Use `true` or `false`.');
    }
  };
  return module.exports;
});
$__System.registerDynamic('2c3', ['2bc', '2ba', '2bd', '2be', '2c0', '2c2'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var config = $__require('2bc');
  var checkers = {
    sourceList: $__require('2ba'),
    pluginTypes: $__require('2bd'),
    sandbox: $__require('2be'),
    reportUri: $__require('2c0'),
    boolean: $__require('2c2')
  };
  module.exports = function (key, value, options) {
    if (options.loose) {
      return;
    }
    if (!config.directives.hasOwnProperty(key)) {
      throw new Error('"' + key + '" is an invalid directive. See the documentation for the supported list. Force this by enabling loose mode.');
    }
    var directiveType = config.directives[key].type;
    checkers[directiveType](key, value, options);
  };
  return module.exports;
});
$__System.registerDynamic('2c4', [], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var isArray = Array.isArray || function (obj) {
    return Object.prototype.toString.call(obj) === '[object Array]';
  };

  var isDate = function (obj) {
    return Object.prototype.toString.call(obj) === '[object Date]';
  };

  var isRegex = function (obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
  };

  var has = Object.prototype.hasOwnProperty;
  var objectKeys = Object.keys || function (obj) {
    var keys = [];
    for (var key in obj) {
      if (has.call(obj, key)) {
        keys.push(key);
      }
    }
    return keys;
  };

  function dashCase(str) {
    return str.replace(/[A-Z](?:(?=[^A-Z])|[A-Z]*(?=[A-Z][^A-Z]|$))/g, function (s, i) {
      return (i > 0 ? '-' : '') + s.toLowerCase();
    });
  }

  function map(xs, f) {
    if (xs.map) {
      return xs.map(f);
    }
    var res = [];
    for (var i = 0; i < xs.length; i++) {
      res.push(f(xs[i], i));
    }
    return res;
  }

  function reduce(xs, f, acc) {
    if (xs.reduce) {
      return xs.reduce(f, acc);
    }
    for (var i = 0; i < xs.length; i++) {
      acc = f(acc, xs[i], i);
    }
    return acc;
  }

  function walk(obj) {
    if (!obj || typeof obj !== 'object') {
      return obj;
    }
    if (isDate(obj) || isRegex(obj)) {
      return obj;
    }
    if (isArray(obj)) {
      return map(obj, walk);
    }
    return reduce(objectKeys(obj), function (acc, key) {
      var camel = dashCase(key);
      acc[camel] = walk(obj[key]);
      return acc;
    }, {});
  }

  module.exports = function (obj) {
    if (typeof obj === 'string') {
      return dashCase(obj);
    }
    return walk(obj);
  };
  return module.exports;
});
$__System.registerDynamic("2c5", ["2c4"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("2c4");
  return module.exports;
});
$__System.registerDynamic('2c6', ['2c3', '2c5'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var checkDirective = $__require('2c3');
  var dasherize = $__require('2c5');
  module.exports = function (options) {
    if (!options) {
      throw new Error('csp must be called with arguments. See the documentation.');
    }
    var directives = options.directives;
    var directivesExist = Object.prototype.toString.call(directives) === '[object Object]';
    if (!directivesExist || Object.keys(directives).length === 0) {
      throw new Error('csp must have at least one directive under the "directives" key. See the documentation.');
    }
    Object.keys(directives).forEach(function (directiveKey) {
      checkDirective(dasherize(directiveKey), directives[directiveKey], options);
    });
  };
  return module.exports;
});
$__System.registerDynamic('2c7', ['2bb'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var isFunction = $__require('2bb');
  module.exports = function containsFunction(obj) {
    for (var key in obj) {
      if (!obj.hasOwnProperty(key)) {
        continue;
      }
      var value = obj[key];
      if (!Array.isArray(value)) {
        value = [value];
      }
      if (value.some(isFunction)) {
        return true;
      }
    }
    return false;
  };
  return module.exports;
});
$__System.registerDynamic('2c8', ['2bc'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var config = $__require('2bc');
  function goodBrowser() {
    return ['Content-Security-Policy'];
  }
  var handlers = {
    'Android Browser': function (browser, options) {
      if (parseFloat(browser.os.version) < 4.4 || options.disableAndroid) {
        return [];
      } else {
        return ['Content-Security-Policy'];
      }
    },
    Chrome: function (browser) {
      var version = parseFloat(browser.version);
      if (version >= 14 && version < 25) {
        return ['X-WebKit-CSP'];
      } else if (version >= 25) {
        return ['Content-Security-Policy'];
      } else {
        return [];
      }
    },
    'Chrome Mobile': function (browser) {
      if (browser.os.family === 'iOS') {
        return ['Content-Security-Policy'];
      } else {
        return handlers['Android Browser'].apply(this, arguments);
      }
    },
    Firefox: function (browser) {
      var version = parseFloat(browser.version);
      if (version >= 23) {
        return ['Content-Security-Policy'];
      } else if (version >= 4 && version < 23) {
        return ['X-Content-Security-Policy'];
      } else {
        return [];
      }
    },
    'Firefox Mobile': function (browser) {
      var family = browser.os.family;
      var version = parseFloat(browser.version);
      if (family === 'Firefox OS') {
        if (version >= 32) {
          return ['Content-Security-Policy'];
        } else {
          return ['X-Content-Security-Policy'];
        }
      } else if (family === 'Android') {
        if (version >= 25) {
          return ['Content-Security-Policy'];
        } else {
          return ['X-Content-Security-Policy'];
        }
      }
      return [];
    },
    IE: function (browser) {
      var version = parseFloat(browser.version);
      var header = version < 12 ? 'X-Content-Security-Policy' : 'Content-Security-Policy';
      return [header];
    },
    'Microsoft Edge': goodBrowser,
    'Microsoft Edge Mobile': goodBrowser,
    Opera: function (browser) {
      if (parseFloat(browser.version) >= 15) {
        return ['Content-Security-Policy'];
      } else {
        return [];
      }
    },
    Safari: function (browser) {
      var version = parseFloat(browser.version);
      if (version >= 7) {
        return ['Content-Security-Policy'];
      } else if (version >= 6) {
        return ['X-WebKit-CSP'];
      } else {
        return [];
      }
    }
  };
  handlers['IE Mobile'] = handlers.IE;
  module.exports = function getHeaderKeysForBrowser(browser, options) {
    var handler = handlers[browser.name];
    if (handler) {
      return handler(browser, options);
    } else {
      return config.allHeaders;
    }
  };
  return module.exports;
});
$__System.registerDynamic('2c9', ['2ca'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var reduce = $__require('2ca');

  function createFirefoxPreCSP10Directives(directives, basePolicy) {
    return reduce(directives, function (result, value, key) {
      if (key === 'connectSrc') {
        result.xhrSrc = value;
      } else {
        result[key] = value;
      }

      if (key === 'scriptSrc') {
        var optionsValues = [];

        if (value.indexOf("'unsafe-inline'") !== -1) {
          optionsValues.push('inline-script');
        }
        if (value.indexOf("'unsafe-eval'") !== -1) {
          optionsValues.push('eval-script');
        }

        if (optionsValues.length !== 0) {
          result.options = optionsValues;
        }
      }

      return result;
    }, basePolicy);
  }

  var handlers = {
    Firefox: function (browser, directives) {
      var version = parseFloat(browser.version);

      if (version >= 4 && version < 23) {
        var basePolicy = {};
        if (version < 5) {
          basePolicy.allow = ['*'];

          if (directives.defaultSrc) {
            basePolicy.allow = directives.defaultSrc;
            delete directives.defaultSrc;
          }
        } else {
          basePolicy.defaultSrc = ['*'];
        }

        return createFirefoxPreCSP10Directives(directives, basePolicy);
      } else {
        return directives;
      }
    },

    'Firefox Mobile': function (browser, directives) {
      // Handles both Firefox for Android and Firefox OS
      var family = browser.os.family;
      var version = parseFloat(browser.version);

      if (family === 'Firefox OS' && version < 32 || family === 'Android' && version < 25) {
        return createFirefoxPreCSP10Directives(directives, { defaultSrc: ['*'] });
      } else {
        return directives;
      }
    }
  };

  module.exports = function transformDirectivesForBrowser(browser, directives) {
    var handler = handlers[browser.name];

    if (handler) {
      return handler(browser, directives);
    } else {
      return directives;
    }
  };
  return module.exports;
});
$__System.registerDynamic('1b9', [], true, function ($__require, exports, module) {
    var define,
        global = this || self,
        GLOBAL = global;
    // shim for using process in browser
    var process = module.exports = {};

    // cached from whatever global is present so that test runners that stub it
    // don't break things.  But we need to wrap it in a try catch in case it is
    // wrapped in strict mode code which doesn't define any globals.  It's inside a
    // function because try/catches deoptimize in certain engines.

    var cachedSetTimeout;
    var cachedClearTimeout;

    function defaultSetTimout() {
        throw new Error('setTimeout has not been defined');
    }
    function defaultClearTimeout() {
        throw new Error('clearTimeout has not been defined');
    }
    (function () {
        try {
            if (typeof setTimeout === 'function') {
                cachedSetTimeout = setTimeout;
            } else {
                cachedSetTimeout = defaultSetTimout;
            }
        } catch (e) {
            cachedSetTimeout = defaultSetTimout;
        }
        try {
            if (typeof clearTimeout === 'function') {
                cachedClearTimeout = clearTimeout;
            } else {
                cachedClearTimeout = defaultClearTimeout;
            }
        } catch (e) {
            cachedClearTimeout = defaultClearTimeout;
        }
    })();
    function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
            //normal enviroments in sane situations
            return setTimeout(fun, 0);
        }
        // if setTimeout wasn't available but was latter defined
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedSetTimeout(fun, 0);
        } catch (e) {
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                return cachedSetTimeout.call(null, fun, 0);
            } catch (e) {
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                return cachedSetTimeout.call(this, fun, 0);
            }
        }
    }
    function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
            //normal enviroments in sane situations
            return clearTimeout(marker);
        }
        // if clearTimeout wasn't available but was latter defined
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedClearTimeout(marker);
        } catch (e) {
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                return cachedClearTimeout.call(null, marker);
            } catch (e) {
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                return cachedClearTimeout.call(this, marker);
            }
        }
    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;

    function cleanUpNextTick() {
        if (!draining || !currentQueue) {
            return;
        }
        draining = false;
        if (currentQueue.length) {
            queue = currentQueue.concat(queue);
        } else {
            queueIndex = -1;
        }
        if (queue.length) {
            drainQueue();
        }
    }

    function drainQueue() {
        if (draining) {
            return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;

        var len = queue.length;
        while (len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
                if (currentQueue) {
                    currentQueue[queueIndex].run();
                }
            }
            queueIndex = -1;
            len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
    }

    process.nextTick = function (fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
            }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
        }
    };

    // v8 likes predictible objects
    function Item(fun, array) {
        this.fun = fun;
        this.array = array;
    }
    Item.prototype.run = function () {
        this.fun.apply(null, this.array);
    };
    process.title = 'browser';
    process.browser = true;
    process.env = {};
    process.argv = [];
    process.version = ''; // empty string to avoid regexp issues
    process.versions = {};

    function noop() {}

    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;

    process.binding = function (name) {
        throw new Error('process.binding is not supported');
    };

    process.cwd = function () {
        return '/';
    };
    process.chdir = function (dir) {
        throw new Error('process.chdir is not supported');
    };
    process.umask = function () {
        return 0;
    };
    return module.exports;
});
$__System.registerDynamic("1b8", ["1b9"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("1b9");
  return module.exports;
});
$__System.registerDynamic('2cb', ['1b8'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__System._nodeRequire ? process : $__require('1b8');
  return module.exports;
});
$__System.registerDynamic("13", ["2cb"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("2cb");
  return module.exports;
});
$__System.registerDynamic('2cc', ['13'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    var LARGE_ARRAY_SIZE = 200;
    var FUNC_ERROR_TEXT = 'Expected a function';
    var HASH_UNDEFINED = '__lodash_hash_undefined__';
    var UNORDERED_COMPARE_FLAG = 1,
        PARTIAL_COMPARE_FLAG = 2;
    var INFINITY = 1 / 0,
        MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = '[object Arguments]',
        arrayTag = '[object Array]',
        boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        errorTag = '[object Error]',
        funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]',
        mapTag = '[object Map]',
        numberTag = '[object Number]',
        objectTag = '[object Object]',
        promiseTag = '[object Promise]',
        regexpTag = '[object RegExp]',
        setTag = '[object Set]',
        stringTag = '[object String]',
        symbolTag = '[object Symbol]',
        weakMapTag = '[object WeakMap]';
    var arrayBufferTag = '[object ArrayBuffer]',
        dataViewTag = '[object DataView]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]';
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
        reIsPlainProp = /^\w*$/,
        reLeadingDot = /^\./,
        rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reEscapeChar = /\\(\\)?/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function('return this')();
    var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function () {
      try {
        return freeProcess && freeProcess.binding('util');
      } catch (e) {}
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1,
          length = array ? array.length : 0;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function arraySome(array, predicate) {
      var index = -1,
          length = array ? array.length : 0;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    function baseProperty(key) {
      return function (object) {
        return object == null ? undefined : object[key];
      };
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function (value, index, collection) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection);
      });
      return accumulator;
    }
    function baseTimes(n, iteratee) {
      var index = -1,
          result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function (value) {
        return func(value);
      };
    }
    function getValue(object, key) {
      return object == null ? undefined : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != 'function') {
        try {
          result = !!(value + '');
        } catch (e) {}
      }
      return result;
    }
    function mapToArray(map) {
      var index = -1,
          result = Array(map.size);
      map.forEach(function (value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function (arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1,
          result = Array(set.size);
      set.forEach(function (value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype,
        funcProto = Function.prototype,
        objectProto = Object.prototype;
    var coreJsData = root['__core-js_shared__'];
    var maskSrcKey = function () {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
      return uid ? 'Symbol(src)_1.' + uid : '';
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
    var Symbol = root.Symbol,
        Uint8Array = root.Uint8Array,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        splice = arrayProto.splice;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView = getNative(root, 'DataView'),
        Map = getNative(root, 'Map'),
        Promise = getNative(root, 'Promise'),
        Set = getNative(root, 'Set'),
        WeakMap = getNative(root, 'WeakMap'),
        nativeCreate = getNative(Object, 'create');
    var dataViewCtorString = toSource(DataView),
        mapCtorString = toSource(Map),
        promiseCtorString = toSource(Promise),
        setCtorString = toSource(Set),
        weakMapCtorString = toSource(WeakMap);
    var symbolProto = Symbol ? Symbol.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
        symbolToString = symbolProto ? symbolProto.toString : undefined;
    function Hash(entries) {
      var index = -1,
          length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : undefined;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype['delete'] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1,
          length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);
      return index < 0 ? undefined : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__,
          index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype['delete'] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1,
          length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        'hash': new Hash(),
        'map': new (Map || ListCache)(),
        'string': new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)['delete'](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype['delete'] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1,
          length = values ? values.length : 0;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key) {
      return this.__data__['delete'](key);
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype['delete'] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length,
          skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    var baseEach = createBaseEach(baseForOwn);
    var baseFor = createBaseFor();
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    function baseGet(object, path) {
      path = isKey(path, object) ? [path] : castPath(path);
      var index = 0,
          length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : undefined;
    }
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }
    function baseIsEqual(value, other, customizer, bitmask, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
    }
    function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = arrayTag,
          othTag = arrayTag;
      if (!objIsArr) {
        objTag = getTag(object);
        objTag = objTag == argsTag ? objectTag : objTag;
      }
      if (!othIsArr) {
        othTag = getTag(other);
        othTag = othTag == argsTag ? objectTag : othTag;
      }
      var objIsObj = objTag == objectTag && !isHostObject(object),
          othIsObj = othTag == objectTag && !isHostObject(other),
          isSameTag = objTag == othTag;
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
      }
      if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object,
              othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
    }
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
    }
    function baseIteratee(value) {
      if (typeof value == 'function') {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == 'object') {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }
      return result;
    }
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function (object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function (object) {
        var objValue = get(object, path);
        return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
      };
    }
    function basePropertyDeep(path) {
      return function (object) {
        return baseGet(object, path);
      };
    }
    function baseToString(value) {
      if (typeof value == 'string') {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : '';
      }
      var result = value + '';
      return result == '0' && 1 / value == -INFINITY ? '-0' : result;
    }
    function castPath(value) {
      return isArray(value) ? value : stringToPath(value);
    }
    function createBaseEach(eachFunc, fromRight) {
      return function (collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length,
            index = fromRight ? length : -1,
            iterable = Object(collection);
        while (fromRight ? index-- : ++index < length) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    function createBaseFor(fromRight) {
      return function (object, iteratee, keysFunc) {
        var index = -1,
            iterable = Object(object),
            props = keysFunc(object),
            length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
          arrLength = array.length,
          othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1,
          result = true,
          seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : undefined;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== undefined) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function (othValue, othIndex) {
            if (!seen.has(othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
              return seen.add(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
          result = false;
          break;
        }
      }
      stack['delete'](array);
      stack['delete'](other);
      return result;
    }
    function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + '';
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= UNORDERED_COMPARE_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
          stack['delete'](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
          objProps = keys(object),
          objLength = objProps.length,
          othProps = keys(other),
          othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;
        if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack['delete'](object);
      stack['delete'](other);
      return result;
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
    }
    function getMatchData(object) {
      var result = keys(object),
          length = result.length;
      while (length--) {
        var key = result[length],
            value = object[key];
        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : undefined;
    }
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
      getTag = function (value) {
        var result = objectToString.call(value),
            Ctor = result == objectTag ? value.constructor : undefined,
            ctorString = Ctor ? toSource(Ctor) : undefined;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function hasPath(object, path, hasFunc) {
      path = isKey(path, object) ? [path] : castPath(path);
      var result,
          index = -1,
          length = path.length;
      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result) {
        return result;
      }
      var length = object ? object.length : 0;
      return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
    }
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
      return value === proto;
    }
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }
    function matchesStrictComparable(key, srcValue) {
      return function (object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
      };
    }
    var stringToPath = memoize(function (string) {
      string = toString(string);
      var result = [];
      if (reLeadingDot.test(string)) {
        result.push('');
      }
      string.replace(rePropName, function (match, number, quote, string) {
        result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);
      });
      return result;
    });
    function toKey(value) {
      if (typeof value == 'string' || isSymbol(value)) {
        return value;
      }
      var result = value + '';
      return result == '0' && 1 / value == -INFINITY ? '-0' : result;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {}
        try {
          return func + '';
        } catch (e) {}
      }
      return '';
    }
    function reduce(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduce : baseReduce,
          initAccum = arguments.length < 3;
      return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
    }
    function memoize(func, resolver) {
      if (typeof func != 'function' || resolver && typeof resolver != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function () {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : '';
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == 'object' || type == 'function');
    }
    function isObjectLike(value) {
      return !!value && typeof value == 'object';
    }
    function isSymbol(value) {
      return typeof value == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function toString(value) {
      return value == null ? '' : baseToString(value);
    }
    function get(object, path, defaultValue) {
      var result = object == null ? undefined : baseGet(object, path);
      return result === undefined ? defaultValue : result;
    }
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function identity(value) {
      return value;
    }
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }
    module.exports = reduce;
  })($__require('13'));
  return module.exports;
});
$__System.registerDynamic("2ca", ["2cc"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("2cc");
  return module.exports;
});
$__System.registerDynamic("2bb", [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function isFunction(value) {
    return value instanceof Function;
  };
  return module.exports;
});
$__System.registerDynamic('2cd', ['2ca', '2bb'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var reduce = $__require('2ca');
  var isFunction = $__require('2bb');
  module.exports = function parseDynamicDirectives(directives, functionArgs) {
    return reduce(directives, function (result, value, key) {
      if (Array.isArray(value)) {
        result[key] = value.map(function (element) {
          if (isFunction(element)) {
            return element.apply(null, functionArgs);
          } else {
            return element;
          }
        });
      } else if (isFunction(value)) {
        result[key] = value.apply(null, functionArgs);
      } else if (value !== false) {
        result[key] = value;
      }
      return result;
    }, {});
  };
  return module.exports;
});
$__System.registerDynamic("2bc", [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = { "directives": { "base-uri": { "type": "sourceList" }, "child-src": { "type": "sourceList" }, "connect-src": { "type": "sourceList" }, "default-src": { "type": "sourceList" }, "font-src": { "type": "sourceList" }, "form-action": { "type": "sourceList" }, "frame-ancestors": { "type": "sourceList" }, "frame-src": { "type": "sourceList" }, "img-src": { "type": "sourceList" }, "media-src": { "type": "sourceList" }, "object-src": { "type": "sourceList" }, "script-src": { "type": "sourceList", "hasUnsafes": true }, "style-src": { "type": "sourceList", "hasUnsafes": true }, "plugin-types": { "type": "pluginTypes" }, "sandbox": { "type": "sandbox" }, "report-uri": { "type": "reportUri" }, "upgrade-insecure-requests": { "type": "boolean" }, "block-all-mixed-content": { "type": "boolean" } }, "allHeaders": ["Content-Security-Policy", "X-Content-Security-Policy", "X-WebKit-CSP"], "mustQuote": ["none", "self", "unsafe-inline", "unsafe-eval"], "unsafes": ["'unsafe-inline'", "unsafe-inline", "'unsafe-eval'", "unsafe-eval"], "sandboxDirectives": ["allow-popups", "allow-top-navigation", "allow-same-origin", "allow-forms", "allow-pointer-lock", "allow-scripts"] };
  return module.exports;
});
$__System.registerDynamic('2ce', ['2b3', '2b7', '2bb', '2b9', '2c6', '2c7', '2c8', '2c9', '2cd', '2bc'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var camelize = $__require('2b3');
  var cspBuilder = $__require('2b7');
  var isFunction = $__require('2bb');
  var platform = $__require('2b9');
  var checkOptions = $__require('2c6');
  var containsFunction = $__require('2c7');
  var getHeaderKeysForBrowser = $__require('2c8');
  var transformDirectivesForBrowser = $__require('2c9');
  var parseDynamicDirectives = $__require('2cd');
  var config = $__require('2bc');
  module.exports = function csp(options) {
    checkOptions(options);
    var originalDirectives = camelize(options.directives || {});
    var directivesAreDynamic = containsFunction(originalDirectives);
    var shouldBrowserSniff = options.browserSniff !== false;
    var reportOnlyIsFunction = isFunction(options.reportOnly);
    if (shouldBrowserSniff) {
      return function csp(req, res, next) {
        var userAgent = req.headers['user-agent'];
        var browser;
        if (userAgent) {
          browser = platform.parse(userAgent);
        } else {
          browser = {};
        }
        var headerKeys;
        if (options.setAllHeaders || !userAgent) {
          headerKeys = config.allHeaders;
        } else {
          headerKeys = getHeaderKeysForBrowser(browser, options);
        }
        if (headerKeys.length === 0) {
          next();
          return;
        }
        var directives = transformDirectivesForBrowser(browser, originalDirectives);
        if (directivesAreDynamic) {
          directives = parseDynamicDirectives(directives, [req, res]);
        }
        var policyString = cspBuilder({ directives: directives });
        headerKeys.forEach(function (headerKey) {
          if (reportOnlyIsFunction && options.reportOnly(req, res) || !reportOnlyIsFunction && options.reportOnly) {
            headerKey += '-Report-Only';
          }
          res.setHeader(headerKey, policyString);
        });
        next();
      };
    } else {
      var headerKeys;
      if (options.setAllHeaders) {
        headerKeys = config.allHeaders;
      } else {
        headerKeys = ['Content-Security-Policy'];
      }
      return function csp(req, res, next) {
        var directives = parseDynamicDirectives(originalDirectives, [req, res]);
        var policyString = cspBuilder({ directives: directives });
        if (reportOnlyIsFunction && options.reportOnly(req, res) || !reportOnlyIsFunction && options.reportOnly) {
          headerKeys.forEach(function (headerKey) {
            res.setHeader(headerKey + '-Report-Only', policyString);
          });
        } else {
          headerKeys.forEach(function (headerKey) {
            res.setHeader(headerKey, policyString);
          });
        }
        next();
      };
    }
  };
  return module.exports;
});
$__System.registerDynamic("2cf", ["2ce"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("2ce");
  return module.exports;
});
$__System.registerDynamic('2d0', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function dnsPrefetchControl(options) {
    if (options && options.allow) {
      return function dnsPrefetchControl(req, res, next) {
        res.setHeader('X-DNS-Prefetch-Control', 'on');
        next();
      };
    } else {
      return function dnsPrefetchControl(req, res, next) {
        res.setHeader('X-DNS-Prefetch-Control', 'off');
        next();
      };
    }
  };
  return module.exports;
});
$__System.registerDynamic("2d1", ["2d0"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("2d0");
  return module.exports;
});
$__System.registerDynamic('2d2', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (val) {
    return typeof val === 'string' || val instanceof String;
  };
  return module.exports;
});
$__System.registerDynamic('2d3', ['2d2'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var isString = $__require('2d2');
  module.exports = function frameguard(options) {
    options = options || {};
    var domain = options.domain;
    var action = options.action;
    var directive;
    if (action === undefined) {
      directive = 'SAMEORIGIN';
    } else if (isString(action)) {
      directive = action.toUpperCase();
    }
    if (directive === 'ALLOWFROM') {
      directive = 'ALLOW-FROM';
    } else if (directive === 'SAME-ORIGIN') {
      directive = 'SAMEORIGIN';
    }
    if (['DENY', 'ALLOW-FROM', 'SAMEORIGIN'].indexOf(directive) === -1) {
      throw new Error('action must be undefined, "DENY", "ALLOW-FROM", or "SAMEORIGIN".');
    }
    if (directive === 'ALLOW-FROM') {
      if (!isString(domain)) {
        throw new Error('ALLOW-FROM action requires a domain parameter.');
      }
      if (!domain.length) {
        throw new Error('domain parameter must not be empty.');
      }
      directive = 'ALLOW-FROM ' + domain;
    }
    return function frameguard(req, res, next) {
      res.setHeader('X-Frame-Options', directive);
      next();
    };
  };
  return module.exports;
});
$__System.registerDynamic("2d4", ["2d3"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("2d3");
  return module.exports;
});
$__System.registerDynamic('2d5', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function hidePoweredBy(options) {
    var setTo = (options || {}).setTo;

    if (setTo) {
      return function hidePoweredBy(req, res, next) {
        res.setHeader('X-Powered-By', setTo);
        next();
      };
    } else {
      return function hidePoweredBy(req, res, next) {
        res.removeHeader('X-Powered-By');
        next();
      };
    }
  };
  return module.exports;
});
$__System.registerDynamic("2d6", ["2d5"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("2d5");
  return module.exports;
});
$__System.registerDynamic('2d7', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var badArgumentsError = new Error('hpkp must be called with a maxAge and at least two SHA-256s (one actually used and another kept as a backup).');

  module.exports = function hpkp(passedOptions) {
    var options = parseOptions(passedOptions);
    var headerKey = getHeaderKey(options);
    var headerValue = getHeaderValue(options);

    return function hpkp(req, res, next) {
      var setHeader = true;
      var setIf = options.setIf;

      if (setIf) {
        setHeader = setIf(req, res);
      }

      if (setHeader) {
        res.setHeader(headerKey, headerValue);
      }

      next();
    };
  };

  function parseOptions(options) {
    if (!options) {
      throw badArgumentsError;
    }

    if (options.maxage && options.maxAge) {
      throw badArgumentsError;
    }

    var maxAge = options.maxAge;
    var sha256s = options.sha256s;
    var setIf = options.setIf;

    if (!maxAge || maxAge <= 0) {
      throw badArgumentsError;
    }
    if (!sha256s || sha256s.length < 2) {
      throw badArgumentsError;
    }
    if (setIf && typeof setIf !== 'function') {
      throw new TypeError('setIf must be a function.');
    }

    if (options.reportOnly && !options.reportUri) {
      throw badArgumentsError;
    }

    return {
      maxAge: maxAge,
      sha256s: sha256s,
      includeSubDomains: options.includeSubDomains || options.includeSubdomains,
      reportUri: options.reportUri,
      reportOnly: options.reportOnly,
      setIf: setIf
    };
  }

  function getHeaderKey(options) {
    var header = 'Public-Key-Pins';
    if (options.reportOnly) {
      header += '-Report-Only';
    }
    return header;
  }

  function getHeaderValue(options) {
    var result = options.sha256s.map(function (sha) {
      return 'pin-sha256="' + sha + '"';
    });
    result.push('max-age=' + Math.round(options.maxAge));
    if (options.includeSubDomains) {
      result.push('includeSubDomains');
    }
    if (options.reportUri) {
      result.push('report-uri="' + options.reportUri + '"');
    }
    return result.join('; ');
  }
  return module.exports;
});
$__System.registerDynamic("2d8", ["2d7"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("2d7");
  return module.exports;
});
$__System.registerDynamic('2d9', [], true, function ($__require, exports, module) {
	var define,
	    global = this || self,
	    GLOBAL = global;
	/* */
	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	;(function (exports) {
		'use strict';

		var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

		var PLUS = '+'.charCodeAt(0);
		var SLASH = '/'.charCodeAt(0);
		var NUMBER = '0'.charCodeAt(0);
		var LOWER = 'a'.charCodeAt(0);
		var UPPER = 'A'.charCodeAt(0);
		var PLUS_URL_SAFE = '-'.charCodeAt(0);
		var SLASH_URL_SAFE = '_'.charCodeAt(0);

		function decode(elt) {
			var code = elt.charCodeAt(0);
			if (code === PLUS || code === PLUS_URL_SAFE) return 62; // '+'
			if (code === SLASH || code === SLASH_URL_SAFE) return 63; // '/'
			if (code < NUMBER) return -1; //no match
			if (code < NUMBER + 10) return code - NUMBER + 26 + 26;
			if (code < UPPER + 26) return code - UPPER;
			if (code < LOWER + 26) return code - LOWER + 26;
		}

		function b64ToByteArray(b64) {
			var i, j, l, tmp, placeHolders, arr;

			if (b64.length % 4 > 0) {
				throw new Error('Invalid string. Length must be a multiple of 4');
			}

			// the number of equal signs (place holders)
			// if there are two placeholders, than the two characters before it
			// represent one byte
			// if there is only one, then the three characters before it represent 2 bytes
			// this is just a cheap hack to not do indexOf twice
			var len = b64.length;
			placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0;

			// base64 is 4/3 + up to two characters of the original data
			arr = new Arr(b64.length * 3 / 4 - placeHolders);

			// if there are placeholders, only get up to the last complete 4 chars
			l = placeHolders > 0 ? b64.length - 4 : b64.length;

			var L = 0;

			function push(v) {
				arr[L++] = v;
			}

			for (i = 0, j = 0; i < l; i += 4, j += 3) {
				tmp = decode(b64.charAt(i)) << 18 | decode(b64.charAt(i + 1)) << 12 | decode(b64.charAt(i + 2)) << 6 | decode(b64.charAt(i + 3));
				push((tmp & 0xFF0000) >> 16);
				push((tmp & 0xFF00) >> 8);
				push(tmp & 0xFF);
			}

			if (placeHolders === 2) {
				tmp = decode(b64.charAt(i)) << 2 | decode(b64.charAt(i + 1)) >> 4;
				push(tmp & 0xFF);
			} else if (placeHolders === 1) {
				tmp = decode(b64.charAt(i)) << 10 | decode(b64.charAt(i + 1)) << 4 | decode(b64.charAt(i + 2)) >> 2;
				push(tmp >> 8 & 0xFF);
				push(tmp & 0xFF);
			}

			return arr;
		}

		function uint8ToBase64(uint8) {
			var i,
			    extraBytes = uint8.length % 3,
			    // if we have 1 byte left, pad 2 bytes
			output = "",
			    temp,
			    length;

			function encode(num) {
				return lookup.charAt(num);
			}

			function tripletToBase64(num) {
				return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F);
			}

			// go through the array every three bytes, we'll deal with trailing stuff later
			for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
				temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
				output += tripletToBase64(temp);
			}

			// pad the end with zeros, but make sure to not forget the extra bytes
			switch (extraBytes) {
				case 1:
					temp = uint8[uint8.length - 1];
					output += encode(temp >> 2);
					output += encode(temp << 4 & 0x3F);
					output += '==';
					break;
				case 2:
					temp = (uint8[uint8.length - 2] << 8) + uint8[uint8.length - 1];
					output += encode(temp >> 10);
					output += encode(temp >> 4 & 0x3F);
					output += encode(temp << 2 & 0x3F);
					output += '=';
					break;
			}

			return output;
		}

		exports.toByteArray = b64ToByteArray;
		exports.fromByteArray = uint8ToBase64;
	})(typeof exports === 'undefined' ? this.base64js = {} : exports);
	return module.exports;
});
$__System.registerDynamic("2da", ["2d9"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("2d9");
  return module.exports;
});
$__System.registerDynamic("2db", [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  exports.read = function (buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];

    i += d;

    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  };

  exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;

    value = Math.abs(value);

    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }

      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }

    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

    e = e << mLen | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

    buffer[offset + i - d] |= s * 128;
  };
  return module.exports;
});
$__System.registerDynamic("2dc", ["2db"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("2db");
  return module.exports;
});
$__System.registerDynamic('2dd', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var toString = {}.toString;

  module.exports = Array.isArray || function (arr) {
    return toString.call(arr) == '[object Array]';
  };
  return module.exports;
});
$__System.registerDynamic("19c", ["2dd"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("2dd");
  return module.exports;
});
$__System.registerDynamic('2de', ['2da', '2dc', '19c'], true, function ($__require, exports, module) {
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   */
  /* eslint-disable no-proto */

  'use strict';

  var define,
      global = this || self,
      GLOBAL = global;
  var base64 = $__require('2da');
  var ieee754 = $__require('2dc');
  var isArray = $__require('19c');

  exports.Buffer = Buffer;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  Buffer.poolSize = 8192; // not used by this implementation

  var rootParent = {};

  /**
   * If `Buffer.TYPED_ARRAY_SUPPORT`:
   *   === true    Use Uint8Array implementation (fastest)
   *   === false   Use Object implementation (most compatible, even IE6)
   *
   * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
   * Opera 11.6+, iOS 4.2+.
   *
   * Due to various browser bugs, sometimes the Object implementation will be used even
   * when the browser supports typed arrays.
   *
   * Note:
   *
   *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
   *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
   *
   *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
   *     on objects.
   *
   *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
   *
   *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
   *     incorrect length in some situations.
  
   * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
   * get the Object implementation, which is slower but behaves correctly.
   */
  Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();

  function typedArraySupport() {
    function Bar() {}
    try {
      var arr = new Uint8Array(1);
      arr.foo = function () {
        return 42;
      };
      arr.constructor = Bar;
      return arr.foo() === 42 && // typed array instances can be augmented
      arr.constructor === Bar && // constructor can be set
      typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
      arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
    } catch (e) {
      return false;
    }
  }

  function kMaxLength() {
    return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
  }

  /**
   * Class: Buffer
   * =============
   *
   * The Buffer constructor returns instances of `Uint8Array` that are augmented
   * with function properties for all the node `Buffer` API functions. We use
   * `Uint8Array` so that square bracket notation works as expected -- it returns
   * a single octet.
   *
   * By augmenting the instances, we can avoid modifying the `Uint8Array`
   * prototype.
   */
  function Buffer(arg) {
    if (!(this instanceof Buffer)) {
      // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
      if (arguments.length > 1) return new Buffer(arg, arguments[1]);
      return new Buffer(arg);
    }

    if (!Buffer.TYPED_ARRAY_SUPPORT) {
      this.length = 0;
      this.parent = undefined;
    }

    // Common case.
    if (typeof arg === 'number') {
      return fromNumber(this, arg);
    }

    // Slightly less common case.
    if (typeof arg === 'string') {
      return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8');
    }

    // Unusual.
    return fromObject(this, arg);
  }

  function fromNumber(that, length) {
    that = allocate(that, length < 0 ? 0 : checked(length) | 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < length; i++) {
        that[i] = 0;
      }
    }
    return that;
  }

  function fromString(that, string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8';

    // Assumption: byteLength() return value is always < kMaxLength.
    var length = byteLength(string, encoding) | 0;
    that = allocate(that, length);

    that.write(string, encoding);
    return that;
  }

  function fromObject(that, object) {
    if (Buffer.isBuffer(object)) return fromBuffer(that, object);

    if (isArray(object)) return fromArray(that, object);

    if (object == null) {
      throw new TypeError('must start with number, buffer, array or string');
    }

    if (typeof ArrayBuffer !== 'undefined') {
      if (object.buffer instanceof ArrayBuffer) {
        return fromTypedArray(that, object);
      }
      if (object instanceof ArrayBuffer) {
        return fromArrayBuffer(that, object);
      }
    }

    if (object.length) return fromArrayLike(that, object);

    return fromJsonObject(that, object);
  }

  function fromBuffer(that, buffer) {
    var length = checked(buffer.length) | 0;
    that = allocate(that, length);
    buffer.copy(that, 0, 0, length);
    return that;
  }

  function fromArray(that, array) {
    var length = checked(array.length) | 0;
    that = allocate(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }

  // Duplicate of fromArray() to keep fromArray() monomorphic.
  function fromTypedArray(that, array) {
    var length = checked(array.length) | 0;
    that = allocate(that, length);
    // Truncating the elements is probably not what people expect from typed
    // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
    // of the old Buffer constructor.
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }

  function fromArrayBuffer(that, array) {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      array.byteLength;
      that = Buffer._augment(new Uint8Array(array));
    } else {
      // Fallback: Return an object instance of the Buffer class
      that = fromTypedArray(that, new Uint8Array(array));
    }
    return that;
  }

  function fromArrayLike(that, array) {
    var length = checked(array.length) | 0;
    that = allocate(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }

  // Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
  // Returns a zero-length buffer for inputs that don't conform to the spec.
  function fromJsonObject(that, object) {
    var array;
    var length = 0;

    if (object.type === 'Buffer' && isArray(object.data)) {
      array = object.data;
      length = checked(array.length) | 0;
    }
    that = allocate(that, length);

    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    Buffer.prototype.__proto__ = Uint8Array.prototype;
    Buffer.__proto__ = Uint8Array;
  } else {
    // pre-set for values that may exist in the future
    Buffer.prototype.length = undefined;
    Buffer.prototype.parent = undefined;
  }

  function allocate(that, length) {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = Buffer._augment(new Uint8Array(length));
      that.__proto__ = Buffer.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      that.length = length;
      that._isBuffer = true;
    }

    var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1;
    if (fromPool) that.parent = rootParent;

    return that;
  }

  function checked(length) {
    // Note: cannot use `length < kMaxLength` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= kMaxLength()) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
    }
    return length | 0;
  }

  function SlowBuffer(subject, encoding) {
    if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding);

    var buf = new Buffer(subject, encoding);
    delete buf.parent;
    return buf;
  }

  Buffer.isBuffer = function isBuffer(b) {
    return !!(b != null && b._isBuffer);
  };

  Buffer.compare = function compare(a, b) {
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
      throw new TypeError('Arguments must be Buffers');
    }

    if (a === b) return 0;

    var x = a.length;
    var y = b.length;

    var i = 0;
    var len = Math.min(x, y);
    while (i < len) {
      if (a[i] !== b[i]) break;

      ++i;
    }

    if (i !== len) {
      x = a[i];
      y = b[i];
    }

    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  };

  Buffer.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'binary':
      case 'base64':
      case 'raw':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true;
      default:
        return false;
    }
  };

  Buffer.concat = function concat(list, length) {
    if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.');

    if (list.length === 0) {
      return new Buffer(0);
    }

    var i;
    if (length === undefined) {
      length = 0;
      for (i = 0; i < list.length; i++) {
        length += list[i].length;
      }
    }

    var buf = new Buffer(length);
    var pos = 0;
    for (i = 0; i < list.length; i++) {
      var item = list[i];
      item.copy(buf, pos);
      pos += item.length;
    }
    return buf;
  };

  function byteLength(string, encoding) {
    if (typeof string !== 'string') string = '' + string;

    var len = string.length;
    if (len === 0) return 0;

    // Use a for loop to avoid recursion
    var loweredCase = false;
    for (;;) {
      switch (encoding) {
        case 'ascii':
        case 'binary':
        // Deprecated
        case 'raw':
        case 'raws':
          return len;
        case 'utf8':
        case 'utf-8':
          return utf8ToBytes(string).length;
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return len * 2;
        case 'hex':
          return len >>> 1;
        case 'base64':
          return base64ToBytes(string).length;
        default:
          if (loweredCase) return utf8ToBytes(string).length; // assume utf8
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer.byteLength = byteLength;

  function slowToString(encoding, start, end) {
    var loweredCase = false;

    start = start | 0;
    end = end === undefined || end === Infinity ? this.length : end | 0;

    if (!encoding) encoding = 'utf8';
    if (start < 0) start = 0;
    if (end > this.length) end = this.length;
    if (end <= start) return '';

    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end);

        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end);

        case 'ascii':
          return asciiSlice(this, start, end);

        case 'binary':
          return binarySlice(this, start, end);

        case 'base64':
          return base64Slice(this, start, end);

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end);

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
          encoding = (encoding + '').toLowerCase();
          loweredCase = true;
      }
    }
  }

  Buffer.prototype.toString = function toString() {
    var length = this.length | 0;
    if (length === 0) return '';
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };

  Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
  };

  Buffer.prototype.inspect = function inspect() {
    var str = '';
    var max = exports.INSPECT_MAX_BYTES;
    if (this.length > 0) {
      str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
      if (this.length > max) str += ' ... ';
    }
    return '<Buffer ' + str + '>';
  };

  Buffer.prototype.compare = function compare(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
    if (this === b) return 0;
    return Buffer.compare(this, b);
  };

  Buffer.prototype.indexOf = function indexOf(val, byteOffset) {
    if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff;else if (byteOffset < -0x80000000) byteOffset = -0x80000000;
    byteOffset >>= 0;

    if (this.length === 0) return -1;
    if (byteOffset >= this.length) return -1;

    // Negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0);

    if (typeof val === 'string') {
      if (val.length === 0) return -1; // special case: looking for empty string always fails
      return String.prototype.indexOf.call(this, val, byteOffset);
    }
    if (Buffer.isBuffer(val)) {
      return arrayIndexOf(this, val, byteOffset);
    }
    if (typeof val === 'number') {
      if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
        return Uint8Array.prototype.indexOf.call(this, val, byteOffset);
      }
      return arrayIndexOf(this, [val], byteOffset);
    }

    function arrayIndexOf(arr, val, byteOffset) {
      var foundIndex = -1;
      for (var i = 0; byteOffset + i < arr.length; i++) {
        if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex;
        } else {
          foundIndex = -1;
        }
      }
      return -1;
    }

    throw new TypeError('val must be string, number or Buffer');
  };

  // `get` is deprecated
  Buffer.prototype.get = function get(offset) {
    console.log('.get() is deprecated. Access using array indexes instead.');
    return this.readUInt8(offset);
  };

  // `set` is deprecated
  Buffer.prototype.set = function set(v, offset) {
    console.log('.set() is deprecated. Access using array indexes instead.');
    return this.writeUInt8(v, offset);
  };

  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }

    // must be an even number of digits
    var strLen = string.length;
    if (strLen % 2 !== 0) throw new Error('Invalid hex string');

    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i = 0; i < length; i++) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (isNaN(parsed)) throw new Error('Invalid hex string');
      buf[offset + i] = parsed;
    }
    return i;
  }

  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }

  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }

  function binaryWrite(buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length);
  }

  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }

  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }

  Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
      encoding = 'utf8';
      length = this.length;
      offset = 0;
      // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
      encoding = offset;
      length = this.length;
      offset = 0;
      // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
      offset = offset | 0;
      if (isFinite(length)) {
        length = length | 0;
        if (encoding === undefined) encoding = 'utf8';
      } else {
        encoding = length;
        length = undefined;
      }
      // legacy write(string, encoding, offset, length) - remove in v0.13
    } else {
      var swap = encoding;
      encoding = offset;
      offset = length | 0;
      length = swap;
    }

    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;

    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError('attempt to write outside buffer bounds');
    }

    if (!encoding) encoding = 'utf8';

    var loweredCase = false;
    for (;;) {
      switch (encoding) {
        case 'hex':
          return hexWrite(this, string, offset, length);

        case 'utf8':
        case 'utf-8':
          return utf8Write(this, string, offset, length);

        case 'ascii':
          return asciiWrite(this, string, offset, length);

        case 'binary':
          return binaryWrite(this, string, offset, length);

        case 'base64':
          // Warning: maxLength not taken into account in base64Write
          return base64Write(this, string, offset, length);

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write(this, string, offset, length);

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };

  Buffer.prototype.toJSON = function toJSON() {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };

  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }

  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];

    var i = start;
    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

      if (i + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;

        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 0x80) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
              if (tempCodePoint > 0x7F) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                codePoint = tempCodePoint;
              }
            }
        }
      }

      if (codePoint === null) {
        // we did not generate a valid codePoint so insert a
        // replacement char (U+FFFD) and advance only 1 byte
        codePoint = 0xFFFD;
        bytesPerSequence = 1;
      } else if (codePoint > 0xFFFF) {
        // encode to utf16 (surrogate pair dance)
        codePoint -= 0x10000;
        res.push(codePoint >>> 10 & 0x3FF | 0xD800);
        codePoint = 0xDC00 | codePoint & 0x3FF;
      }

      res.push(codePoint);
      i += bytesPerSequence;
    }

    return decodeCodePointsArray(res);
  }

  // Based on http://stackoverflow.com/a/22747272/680742, the browser with
  // the lowest limit is Chrome, with 0x10000 args.
  // We go 1 magnitude less, for safety
  var MAX_ARGUMENTS_LENGTH = 0x1000;

  function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
    }

    // Decode in chunks to avoid "call stack size exceeded".
    var res = '';
    var i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    }
    return res;
  }

  function asciiSlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; i++) {
      ret += String.fromCharCode(buf[i] & 0x7F);
    }
    return ret;
  }

  function binarySlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; i++) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }

  function hexSlice(buf, start, end) {
    var len = buf.length;

    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;

    var out = '';
    for (var i = start; i < end; i++) {
      out += toHex(buf[i]);
    }
    return out;
  }

  function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';
    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }

  Buffer.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;

    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }

    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }

    if (end < start) end = start;

    var newBuf;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      newBuf = Buffer._augment(this.subarray(start, end));
    } else {
      var sliceLen = end - start;
      newBuf = new Buffer(sliceLen, undefined);
      for (var i = 0; i < sliceLen; i++) {
        newBuf[i] = this[i + start];
      }
    }

    if (newBuf.length) newBuf.parent = this.parent || this;

    return newBuf;
  };

  /*
   * Need to make sure that buffer isn't trying to write out of bounds.
   */
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
  }

  Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }

    return val;
  };

  Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      checkOffset(offset, byteLength, this.length);
    }

    var val = this[offset + --byteLength];
    var mul = 1;
    while (byteLength > 0 && (mul *= 0x100)) {
      val += this[offset + --byteLength] * mul;
    }

    return val;
  };

  Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
  };

  Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };

  Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };

  Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
  };

  Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };

  Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }
    mul *= 0x80;

    if (val >= mul) val -= Math.pow(2, 8 * byteLength);

    return val;
  };

  Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while (i > 0 && (mul *= 0x100)) {
      val += this[offset + --i] * mul;
    }
    mul *= 0x80;

    if (val >= mul) val -= Math.pow(2, 8 * byteLength);

    return val;
  };

  Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
  };

  Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
  };

  Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
  };

  Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };

  Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };

  Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
  };

  Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
  };

  Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
  };

  Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
  };

  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('value is out of bounds');
    if (offset + ext > buf.length) throw new RangeError('index out of range');
  }

  Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);

    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = value / mul & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);

    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = value / mul & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    this[offset] = value & 0xff;
    return offset + 1;
  };

  function objectWriteUInt16(buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffff + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
      buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
    }
  }

  Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2;
  };

  Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 8;
      this[offset + 1] = value & 0xff;
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2;
  };

  function objectWriteUInt32(buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffffffff + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
      buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
    }
  }

  Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 0xff;
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4;
  };

  Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 0xff;
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4;
  };

  Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);

      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = 0;
    var mul = 1;
    var sub = value < 0 ? 1 : 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);

      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = byteLength - 1;
    var mul = 1;
    var sub = value < 0 ? 1 : 0;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
  };

  Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2;
  };

  Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 8;
      this[offset + 1] = value & 0xff;
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2;
  };

  Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4;
  };

  Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (value < 0) value = 0xffffffff + value + 1;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 0xff;
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4;
  };

  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (value > max || value < min) throw new RangeError('value is out of bounds');
    if (offset + ext > buf.length) throw new RangeError('index out of range');
    if (offset < 0) throw new RangeError('index out of range');
  }

  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
    }
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }

  Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };

  Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };

  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
    }
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }

  Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };

  Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };

  // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
  Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;

    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;

    // Fatal error conditions
    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds');
    }
    if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
    if (end < 0) throw new RangeError('sourceEnd out of bounds');

    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }

    var len = end - start;
    var i;

    if (this === target && start < targetStart && targetStart < end) {
      // descending copy from end
      for (i = len - 1; i >= 0; i--) {
        target[i + targetStart] = this[i + start];
      }
    } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
      // ascending copy from start
      for (i = 0; i < len; i++) {
        target[i + targetStart] = this[i + start];
      }
    } else {
      target._set(this.subarray(start, start + len), targetStart);
    }

    return len;
  };

  // fill(value, start=0, end=buffer.length)
  Buffer.prototype.fill = function fill(value, start, end) {
    if (!value) value = 0;
    if (!start) start = 0;
    if (!end) end = this.length;

    if (end < start) throw new RangeError('end < start');

    // Fill 0 bytes; we're done
    if (end === start) return;
    if (this.length === 0) return;

    if (start < 0 || start >= this.length) throw new RangeError('start out of bounds');
    if (end < 0 || end > this.length) throw new RangeError('end out of bounds');

    var i;
    if (typeof value === 'number') {
      for (i = start; i < end; i++) {
        this[i] = value;
      }
    } else {
      var bytes = utf8ToBytes(value.toString());
      var len = bytes.length;
      for (i = start; i < end; i++) {
        this[i] = bytes[i % len];
      }
    }

    return this;
  };

  /**
   * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
   * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
   */
  Buffer.prototype.toArrayBuffer = function toArrayBuffer() {
    if (typeof Uint8Array !== 'undefined') {
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        return new Buffer(this).buffer;
      } else {
        var buf = new Uint8Array(this.length);
        for (var i = 0, len = buf.length; i < len; i += 1) {
          buf[i] = this[i];
        }
        return buf.buffer;
      }
    } else {
      throw new TypeError('Buffer.toArrayBuffer not supported in this browser');
    }
  };

  // HELPER FUNCTIONS
  // ================

  var BP = Buffer.prototype;

  /**
   * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
   */
  Buffer._augment = function _augment(arr) {
    arr.constructor = Buffer;
    arr._isBuffer = true;

    // save reference to original Uint8Array set method before overwriting
    arr._set = arr.set;

    // deprecated
    arr.get = BP.get;
    arr.set = BP.set;

    arr.write = BP.write;
    arr.toString = BP.toString;
    arr.toLocaleString = BP.toString;
    arr.toJSON = BP.toJSON;
    arr.equals = BP.equals;
    arr.compare = BP.compare;
    arr.indexOf = BP.indexOf;
    arr.copy = BP.copy;
    arr.slice = BP.slice;
    arr.readUIntLE = BP.readUIntLE;
    arr.readUIntBE = BP.readUIntBE;
    arr.readUInt8 = BP.readUInt8;
    arr.readUInt16LE = BP.readUInt16LE;
    arr.readUInt16BE = BP.readUInt16BE;
    arr.readUInt32LE = BP.readUInt32LE;
    arr.readUInt32BE = BP.readUInt32BE;
    arr.readIntLE = BP.readIntLE;
    arr.readIntBE = BP.readIntBE;
    arr.readInt8 = BP.readInt8;
    arr.readInt16LE = BP.readInt16LE;
    arr.readInt16BE = BP.readInt16BE;
    arr.readInt32LE = BP.readInt32LE;
    arr.readInt32BE = BP.readInt32BE;
    arr.readFloatLE = BP.readFloatLE;
    arr.readFloatBE = BP.readFloatBE;
    arr.readDoubleLE = BP.readDoubleLE;
    arr.readDoubleBE = BP.readDoubleBE;
    arr.writeUInt8 = BP.writeUInt8;
    arr.writeUIntLE = BP.writeUIntLE;
    arr.writeUIntBE = BP.writeUIntBE;
    arr.writeUInt16LE = BP.writeUInt16LE;
    arr.writeUInt16BE = BP.writeUInt16BE;
    arr.writeUInt32LE = BP.writeUInt32LE;
    arr.writeUInt32BE = BP.writeUInt32BE;
    arr.writeIntLE = BP.writeIntLE;
    arr.writeIntBE = BP.writeIntBE;
    arr.writeInt8 = BP.writeInt8;
    arr.writeInt16LE = BP.writeInt16LE;
    arr.writeInt16BE = BP.writeInt16BE;
    arr.writeInt32LE = BP.writeInt32LE;
    arr.writeInt32BE = BP.writeInt32BE;
    arr.writeFloatLE = BP.writeFloatLE;
    arr.writeFloatBE = BP.writeFloatBE;
    arr.writeDoubleLE = BP.writeDoubleLE;
    arr.writeDoubleBE = BP.writeDoubleBE;
    arr.fill = BP.fill;
    arr.inspect = BP.inspect;
    arr.toArrayBuffer = BP.toArrayBuffer;

    return arr;
  };

  var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

  function base64clean(str) {
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = stringtrim(str).replace(INVALID_BASE64_RE, '');
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return '';
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while (str.length % 4 !== 0) {
      str = str + '=';
    }
    return str;
  }

  function stringtrim(str) {
    if (str.trim) return str.trim();
    return str.replace(/^\s+|\s+$/g, '');
  }

  function toHex(n) {
    if (n < 16) return '0' + n.toString(16);
    return n.toString(16);
  }

  function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];

    for (var i = 0; i < length; i++) {
      codePoint = string.charCodeAt(i);

      // is surrogate component
      if (codePoint > 0xD7FF && codePoint < 0xE000) {
        // last char was a lead
        if (!leadSurrogate) {
          // no lead yet
          if (codePoint > 0xDBFF) {
            // unexpected trail
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          } else if (i + 1 === length) {
            // unpaired lead
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          }

          // valid lead
          leadSurrogate = codePoint;

          continue;
        }

        // 2 leads in a row
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          leadSurrogate = codePoint;
          continue;
        }

        // valid surrogate pair
        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
      } else if (leadSurrogate) {
        // valid bmp char, but last char was a lead
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
      }

      leadSurrogate = null;

      // encode utf8
      if (codePoint < 0x80) {
        if ((units -= 1) < 0) break;
        bytes.push(codePoint);
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0) break;
        bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0) break;
        bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x110000) {
        if ((units -= 4) < 0) break;
        bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else {
        throw new Error('Invalid code point');
      }
    }

    return bytes;
  }

  function asciiToBytes(str) {
    var byteArray = [];
    for (var i = 0; i < str.length; i++) {
      // Node's code seems to be doing this and not & 0x7F..
      byteArray.push(str.charCodeAt(i) & 0xFF);
    }
    return byteArray;
  }

  function utf16leToBytes(str, units) {
    var c, hi, lo;
    var byteArray = [];
    for (var i = 0; i < str.length; i++) {
      if ((units -= 2) < 0) break;

      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }

    return byteArray;
  }

  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }

  function blitBuffer(src, dst, offset, length) {
    for (var i = 0; i < length; i++) {
      if (i + offset >= dst.length || i >= src.length) break;
      dst[i + offset] = src[i];
    }
    return i;
  }
  return module.exports;
});
$__System.registerDynamic("2df", ["2de"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("2de");
  return module.exports;
});
$__System.registerDynamic('2e0', ['2df'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  module.exports = $__System._nodeRequire ? $__System._nodeRequire('buffer') : $__require('2df');
  return module.exports;
});
$__System.registerDynamic("2a", ["2e0"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("2e0");
  return module.exports;
});
$__System.registerDynamic('2e1', ['2a'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  (function (Buffer) {
    function isArray(arg) {
      if (Array.isArray) {
        return Array.isArray(arg);
      }
      return objectToString(arg) === '[object Array]';
    }
    exports.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === 'boolean';
    }
    exports.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === 'number';
    }
    exports.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === 'string';
    }
    exports.isString = isString;
    function isSymbol(arg) {
      return typeof arg === 'symbol';
    }
    exports.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    function isRegExp(re) {
      return objectToString(re) === '[object RegExp]';
    }
    exports.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === 'object' && arg !== null;
    }
    exports.isObject = isObject;
    function isDate(d) {
      return objectToString(d) === '[object Date]';
    }
    exports.isDate = isDate;
    function isError(e) {
      return objectToString(e) === '[object Error]' || e instanceof Error;
    }
    exports.isError = isError;
    function isFunction(arg) {
      return typeof arg === 'function';
    }
    exports.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || typeof arg === 'undefined';
    }
    exports.isPrimitive = isPrimitive;
    exports.isBuffer = Buffer.isBuffer;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  })($__require('2a').Buffer);
  return module.exports;
});
$__System.registerDynamic("19d", ["2e1"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("2e1");
  return module.exports;
});
$__System.registerDynamic('2e2', ['19d'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var util = $__require('19d');

  var defaultMaxAge = 180 * 24 * 60 * 60;

  module.exports = function hsts(options) {
    options = options || {};

    var maxAge = options.maxAge != null ? options.maxAge : defaultMaxAge;
    var includeSubDomains = options.includeSubDomains !== false && options.includeSubdomains !== false;
    var force = options.force;
    var setIf = options.setIf;

    if (options.hasOwnProperty('maxage')) {
      throw new Error('maxage is not a supported property. Did you mean to pass "maxAge" instead of "maxage"?');
    }
    if (arguments.length > 1) {
      throw new Error('HSTS passed the wrong number of arguments.');
    }
    if (!util.isNumber(maxAge)) {
      throw new TypeError('HSTS must be passed a numeric maxAge parameter.');
    }
    if (maxAge < 0) {
      throw new RangeError('HSTS maxAge must be nonnegative.');
    }
    if (options.hasOwnProperty('setIf')) {
      if (!util.isFunction(setIf)) {
        throw new TypeError('setIf must be a function.');
      }
      if (options.hasOwnProperty('force')) {
        throw new Error('setIf and force cannot both be specified.');
      }
    }
    if (options.hasOwnProperty('includeSubDomains') && options.hasOwnProperty('includeSubdomains')) {
      throw new Error('includeSubDomains and includeSubdomains cannot both be specified.');
    }

    var header = 'max-age=' + Math.round(maxAge);
    if (includeSubDomains) {
      header += '; includeSubDomains';
    }
    if (options.preload) {
      header += '; preload';
    }

    return function hsts(req, res, next) {
      var setHeader;
      if (setIf) {
        setHeader = setIf(req, res);
      } else {
        setHeader = force || req.secure;
      }

      if (setHeader) {
        res.setHeader('Strict-Transport-Security', header);
      }

      next();
    };
  };
  return module.exports;
});
$__System.registerDynamic("2e3", ["2e2"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("2e2");
  return module.exports;
});
$__System.registerDynamic('2e4', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function ienoopen() {
    return function ienoopen(req, res, next) {
      res.setHeader('X-Download-Options', 'noopen');
      next();
    };
  };
  return module.exports;
});
$__System.registerDynamic("2e5", ["2e4"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("2e4");
  return module.exports;
});
$__System.registerDynamic('2e6', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function nocache() {
    return function nocache(req, res, next) {
      res.setHeader('Surrogate-Control', 'no-store');
      res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate, proxy-revalidate');
      res.setHeader('Pragma', 'no-cache');
      res.setHeader('Expires', '0');

      next();
    };
  };
  return module.exports;
});
$__System.registerDynamic("2e7", ["2e6"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("2e6");
  return module.exports;
});
$__System.registerDynamic('2e8', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function nosniff() {
    return function nosniff(req, res, next) {
      res.setHeader('X-Content-Type-Options', 'nosniff');
      next();
    };
  };
  return module.exports;
});
$__System.registerDynamic("2e9", ["2e8"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("2e8");
  return module.exports;
});
$__System.registerDynamic('2ea', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var DEFAULT_POLICY = 'no-referrer';
  var ALLOWED_POLICIES = ['no-referrer', 'no-referrer-when-downgrade', 'same-origin', 'origin', 'origin-when-cross-origin', 'unsafe-url', ''];
  var ALLOWED_POLICIES_ERROR_LIST = ALLOWED_POLICIES.map(function (policy) {
    if (policy.length) {
      return '"' + policy + '"';
    } else {
      return 'and the empty string';
    }
  }).join(', ');

  module.exports = function referrerPolicy(options) {
    options = options || {};

    var policy;
    if ('policy' in options) {
      policy = options.policy;
    } else {
      policy = DEFAULT_POLICY;
    }

    if (ALLOWED_POLICIES.indexOf(policy) === -1) {
      throw new Error('"' + policy + '" is not a valid policy. Allowed policies: ' + ALLOWED_POLICIES_ERROR_LIST + '.');
    }

    return function referrerPolicy(req, res, next) {
      res.setHeader('Referrer-Policy', policy);
      next();
    };
  };
  return module.exports;
});
$__System.registerDynamic("2eb", ["2ea"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("2ea");
  return module.exports;
});
$__System.registerDynamic('2ec', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function xXssProtection(options) {
    if (options && options.setOnOldIE) {
      return function xXssProtection(req, res, next) {
        res.setHeader('X-XSS-Protection', '1; mode=block');
        next();
      };
    } else {
      return function xXssProtection(req, res, next) {
        var matches = /msie\s*(\d+)/i.exec(req.headers['user-agent']);

        var value;
        if (!matches || parseFloat(matches[1]) >= 9) {
          value = '1; mode=block';
        } else {
          value = '0';
        }

        res.setHeader('X-XSS-Protection', value);
        next();
      };
    }
  };
  return module.exports;
});
$__System.registerDynamic("2ed", ["2ec"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("2ec");
  return module.exports;
});
$__System.registerDynamic('2ee', ['2b0', '2b1', '2cf', '2d1', '2d4', '2d6', '2d8', '2e3', '2e5', '2e7', '2e9', '2eb', '2ed'], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  /* */
  var connect = $__require('2b0');
  var config = $__require('2b1');
  var middlewares;
  function helmet(options) {
    options = options || {};
    var chain = connect();
    middlewares.forEach(function (middlewareName) {
      var middleware = helmet[middlewareName];
      var option = options[middlewareName];
      var isDefault = config.defaultMiddleware.indexOf(middlewareName) !== -1;
      if (option === false) {
        return;
      }
      if (option != null) {
        if (option === true) {
          chain.use(middleware({}));
        } else {
          chain.use(middleware(option));
        }
      } else if (isDefault) {
        chain.use(middleware({}));
      }
    });
    return chain;
  }
  helmet.contentSecurityPolicy = $__require('2cf');
  helmet.dnsPrefetchControl = $__require('2d1');
  helmet.frameguard = $__require('2d4');
  helmet.hidePoweredBy = $__require('2d6');
  helmet.hpkp = $__require('2d8');
  helmet.hsts = $__require('2e3');
  helmet.ieNoOpen = $__require('2e5');
  helmet.noCache = $__require('2e7');
  helmet.noSniff = $__require('2e9');
  helmet.referrerPolicy = $__require('2eb');
  helmet.xssFilter = $__require('2ed');
  middlewares = Object.keys(helmet);
  module.exports = helmet;
  return module.exports;
});
$__System.registerDynamic("2ef", ["2ee"], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require("2ee");
  return module.exports;
});
$__System.registerDynamic("2f0", [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  const users = {
    admin: {
      username: "admin",
      password: "purpledin09",
      email: "bryan.schauerte@gmail.com",
      admin: true,
      _id: "1x8p01g5b898m3oo08th7v91wd6e9"
    },
    guest: {
      username: 'guest',
      password: '123password',
      email: 'test@test.com',
      admin: false,
      _id: 'guest'
    }
  };

  module.exports = users;
  return module.exports;
});
$__System.registerDynamic("2f1", [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;
  const secret = "5n58t13t629w081d0b01ssdf8d5";
  module.exports = secret;
  return module.exports;
});
$__System.registerDynamic('2f2', [], true, function ($__require, exports, module) {
  var define,
      global = this || self,
      GLOBAL = global;


  module.exports = function newContent(req, res) {

    let date = new Date();
    req.body.dateCreated = date;
    let _id = mongodb.ObjectId();
    req.body._id = _id;
    db.collection('contents').save(req.body, (err, result) => {
      if (err) return res.send(err);
      res.send(result);
    });
  };

  module.exports = function updateContent(req, res) {

    let targetID = req.body._id;
    let content = req.body.contentItems;

    db.collection('contents').update({ '_id': mongodb.ObjectId(targetID) }, { $set: { 'contentItems': content } }, { upsert: true }, (err, result) => {
      if (err) {
        console.log(err);
      } else {
        res.send(result);
      }
    });
  };

  module.exports = function deleteContent(req, res) {

    let targetID = req.body._id;

    db.collection('contents', (err, collection) => {
      collection.remove({ '_id': mongodb.ObjectId(targetID) }, { safe: true }, (err, result) => {
        if (err) {
          res.send(err);
        } else {
          res.send(collection);
        }
      });
    });
  };
  module.exports = function loginForToken(req, res) {
    if (!req.body.username || !req.body.password) {
      res.status(400).send('Missing info!');
    }

    if (users[req.body.username]) {
      if (users[req.body.username].password == users[req.body.username].password) {
        let token = jwt.sign(users[req.body.username], secret);
        return res.status(200).json({ token: token, admin: users[req.body.username].admin });
      }
    } else {
      return res.status(400).send('incorrect info!');
    }
  };
  return module.exports;
});
$__System.register("2f3", [], function (_export) {
  "use strict";

  return {
    setters: [],
    execute: function () {
      _export("default", function (_ref) {
        var body = _ref.body;
        var title = _ref.title;
        var initialState = _ref.initialState;

        return "\n    <!DOCTYPE html>\n    <html>\n      <head>\n        <script>window.__APP_INITIAL_STATE__ = " + initialState + "</script>\n        <title>" + title + "</title>\n        <link rel=\"stylesheet\" href=\"public/main.css\">\n      </head>\n\n      <body>\n        <div id=\"root\">" + body + "</div>\n      </body>\n\n      <script src=\"/assets/bundle.js\"></script>\n    </html>\n  ";
      });
    }
  };
});
$__System.register('1', ['7', '128', '5b', '5e', '10e', '17a', '17d', '27e', '27f', '2ef', '2f0', '2f1', '2f2', '2f3'], function (_export) {

  //route handling

  // import * as expressJWT from 'express-jwt';

  // import * as jwt from 'jsonwebtoken';

  'use strict';

  //client
  // import Base from '../app/base/Base';

  // import * as session from 'cookie-session';

  var fs, axios, express, React, renderToString, bodyParser, cors, mongodb, mongoLABSURLINFO, helmet, users, secret, requestHandling, template, server, PORT, MongoClient, db;
  return {
    setters: [function (_) {
      fs = _['default'];
    }, function (_2) {
      axios = _2['default'];
    }, function (_b) {
      express = _b['default'];
    }, function (_e) {
      React = _e['default'];
    }, function (_e2) {
      renderToString = _e2.renderToString;
    }, function (_a) {
      bodyParser = _a['default'];
    }, function (_d) {
      cors = _d['default'];
    }, function (_e3) {
      mongodb = _e3['default'];
    }, function (_f) {
      mongoLABSURLINFO = _f.mongoLABSURLINFO;
    }, function (_ef) {
      helmet = _ef;
    }, function (_f0) {
      users = _f0.users;
    }, function (_f1) {
      secret = _f1.secret;
    }, function (_f2) {
      requestHandling = _f2;
    }, function (_f3) {
      template = _f3['default'];
    }],
    execute: function () {
      server = express();

      server.use(helmet());
      server.use(bodyParser.urlencoded({ extended: true }));
      server.use(bodyParser.json({ type: 'application/json' }));

      // app.use(express.static(__dirname + '/__build__'));

      server.use('/assets', express['static']('assets'));

      server.get('/', function (req, res) {});

      PORT = process.env.PORT || 8080;
      MongoClient = require('mongodb').MongoClient;
      db = undefined;

      MongoClient.connect(mongoLABSURLINFO, function (err, database) {

        db = database;
        app.listen(PORT, function () {
          console.log('listening on ' + PORT);
        });
      });

      //handling admin
      app.post('/editContents', expressJWT({ secret: secret }), requestHandling.newContent);
      app.put('/editContents', expressJWT({ secret: secret }), requestHandling.updateContent);
      app['delete']('/editContents', expressJWT({ secret: secret }), requestHandling.deleteContent);

      // app.post('/login', requestHandling.loginForToken)

      app.get('*', function (req, res) {

        if (req.url) {

          if (req.url == '/') {

            var initialState = { test: 'true' };
            var appString = 'test'; //renderToString(<Base {...initialState} />);

            res.send(template({
              body: appString,
              title: 'Hello World from the server',
              initialState: JSON.stringify(initialState)
            }));
          }

          if (req.url == '/getContents/profile') {

            db.collection('contents').find().toArray(function (err, results) {
              if (err) {
                return res.sendStatus(404);
              }
              if (results) {
                return res.send(results);
              }
              res.send('Nothing in DB').sendStatus(200);
            });
          }
        }
      });
    }
  };
});
})
(function(factory) {
  factory();
});
//# sourceMappingURL=bundledServer.js.map